(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/regenerator'), require('compilerr'), require('@babel/runtime/helpers/defineProperty'), require('fast-unique-numbers')) :
    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/regenerator', 'compilerr', '@babel/runtime/helpers/defineProperty', 'fast-unique-numbers'], factory) :
    (global = global || self, factory(global.workerFactory = {}, global._regeneratorRuntime, global.compilerr, global._defineProperty, global.fastUniqueNumbers));
}(this, (function (exports, _regeneratorRuntime, compilerr, _defineProperty, fastUniqueNumbers) { 'use strict';

    _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;
    _defineProperty = _defineProperty && _defineProperty.hasOwnProperty('default') ? _defineProperty['default'] : _defineProperty;

    var JSON_RPC_ERROR_CODES = {
      INTERNAL_ERROR: -32603,
      INVALID_PARAMS: -32602,
      METHOD_NOT_FOUND: -32601
    };
    var renderMethodNotFoundError = compilerr.compile({
      message: 'The requested method called "${method}" is not supported.',
      status: JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND
    });
    var renderMissingResponseError = compilerr.compile({
      message: 'The handler of the method called "${method}" returned no required result.',
      status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR
    });
    var renderUnexpectedResultError = compilerr.compile({
      message: 'The handler of the method called "${method}" returned an unexpected result.',
      status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR
    });
    var renderUnknownPortIdError = compilerr.compile({
      message: 'The specified parameter called "portId" with the given value "${portId}" does not identify a port connected to this worker.',
      status: JSON_RPC_ERROR_CODES.INVALID_PARAMS
    });

    var createMessageHandler = function createMessageHandler(receiver, workerImplementation) {
      return function _callee(_ref) {
        var _ref$data, id, method, params, messageHandler, response, synchronousResponse, result, _synchronousResponse$, transferables, message, _err$status, status;

        return _regeneratorRuntime.async(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _ref$data = _ref.data, id = _ref$data.id, method = _ref$data.method, params = _ref$data.params;
                messageHandler = workerImplementation[method];
                _context.prev = 2;

                if (!(messageHandler === undefined)) {
                  _context.next = 5;
                  break;
                }

                throw renderMethodNotFoundError({
                  method: method
                });

              case 5:
                response = params === undefined ? messageHandler() : messageHandler(params);

                if (!(response === undefined)) {
                  _context.next = 8;
                  break;
                }

                throw renderMissingResponseError({
                  method: method
                });

              case 8:
                if (!(response instanceof Promise)) {
                  _context.next = 14;
                  break;
                }

                _context.next = 11;
                return _regeneratorRuntime.awrap(response);

              case 11:
                _context.t0 = _context.sent;
                _context.next = 15;
                break;

              case 14:
                _context.t0 = response;

              case 15:
                synchronousResponse = _context.t0;

                if (!(id === null)) {
                  _context.next = 21;
                  break;
                }

                if (!(synchronousResponse.result !== undefined)) {
                  _context.next = 19;
                  break;
                }

                throw renderUnexpectedResultError({
                  method: method
                });

              case 19:
                _context.next = 25;
                break;

              case 21:
                if (!(synchronousResponse.result === undefined)) {
                  _context.next = 23;
                  break;
                }

                throw renderUnexpectedResultError({
                  method: method
                });

              case 23:
                result = synchronousResponse.result, _synchronousResponse$ = synchronousResponse.transferables, transferables = _synchronousResponse$ === void 0 ? [] : _synchronousResponse$;
                receiver.postMessage({
                  id: id,
                  result: result
                }, transferables);

              case 25:
                _context.next = 31;
                break;

              case 27:
                _context.prev = 27;
                _context.t1 = _context["catch"](2);
                message = _context.t1.message, _err$status = _context.t1.status, status = _err$status === void 0 ? -32603 : _err$status;
                receiver.postMessage({
                  error: {
                    code: status,
                    message: message
                  },
                  id: id
                });

              case 31:
              case "end":
                return _context.stop();
            }
          }
        }, null, null, [[2, 27]]);
      };
    };

    // Bug #1: Safari does currently not support to use transferables.
    var isSupportingTransferables = function isSupportingTransferables() {
      return new Promise(function (resolve) {
        var arrayBuffer = new ArrayBuffer(0);

        var _ref = new MessageChannel(),
            port1 = _ref.port1,
            port2 = _ref.port2;

        port1.onmessage = function (_ref2) {
          var data = _ref2.data;
          return resolve(data !== null);
        };

        port2.postMessage(arrayBuffer, [arrayBuffer]);
      });
    };

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
    var DESTROY_WORKER_FUNCTIONS = new Map();
    var extendWorkerImplementation = function extendWorkerImplementation(createWorker, partialWorkerImplementation, isSupportedFunction) {
      return _objectSpread({}, partialWorkerImplementation, {
        connect: function connect(_ref) {
          var port = _ref.port;
          port.start();
          var destroyWorker = createWorker(port, partialWorkerImplementation);
          var portId = fastUniqueNumbers.generateUniqueNumber(DESTROY_WORKER_FUNCTIONS);
          DESTROY_WORKER_FUNCTIONS.set(portId, function () {
            destroyWorker();
            port.close();
            DESTROY_WORKER_FUNCTIONS["delete"](portId);
          });
          return {
            result: portId
          };
        },
        disconnect: function disconnect(_ref2) {
          var portId = _ref2.portId;
          var destroyWorker = DESTROY_WORKER_FUNCTIONS.get(portId);

          if (destroyWorker === undefined) {
            throw renderUnknownPortIdError({
              portId: portId.toString()
            });
          }

          destroyWorker();
          return {
            result: null
          };
        },
        isSupported: function isSupported() {
          var isSelfSupported, result, synchronousResult;
          return _regeneratorRuntime.async(function isSupported$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _regeneratorRuntime.awrap(isSupportingTransferables());

                case 2:
                  isSelfSupported = _context.sent;

                  if (!isSelfSupported) {
                    _context.next = 14;
                    break;
                  }

                  result = isSupportedFunction();

                  if (!(result instanceof Promise)) {
                    _context.next = 11;
                    break;
                  }

                  _context.next = 8;
                  return _regeneratorRuntime.awrap(result);

                case 8:
                  _context.t0 = _context.sent;
                  _context.next = 12;
                  break;

                case 11:
                  _context.t0 = result;

                case 12:
                  synchronousResult = _context.t0;
                  return _context.abrupt("return", {
                    result: synchronousResult
                  });

                case 14:
                  return _context.abrupt("return", {
                    result: false
                  });

                case 15:
                case "end":
                  return _context.stop();
              }
            }
          });
        }
      });
    };

    var createWorker = function createWorker(receiver, workerImplementation) {
      var isSupportedFunction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {
        return true;
      };
      var fullWorkerImplementation = extendWorkerImplementation(createWorker, workerImplementation, isSupportedFunction);
      var messageHandler = createMessageHandler(receiver, fullWorkerImplementation);
      receiver.addEventListener('message', messageHandler);
      return function () {
        return receiver.removeEventListener('message', messageHandler);
      };
    };

    exports.createWorker = createWorker;
    exports.isSupported = isSupportingTransferables;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
