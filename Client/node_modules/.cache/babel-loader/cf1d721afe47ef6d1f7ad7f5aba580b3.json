{"ast":null,"code":"var _slicedToArray = require(\"/home/oem/Desktop/Melody/song-generation/Client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.mm = t() : e.mm = t();\n}(global, function () {\n  return function (e) {\n    var t = {};\n\n    function n(r) {\n      if (t[r]) return t[r].exports;\n      var o = t[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = e, n.c = t, n.d = function (e, t, r) {\n      n.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: r\n      });\n    }, n.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (e, t) {\n      if (1 & t && (e = n(e)), 8 & t) return e;\n      if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n      var r = Object.create(null);\n      if (n.r(r), Object.defineProperty(r, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var o in e) n.d(r, o, function (t) {\n        return e[t];\n      }.bind(null, o));\n      return r;\n    }, n.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return n.d(t, \"a\", t), t;\n    }, n.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 21);\n  }([function (e, t) {\n    e.exports = require(\"@tensorflow/tfjs\");\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"DEFAULT_QUARTERS_PER_MINUTE\", function () {\n      return r;\n    }), n.d(t, \"DEFAULT_STEPS_PER_BAR\", function () {\n      return o;\n    }), n.d(t, \"DEFAULT_STEPS_PER_QUARTER\", function () {\n      return i;\n    }), n.d(t, \"DEFAULT_STEPS_PER_SECOND\", function () {\n      return s;\n    }), n.d(t, \"DEFAULT_VELOCITY\", function () {\n      return a;\n    }), n.d(t, \"DEFAULT_PROGRAM\", function () {\n      return u;\n    }), n.d(t, \"DEFAULT_TICKS_PER_QUARTER\", function () {\n      return c;\n    }), n.d(t, \"DEFAULT_CHANNEL\", function () {\n      return p;\n    }), n.d(t, \"DRUM_CHANNEL\", function () {\n      return l;\n    }), n.d(t, \"MIN_MIDI_VELOCITY\", function () {\n      return m;\n    }), n.d(t, \"MAX_MIDI_VELOCITY\", function () {\n      return h;\n    }), n.d(t, \"MIDI_VELOCITIES\", function () {\n      return d;\n    }), n.d(t, \"NO_CHORD\", function () {\n      return f;\n    }), n.d(t, \"NUM_PITCH_CLASSES\", function () {\n      return g;\n    }), n.d(t, \"MIN_MIDI_PITCH\", function () {\n      return S;\n    }), n.d(t, \"MAX_MIDI_PITCH\", function () {\n      return y;\n    }), n.d(t, \"MIDI_PITCHES\", function () {\n      return w;\n    }), n.d(t, \"MIN_PIANO_PITCH\", function () {\n      return b;\n    }), n.d(t, \"MAX_PIANO_PITCH\", function () {\n      return N;\n    }), n.d(t, \"MIN_DRUM_PITCH\", function () {\n      return T;\n    }), n.d(t, \"MAX_DRUM_PITCH\", function () {\n      return q;\n    }), n.d(t, \"MIN_MIDI_PROGRAM\", function () {\n      return P;\n    }), n.d(t, \"MAX_MIDI_PROGRAM\", function () {\n      return O;\n    }), n.d(t, \"LO_CLICK_PITCH\", function () {\n      return I;\n    }), n.d(t, \"HI_CLICK_PITCH\", function () {\n      return A;\n    }), n.d(t, \"LO_CLICK_CLASS\", function () {\n      return v;\n    }), n.d(t, \"HI_CLICK_CLASS\", function () {\n      return E;\n    });\n    const r = 120,\n          o = 16,\n          i = 4,\n          s = 100,\n          a = 80,\n          u = 0,\n          c = 220,\n          p = 0,\n          l = 9,\n          m = 0,\n          h = 127,\n          d = h - m + 1,\n          f = \"N.C.\",\n          g = 12,\n          S = 0,\n          y = 127,\n          w = y - S + 1,\n          b = 21,\n          N = 108,\n          T = 35,\n          q = 81,\n          P = 0,\n          O = 127,\n          I = 89,\n          A = 90,\n          v = 9,\n          E = 10;\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.d(t, \"a\", function () {\n      return o;\n    });\n    var r = n(11),\n        o = r.tensorflow.magenta.NoteSequence;\n  }, function (e, t) {\n    e.exports = require(\"tone\");\n  },, function (e, t, n) {\n    \"use strict\";\n\n    var r;\n    n.r(t), n.d(t, \"Level\", function () {\n      return r;\n    }), n.d(t, \"verbosity\", function () {\n      return o;\n    }), n.d(t, \"log\", function () {\n      return i;\n    }), n.d(t, \"logWithDuration\", function () {\n      return s;\n    }), function (e) {\n      e[e.NONE = 0] = \"NONE\", e[e.WARN = 5] = \"WARN\", e[e.INFO = 10] = \"INFO\", e[e.DEBUG = 20] = \"DEBUG\";\n    }(r || (r = {}));\n    let o = 10;\n\n    function i(e, t = \"Magenta.js\", n = 10) {\n      if (0 === n) throw Error(\"Logging level cannot be NONE.\");\n\n      if (o >= n) {\n        (5 === n ? console.warn : console.log)(\"%c \".concat(t, \" \"), \"background:magenta; color:white\", e);\n      }\n    }\n\n    function s(e, t, n = \"Magenta.js\", r = 10) {\n      i(\"\".concat(e, \" in \").concat(((performance.now() - t) / 1e3).toPrecision(3), \"s\"), n, r);\n    }\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"MultipleTimeSignatureException\", function () {\n      return s;\n    }), n.d(t, \"BadTimeSignatureException\", function () {\n      return a;\n    }), n.d(t, \"NegativeTimeException\", function () {\n      return u;\n    }), n.d(t, \"MultipleTempoException\", function () {\n      return c;\n    }), n.d(t, \"QuantizationStatusException\", function () {\n      return p;\n    }), n.d(t, \"clone\", function () {\n      return l;\n    }), n.d(t, \"stepsPerQuarterToStepsPerSecond\", function () {\n      return m;\n    }), n.d(t, \"quantizeToStep\", function () {\n      return h;\n    }), n.d(t, \"quantizeNoteSequence\", function () {\n      return g;\n    }), n.d(t, \"isQuantizedSequence\", function () {\n      return S;\n    }), n.d(t, \"assertIsQuantizedSequence\", function () {\n      return y;\n    }), n.d(t, \"isRelativeQuantizedSequence\", function () {\n      return w;\n    }), n.d(t, \"assertIsRelativeQuantizedSequence\", function () {\n      return b;\n    }), n.d(t, \"isAbsoluteQuantizedSequence\", function () {\n      return N;\n    }), n.d(t, \"assertIsAbsoluteQuantizedSequence\", function () {\n      return T;\n    }), n.d(t, \"unquantizeSequence\", function () {\n      return q;\n    }), n.d(t, \"mergeInstruments\", function () {\n      return P;\n    }), n.d(t, \"replaceInstruments\", function () {\n      return O;\n    }), n.d(t, \"mergeConsecutiveNotes\", function () {\n      return I;\n    }), n.d(t, \"concatenate\", function () {\n      return A;\n    }), n.d(t, \"trim\", function () {\n      return v;\n    }), n.d(t, \"split\", function () {\n      return z;\n    });\n    var r = n(2),\n        o = n(1);\n    const i = .5;\n\n    class s extends Error {\n      constructor(e) {\n        super(e), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class a extends Error {\n      constructor(e) {\n        super(e), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class u extends Error {\n      constructor(e) {\n        super(e), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class c extends Error {\n      constructor(e) {\n        super(e), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class p extends Error {\n      constructor(e) {\n        super(e), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    function l(e) {\n      return r.a.decode(r.a.encode(e).finish());\n    }\n\n    function m(e, t) {\n      return e * t / 60;\n    }\n\n    function h(e, t, n = i) {\n      const r = e * t;\n      return Math.floor(r + (1 - n));\n    }\n\n    function d(e) {\n      return e.controlChanges.concat(e.textAnnotations);\n    }\n\n    function f(e) {\n      if (e.tempos && 0 !== e.tempos.length) {\n        if (e.tempos.sort((e, t) => e.time - t.time), 0 !== e.tempos[0].time && e.tempos[0].qpm !== o.DEFAULT_QUARTERS_PER_MINUTE) throw new c(\"NoteSequence has an implicit tempo change from initial \" + \"\".concat(o.DEFAULT_QUARTERS_PER_MINUTE, \" qpm to \") + \"\".concat(e.tempos[0].qpm, \" qpm at \").concat(e.tempos[0].time, \" seconds.\"));\n\n        for (let t = 1; t < e.tempos.length; t++) if (e.tempos[t].qpm !== e.tempos[0].qpm) throw new c(\"NoteSequence has at least one tempo change from \" + \"\".concat(e.tempos[0].qpm, \" qpm to \").concat(e.tempos[t].qpm) + \"qpm at \".concat(e.tempos[t].time, \" seconds.\"));\n      }\n    }\n\n    function g(e, t) {\n      const n = l(e);\n\n      if (n.quantizationInfo = r.a.QuantizationInfo.create({\n        stepsPerQuarter: t\n      }), n.timeSignatures.length > 0) {\n        if (n.timeSignatures.sort((e, t) => e.time - t.time), 0 !== n.timeSignatures[0].time && (4 !== n.timeSignatures[0].numerator || 4 !== n.timeSignatures[0].denominator)) throw new s(\"NoteSequence has an implicit change from initial 4/4 time \" + \"signature to \".concat(n.timeSignatures[0].numerator, \"/\") + \"\".concat(n.timeSignatures[0].denominator, \" at \") + \"\".concat(n.timeSignatures[0].time, \" seconds.\"));\n\n        for (let e = 1; e < n.timeSignatures.length; e++) {\n          const t = n.timeSignatures[e];\n          if (t.numerator !== n.timeSignatures[0].numerator || t.denominator !== n.timeSignatures[0].denominator) throw new s(\"NoteSequence has at least one time signature change from \" + \"\".concat(n.timeSignatures[0].numerator, \"/\") + \"\".concat(n.timeSignatures[0].denominator, \" to \") + \"\".concat(t.numerator, \"/\").concat(t.denominator, \" \") + \"at \".concat(t.time, \" seconds\"));\n        }\n\n        n.timeSignatures[0].time = 0, n.timeSignatures = [n.timeSignatures[0]];\n      } else {\n        const e = r.a.TimeSignature.create({\n          numerator: 4,\n          denominator: 4,\n          time: 0\n        });\n        n.timeSignatures.push(e);\n      }\n\n      const i = n.timeSignatures[0];\n      if (!(c = i.denominator) || 0 != (c & c - 1)) throw new a(\"Denominator is not a power of 2. Time signature: \" + \"\".concat(i.numerator, \"/\").concat(i.denominator));\n      var c;\n      if (0 === i.numerator) throw new a(\"Numerator is 0. Time signature: \" + \"\".concat(i.numerator, \"/\").concat(i.denominator));\n      if (n.tempos.length > 0) f(n), n.tempos[0].time = 0, n.tempos = [n.tempos[0]];else {\n        const e = r.a.Tempo.create({\n          qpm: o.DEFAULT_QUARTERS_PER_MINUTE,\n          time: 0\n        });\n        n.tempos.push(e);\n      }\n      const p = m(t, n.tempos[0].qpm);\n      return n.totalQuantizedSteps = h(e.totalTime, p), function (e, t) {\n        for (const n of e.notes) {\n          if (n.quantizedStartStep = h(n.startTime, t), n.quantizedEndStep = h(n.endTime, t), n.quantizedEndStep === n.quantizedStartStep && (n.quantizedEndStep += 1), n.quantizedStartStep < 0 || n.quantizedEndStep < 0) throw new u(\"Got negative note time: start_step = \" + \"\".concat(n.quantizedStartStep, \", end_step = \") + \"\".concat(n.quantizedEndStep));\n          n.quantizedEndStep > e.totalQuantizedSteps && (e.totalQuantizedSteps = n.quantizedEndStep);\n        }\n\n        d(e).forEach(e => {\n          if (e.quantizedStep = h(e.time, t), e.quantizedStep < 0) throw new u(\"Got negative event time: step = \".concat(e.quantizedStep));\n        });\n      }(n, p), n;\n    }\n\n    function S(e) {\n      return e.quantizationInfo && (e.quantizationInfo.stepsPerQuarter > 0 || e.quantizationInfo.stepsPerSecond > 0);\n    }\n\n    function y(e) {\n      if (!S(e)) throw new p(\"NoteSequence \".concat(e.id, \" is not quantized (missing quantizationInfo)\"));\n    }\n\n    function w(e) {\n      return e.quantizationInfo && e.quantizationInfo.stepsPerQuarter > 0;\n    }\n\n    function b(e) {\n      if (!w(e)) throw new p(\"NoteSequence \".concat(e.id, \" is not quantized or is quantized based on absolute timing\"));\n    }\n\n    function N(e) {\n      return e.quantizationInfo && e.quantizationInfo.stepsPerSecond > 0;\n    }\n\n    function T(e) {\n      if (!N(e)) throw new p(\"NoteSequence \".concat(e.id, \" is not quantized or is quantized based on relative timing\"));\n    }\n\n    function q(e, t) {\n      b(e), f(e);\n      const n = l(e);\n      t ? n.tempos && n.tempos.length > 0 ? n.tempos[0].qpm = t : n.tempos.push(r.a.Tempo.create({\n        time: 0,\n        qpm: t\n      })) : t = e.tempos && e.tempos.length > 0 ? n.tempos[0].qpm : o.DEFAULT_QUARTERS_PER_MINUTE;\n\n      const i = e => e / n.quantizationInfo.stepsPerQuarter * (60 / t);\n\n      return n.totalTime = i(n.totalQuantizedSteps), n.notes.forEach(e => {\n        e.startTime = i(e.quantizedStartStep), e.endTime = i(e.quantizedEndStep), n.totalTime = Math.max(n.totalTime, e.endTime), delete e.quantizedStartStep, delete e.quantizedEndStep;\n      }), d(n).forEach(e => {\n        e.time = i(e.time);\n      }), delete n.totalQuantizedSteps, delete n.quantizationInfo, n;\n    }\n\n    function P(e) {\n      const t = l(e),\n            n = t.notes.concat(t.pitchBends).concat(t.controlChanges),\n            r = Array.from(new Set(n.filter(e => !e.isDrum).map(e => e.program)));\n      return n.forEach(e => {\n        e.isDrum ? (e.program = 0, e.instrument = r.length) : e.instrument = r.indexOf(e.program);\n      }), t;\n    }\n\n    function O(e, t) {\n      const n = new Set(e.notes.map(e => e.instrument)),\n            o = new Set(t.notes.map(e => e.instrument)),\n            i = [];\n      e.notes.forEach(e => {\n        o.has(e.instrument) || i.push(r.a.Note.create(e));\n      }), t.notes.forEach(e => {\n        n.has(e.instrument) && i.push(r.a.Note.create(e));\n      });\n      const s = l(e);\n      return s.notes = i.sort((e, t) => {\n        const n = e.instrument - t.instrument;\n        return n || e.quantizedStartStep - t.quantizedStartStep;\n      }), s;\n    }\n\n    function I(e) {\n      y(e);\n      const t = l(e);\n      t.notes = [];\n      const n = e.notes.sort((e, t) => {\n        const n = e.instrument - t.instrument;\n        return n || e.quantizedStartStep - t.quantizedStartStep;\n      }),\n            o = new r.a.Note();\n      o.pitch = n[0].pitch, o.instrument = n[0].instrument, o.quantizedStartStep = n[0].quantizedStartStep, o.quantizedEndStep = n[0].quantizedEndStep, t.notes.push(o);\n      let i = 0;\n\n      for (let e = 1; e < n.length; e++) {\n        const o = n[e],\n              s = t.notes[i];\n        if (s.instrument === o.instrument && s.pitch === o.pitch && o.quantizedStartStep === s.quantizedEndStep && o.quantizedStartStep % 16 != 0) t.notes[i].quantizedEndStep += o.quantizedEndStep - o.quantizedStartStep;else {\n          const o = new r.a.Note();\n          o.pitch = n[e].pitch, o.instrument = n[e].instrument, o.quantizedStartStep = n[e].quantizedStartStep, o.quantizedEndStep = n[e].quantizedEndStep, t.notes.push(o), i++;\n        }\n      }\n\n      return t;\n    }\n\n    function A(e, t) {\n      if (t && t.length !== e.length) throw new Error(\"Number of sequences to concatenate and their individual\\n durations does not match.\");\n\n      if (S(e[0])) {\n        for (let t = 0; t < e.length; ++t) if (y(e[t]), e[t].quantizationInfo.stepsPerQuarter !== e[0].quantizationInfo.stepsPerQuarter) throw new Error(\"Not all sequences have the same quantizationInfo\");\n\n        return E(e, \"totalQuantizedSteps\", \"quantizedStartStep\", \"quantizedEndStep\", t);\n      }\n\n      return E(e, \"totalTime\", \"startTime\", \"endTime\", t);\n    }\n\n    function v(e, t, n, r) {\n      return S(e) ? k(e, t, n, \"totalQuantizedSteps\", \"quantizedStartStep\", \"quantizedEndStep\", r) : k(e, t, n, \"totalTime\", \"startTime\", \"endTime\", r);\n    }\n\n    function E(e, t, n, o, i) {\n      let s,\n          a = 0;\n\n      for (let u = 0; u < e.length; ++u) {\n        const c = i ? i[u] : e[u][t];\n        if (0 === c) throw Error(\"Sequence \".concat(e[u].id, \" has no \").concat(t, \", and no individual duration was provided.\"));\n        0 === u ? s = l(e[0]) : Array.prototype.push.apply(s.notes, e[u].notes.map(e => {\n          const t = r.a.Note.create(e);\n          return t[n] += a, t[o] += a, t;\n        })), a += c;\n      }\n\n      return s[t] = a, s;\n    }\n\n    function k(e, t, n, r, o, i, s) {\n      const a = l(e);\n      a[r] = n, a.notes = a.notes.filter(e => e[o] >= t && e[o] <= n && (s || e[i] <= n));\n\n      for (let e = 0; e < a.notes.length; e++) a.notes[e][o] -= t, a.notes[e][i] -= t, s && (a.notes[e][i] = Math.min(a.notes[e][i], n));\n\n      return a[r] = Math.min(e[r] - t, n), a;\n    }\n\n    function z(e, t) {\n      y(e);\n      const n = l(e),\n            o = n.notes.sort((e, t) => e.quantizedStartStep - t.quantizedStartStep),\n            i = [];\n      let s = 0,\n          a = [];\n\n      for (let e = 0; e < o.length; e++) {\n        const u = o[e],\n              c = u.quantizedStartStep,\n              p = u.quantizedEndStep;\n        if (u.quantizedStartStep -= s, u.quantizedEndStep -= s, !(u.quantizedStartStep < 0)) if (u.quantizedEndStep <= t) a.push(u);else {\n          if (u.quantizedStartStep < t) {\n            const e = r.a.Note.create(u);\n            e.quantizedEndStep = t, e.startTime = e.endTime = void 0, a.push(e), u.quantizedStartStep = s + t, u.quantizedEndStep = p;\n          } else u.quantizedStartStep = c, u.quantizedEndStep = p;\n\n          if ((u.quantizedEndStep > t || u.quantizedStartStep > t) && (e -= 1), 0 !== a.length) {\n            const e = l(n);\n            e.notes = a, e.totalQuantizedSteps = t, i.push(e);\n          }\n\n          a = [], s += t;\n        }\n      }\n\n      if (0 !== a.length) {\n        const e = l(n);\n        e.notes = a, e.totalQuantizedSteps = t, i.push(e);\n      }\n\n      return i;\n    }\n  }, function (e, t) {\n    e.exports = require(\"tonal\");\n  },, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"DEFAULT_DRUM_PITCH_CLASSES\", function () {\n      return u;\n    }), n.d(t, \"converterFromSpec\", function () {\n      return c;\n    }), n.d(t, \"DataConverter\", function () {\n      return p;\n    }), n.d(t, \"DrumsConverter\", function () {\n      return l;\n    }), n.d(t, \"DrumRollConverter\", function () {\n      return m;\n    }), n.d(t, \"DrumsOneHotConverter\", function () {\n      return h;\n    }), n.d(t, \"MelodyConverter\", function () {\n      return d;\n    }), n.d(t, \"TrioConverter\", function () {\n      return f;\n    }), n.d(t, \"MultitrackConverter\", function () {\n      return g;\n    }), n.d(t, \"GrooveConverter\", function () {\n      return S;\n    });\n    var r = n(0),\n        o = n(2),\n        i = n(1),\n        s = n(10),\n        a = n(6);\n    const u = [[36, 35], [38, 27, 28, 31, 32, 33, 34, 37, 39, 40, 56, 65, 66, 75, 85], [42, 44, 54, 68, 69, 70, 71, 73, 78, 80], [46, 67, 72, 74, 79, 81], [45, 29, 41, 61, 64, 84], [48, 47, 60, 63, 77, 86, 87], [50, 30, 43, 62, 76, 83], [49, 55, 57, 58], [51, 52, 53, 59, 82]];\n\n    function c(e) {\n      switch (e.type) {\n        case \"MelodyConverter\":\n          return new d(e.args);\n\n        case \"DrumsConverter\":\n          return new l(e.args);\n\n        case \"DrumRollConverter\":\n          return new m(e.args);\n\n        case \"TrioConverter\":\n          return new f(e.args);\n\n        case \"DrumsOneHotConverter\":\n          return new h(e.args);\n\n        case \"MultitrackConverter\":\n          return new g(e.args);\n\n        case \"GrooveConverter\":\n          return new S(e.args);\n\n        default:\n          throw new Error(\"Unknown DataConverter type: \".concat(e));\n      }\n    }\n\n    class p {\n      constructor(e) {\n        this.NUM_SPLITS = 0, this.SEGMENTED_BY_TRACK = !1, this.numSteps = e.numSteps, this.numSegments = e.numSegments;\n      }\n\n      tensorSteps(e) {\n        return r.scalar(e.shape[0], \"int32\");\n      }\n\n    }\n\n    class l extends p {\n      constructor(e) {\n        super(e), this.pitchClasses = e.pitchClasses || u, this.pitchToClass = new Map();\n\n        for (let e = 0; e < this.pitchClasses.length; ++e) this.pitchClasses[e].forEach(t => {\n          this.pitchToClass.set(t, e);\n        });\n\n        this.depth = this.pitchClasses.length;\n      }\n\n      toTensor(e) {\n        a.assertIsQuantizedSequence(e);\n        const t = this.numSteps || e.totalQuantizedSteps,\n              n = r.buffer([t, this.pitchClasses.length + 1], \"int32\");\n\n        for (let e = 0; e < t; ++e) n.set(1, e, -1);\n\n        return e.notes.forEach(e => {\n          n.set(1, e.quantizedStartStep, this.pitchToClass.get(e.pitch)), n.set(0, e.quantizedStartStep, -1);\n        }), n.toTensor();\n      }\n\n      async toNoteSequence(e, t, n) {\n        const r = y(t, n),\n              i = e.argMax(1),\n              s = await i.data();\n        i.dispose();\n\n        for (let e = 0; e < s.length; ++e) for (let t = 0; t < this.pitchClasses.length; t++) s[e] >> t & 1 && r.notes.push(o.a.Note.create({\n          pitch: this.pitchClasses[t][0],\n          quantizedStartStep: e,\n          quantizedEndStep: e + 1,\n          isDrum: !0\n        }));\n\n        return r.totalQuantizedSteps = s.length, r;\n      }\n\n    }\n\n    class m extends l {\n      async toNoteSequence(e, t, n) {\n        const r = y(t, n),\n              i = await e.data();\n\n        for (let t = 0; t < e.shape[0]; ++t) {\n          const e = i.slice(t * this.depth, (t + 1) * this.depth);\n\n          for (let n = 0; n < e.length; ++n) e[n] && r.notes.push(o.a.Note.create({\n            pitch: this.pitchClasses[n][0],\n            quantizedStartStep: t,\n            quantizedEndStep: t + 1,\n            isDrum: !0\n          }));\n        }\n\n        return r.totalQuantizedSteps = e.shape[0], r;\n      }\n\n    }\n\n    class h extends l {\n      constructor(e) {\n        super(e), this.depth = Math.pow(2, this.pitchClasses.length);\n      }\n\n      toTensor(e) {\n        a.assertIsRelativeQuantizedSequence(e);\n        const t = this.numSteps || e.totalQuantizedSteps,\n              n = Array(t).fill(0);\n\n        for (const _ref of e.notes) {\n          const t = _ref.pitch;\n          const r = _ref.quantizedStartStep;\n          n[r] += Math.pow(2, this.pitchToClass.get(t));\n        }\n\n        return r.tidy(() => r.oneHot(r.tensor1d(n, \"int32\"), this.depth));\n      }\n\n    }\n\n    class d extends p {\n      constructor(e) {\n        super(e), this.NOTE_OFF = 1, this.FIRST_PITCH = 2, this.minPitch = e.minPitch, this.maxPitch = e.maxPitch, this.ignorePolyphony = void 0 === e.ignorePolyphony || e.ignorePolyphony, this.depth = e.maxPitch - e.minPitch + 1 + this.FIRST_PITCH;\n      }\n\n      toTensor(e) {\n        a.assertIsQuantizedSequence(e);\n        const t = this.numSteps || e.totalQuantizedSteps,\n              n = e.notes.sort((e, t) => e.quantizedStartStep === t.quantizedStartStep ? t.pitch - e.pitch : e.quantizedStartStep - t.quantizedStartStep),\n              o = r.buffer([t], \"int32\");\n        let i = -1;\n        return n.forEach(e => {\n          if (e.quantizedStartStep === i) {\n            if (this.ignorePolyphony) return;\n            throw new Error(\"`NoteSequence` is not monophonic.\");\n          }\n\n          if (e.pitch < this.minPitch || e.pitch > this.maxPitch) throw Error(\"`NoteSequence` has a pitch outside of the valid range: \" + \"\".concat(e.pitch));\n          o.set(e.pitch - this.minPitch + this.FIRST_PITCH, e.quantizedStartStep), o.set(this.NOTE_OFF, e.quantizedEndStep), i = e.quantizedStartStep;\n        }), r.tidy(() => r.oneHot(o.toTensor(), this.depth));\n      }\n\n      async toNoteSequence(e, t, n) {\n        const r = y(t, n),\n              i = e.argMax(1),\n              s = await i.data();\n        i.dispose();\n        let a = null;\n\n        for (let e = 0; e < s.length; ++e) {\n          const t = s[e];\n\n          switch (t) {\n            case 0:\n              break;\n\n            case 1:\n              a && (a.quantizedEndStep = e, r.notes.push(a), a = null);\n              break;\n\n            default:\n              a && (a.quantizedEndStep = e, r.notes.push(a)), a = o.a.Note.create({\n                pitch: t - this.FIRST_PITCH + this.minPitch,\n                quantizedStartStep: e\n              });\n          }\n        }\n\n        return a && (a.quantizedEndStep = s.length, r.notes.push(a)), r.totalQuantizedSteps = s.length, r;\n      }\n\n    }\n\n    class f extends p {\n      constructor(e) {\n        super(e), this.NUM_SPLITS = 3, this.MEL_PROG_RANGE = [0, 31], this.BASS_PROG_RANGE = [32, 39], e.melArgs.numSteps = e.numSteps, e.bassArgs.numSteps = e.numSteps, e.drumsArgs.numSteps = e.numSteps, this.melConverter = new d(e.melArgs), this.bassConverter = new d(e.bassArgs), this.drumsConverter = new h(e.drumsArgs), this.depth = this.melConverter.depth + this.bassConverter.depth + this.drumsConverter.depth;\n      }\n\n      toTensor(e) {\n        a.assertIsQuantizedSequence(e);\n        const t = a.clone(e),\n              n = a.clone(e),\n              o = a.clone(e);\n        return t.notes = e.notes.filter(e => !e.isDrum && e.program >= this.MEL_PROG_RANGE[0] && e.program <= this.MEL_PROG_RANGE[1]), n.notes = e.notes.filter(e => !e.isDrum && e.program >= this.BASS_PROG_RANGE[0] && e.program <= this.BASS_PROG_RANGE[1]), o.notes = e.notes.filter(e => e.isDrum), r.tidy(() => r.concat([this.melConverter.toTensor(t), this.bassConverter.toTensor(n), this.drumsConverter.toTensor(o)], -1));\n      }\n\n      async toNoteSequence(e, t, n) {\n        const o = r.split(e, [this.melConverter.depth, this.bassConverter.depth, this.drumsConverter.depth], -1),\n              i = await this.melConverter.toNoteSequence(o[0], t, n);\n        i.notes.forEach(e => {\n          e.instrument = 0, e.program = 0;\n        });\n        const s = await this.bassConverter.toNoteSequence(o[1], t, n);\n        i.notes.push(...s.notes.map(e => (e.instrument = 1, e.program = this.BASS_PROG_RANGE[0], e)));\n        const a = await this.drumsConverter.toNoteSequence(o[2], t, n);\n        return i.notes.push(...a.notes.map(e => (e.instrument = 2, e))), o.forEach(e => e.dispose()), i;\n      }\n\n    }\n\n    class g extends p {\n      constructor(e) {\n        super(e), this.SEGMENTED_BY_TRACK = !0, this.stepsPerQuarter = e.stepsPerQuarter, this.totalSteps = e.totalSteps, this.numVelocityBins = e.numVelocityBins, this.minPitch = e.minPitch ? e.minPitch : i.MIN_MIDI_PITCH, this.maxPitch = e.maxPitch ? e.maxPitch : i.MAX_MIDI_PITCH, this.numPitches = this.maxPitch - this.minPitch + 1, this.performanceEventDepth = 2 * this.numPitches + this.totalSteps + this.numVelocityBins, this.numPrograms = i.MAX_MIDI_PROGRAM - i.MIN_MIDI_PROGRAM + 2, this.endToken = this.performanceEventDepth + this.numPrograms, this.depth = this.endToken + 1, this.endTensor = r.tidy(() => r.oneHot(r.tensor1d([this.endToken], \"int32\"), this.depth).as1D());\n      }\n\n      trackToTensor(e) {\n        const t = this.numSteps / this.numSegments;\n        let n = void 0;\n\n        if (e) {\n          for (; e.events.length > t - 2;) e.events.pop();\n\n          (n = r.buffer([e.events.length + 2], \"int32\")).set(this.performanceEventDepth + (e.isDrum ? this.numPrograms - 1 : e.program), 0), e.events.forEach((e, t) => {\n            switch (e.type) {\n              case \"note-on\":\n                n.set(e.pitch - this.minPitch, t + 1);\n                break;\n\n              case \"note-off\":\n                n.set(this.numPitches + e.pitch - this.minPitch, t + 1);\n                break;\n\n              case \"time-shift\":\n                n.set(2 * this.numPitches + e.steps - 1, t + 1);\n                break;\n\n              case \"velocity-change\":\n                n.set(2 * this.numPitches + this.totalSteps + e.velocityBin - 1, t + 1);\n                break;\n\n              default:\n                throw new Error(\"Unrecognized performance event: \".concat(e));\n            }\n          }), n.set(this.endToken, e.events.length + 1);\n        } else n = r.buffer([1], \"int32\", new Int32Array([this.endToken]));\n\n        return r.tidy(() => {\n          const e = r.oneHot(n.toTensor(), this.depth);\n          return e.pad([[0, t - e.shape[0]], [0, 0]]);\n        });\n      }\n\n      toTensor(e) {\n        if (a.assertIsRelativeQuantizedSequence(e), e.quantizationInfo.stepsPerQuarter !== this.stepsPerQuarter) throw new Error(\"Steps per quarter note mismatch: \".concat(e.quantizationInfo.stepsPerQuarter, \" != \").concat(this.stepsPerQuarter));\n        const t = a.clone(e);\n        t.notes = e.notes.filter(e => e.pitch >= this.minPitch && e.pitch <= this.maxPitch);\n        const n = new Set(t.notes.map(e => e.instrument)),\n              o = Array.from(n).map(e => s.Performance.fromNoteSequence(t, this.totalSteps, this.numVelocityBins, e)).sort((e, t) => t.isDrum ? -1 : e.isDrum ? 1 : e.program - t.program);\n\n        for (; o.length > this.numSegments;) o.pop();\n\n        for (o.forEach(e => e.setNumSteps(this.totalSteps)); o.length < this.numSegments;) o.push(void 0);\n\n        return r.tidy(() => r.concat(o.map(e => this.trackToTensor(e)), 0));\n      }\n\n      tokensToTrack(e) {\n        const t = e.indexOf(this.endToken),\n              n = t >= 0 ? t : e.length,\n              r = e.slice(0, n),\n              o = r.filter(e => e < this.performanceEventDepth),\n              i = r.filter(e => e >= this.performanceEventDepth),\n              _ref2 = i.length ? i[0] - this.performanceEventDepth < this.numPrograms - 1 ? [i[0] - this.performanceEventDepth, !1] : [0, !0] : [0, !1],\n              _ref3 = _slicedToArray(_ref2, 2),\n              a = _ref3[0],\n              u = _ref3[1],\n              c = Array.from(o).map(e => {\n          if (e < this.numPitches) return {\n            type: \"note-on\",\n            pitch: this.minPitch + e\n          };\n          if (e < 2 * this.numPitches) return {\n            type: \"note-off\",\n            pitch: this.minPitch + e - this.numPitches\n          };\n          if (e < 2 * this.numPitches + this.totalSteps) return {\n            type: \"time-shift\",\n            steps: e - 2 * this.numPitches + 1\n          };\n          if (e < 2 * this.numPitches + this.totalSteps + this.numVelocityBins) return {\n            type: \"velocity-change\",\n            velocityBin: e - 2 * this.numPitches - this.totalSteps + 1\n          };\n          throw new Error(\"Invalid performance event token: \".concat(e));\n        });\n\n        return new s.Performance(c, this.totalSteps, this.numVelocityBins, a, u);\n      }\n\n      async toNoteSequence(e, t = this.stepsPerQuarter, n) {\n        const o = y(t, n);\n        o.totalQuantizedSteps = this.totalSteps;\n        const i = r.tidy(() => r.split(e.argMax(1), this.numSegments));\n        return (await Promise.all(i.map(async e => {\n          const t = await e.data(),\n                n = this.tokensToTrack(t);\n          return e.dispose(), n;\n        }))).forEach((e, t) => {\n          e.setNumSteps(this.totalSteps), o.notes.push(...e.toNoteSequence(t).notes);\n        }), o;\n      }\n\n    }\n\n    class S extends p {\n      constructor(e) {\n        super(e), this.TAPIFY_CHANNEL = 3, this.stepsPerQuarter = e.stepsPerQuarter || i.DEFAULT_STEPS_PER_QUARTER, this.pitchClasses = e.pitchClasses || u, this.pitchToClass = new Map();\n\n        for (let e = 0; e < this.pitchClasses.length; ++e) this.pitchClasses[e].forEach(t => {\n          this.pitchToClass.set(t, e);\n        });\n\n        this.humanize = e.humanize || !1, this.tapify = e.tapify || !1, this.splitInstruments = e.splitInstruments || !1, this.depth = 3;\n      }\n\n      toTensor(e) {\n        const t = a.isRelativeQuantizedSequence(e) ? e : a.quantizeNoteSequence(e, this.stepsPerQuarter),\n              n = this.numSteps,\n              o = t.tempos && t.tempos.length ? t.tempos[0].qpm : i.DEFAULT_QUARTERS_PER_MINUTE,\n              s = 60 / o / this.stepsPerQuarter,\n              u = [];\n\n        for (let e = 0; e < n; ++e) u.push(new Map());\n\n        t.notes.forEach(e => {\n          if (!this.tapify && !this.pitchToClass.has(e.pitch)) return;\n          const t = e.quantizedStartStep;\n          if (t >= u.length) throw Error(\"Model does not support sequences with more than \".concat(n, \" steps (\").concat(n * s, \" seconds at qpm \").concat(o, \").\"));\n          const r = this.tapify ? this.TAPIFY_CHANNEL : this.pitchToClass.get(e.pitch);\n          (!u[t].has(r) || u[t].get(r).velocity < e.velocity) && u[t].set(r, e);\n        });\n        const c = this.pitchClasses.length,\n              p = r.buffer([n, c]),\n              l = r.buffer([n, c]),\n              m = r.buffer([n, c]);\n\n        function h(e) {\n          if (void 0 === e.startTime) return 0;\n          const t = e.startTime;\n          return 2 * (e.quantizedStartStep * s - t) / s;\n        }\n\n        for (let e = 0; e < n; ++e) for (let t = 0; t < c; ++t) {\n          const n = u[e].get(t);\n          p.set(n ? 1 : 0, e, t), this.humanize || this.tapify || l.set(n ? n.velocity / i.MAX_MIDI_VELOCITY : 0, e, t), this.humanize || m.set(n ? h(n) : 0, e, t);\n        }\n\n        return r.tidy(() => {\n          const e = p.toTensor(),\n                t = l.toTensor(),\n                o = m.toTensor(),\n                i = this.splitInstruments ? n * c : n;\n          return r.concat([e.as2D(i, -1), t.as2D(i, -1), o.as2D(i, -1)], 1);\n        });\n      }\n\n      async toNoteSequence(e, t, n = i.DEFAULT_QUARTERS_PER_MINUTE) {\n        if (t && t !== this.stepsPerQuarter) throw Error(\"`stepsPerQuarter` is set by the model.\");\n        t = this.stepsPerQuarter;\n        const r = this.splitInstruments ? e.shape[0] / this.pitchClasses.length : e.shape[0],\n              s = 60 / n / this.stepsPerQuarter,\n              a = o.a.create({\n          totalTime: r * s,\n          tempos: [{\n            qpm: n\n          }]\n        }),\n              u = await e.data();\n\n        function c(e, t, n) {\n          return Math.min(Math.max(e, t), n);\n        }\n\n        const p = this.pitchClasses.length;\n\n        for (let e = 0; e < r; ++e) {\n          const t = u.slice(e * p * this.depth, (e + 1) * p * this.depth);\n\n          for (let n = 0; n < p; ++n) {\n            const r = t[this.splitInstruments ? n * this.depth : n],\n                  u = t[this.splitInstruments ? n * this.depth + 1 : p + n],\n                  l = t[this.splitInstruments ? n * this.depth + 2 : 2 * p + n];\n\n            if (r > .5) {\n              const t = c(Math.round(u * i.MAX_MIDI_VELOCITY), i.MIN_MIDI_VELOCITY, i.MAX_MIDI_VELOCITY),\n                    r = c(l / 2, -.5, .5);\n              a.notes.push(o.a.Note.create({\n                pitch: this.pitchClasses[n][0],\n                startTime: (e - r) * s,\n                endTime: (e - r + 1) * s,\n                velocity: t,\n                isDrum: !0\n              }));\n            }\n          }\n        }\n\n        return a;\n      }\n\n    }\n\n    function y(e = i.DEFAULT_STEPS_PER_QUARTER, t = i.DEFAULT_QUARTERS_PER_MINUTE) {\n      return o.a.create({\n        quantizationInfo: {\n          stepsPerQuarter: e\n        },\n        tempos: [{\n          qpm: t\n        }]\n      });\n    }\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"Performance\", function () {\n      return a;\n    });\n    var r = n(2),\n        o = n(1),\n        i = n(6),\n        s = n(5);\n\n    class a {\n      constructor(e, t, n, r, o) {\n        this.events = e, this.maxShiftSteps = t, this.numVelocityBins = n, this.program = r, this.isDrum = o;\n      }\n\n      static fromNoteSequence(e, t, n, r) {\n        i.assertIsQuantizedSequence(e);\n        const s = e.notes.filter((e, t) => void 0 === r || e.instrument === r),\n              u = s.sort((e, t) => e.startTime === t.startTime ? e.pitch - t.pitch : e.startTime - t.startTime),\n              c = u.map((e, t) => ({\n          step: e.quantizedStartStep,\n          index: t,\n          isOffset: 0\n        })),\n              p = u.map((e, t) => ({\n          step: e.quantizedEndStep,\n          index: t,\n          isOffset: 1\n        })),\n              l = c.concat(p).sort((e, t) => e.step === t.step ? e.index === t.index ? e.isOffset - t.isOffset : e.index - t.index : e.step - t.step),\n              m = n ? Math.ceil((o.MIDI_VELOCITIES - 1) / n) : void 0,\n              h = [];\n        let d = 0,\n            f = n;\n\n        for (const e of l) {\n          if (e.step > d) {\n            for (; e.step > d + t;) h.push({\n              type: \"time-shift\",\n              steps: t\n            }), d += t;\n\n            h.push({\n              type: \"time-shift\",\n              steps: e.step - d\n            }), d = e.step;\n          }\n\n          if (e.isOffset) h.push({\n            type: \"note-off\",\n            pitch: u[e.index].pitch\n          });else {\n            if (m) {\n              const t = Math.floor((u[e.index].velocity - o.MIN_MIDI_VELOCITY - 1) / m) + 1;\n              t !== f && (h.push({\n                type: \"velocity-change\",\n                velocityBin: t\n              }), f = t);\n            }\n\n            h.push({\n              type: \"note-on\",\n              pitch: u[e.index].pitch\n            });\n          }\n        }\n\n        const g = !!s.some(e => e.isDrum) && (!s.some(e => !e.isDrum) || void 0),\n              S = Array.from(new Set(s.map(e => e.program))),\n              y = g || 1 !== S.length ? void 0 : S[0],\n              w = new a(h, t, n, y, g);\n        return w.setNumSteps(e.totalQuantizedSteps), w;\n      }\n\n      getNumSteps() {\n        return this.events.filter(e => \"time-shift\" === e.type).map(e => e.steps).reduce((e, t) => e + t, 0);\n      }\n\n      setNumSteps(e) {\n        let t = this.getNumSteps();\n\n        if (t < e) {\n          if (this.events.length) {\n            const n = this.events[this.events.length - 1];\n\n            if (\"time-shift\" === n.type) {\n              const r = Math.min(e - t, this.maxShiftSteps - n.steps);\n              n.steps += r, t += r;\n            }\n          }\n\n          for (; t < e;) t + this.maxShiftSteps > e ? (this.events.push({\n            type: \"time-shift\",\n            steps: e - t\n          }), t = e) : (this.events.push({\n            type: \"time-shift\",\n            steps: this.maxShiftSteps\n          }), t += this.maxShiftSteps);\n        } else if (t > e) for (; this.events.length && t > e;) {\n          const n = this.events[this.events.length - 1];\n          \"time-shift\" === n.type ? t - n.steps < e ? (n.steps -= t - e, t = e) : (this.events.pop(), t -= n.steps) : this.events.pop();\n        }\n      }\n\n      toNoteSequence(e) {\n        const t = this.numVelocityBins ? Math.ceil((o.MIDI_VELOCITIES - 1) / this.numVelocityBins) : void 0,\n              n = r.a.create();\n        let i = 0,\n            a = void 0;\n        const u = new Map();\n\n        for (let e = o.MIN_MIDI_PITCH; e <= o.MAX_MIDI_PITCH; ++e) u.set(e, []);\n\n        for (const c of this.events) switch (c.type) {\n          case \"note-on\":\n            u.get(c.pitch).push([i, a]);\n            break;\n\n          case \"note-off\":\n            const p = u.get(c.pitch);\n\n            if (p.length) {\n              const _p$shift = p.shift(),\n                    _p$shift2 = _slicedToArray(_p$shift, 2),\n                    t = _p$shift2[0],\n                    o = _p$shift2[1];\n\n              i > t ? n.notes.push(r.a.Note.create({\n                pitch: c.pitch,\n                velocity: o,\n                instrument: e,\n                quantizedStartStep: t,\n                quantizedEndStep: i,\n                program: this.program,\n                isDrum: this.isDrum\n              })) : s.log(\"Ignoring zero-length note: \" + \"(pitch = \".concat(c.pitch, \", step = \").concat(i, \")\"), \"Performance\");\n            } else s.log(\"Ignoring note-off with no previous note-on:\" + \"(pitch = \".concat(c.pitch, \", step = \").concat(i, \")\"), \"Performance\");\n\n            break;\n\n          case \"time-shift\":\n            i += c.steps;\n            break;\n\n          case \"velocity-change\":\n            if (!t) throw new Error(\"Unexpected velocity change event: \".concat(c));\n            a = o.MIN_MIDI_VELOCITY + (c.velocityBin - 1) * t + 1;\n            break;\n\n          default:\n            throw new Error(\"Unrecognized performance event: \".concat(c));\n        }\n\n        return u.forEach((t, o) => {\n          for (const _ref4 of t) {\n            var _ref5 = _slicedToArray(_ref4, 2);\n\n            const a = _ref5[0];\n            const u = _ref5[1];\n            i > a ? n.notes.push(r.a.Note.create({\n              pitch: o,\n              velocity: u,\n              instrument: e,\n              quantizedStartStep: a,\n              quantizedEndStep: i,\n              program: this.program,\n              isDrum: this.isDrum\n            })) : s.log(\"Ignoring zero-length note: \" + \"(pitch = \".concat(o, \", step = \").concat(i, \")\"), \"Performance\");\n          }\n        }), n.totalQuantizedSteps = i, n;\n      }\n\n    }\n  }, function (e, t, n) {\n    \"use strict\";\n\n    var r,\n        o,\n        i = n(14),\n        s = i.Reader,\n        a = i.Writer,\n        u = i.util,\n        c = i.roots.default || (i.roots.default = {});\n    c.tensorflow = ((o = {}).magenta = ((r = {}).NoteSequence = function () {\n      function e(e) {\n        if (this.timeSignatures = [], this.keySignatures = [], this.tempos = [], this.notes = [], this.pitchBends = [], this.controlChanges = [], this.partInfos = [], this.textAnnotations = [], this.sectionAnnotations = [], this.sectionGroups = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n      }\n\n      var t, n;\n      return e.prototype.id = \"\", e.prototype.filename = \"\", e.prototype.referenceNumber = u.Long ? u.Long.fromBits(0, 0, !1) : 0, e.prototype.collectionName = \"\", e.prototype.ticksPerQuarter = 0, e.prototype.timeSignatures = u.emptyArray, e.prototype.keySignatures = u.emptyArray, e.prototype.tempos = u.emptyArray, e.prototype.notes = u.emptyArray, e.prototype.totalTime = 0, e.prototype.totalQuantizedSteps = u.Long ? u.Long.fromBits(0, 0, !1) : 0, e.prototype.pitchBends = u.emptyArray, e.prototype.controlChanges = u.emptyArray, e.prototype.partInfos = u.emptyArray, e.prototype.sourceInfo = null, e.prototype.textAnnotations = u.emptyArray, e.prototype.sectionAnnotations = u.emptyArray, e.prototype.sectionGroups = u.emptyArray, e.prototype.quantizationInfo = null, e.prototype.subsequenceInfo = null, e.prototype.sequenceMetadata = null, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (e, t) {\n        if (t || (t = a.create()), null != e.id && e.hasOwnProperty(\"id\") && t.uint32(10).string(e.id), null != e.filename && e.hasOwnProperty(\"filename\") && t.uint32(18).string(e.filename), null != e.collectionName && e.hasOwnProperty(\"collectionName\") && t.uint32(26).string(e.collectionName), null != e.ticksPerQuarter && e.hasOwnProperty(\"ticksPerQuarter\") && t.uint32(32).int32(e.ticksPerQuarter), null != e.timeSignatures && e.timeSignatures.length) for (var n = 0; n < e.timeSignatures.length; ++n) c.tensorflow.magenta.NoteSequence.TimeSignature.encode(e.timeSignatures[n], t.uint32(42).fork()).ldelim();\n        if (null != e.keySignatures && e.keySignatures.length) for (n = 0; n < e.keySignatures.length; ++n) c.tensorflow.magenta.NoteSequence.KeySignature.encode(e.keySignatures[n], t.uint32(50).fork()).ldelim();\n        if (null != e.tempos && e.tempos.length) for (n = 0; n < e.tempos.length; ++n) c.tensorflow.magenta.NoteSequence.Tempo.encode(e.tempos[n], t.uint32(58).fork()).ldelim();\n        if (null != e.notes && e.notes.length) for (n = 0; n < e.notes.length; ++n) c.tensorflow.magenta.NoteSequence.Note.encode(e.notes[n], t.uint32(66).fork()).ldelim();\n        if (null != e.totalTime && e.hasOwnProperty(\"totalTime\") && t.uint32(73).double(e.totalTime), null != e.pitchBends && e.pitchBends.length) for (n = 0; n < e.pitchBends.length; ++n) c.tensorflow.magenta.NoteSequence.PitchBend.encode(e.pitchBends[n], t.uint32(82).fork()).ldelim();\n        if (null != e.controlChanges && e.controlChanges.length) for (n = 0; n < e.controlChanges.length; ++n) c.tensorflow.magenta.NoteSequence.ControlChange.encode(e.controlChanges[n], t.uint32(90).fork()).ldelim();\n        if (null != e.partInfos && e.partInfos.length) for (n = 0; n < e.partInfos.length; ++n) c.tensorflow.magenta.NoteSequence.PartInfo.encode(e.partInfos[n], t.uint32(98).fork()).ldelim();\n        if (null != e.sourceInfo && e.hasOwnProperty(\"sourceInfo\") && c.tensorflow.magenta.NoteSequence.SourceInfo.encode(e.sourceInfo, t.uint32(106).fork()).ldelim(), null != e.textAnnotations && e.textAnnotations.length) for (n = 0; n < e.textAnnotations.length; ++n) c.tensorflow.magenta.NoteSequence.TextAnnotation.encode(e.textAnnotations[n], t.uint32(114).fork()).ldelim();\n        if (null != e.quantizationInfo && e.hasOwnProperty(\"quantizationInfo\") && c.tensorflow.magenta.NoteSequence.QuantizationInfo.encode(e.quantizationInfo, t.uint32(122).fork()).ldelim(), null != e.totalQuantizedSteps && e.hasOwnProperty(\"totalQuantizedSteps\") && t.uint32(128).int64(e.totalQuantizedSteps), null != e.subsequenceInfo && e.hasOwnProperty(\"subsequenceInfo\") && c.tensorflow.magenta.NoteSequence.SubsequenceInfo.encode(e.subsequenceInfo, t.uint32(138).fork()).ldelim(), null != e.referenceNumber && e.hasOwnProperty(\"referenceNumber\") && t.uint32(144).int64(e.referenceNumber), null != e.sequenceMetadata && e.hasOwnProperty(\"sequenceMetadata\") && c.tensorflow.magenta.SequenceMetadata.encode(e.sequenceMetadata, t.uint32(154).fork()).ldelim(), null != e.sectionAnnotations && e.sectionAnnotations.length) for (n = 0; n < e.sectionAnnotations.length; ++n) c.tensorflow.magenta.NoteSequence.SectionAnnotation.encode(e.sectionAnnotations[n], t.uint32(162).fork()).ldelim();\n        if (null != e.sectionGroups && e.sectionGroups.length) for (n = 0; n < e.sectionGroups.length; ++n) c.tensorflow.magenta.NoteSequence.SectionGroup.encode(e.sectionGroups[n], t.uint32(170).fork()).ldelim();\n        return t;\n      }, e.encodeDelimited = function (e, t) {\n        return this.encode(e, t).ldelim();\n      }, e.decode = function (e, t) {\n        e instanceof s || (e = s.create(e));\n\n        for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence(); e.pos < n;) {\n          var o = e.uint32();\n\n          switch (o >>> 3) {\n            case 1:\n              r.id = e.string();\n              break;\n\n            case 2:\n              r.filename = e.string();\n              break;\n\n            case 18:\n              r.referenceNumber = u.Long ? e.int64().toNumber() : e.int64();\n              break;\n\n            case 3:\n              r.collectionName = e.string();\n              break;\n\n            case 4:\n              r.ticksPerQuarter = e.int32();\n              break;\n\n            case 5:\n              r.timeSignatures && r.timeSignatures.length || (r.timeSignatures = []), r.timeSignatures.push(c.tensorflow.magenta.NoteSequence.TimeSignature.decode(e, e.uint32()));\n              break;\n\n            case 6:\n              r.keySignatures && r.keySignatures.length || (r.keySignatures = []), r.keySignatures.push(c.tensorflow.magenta.NoteSequence.KeySignature.decode(e, e.uint32()));\n              break;\n\n            case 7:\n              r.tempos && r.tempos.length || (r.tempos = []), r.tempos.push(c.tensorflow.magenta.NoteSequence.Tempo.decode(e, e.uint32()));\n              break;\n\n            case 8:\n              r.notes && r.notes.length || (r.notes = []), r.notes.push(c.tensorflow.magenta.NoteSequence.Note.decode(e, e.uint32()));\n              break;\n\n            case 9:\n              r.totalTime = e.double();\n              break;\n\n            case 16:\n              r.totalQuantizedSteps = u.Long ? e.int64().toNumber() : e.int64();\n              break;\n\n            case 10:\n              r.pitchBends && r.pitchBends.length || (r.pitchBends = []), r.pitchBends.push(c.tensorflow.magenta.NoteSequence.PitchBend.decode(e, e.uint32()));\n              break;\n\n            case 11:\n              r.controlChanges && r.controlChanges.length || (r.controlChanges = []), r.controlChanges.push(c.tensorflow.magenta.NoteSequence.ControlChange.decode(e, e.uint32()));\n              break;\n\n            case 12:\n              r.partInfos && r.partInfos.length || (r.partInfos = []), r.partInfos.push(c.tensorflow.magenta.NoteSequence.PartInfo.decode(e, e.uint32()));\n              break;\n\n            case 13:\n              r.sourceInfo = c.tensorflow.magenta.NoteSequence.SourceInfo.decode(e, e.uint32());\n              break;\n\n            case 14:\n              r.textAnnotations && r.textAnnotations.length || (r.textAnnotations = []), r.textAnnotations.push(c.tensorflow.magenta.NoteSequence.TextAnnotation.decode(e, e.uint32()));\n              break;\n\n            case 20:\n              r.sectionAnnotations && r.sectionAnnotations.length || (r.sectionAnnotations = []), r.sectionAnnotations.push(c.tensorflow.magenta.NoteSequence.SectionAnnotation.decode(e, e.uint32()));\n              break;\n\n            case 21:\n              r.sectionGroups && r.sectionGroups.length || (r.sectionGroups = []), r.sectionGroups.push(c.tensorflow.magenta.NoteSequence.SectionGroup.decode(e, e.uint32()));\n              break;\n\n            case 15:\n              r.quantizationInfo = c.tensorflow.magenta.NoteSequence.QuantizationInfo.decode(e, e.uint32());\n              break;\n\n            case 17:\n              r.subsequenceInfo = c.tensorflow.magenta.NoteSequence.SubsequenceInfo.decode(e, e.uint32());\n              break;\n\n            case 19:\n              r.sequenceMetadata = c.tensorflow.magenta.SequenceMetadata.decode(e, e.uint32());\n              break;\n\n            default:\n              e.skipType(7 & o);\n          }\n        }\n\n        return r;\n      }, e.decodeDelimited = function (e) {\n        return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n      }, e.verify = function (e) {\n        if (\"object\" != typeof e || null === e) return \"object expected\";\n        if (null != e.id && e.hasOwnProperty(\"id\") && !u.isString(e.id)) return \"id: string expected\";\n        if (null != e.filename && e.hasOwnProperty(\"filename\") && !u.isString(e.filename)) return \"filename: string expected\";\n        if (null != e.referenceNumber && e.hasOwnProperty(\"referenceNumber\") && !(u.isInteger(e.referenceNumber) || e.referenceNumber && u.isInteger(e.referenceNumber.low) && u.isInteger(e.referenceNumber.high))) return \"referenceNumber: integer|Long expected\";\n        if (null != e.collectionName && e.hasOwnProperty(\"collectionName\") && !u.isString(e.collectionName)) return \"collectionName: string expected\";\n        if (null != e.ticksPerQuarter && e.hasOwnProperty(\"ticksPerQuarter\") && !u.isInteger(e.ticksPerQuarter)) return \"ticksPerQuarter: integer expected\";\n\n        if (null != e.timeSignatures && e.hasOwnProperty(\"timeSignatures\")) {\n          if (!Array.isArray(e.timeSignatures)) return \"timeSignatures: array expected\";\n\n          for (var t = 0; t < e.timeSignatures.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.TimeSignature.verify(e.timeSignatures[t])) return \"timeSignatures.\" + n;\n        }\n\n        if (null != e.keySignatures && e.hasOwnProperty(\"keySignatures\")) {\n          if (!Array.isArray(e.keySignatures)) return \"keySignatures: array expected\";\n\n          for (t = 0; t < e.keySignatures.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.KeySignature.verify(e.keySignatures[t])) return \"keySignatures.\" + n;\n        }\n\n        if (null != e.tempos && e.hasOwnProperty(\"tempos\")) {\n          if (!Array.isArray(e.tempos)) return \"tempos: array expected\";\n\n          for (t = 0; t < e.tempos.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.Tempo.verify(e.tempos[t])) return \"tempos.\" + n;\n        }\n\n        if (null != e.notes && e.hasOwnProperty(\"notes\")) {\n          if (!Array.isArray(e.notes)) return \"notes: array expected\";\n\n          for (t = 0; t < e.notes.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.Note.verify(e.notes[t])) return \"notes.\" + n;\n        }\n\n        if (null != e.totalTime && e.hasOwnProperty(\"totalTime\") && \"number\" != typeof e.totalTime) return \"totalTime: number expected\";\n        if (null != e.totalQuantizedSteps && e.hasOwnProperty(\"totalQuantizedSteps\") && !(u.isInteger(e.totalQuantizedSteps) || e.totalQuantizedSteps && u.isInteger(e.totalQuantizedSteps.low) && u.isInteger(e.totalQuantizedSteps.high))) return \"totalQuantizedSteps: integer|Long expected\";\n\n        if (null != e.pitchBends && e.hasOwnProperty(\"pitchBends\")) {\n          if (!Array.isArray(e.pitchBends)) return \"pitchBends: array expected\";\n\n          for (t = 0; t < e.pitchBends.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.PitchBend.verify(e.pitchBends[t])) return \"pitchBends.\" + n;\n        }\n\n        if (null != e.controlChanges && e.hasOwnProperty(\"controlChanges\")) {\n          if (!Array.isArray(e.controlChanges)) return \"controlChanges: array expected\";\n\n          for (t = 0; t < e.controlChanges.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.ControlChange.verify(e.controlChanges[t])) return \"controlChanges.\" + n;\n        }\n\n        if (null != e.partInfos && e.hasOwnProperty(\"partInfos\")) {\n          if (!Array.isArray(e.partInfos)) return \"partInfos: array expected\";\n\n          for (t = 0; t < e.partInfos.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.PartInfo.verify(e.partInfos[t])) return \"partInfos.\" + n;\n        }\n\n        if (null != e.sourceInfo && e.hasOwnProperty(\"sourceInfo\") && (n = c.tensorflow.magenta.NoteSequence.SourceInfo.verify(e.sourceInfo))) return \"sourceInfo.\" + n;\n\n        if (null != e.textAnnotations && e.hasOwnProperty(\"textAnnotations\")) {\n          if (!Array.isArray(e.textAnnotations)) return \"textAnnotations: array expected\";\n\n          for (t = 0; t < e.textAnnotations.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.TextAnnotation.verify(e.textAnnotations[t])) return \"textAnnotations.\" + n;\n        }\n\n        if (null != e.sectionAnnotations && e.hasOwnProperty(\"sectionAnnotations\")) {\n          if (!Array.isArray(e.sectionAnnotations)) return \"sectionAnnotations: array expected\";\n\n          for (t = 0; t < e.sectionAnnotations.length; ++t) if (n = c.tensorflow.magenta.NoteSequence.SectionAnnotation.verify(e.sectionAnnotations[t])) return \"sectionAnnotations.\" + n;\n        }\n\n        if (null != e.sectionGroups && e.hasOwnProperty(\"sectionGroups\")) {\n          if (!Array.isArray(e.sectionGroups)) return \"sectionGroups: array expected\";\n\n          for (t = 0; t < e.sectionGroups.length; ++t) {\n            var n;\n            if (n = c.tensorflow.magenta.NoteSequence.SectionGroup.verify(e.sectionGroups[t])) return \"sectionGroups.\" + n;\n          }\n        }\n\n        return null != e.quantizationInfo && e.hasOwnProperty(\"quantizationInfo\") && (n = c.tensorflow.magenta.NoteSequence.QuantizationInfo.verify(e.quantizationInfo)) ? \"quantizationInfo.\" + n : null != e.subsequenceInfo && e.hasOwnProperty(\"subsequenceInfo\") && (n = c.tensorflow.magenta.NoteSequence.SubsequenceInfo.verify(e.subsequenceInfo)) ? \"subsequenceInfo.\" + n : null != e.sequenceMetadata && e.hasOwnProperty(\"sequenceMetadata\") && (n = c.tensorflow.magenta.SequenceMetadata.verify(e.sequenceMetadata)) ? \"sequenceMetadata.\" + n : null;\n      }, e.fromObject = function (e) {\n        if (e instanceof c.tensorflow.magenta.NoteSequence) return e;\n        var t = new c.tensorflow.magenta.NoteSequence();\n\n        if (null != e.id && (t.id = String(e.id)), null != e.filename && (t.filename = String(e.filename)), null != e.referenceNumber && (u.Long ? (t.referenceNumber = u.Long.fromValue(e.referenceNumber)).unsigned = !1 : \"string\" == typeof e.referenceNumber ? t.referenceNumber = parseInt(e.referenceNumber, 10) : \"number\" == typeof e.referenceNumber ? t.referenceNumber = e.referenceNumber : \"object\" == typeof e.referenceNumber && (t.referenceNumber = new u.LongBits(e.referenceNumber.low >>> 0, e.referenceNumber.high >>> 0).toNumber())), null != e.collectionName && (t.collectionName = String(e.collectionName)), null != e.ticksPerQuarter && (t.ticksPerQuarter = 0 | e.ticksPerQuarter), e.timeSignatures) {\n          if (!Array.isArray(e.timeSignatures)) throw TypeError(\".tensorflow.magenta.NoteSequence.timeSignatures: array expected\");\n          t.timeSignatures = [];\n\n          for (var n = 0; n < e.timeSignatures.length; ++n) {\n            if (\"object\" != typeof e.timeSignatures[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.timeSignatures: object expected\");\n            t.timeSignatures[n] = c.tensorflow.magenta.NoteSequence.TimeSignature.fromObject(e.timeSignatures[n]);\n          }\n        }\n\n        if (e.keySignatures) {\n          if (!Array.isArray(e.keySignatures)) throw TypeError(\".tensorflow.magenta.NoteSequence.keySignatures: array expected\");\n\n          for (t.keySignatures = [], n = 0; n < e.keySignatures.length; ++n) {\n            if (\"object\" != typeof e.keySignatures[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.keySignatures: object expected\");\n            t.keySignatures[n] = c.tensorflow.magenta.NoteSequence.KeySignature.fromObject(e.keySignatures[n]);\n          }\n        }\n\n        if (e.tempos) {\n          if (!Array.isArray(e.tempos)) throw TypeError(\".tensorflow.magenta.NoteSequence.tempos: array expected\");\n\n          for (t.tempos = [], n = 0; n < e.tempos.length; ++n) {\n            if (\"object\" != typeof e.tempos[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.tempos: object expected\");\n            t.tempos[n] = c.tensorflow.magenta.NoteSequence.Tempo.fromObject(e.tempos[n]);\n          }\n        }\n\n        if (e.notes) {\n          if (!Array.isArray(e.notes)) throw TypeError(\".tensorflow.magenta.NoteSequence.notes: array expected\");\n\n          for (t.notes = [], n = 0; n < e.notes.length; ++n) {\n            if (\"object\" != typeof e.notes[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.notes: object expected\");\n            t.notes[n] = c.tensorflow.magenta.NoteSequence.Note.fromObject(e.notes[n]);\n          }\n        }\n\n        if (null != e.totalTime && (t.totalTime = Number(e.totalTime)), null != e.totalQuantizedSteps && (u.Long ? (t.totalQuantizedSteps = u.Long.fromValue(e.totalQuantizedSteps)).unsigned = !1 : \"string\" == typeof e.totalQuantizedSteps ? t.totalQuantizedSteps = parseInt(e.totalQuantizedSteps, 10) : \"number\" == typeof e.totalQuantizedSteps ? t.totalQuantizedSteps = e.totalQuantizedSteps : \"object\" == typeof e.totalQuantizedSteps && (t.totalQuantizedSteps = new u.LongBits(e.totalQuantizedSteps.low >>> 0, e.totalQuantizedSteps.high >>> 0).toNumber())), e.pitchBends) {\n          if (!Array.isArray(e.pitchBends)) throw TypeError(\".tensorflow.magenta.NoteSequence.pitchBends: array expected\");\n\n          for (t.pitchBends = [], n = 0; n < e.pitchBends.length; ++n) {\n            if (\"object\" != typeof e.pitchBends[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.pitchBends: object expected\");\n            t.pitchBends[n] = c.tensorflow.magenta.NoteSequence.PitchBend.fromObject(e.pitchBends[n]);\n          }\n        }\n\n        if (e.controlChanges) {\n          if (!Array.isArray(e.controlChanges)) throw TypeError(\".tensorflow.magenta.NoteSequence.controlChanges: array expected\");\n\n          for (t.controlChanges = [], n = 0; n < e.controlChanges.length; ++n) {\n            if (\"object\" != typeof e.controlChanges[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.controlChanges: object expected\");\n            t.controlChanges[n] = c.tensorflow.magenta.NoteSequence.ControlChange.fromObject(e.controlChanges[n]);\n          }\n        }\n\n        if (e.partInfos) {\n          if (!Array.isArray(e.partInfos)) throw TypeError(\".tensorflow.magenta.NoteSequence.partInfos: array expected\");\n\n          for (t.partInfos = [], n = 0; n < e.partInfos.length; ++n) {\n            if (\"object\" != typeof e.partInfos[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.partInfos: object expected\");\n            t.partInfos[n] = c.tensorflow.magenta.NoteSequence.PartInfo.fromObject(e.partInfos[n]);\n          }\n        }\n\n        if (null != e.sourceInfo) {\n          if (\"object\" != typeof e.sourceInfo) throw TypeError(\".tensorflow.magenta.NoteSequence.sourceInfo: object expected\");\n          t.sourceInfo = c.tensorflow.magenta.NoteSequence.SourceInfo.fromObject(e.sourceInfo);\n        }\n\n        if (e.textAnnotations) {\n          if (!Array.isArray(e.textAnnotations)) throw TypeError(\".tensorflow.magenta.NoteSequence.textAnnotations: array expected\");\n\n          for (t.textAnnotations = [], n = 0; n < e.textAnnotations.length; ++n) {\n            if (\"object\" != typeof e.textAnnotations[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.textAnnotations: object expected\");\n            t.textAnnotations[n] = c.tensorflow.magenta.NoteSequence.TextAnnotation.fromObject(e.textAnnotations[n]);\n          }\n        }\n\n        if (e.sectionAnnotations) {\n          if (!Array.isArray(e.sectionAnnotations)) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionAnnotations: array expected\");\n\n          for (t.sectionAnnotations = [], n = 0; n < e.sectionAnnotations.length; ++n) {\n            if (\"object\" != typeof e.sectionAnnotations[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionAnnotations: object expected\");\n            t.sectionAnnotations[n] = c.tensorflow.magenta.NoteSequence.SectionAnnotation.fromObject(e.sectionAnnotations[n]);\n          }\n        }\n\n        if (e.sectionGroups) {\n          if (!Array.isArray(e.sectionGroups)) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionGroups: array expected\");\n\n          for (t.sectionGroups = [], n = 0; n < e.sectionGroups.length; ++n) {\n            if (\"object\" != typeof e.sectionGroups[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionGroups: object expected\");\n            t.sectionGroups[n] = c.tensorflow.magenta.NoteSequence.SectionGroup.fromObject(e.sectionGroups[n]);\n          }\n        }\n\n        if (null != e.quantizationInfo) {\n          if (\"object\" != typeof e.quantizationInfo) throw TypeError(\".tensorflow.magenta.NoteSequence.quantizationInfo: object expected\");\n          t.quantizationInfo = c.tensorflow.magenta.NoteSequence.QuantizationInfo.fromObject(e.quantizationInfo);\n        }\n\n        if (null != e.subsequenceInfo) {\n          if (\"object\" != typeof e.subsequenceInfo) throw TypeError(\".tensorflow.magenta.NoteSequence.subsequenceInfo: object expected\");\n          t.subsequenceInfo = c.tensorflow.magenta.NoteSequence.SubsequenceInfo.fromObject(e.subsequenceInfo);\n        }\n\n        if (null != e.sequenceMetadata) {\n          if (\"object\" != typeof e.sequenceMetadata) throw TypeError(\".tensorflow.magenta.NoteSequence.sequenceMetadata: object expected\");\n          t.sequenceMetadata = c.tensorflow.magenta.SequenceMetadata.fromObject(e.sequenceMetadata);\n        }\n\n        return t;\n      }, e.toObject = function (e, t) {\n        t || (t = {});\n        var n = {};\n\n        if ((t.arrays || t.defaults) && (n.timeSignatures = [], n.keySignatures = [], n.tempos = [], n.notes = [], n.pitchBends = [], n.controlChanges = [], n.partInfos = [], n.textAnnotations = [], n.sectionAnnotations = [], n.sectionGroups = []), t.defaults) {\n          if (n.id = \"\", n.filename = \"\", n.collectionName = \"\", n.ticksPerQuarter = 0, n.totalTime = 0, n.sourceInfo = null, n.quantizationInfo = null, u.Long) {\n            var r = new u.Long(0, 0, !1);\n            n.totalQuantizedSteps = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n          } else n.totalQuantizedSteps = t.longs === String ? \"0\" : 0;\n\n          n.subsequenceInfo = null, u.Long ? (r = new u.Long(0, 0, !1), n.referenceNumber = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r) : n.referenceNumber = t.longs === String ? \"0\" : 0, n.sequenceMetadata = null;\n        }\n\n        if (null != e.id && e.hasOwnProperty(\"id\") && (n.id = e.id), null != e.filename && e.hasOwnProperty(\"filename\") && (n.filename = e.filename), null != e.collectionName && e.hasOwnProperty(\"collectionName\") && (n.collectionName = e.collectionName), null != e.ticksPerQuarter && e.hasOwnProperty(\"ticksPerQuarter\") && (n.ticksPerQuarter = e.ticksPerQuarter), e.timeSignatures && e.timeSignatures.length) {\n          n.timeSignatures = [];\n\n          for (var o = 0; o < e.timeSignatures.length; ++o) n.timeSignatures[o] = c.tensorflow.magenta.NoteSequence.TimeSignature.toObject(e.timeSignatures[o], t);\n        }\n\n        if (e.keySignatures && e.keySignatures.length) for (n.keySignatures = [], o = 0; o < e.keySignatures.length; ++o) n.keySignatures[o] = c.tensorflow.magenta.NoteSequence.KeySignature.toObject(e.keySignatures[o], t);\n        if (e.tempos && e.tempos.length) for (n.tempos = [], o = 0; o < e.tempos.length; ++o) n.tempos[o] = c.tensorflow.magenta.NoteSequence.Tempo.toObject(e.tempos[o], t);\n        if (e.notes && e.notes.length) for (n.notes = [], o = 0; o < e.notes.length; ++o) n.notes[o] = c.tensorflow.magenta.NoteSequence.Note.toObject(e.notes[o], t);\n        if (null != e.totalTime && e.hasOwnProperty(\"totalTime\") && (n.totalTime = t.json && !isFinite(e.totalTime) ? String(e.totalTime) : e.totalTime), e.pitchBends && e.pitchBends.length) for (n.pitchBends = [], o = 0; o < e.pitchBends.length; ++o) n.pitchBends[o] = c.tensorflow.magenta.NoteSequence.PitchBend.toObject(e.pitchBends[o], t);\n        if (e.controlChanges && e.controlChanges.length) for (n.controlChanges = [], o = 0; o < e.controlChanges.length; ++o) n.controlChanges[o] = c.tensorflow.magenta.NoteSequence.ControlChange.toObject(e.controlChanges[o], t);\n        if (e.partInfos && e.partInfos.length) for (n.partInfos = [], o = 0; o < e.partInfos.length; ++o) n.partInfos[o] = c.tensorflow.magenta.NoteSequence.PartInfo.toObject(e.partInfos[o], t);\n        if (null != e.sourceInfo && e.hasOwnProperty(\"sourceInfo\") && (n.sourceInfo = c.tensorflow.magenta.NoteSequence.SourceInfo.toObject(e.sourceInfo, t)), e.textAnnotations && e.textAnnotations.length) for (n.textAnnotations = [], o = 0; o < e.textAnnotations.length; ++o) n.textAnnotations[o] = c.tensorflow.magenta.NoteSequence.TextAnnotation.toObject(e.textAnnotations[o], t);\n        if (null != e.quantizationInfo && e.hasOwnProperty(\"quantizationInfo\") && (n.quantizationInfo = c.tensorflow.magenta.NoteSequence.QuantizationInfo.toObject(e.quantizationInfo, t)), null != e.totalQuantizedSteps && e.hasOwnProperty(\"totalQuantizedSteps\") && (\"number\" == typeof e.totalQuantizedSteps ? n.totalQuantizedSteps = t.longs === String ? String(e.totalQuantizedSteps) : e.totalQuantizedSteps : n.totalQuantizedSteps = t.longs === String ? u.Long.prototype.toString.call(e.totalQuantizedSteps) : t.longs === Number ? new u.LongBits(e.totalQuantizedSteps.low >>> 0, e.totalQuantizedSteps.high >>> 0).toNumber() : e.totalQuantizedSteps), null != e.subsequenceInfo && e.hasOwnProperty(\"subsequenceInfo\") && (n.subsequenceInfo = c.tensorflow.magenta.NoteSequence.SubsequenceInfo.toObject(e.subsequenceInfo, t)), null != e.referenceNumber && e.hasOwnProperty(\"referenceNumber\") && (\"number\" == typeof e.referenceNumber ? n.referenceNumber = t.longs === String ? String(e.referenceNumber) : e.referenceNumber : n.referenceNumber = t.longs === String ? u.Long.prototype.toString.call(e.referenceNumber) : t.longs === Number ? new u.LongBits(e.referenceNumber.low >>> 0, e.referenceNumber.high >>> 0).toNumber() : e.referenceNumber), null != e.sequenceMetadata && e.hasOwnProperty(\"sequenceMetadata\") && (n.sequenceMetadata = c.tensorflow.magenta.SequenceMetadata.toObject(e.sequenceMetadata, t)), e.sectionAnnotations && e.sectionAnnotations.length) for (n.sectionAnnotations = [], o = 0; o < e.sectionAnnotations.length; ++o) n.sectionAnnotations[o] = c.tensorflow.magenta.NoteSequence.SectionAnnotation.toObject(e.sectionAnnotations[o], t);\n        if (e.sectionGroups && e.sectionGroups.length) for (n.sectionGroups = [], o = 0; o < e.sectionGroups.length; ++o) n.sectionGroups[o] = c.tensorflow.magenta.NoteSequence.SectionGroup.toObject(e.sectionGroups[o], t);\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, i.util.toJSONOptions);\n      }, e.Note = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.pitch = 0, e.prototype.pitchName = 0, e.prototype.velocity = 0, e.prototype.startTime = 0, e.prototype.quantizedStartStep = u.Long ? u.Long.fromBits(0, 0, !1) : 0, e.prototype.endTime = 0, e.prototype.quantizedEndStep = u.Long ? u.Long.fromBits(0, 0, !1) : 0, e.prototype.numerator = 0, e.prototype.denominator = 0, e.prototype.instrument = 0, e.prototype.program = 0, e.prototype.isDrum = !1, e.prototype.part = 0, e.prototype.voice = 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.pitch && e.hasOwnProperty(\"pitch\") && t.uint32(8).int32(e.pitch), null != e.velocity && e.hasOwnProperty(\"velocity\") && t.uint32(16).int32(e.velocity), null != e.startTime && e.hasOwnProperty(\"startTime\") && t.uint32(25).double(e.startTime), null != e.endTime && e.hasOwnProperty(\"endTime\") && t.uint32(33).double(e.endTime), null != e.numerator && e.hasOwnProperty(\"numerator\") && t.uint32(40).int32(e.numerator), null != e.denominator && e.hasOwnProperty(\"denominator\") && t.uint32(48).int32(e.denominator), null != e.instrument && e.hasOwnProperty(\"instrument\") && t.uint32(56).int32(e.instrument), null != e.program && e.hasOwnProperty(\"program\") && t.uint32(64).int32(e.program), null != e.isDrum && e.hasOwnProperty(\"isDrum\") && t.uint32(72).bool(e.isDrum), null != e.part && e.hasOwnProperty(\"part\") && t.uint32(80).int32(e.part), null != e.pitchName && e.hasOwnProperty(\"pitchName\") && t.uint32(88).int32(e.pitchName), null != e.voice && e.hasOwnProperty(\"voice\") && t.uint32(96).int32(e.voice), null != e.quantizedStartStep && e.hasOwnProperty(\"quantizedStartStep\") && t.uint32(104).int64(e.quantizedStartStep), null != e.quantizedEndStep && e.hasOwnProperty(\"quantizedEndStep\") && t.uint32(112).int64(e.quantizedEndStep), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.Note(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.pitch = e.int32();\n                break;\n\n              case 11:\n                r.pitchName = e.int32();\n                break;\n\n              case 2:\n                r.velocity = e.int32();\n                break;\n\n              case 3:\n                r.startTime = e.double();\n                break;\n\n              case 13:\n                r.quantizedStartStep = u.Long ? e.int64().toNumber() : e.int64();\n                break;\n\n              case 4:\n                r.endTime = e.double();\n                break;\n\n              case 14:\n                r.quantizedEndStep = u.Long ? e.int64().toNumber() : e.int64();\n                break;\n\n              case 5:\n                r.numerator = e.int32();\n                break;\n\n              case 6:\n                r.denominator = e.int32();\n                break;\n\n              case 7:\n                r.instrument = e.int32();\n                break;\n\n              case 8:\n                r.program = e.int32();\n                break;\n\n              case 9:\n                r.isDrum = e.bool();\n                break;\n\n              case 10:\n                r.part = e.int32();\n                break;\n\n              case 12:\n                r.voice = e.int32();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          if (\"object\" != typeof e || null === e) return \"object expected\";\n          if (null != e.pitch && e.hasOwnProperty(\"pitch\") && !u.isInteger(e.pitch)) return \"pitch: integer expected\";\n          if (null != e.pitchName && e.hasOwnProperty(\"pitchName\")) switch (e.pitchName) {\n            default:\n              return \"pitchName: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n            case 19:\n            case 20:\n            case 21:\n            case 22:\n            case 23:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 28:\n            case 29:\n            case 30:\n            case 31:\n            case 32:\n            case 33:\n            case 34:\n            case 35:\n          }\n          return null != e.velocity && e.hasOwnProperty(\"velocity\") && !u.isInteger(e.velocity) ? \"velocity: integer expected\" : null != e.startTime && e.hasOwnProperty(\"startTime\") && \"number\" != typeof e.startTime ? \"startTime: number expected\" : null != e.quantizedStartStep && e.hasOwnProperty(\"quantizedStartStep\") && !(u.isInteger(e.quantizedStartStep) || e.quantizedStartStep && u.isInteger(e.quantizedStartStep.low) && u.isInteger(e.quantizedStartStep.high)) ? \"quantizedStartStep: integer|Long expected\" : null != e.endTime && e.hasOwnProperty(\"endTime\") && \"number\" != typeof e.endTime ? \"endTime: number expected\" : null != e.quantizedEndStep && e.hasOwnProperty(\"quantizedEndStep\") && !(u.isInteger(e.quantizedEndStep) || e.quantizedEndStep && u.isInteger(e.quantizedEndStep.low) && u.isInteger(e.quantizedEndStep.high)) ? \"quantizedEndStep: integer|Long expected\" : null != e.numerator && e.hasOwnProperty(\"numerator\") && !u.isInteger(e.numerator) ? \"numerator: integer expected\" : null != e.denominator && e.hasOwnProperty(\"denominator\") && !u.isInteger(e.denominator) ? \"denominator: integer expected\" : null != e.instrument && e.hasOwnProperty(\"instrument\") && !u.isInteger(e.instrument) ? \"instrument: integer expected\" : null != e.program && e.hasOwnProperty(\"program\") && !u.isInteger(e.program) ? \"program: integer expected\" : null != e.isDrum && e.hasOwnProperty(\"isDrum\") && \"boolean\" != typeof e.isDrum ? \"isDrum: boolean expected\" : null != e.part && e.hasOwnProperty(\"part\") && !u.isInteger(e.part) ? \"part: integer expected\" : null != e.voice && e.hasOwnProperty(\"voice\") && !u.isInteger(e.voice) ? \"voice: integer expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.Note) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.Note();\n\n          switch (null != e.pitch && (t.pitch = 0 | e.pitch), e.pitchName) {\n            case \"UNKNOWN_PITCH_NAME\":\n            case 0:\n              t.pitchName = 0;\n              break;\n\n            case \"F_FLAT_FLAT\":\n            case 1:\n              t.pitchName = 1;\n              break;\n\n            case \"C_FLAT_FLAT\":\n            case 2:\n              t.pitchName = 2;\n              break;\n\n            case \"G_FLAT_FLAT\":\n            case 3:\n              t.pitchName = 3;\n              break;\n\n            case \"D_FLAT_FLAT\":\n            case 4:\n              t.pitchName = 4;\n              break;\n\n            case \"A_FLAT_FLAT\":\n            case 5:\n              t.pitchName = 5;\n              break;\n\n            case \"E_FLAT_FLAT\":\n            case 6:\n              t.pitchName = 6;\n              break;\n\n            case \"B_FLAT_FLAT\":\n            case 7:\n              t.pitchName = 7;\n              break;\n\n            case \"F_FLAT\":\n            case 8:\n              t.pitchName = 8;\n              break;\n\n            case \"C_FLAT\":\n            case 9:\n              t.pitchName = 9;\n              break;\n\n            case \"G_FLAT\":\n            case 10:\n              t.pitchName = 10;\n              break;\n\n            case \"D_FLAT\":\n            case 11:\n              t.pitchName = 11;\n              break;\n\n            case \"A_FLAT\":\n            case 12:\n              t.pitchName = 12;\n              break;\n\n            case \"E_FLAT\":\n            case 13:\n              t.pitchName = 13;\n              break;\n\n            case \"B_FLAT\":\n            case 14:\n              t.pitchName = 14;\n              break;\n\n            case \"F\":\n            case 15:\n              t.pitchName = 15;\n              break;\n\n            case \"C\":\n            case 16:\n              t.pitchName = 16;\n              break;\n\n            case \"G\":\n            case 17:\n              t.pitchName = 17;\n              break;\n\n            case \"D\":\n            case 18:\n              t.pitchName = 18;\n              break;\n\n            case \"A\":\n            case 19:\n              t.pitchName = 19;\n              break;\n\n            case \"E\":\n            case 20:\n              t.pitchName = 20;\n              break;\n\n            case \"B\":\n            case 21:\n              t.pitchName = 21;\n              break;\n\n            case \"F_SHARP\":\n            case 22:\n              t.pitchName = 22;\n              break;\n\n            case \"C_SHARP\":\n            case 23:\n              t.pitchName = 23;\n              break;\n\n            case \"G_SHARP\":\n            case 24:\n              t.pitchName = 24;\n              break;\n\n            case \"D_SHARP\":\n            case 25:\n              t.pitchName = 25;\n              break;\n\n            case \"A_SHARP\":\n            case 26:\n              t.pitchName = 26;\n              break;\n\n            case \"E_SHARP\":\n            case 27:\n              t.pitchName = 27;\n              break;\n\n            case \"B_SHARP\":\n            case 28:\n              t.pitchName = 28;\n              break;\n\n            case \"F_SHARP_SHARP\":\n            case 29:\n              t.pitchName = 29;\n              break;\n\n            case \"C_SHARP_SHARP\":\n            case 30:\n              t.pitchName = 30;\n              break;\n\n            case \"G_SHARP_SHARP\":\n            case 31:\n              t.pitchName = 31;\n              break;\n\n            case \"D_SHARP_SHARP\":\n            case 32:\n              t.pitchName = 32;\n              break;\n\n            case \"A_SHARP_SHARP\":\n            case 33:\n              t.pitchName = 33;\n              break;\n\n            case \"E_SHARP_SHARP\":\n            case 34:\n              t.pitchName = 34;\n              break;\n\n            case \"B_SHARP_SHARP\":\n            case 35:\n              t.pitchName = 35;\n          }\n\n          return null != e.velocity && (t.velocity = 0 | e.velocity), null != e.startTime && (t.startTime = Number(e.startTime)), null != e.quantizedStartStep && (u.Long ? (t.quantizedStartStep = u.Long.fromValue(e.quantizedStartStep)).unsigned = !1 : \"string\" == typeof e.quantizedStartStep ? t.quantizedStartStep = parseInt(e.quantizedStartStep, 10) : \"number\" == typeof e.quantizedStartStep ? t.quantizedStartStep = e.quantizedStartStep : \"object\" == typeof e.quantizedStartStep && (t.quantizedStartStep = new u.LongBits(e.quantizedStartStep.low >>> 0, e.quantizedStartStep.high >>> 0).toNumber())), null != e.endTime && (t.endTime = Number(e.endTime)), null != e.quantizedEndStep && (u.Long ? (t.quantizedEndStep = u.Long.fromValue(e.quantizedEndStep)).unsigned = !1 : \"string\" == typeof e.quantizedEndStep ? t.quantizedEndStep = parseInt(e.quantizedEndStep, 10) : \"number\" == typeof e.quantizedEndStep ? t.quantizedEndStep = e.quantizedEndStep : \"object\" == typeof e.quantizedEndStep && (t.quantizedEndStep = new u.LongBits(e.quantizedEndStep.low >>> 0, e.quantizedEndStep.high >>> 0).toNumber())), null != e.numerator && (t.numerator = 0 | e.numerator), null != e.denominator && (t.denominator = 0 | e.denominator), null != e.instrument && (t.instrument = 0 | e.instrument), null != e.program && (t.program = 0 | e.program), null != e.isDrum && (t.isDrum = Boolean(e.isDrum)), null != e.part && (t.part = 0 | e.part), null != e.voice && (t.voice = 0 | e.voice), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n\n          if (t.defaults) {\n            if (n.pitch = 0, n.velocity = 0, n.startTime = 0, n.endTime = 0, n.numerator = 0, n.denominator = 0, n.instrument = 0, n.program = 0, n.isDrum = !1, n.part = 0, n.pitchName = t.enums === String ? \"UNKNOWN_PITCH_NAME\" : 0, n.voice = 0, u.Long) {\n              var r = new u.Long(0, 0, !1);\n              n.quantizedStartStep = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n            } else n.quantizedStartStep = t.longs === String ? \"0\" : 0;\n\n            u.Long ? (r = new u.Long(0, 0, !1), n.quantizedEndStep = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r) : n.quantizedEndStep = t.longs === String ? \"0\" : 0;\n          }\n\n          return null != e.pitch && e.hasOwnProperty(\"pitch\") && (n.pitch = e.pitch), null != e.velocity && e.hasOwnProperty(\"velocity\") && (n.velocity = e.velocity), null != e.startTime && e.hasOwnProperty(\"startTime\") && (n.startTime = t.json && !isFinite(e.startTime) ? String(e.startTime) : e.startTime), null != e.endTime && e.hasOwnProperty(\"endTime\") && (n.endTime = t.json && !isFinite(e.endTime) ? String(e.endTime) : e.endTime), null != e.numerator && e.hasOwnProperty(\"numerator\") && (n.numerator = e.numerator), null != e.denominator && e.hasOwnProperty(\"denominator\") && (n.denominator = e.denominator), null != e.instrument && e.hasOwnProperty(\"instrument\") && (n.instrument = e.instrument), null != e.program && e.hasOwnProperty(\"program\") && (n.program = e.program), null != e.isDrum && e.hasOwnProperty(\"isDrum\") && (n.isDrum = e.isDrum), null != e.part && e.hasOwnProperty(\"part\") && (n.part = e.part), null != e.pitchName && e.hasOwnProperty(\"pitchName\") && (n.pitchName = t.enums === String ? c.tensorflow.magenta.NoteSequence.PitchName[e.pitchName] : e.pitchName), null != e.voice && e.hasOwnProperty(\"voice\") && (n.voice = e.voice), null != e.quantizedStartStep && e.hasOwnProperty(\"quantizedStartStep\") && (\"number\" == typeof e.quantizedStartStep ? n.quantizedStartStep = t.longs === String ? String(e.quantizedStartStep) : e.quantizedStartStep : n.quantizedStartStep = t.longs === String ? u.Long.prototype.toString.call(e.quantizedStartStep) : t.longs === Number ? new u.LongBits(e.quantizedStartStep.low >>> 0, e.quantizedStartStep.high >>> 0).toNumber() : e.quantizedStartStep), null != e.quantizedEndStep && e.hasOwnProperty(\"quantizedEndStep\") && (\"number\" == typeof e.quantizedEndStep ? n.quantizedEndStep = t.longs === String ? String(e.quantizedEndStep) : e.quantizedEndStep : n.quantizedEndStep = t.longs === String ? u.Long.prototype.toString.call(e.quantizedEndStep) : t.longs === Number ? new u.LongBits(e.quantizedEndStep.low >>> 0, e.quantizedEndStep.high >>> 0).toNumber() : e.quantizedEndStep), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.PitchName = (t = {}, (n = Object.create(t))[t[0] = \"UNKNOWN_PITCH_NAME\"] = 0, n[t[1] = \"F_FLAT_FLAT\"] = 1, n[t[2] = \"C_FLAT_FLAT\"] = 2, n[t[3] = \"G_FLAT_FLAT\"] = 3, n[t[4] = \"D_FLAT_FLAT\"] = 4, n[t[5] = \"A_FLAT_FLAT\"] = 5, n[t[6] = \"E_FLAT_FLAT\"] = 6, n[t[7] = \"B_FLAT_FLAT\"] = 7, n[t[8] = \"F_FLAT\"] = 8, n[t[9] = \"C_FLAT\"] = 9, n[t[10] = \"G_FLAT\"] = 10, n[t[11] = \"D_FLAT\"] = 11, n[t[12] = \"A_FLAT\"] = 12, n[t[13] = \"E_FLAT\"] = 13, n[t[14] = \"B_FLAT\"] = 14, n[t[15] = \"F\"] = 15, n[t[16] = \"C\"] = 16, n[t[17] = \"G\"] = 17, n[t[18] = \"D\"] = 18, n[t[19] = \"A\"] = 19, n[t[20] = \"E\"] = 20, n[t[21] = \"B\"] = 21, n[t[22] = \"F_SHARP\"] = 22, n[t[23] = \"C_SHARP\"] = 23, n[t[24] = \"G_SHARP\"] = 24, n[t[25] = \"D_SHARP\"] = 25, n[t[26] = \"A_SHARP\"] = 26, n[t[27] = \"E_SHARP\"] = 27, n[t[28] = \"B_SHARP\"] = 28, n[t[29] = \"F_SHARP_SHARP\"] = 29, n[t[30] = \"C_SHARP_SHARP\"] = 30, n[t[31] = \"G_SHARP_SHARP\"] = 31, n[t[32] = \"D_SHARP_SHARP\"] = 32, n[t[33] = \"A_SHARP_SHARP\"] = 33, n[t[34] = \"E_SHARP_SHARP\"] = 34, n[t[35] = \"B_SHARP_SHARP\"] = 35, n), e.TimeSignature = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.time = 0, e.prototype.numerator = 0, e.prototype.denominator = 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.time && e.hasOwnProperty(\"time\") && t.uint32(9).double(e.time), null != e.numerator && e.hasOwnProperty(\"numerator\") && t.uint32(16).int32(e.numerator), null != e.denominator && e.hasOwnProperty(\"denominator\") && t.uint32(24).int32(e.denominator), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.TimeSignature(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = e.double();\n                break;\n\n              case 2:\n                r.numerator = e.int32();\n                break;\n\n              case 3:\n                r.denominator = e.int32();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          return \"object\" != typeof e || null === e ? \"object expected\" : null != e.time && e.hasOwnProperty(\"time\") && \"number\" != typeof e.time ? \"time: number expected\" : null != e.numerator && e.hasOwnProperty(\"numerator\") && !u.isInteger(e.numerator) ? \"numerator: integer expected\" : null != e.denominator && e.hasOwnProperty(\"denominator\") && !u.isInteger(e.denominator) ? \"denominator: integer expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.TimeSignature) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.TimeSignature();\n          return null != e.time && (t.time = Number(e.time)), null != e.numerator && (t.numerator = 0 | e.numerator), null != e.denominator && (t.denominator = 0 | e.denominator), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return t.defaults && (n.time = 0, n.numerator = 0, n.denominator = 0), null != e.time && e.hasOwnProperty(\"time\") && (n.time = t.json && !isFinite(e.time) ? String(e.time) : e.time), null != e.numerator && e.hasOwnProperty(\"numerator\") && (n.numerator = e.numerator), null != e.denominator && e.hasOwnProperty(\"denominator\") && (n.denominator = e.denominator), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.KeySignature = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.time = 0, e.prototype.key = 0, e.prototype.mode = 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.time && e.hasOwnProperty(\"time\") && t.uint32(9).double(e.time), null != e.key && e.hasOwnProperty(\"key\") && t.uint32(16).int32(e.key), null != e.mode && e.hasOwnProperty(\"mode\") && t.uint32(24).int32(e.mode), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.KeySignature(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = e.double();\n                break;\n\n              case 2:\n                r.key = e.int32();\n                break;\n\n              case 3:\n                r.mode = e.int32();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          if (\"object\" != typeof e || null === e) return \"object expected\";\n          if (null != e.time && e.hasOwnProperty(\"time\") && \"number\" != typeof e.time) return \"time: number expected\";\n          if (null != e.key && e.hasOwnProperty(\"key\")) switch (e.key) {\n            default:\n              return \"key: enum value expected\";\n\n            case 0:\n            case 1:\n            case 1:\n            case 2:\n            case 3:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 6:\n            case 7:\n            case 8:\n            case 8:\n            case 9:\n            case 10:\n            case 10:\n            case 11:\n          }\n          if (null != e.mode && e.hasOwnProperty(\"mode\")) switch (e.mode) {\n            default:\n              return \"mode: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n          }\n          return null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.KeySignature) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.KeySignature();\n\n          switch (null != e.time && (t.time = Number(e.time)), e.key) {\n            case \"C\":\n            case 0:\n              t.key = 0;\n              break;\n\n            case \"C_SHARP\":\n            case 1:\n              t.key = 1;\n              break;\n\n            case \"D_FLAT\":\n            case 1:\n              t.key = 1;\n              break;\n\n            case \"D\":\n            case 2:\n              t.key = 2;\n              break;\n\n            case \"D_SHARP\":\n            case 3:\n              t.key = 3;\n              break;\n\n            case \"E_FLAT\":\n            case 3:\n              t.key = 3;\n              break;\n\n            case \"E\":\n            case 4:\n              t.key = 4;\n              break;\n\n            case \"F\":\n            case 5:\n              t.key = 5;\n              break;\n\n            case \"F_SHARP\":\n            case 6:\n              t.key = 6;\n              break;\n\n            case \"G_FLAT\":\n            case 6:\n              t.key = 6;\n              break;\n\n            case \"G\":\n            case 7:\n              t.key = 7;\n              break;\n\n            case \"G_SHARP\":\n            case 8:\n              t.key = 8;\n              break;\n\n            case \"A_FLAT\":\n            case 8:\n              t.key = 8;\n              break;\n\n            case \"A\":\n            case 9:\n              t.key = 9;\n              break;\n\n            case \"A_SHARP\":\n            case 10:\n              t.key = 10;\n              break;\n\n            case \"B_FLAT\":\n            case 10:\n              t.key = 10;\n              break;\n\n            case \"B\":\n            case 11:\n              t.key = 11;\n          }\n\n          switch (e.mode) {\n            case \"MAJOR\":\n            case 0:\n              t.mode = 0;\n              break;\n\n            case \"MINOR\":\n            case 1:\n              t.mode = 1;\n              break;\n\n            case \"NOT_SPECIFIED\":\n            case 2:\n              t.mode = 2;\n              break;\n\n            case \"MIXOLYDIAN\":\n            case 3:\n              t.mode = 3;\n              break;\n\n            case \"DORIAN\":\n            case 4:\n              t.mode = 4;\n              break;\n\n            case \"PHRYGIAN\":\n            case 5:\n              t.mode = 5;\n              break;\n\n            case \"LYDIAN\":\n            case 6:\n              t.mode = 6;\n              break;\n\n            case \"LOCRIAN\":\n            case 7:\n              t.mode = 7;\n          }\n\n          return t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return t.defaults && (n.time = 0, n.key = t.enums === String ? \"C\" : 0, n.mode = t.enums === String ? \"MAJOR\" : 0), null != e.time && e.hasOwnProperty(\"time\") && (n.time = t.json && !isFinite(e.time) ? String(e.time) : e.time), null != e.key && e.hasOwnProperty(\"key\") && (n.key = t.enums === String ? c.tensorflow.magenta.NoteSequence.KeySignature.Key[e.key] : e.key), null != e.mode && e.hasOwnProperty(\"mode\") && (n.mode = t.enums === String ? c.tensorflow.magenta.NoteSequence.KeySignature.Mode[e.mode] : e.mode), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e.Key = function () {\n          var e = {},\n              t = Object.create(e);\n          return t[e[0] = \"C\"] = 0, t[e[1] = \"C_SHARP\"] = 1, t.D_FLAT = 1, t[e[2] = \"D\"] = 2, t[e[3] = \"D_SHARP\"] = 3, t.E_FLAT = 3, t[e[4] = \"E\"] = 4, t[e[5] = \"F\"] = 5, t[e[6] = \"F_SHARP\"] = 6, t.G_FLAT = 6, t[e[7] = \"G\"] = 7, t[e[8] = \"G_SHARP\"] = 8, t.A_FLAT = 8, t[e[9] = \"A\"] = 9, t[e[10] = \"A_SHARP\"] = 10, t.B_FLAT = 10, t[e[11] = \"B\"] = 11, t;\n        }(), e.Mode = function () {\n          var e = {},\n              t = Object.create(e);\n          return t[e[0] = \"MAJOR\"] = 0, t[e[1] = \"MINOR\"] = 1, t[e[2] = \"NOT_SPECIFIED\"] = 2, t[e[3] = \"MIXOLYDIAN\"] = 3, t[e[4] = \"DORIAN\"] = 4, t[e[5] = \"PHRYGIAN\"] = 5, t[e[6] = \"LYDIAN\"] = 6, t[e[7] = \"LOCRIAN\"] = 7, t;\n        }(), e;\n      }(), e.Tempo = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.time = 0, e.prototype.qpm = 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.time && e.hasOwnProperty(\"time\") && t.uint32(9).double(e.time), null != e.qpm && e.hasOwnProperty(\"qpm\") && t.uint32(17).double(e.qpm), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.Tempo(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = e.double();\n                break;\n\n              case 2:\n                r.qpm = e.double();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          return \"object\" != typeof e || null === e ? \"object expected\" : null != e.time && e.hasOwnProperty(\"time\") && \"number\" != typeof e.time ? \"time: number expected\" : null != e.qpm && e.hasOwnProperty(\"qpm\") && \"number\" != typeof e.qpm ? \"qpm: number expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.Tempo) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.Tempo();\n          return null != e.time && (t.time = Number(e.time)), null != e.qpm && (t.qpm = Number(e.qpm)), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return t.defaults && (n.time = 0, n.qpm = 0), null != e.time && e.hasOwnProperty(\"time\") && (n.time = t.json && !isFinite(e.time) ? String(e.time) : e.time), null != e.qpm && e.hasOwnProperty(\"qpm\") && (n.qpm = t.json && !isFinite(e.qpm) ? String(e.qpm) : e.qpm), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.PitchBend = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.time = 0, e.prototype.bend = 0, e.prototype.instrument = 0, e.prototype.program = 0, e.prototype.isDrum = !1, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.time && e.hasOwnProperty(\"time\") && t.uint32(9).double(e.time), null != e.bend && e.hasOwnProperty(\"bend\") && t.uint32(16).int32(e.bend), null != e.instrument && e.hasOwnProperty(\"instrument\") && t.uint32(24).int32(e.instrument), null != e.program && e.hasOwnProperty(\"program\") && t.uint32(32).int32(e.program), null != e.isDrum && e.hasOwnProperty(\"isDrum\") && t.uint32(40).bool(e.isDrum), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.PitchBend(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = e.double();\n                break;\n\n              case 2:\n                r.bend = e.int32();\n                break;\n\n              case 3:\n                r.instrument = e.int32();\n                break;\n\n              case 4:\n                r.program = e.int32();\n                break;\n\n              case 5:\n                r.isDrum = e.bool();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          return \"object\" != typeof e || null === e ? \"object expected\" : null != e.time && e.hasOwnProperty(\"time\") && \"number\" != typeof e.time ? \"time: number expected\" : null != e.bend && e.hasOwnProperty(\"bend\") && !u.isInteger(e.bend) ? \"bend: integer expected\" : null != e.instrument && e.hasOwnProperty(\"instrument\") && !u.isInteger(e.instrument) ? \"instrument: integer expected\" : null != e.program && e.hasOwnProperty(\"program\") && !u.isInteger(e.program) ? \"program: integer expected\" : null != e.isDrum && e.hasOwnProperty(\"isDrum\") && \"boolean\" != typeof e.isDrum ? \"isDrum: boolean expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.PitchBend) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.PitchBend();\n          return null != e.time && (t.time = Number(e.time)), null != e.bend && (t.bend = 0 | e.bend), null != e.instrument && (t.instrument = 0 | e.instrument), null != e.program && (t.program = 0 | e.program), null != e.isDrum && (t.isDrum = Boolean(e.isDrum)), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return t.defaults && (n.time = 0, n.bend = 0, n.instrument = 0, n.program = 0, n.isDrum = !1), null != e.time && e.hasOwnProperty(\"time\") && (n.time = t.json && !isFinite(e.time) ? String(e.time) : e.time), null != e.bend && e.hasOwnProperty(\"bend\") && (n.bend = e.bend), null != e.instrument && e.hasOwnProperty(\"instrument\") && (n.instrument = e.instrument), null != e.program && e.hasOwnProperty(\"program\") && (n.program = e.program), null != e.isDrum && e.hasOwnProperty(\"isDrum\") && (n.isDrum = e.isDrum), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.ControlChange = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.time = 0, e.prototype.quantizedStep = u.Long ? u.Long.fromBits(0, 0, !1) : 0, e.prototype.controlNumber = 0, e.prototype.controlValue = 0, e.prototype.instrument = 0, e.prototype.program = 0, e.prototype.isDrum = !1, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.time && e.hasOwnProperty(\"time\") && t.uint32(9).double(e.time), null != e.controlNumber && e.hasOwnProperty(\"controlNumber\") && t.uint32(16).int32(e.controlNumber), null != e.controlValue && e.hasOwnProperty(\"controlValue\") && t.uint32(24).int32(e.controlValue), null != e.instrument && e.hasOwnProperty(\"instrument\") && t.uint32(32).int32(e.instrument), null != e.program && e.hasOwnProperty(\"program\") && t.uint32(40).int32(e.program), null != e.isDrum && e.hasOwnProperty(\"isDrum\") && t.uint32(48).bool(e.isDrum), null != e.quantizedStep && e.hasOwnProperty(\"quantizedStep\") && t.uint32(56).int64(e.quantizedStep), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.ControlChange(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = e.double();\n                break;\n\n              case 7:\n                r.quantizedStep = u.Long ? e.int64().toNumber() : e.int64();\n                break;\n\n              case 2:\n                r.controlNumber = e.int32();\n                break;\n\n              case 3:\n                r.controlValue = e.int32();\n                break;\n\n              case 4:\n                r.instrument = e.int32();\n                break;\n\n              case 5:\n                r.program = e.int32();\n                break;\n\n              case 6:\n                r.isDrum = e.bool();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          return \"object\" != typeof e || null === e ? \"object expected\" : null != e.time && e.hasOwnProperty(\"time\") && \"number\" != typeof e.time ? \"time: number expected\" : null != e.quantizedStep && e.hasOwnProperty(\"quantizedStep\") && !(u.isInteger(e.quantizedStep) || e.quantizedStep && u.isInteger(e.quantizedStep.low) && u.isInteger(e.quantizedStep.high)) ? \"quantizedStep: integer|Long expected\" : null != e.controlNumber && e.hasOwnProperty(\"controlNumber\") && !u.isInteger(e.controlNumber) ? \"controlNumber: integer expected\" : null != e.controlValue && e.hasOwnProperty(\"controlValue\") && !u.isInteger(e.controlValue) ? \"controlValue: integer expected\" : null != e.instrument && e.hasOwnProperty(\"instrument\") && !u.isInteger(e.instrument) ? \"instrument: integer expected\" : null != e.program && e.hasOwnProperty(\"program\") && !u.isInteger(e.program) ? \"program: integer expected\" : null != e.isDrum && e.hasOwnProperty(\"isDrum\") && \"boolean\" != typeof e.isDrum ? \"isDrum: boolean expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.ControlChange) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.ControlChange();\n          return null != e.time && (t.time = Number(e.time)), null != e.quantizedStep && (u.Long ? (t.quantizedStep = u.Long.fromValue(e.quantizedStep)).unsigned = !1 : \"string\" == typeof e.quantizedStep ? t.quantizedStep = parseInt(e.quantizedStep, 10) : \"number\" == typeof e.quantizedStep ? t.quantizedStep = e.quantizedStep : \"object\" == typeof e.quantizedStep && (t.quantizedStep = new u.LongBits(e.quantizedStep.low >>> 0, e.quantizedStep.high >>> 0).toNumber())), null != e.controlNumber && (t.controlNumber = 0 | e.controlNumber), null != e.controlValue && (t.controlValue = 0 | e.controlValue), null != e.instrument && (t.instrument = 0 | e.instrument), null != e.program && (t.program = 0 | e.program), null != e.isDrum && (t.isDrum = Boolean(e.isDrum)), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          if (t.defaults) if (n.time = 0, n.controlNumber = 0, n.controlValue = 0, n.instrument = 0, n.program = 0, n.isDrum = !1, u.Long) {\n            var r = new u.Long(0, 0, !1);\n            n.quantizedStep = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n          } else n.quantizedStep = t.longs === String ? \"0\" : 0;\n          return null != e.time && e.hasOwnProperty(\"time\") && (n.time = t.json && !isFinite(e.time) ? String(e.time) : e.time), null != e.controlNumber && e.hasOwnProperty(\"controlNumber\") && (n.controlNumber = e.controlNumber), null != e.controlValue && e.hasOwnProperty(\"controlValue\") && (n.controlValue = e.controlValue), null != e.instrument && e.hasOwnProperty(\"instrument\") && (n.instrument = e.instrument), null != e.program && e.hasOwnProperty(\"program\") && (n.program = e.program), null != e.isDrum && e.hasOwnProperty(\"isDrum\") && (n.isDrum = e.isDrum), null != e.quantizedStep && e.hasOwnProperty(\"quantizedStep\") && (\"number\" == typeof e.quantizedStep ? n.quantizedStep = t.longs === String ? String(e.quantizedStep) : e.quantizedStep : n.quantizedStep = t.longs === String ? u.Long.prototype.toString.call(e.quantizedStep) : t.longs === Number ? new u.LongBits(e.quantizedStep.low >>> 0, e.quantizedStep.high >>> 0).toNumber() : e.quantizedStep), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.PartInfo = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.part = 0, e.prototype.name = \"\", e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.part && e.hasOwnProperty(\"part\") && t.uint32(8).int32(e.part), null != e.name && e.hasOwnProperty(\"name\") && t.uint32(18).string(e.name), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.PartInfo(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.part = e.int32();\n                break;\n\n              case 2:\n                r.name = e.string();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          return \"object\" != typeof e || null === e ? \"object expected\" : null != e.part && e.hasOwnProperty(\"part\") && !u.isInteger(e.part) ? \"part: integer expected\" : null != e.name && e.hasOwnProperty(\"name\") && !u.isString(e.name) ? \"name: string expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.PartInfo) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.PartInfo();\n          return null != e.part && (t.part = 0 | e.part), null != e.name && (t.name = String(e.name)), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return t.defaults && (n.part = 0, n.name = \"\"), null != e.part && e.hasOwnProperty(\"part\") && (n.part = e.part), null != e.name && e.hasOwnProperty(\"name\") && (n.name = e.name), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.SourceInfo = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.sourceType = 0, e.prototype.encodingType = 0, e.prototype.parser = 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.sourceType && e.hasOwnProperty(\"sourceType\") && t.uint32(8).int32(e.sourceType), null != e.encodingType && e.hasOwnProperty(\"encodingType\") && t.uint32(16).int32(e.encodingType), null != e.parser && e.hasOwnProperty(\"parser\") && t.uint32(24).int32(e.parser), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.SourceInfo(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.sourceType = e.int32();\n                break;\n\n              case 2:\n                r.encodingType = e.int32();\n                break;\n\n              case 3:\n                r.parser = e.int32();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          if (\"object\" != typeof e || null === e) return \"object expected\";\n          if (null != e.sourceType && e.hasOwnProperty(\"sourceType\")) switch (e.sourceType) {\n            default:\n              return \"sourceType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n          }\n          if (null != e.encodingType && e.hasOwnProperty(\"encodingType\")) switch (e.encodingType) {\n            default:\n              return \"encodingType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n          }\n          if (null != e.parser && e.hasOwnProperty(\"parser\")) switch (e.parser) {\n            default:\n              return \"parser: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n          }\n          return null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.SourceInfo) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.SourceInfo();\n\n          switch (e.sourceType) {\n            case \"UNKNOWN_SOURCE_TYPE\":\n            case 0:\n              t.sourceType = 0;\n              break;\n\n            case \"SCORE_BASED\":\n            case 1:\n              t.sourceType = 1;\n              break;\n\n            case \"PERFORMANCE_BASED\":\n            case 2:\n              t.sourceType = 2;\n          }\n\n          switch (e.encodingType) {\n            case \"UNKNOWN_ENCODING_TYPE\":\n            case 0:\n              t.encodingType = 0;\n              break;\n\n            case \"MUSIC_XML\":\n            case 1:\n              t.encodingType = 1;\n              break;\n\n            case \"ABC\":\n            case 2:\n              t.encodingType = 2;\n              break;\n\n            case \"MIDI\":\n            case 3:\n              t.encodingType = 3;\n              break;\n\n            case \"MUSICNET\":\n            case 4:\n              t.encodingType = 4;\n          }\n\n          switch (e.parser) {\n            case \"UNKNOWN_PARSER\":\n            case 0:\n              t.parser = 0;\n              break;\n\n            case \"MUSIC21\":\n            case 1:\n              t.parser = 1;\n              break;\n\n            case \"PRETTY_MIDI\":\n            case 2:\n              t.parser = 2;\n              break;\n\n            case \"MAGENTA_MUSIC_XML\":\n            case 3:\n              t.parser = 3;\n              break;\n\n            case \"MAGENTA_MUSICNET\":\n            case 4:\n              t.parser = 4;\n              break;\n\n            case \"MAGENTA_ABC\":\n            case 5:\n              t.parser = 5;\n              break;\n\n            case \"TONEJS_MIDI_CONVERT\":\n            case 6:\n              t.parser = 6;\n          }\n\n          return t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return t.defaults && (n.sourceType = t.enums === String ? \"UNKNOWN_SOURCE_TYPE\" : 0, n.encodingType = t.enums === String ? \"UNKNOWN_ENCODING_TYPE\" : 0, n.parser = t.enums === String ? \"UNKNOWN_PARSER\" : 0), null != e.sourceType && e.hasOwnProperty(\"sourceType\") && (n.sourceType = t.enums === String ? c.tensorflow.magenta.NoteSequence.SourceInfo.SourceType[e.sourceType] : e.sourceType), null != e.encodingType && e.hasOwnProperty(\"encodingType\") && (n.encodingType = t.enums === String ? c.tensorflow.magenta.NoteSequence.SourceInfo.EncodingType[e.encodingType] : e.encodingType), null != e.parser && e.hasOwnProperty(\"parser\") && (n.parser = t.enums === String ? c.tensorflow.magenta.NoteSequence.SourceInfo.Parser[e.parser] : e.parser), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e.SourceType = function () {\n          var e = {},\n              t = Object.create(e);\n          return t[e[0] = \"UNKNOWN_SOURCE_TYPE\"] = 0, t[e[1] = \"SCORE_BASED\"] = 1, t[e[2] = \"PERFORMANCE_BASED\"] = 2, t;\n        }(), e.EncodingType = function () {\n          var e = {},\n              t = Object.create(e);\n          return t[e[0] = \"UNKNOWN_ENCODING_TYPE\"] = 0, t[e[1] = \"MUSIC_XML\"] = 1, t[e[2] = \"ABC\"] = 2, t[e[3] = \"MIDI\"] = 3, t[e[4] = \"MUSICNET\"] = 4, t;\n        }(), e.Parser = function () {\n          var e = {},\n              t = Object.create(e);\n          return t[e[0] = \"UNKNOWN_PARSER\"] = 0, t[e[1] = \"MUSIC21\"] = 1, t[e[2] = \"PRETTY_MIDI\"] = 2, t[e[3] = \"MAGENTA_MUSIC_XML\"] = 3, t[e[4] = \"MAGENTA_MUSICNET\"] = 4, t[e[5] = \"MAGENTA_ABC\"] = 5, t[e[6] = \"TONEJS_MIDI_CONVERT\"] = 6, t;\n        }(), e;\n      }(), e.TextAnnotation = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.time = 0, e.prototype.quantizedStep = u.Long ? u.Long.fromBits(0, 0, !1) : 0, e.prototype.text = \"\", e.prototype.annotationType = 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.time && e.hasOwnProperty(\"time\") && t.uint32(9).double(e.time), null != e.text && e.hasOwnProperty(\"text\") && t.uint32(18).string(e.text), null != e.annotationType && e.hasOwnProperty(\"annotationType\") && t.uint32(24).int32(e.annotationType), null != e.quantizedStep && e.hasOwnProperty(\"quantizedStep\") && t.uint32(32).int64(e.quantizedStep), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.TextAnnotation(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = e.double();\n                break;\n\n              case 4:\n                r.quantizedStep = u.Long ? e.int64().toNumber() : e.int64();\n                break;\n\n              case 2:\n                r.text = e.string();\n                break;\n\n              case 3:\n                r.annotationType = e.int32();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          if (\"object\" != typeof e || null === e) return \"object expected\";\n          if (null != e.time && e.hasOwnProperty(\"time\") && \"number\" != typeof e.time) return \"time: number expected\";\n          if (null != e.quantizedStep && e.hasOwnProperty(\"quantizedStep\") && !(u.isInteger(e.quantizedStep) || e.quantizedStep && u.isInteger(e.quantizedStep.low) && u.isInteger(e.quantizedStep.high))) return \"quantizedStep: integer|Long expected\";\n          if (null != e.text && e.hasOwnProperty(\"text\") && !u.isString(e.text)) return \"text: string expected\";\n          if (null != e.annotationType && e.hasOwnProperty(\"annotationType\")) switch (e.annotationType) {\n            default:\n              return \"annotationType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n          }\n          return null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.TextAnnotation) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.TextAnnotation();\n\n          switch (null != e.time && (t.time = Number(e.time)), null != e.quantizedStep && (u.Long ? (t.quantizedStep = u.Long.fromValue(e.quantizedStep)).unsigned = !1 : \"string\" == typeof e.quantizedStep ? t.quantizedStep = parseInt(e.quantizedStep, 10) : \"number\" == typeof e.quantizedStep ? t.quantizedStep = e.quantizedStep : \"object\" == typeof e.quantizedStep && (t.quantizedStep = new u.LongBits(e.quantizedStep.low >>> 0, e.quantizedStep.high >>> 0).toNumber())), null != e.text && (t.text = String(e.text)), e.annotationType) {\n            case \"UNKNOWN\":\n            case 0:\n              t.annotationType = 0;\n              break;\n\n            case \"CHORD_SYMBOL\":\n            case 1:\n              t.annotationType = 1;\n              break;\n\n            case \"BEAT\":\n            case 2:\n              t.annotationType = 2;\n          }\n\n          return t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          if (t.defaults) if (n.time = 0, n.text = \"\", n.annotationType = t.enums === String ? \"UNKNOWN\" : 0, u.Long) {\n            var r = new u.Long(0, 0, !1);\n            n.quantizedStep = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n          } else n.quantizedStep = t.longs === String ? \"0\" : 0;\n          return null != e.time && e.hasOwnProperty(\"time\") && (n.time = t.json && !isFinite(e.time) ? String(e.time) : e.time), null != e.text && e.hasOwnProperty(\"text\") && (n.text = e.text), null != e.annotationType && e.hasOwnProperty(\"annotationType\") && (n.annotationType = t.enums === String ? c.tensorflow.magenta.NoteSequence.TextAnnotation.TextAnnotationType[e.annotationType] : e.annotationType), null != e.quantizedStep && e.hasOwnProperty(\"quantizedStep\") && (\"number\" == typeof e.quantizedStep ? n.quantizedStep = t.longs === String ? String(e.quantizedStep) : e.quantizedStep : n.quantizedStep = t.longs === String ? u.Long.prototype.toString.call(e.quantizedStep) : t.longs === Number ? new u.LongBits(e.quantizedStep.low >>> 0, e.quantizedStep.high >>> 0).toNumber() : e.quantizedStep), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e.TextAnnotationType = function () {\n          var e = {},\n              t = Object.create(e);\n          return t[e[0] = \"UNKNOWN\"] = 0, t[e[1] = \"CHORD_SYMBOL\"] = 1, t[e[2] = \"BEAT\"] = 2, t;\n        }(), e;\n      }(), e.QuantizationInfo = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        var t;\n        return e.prototype.stepsPerQuarter = 0, e.prototype.stepsPerSecond = 0, Object.defineProperty(e.prototype, \"resolution\", {\n          get: u.oneOfGetter(t = [\"stepsPerQuarter\", \"stepsPerSecond\"]),\n          set: u.oneOfSetter(t)\n        }), e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.stepsPerQuarter && e.hasOwnProperty(\"stepsPerQuarter\") && t.uint32(8).int32(e.stepsPerQuarter), null != e.stepsPerSecond && e.hasOwnProperty(\"stepsPerSecond\") && t.uint32(16).int32(e.stepsPerSecond), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.QuantizationInfo(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.stepsPerQuarter = e.int32();\n                break;\n\n              case 2:\n                r.stepsPerSecond = e.int32();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          if (\"object\" != typeof e || null === e) return \"object expected\";\n          var t = {};\n          if (null != e.stepsPerQuarter && e.hasOwnProperty(\"stepsPerQuarter\") && (t.resolution = 1, !u.isInteger(e.stepsPerQuarter))) return \"stepsPerQuarter: integer expected\";\n\n          if (null != e.stepsPerSecond && e.hasOwnProperty(\"stepsPerSecond\")) {\n            if (1 === t.resolution) return \"resolution: multiple values\";\n            if (t.resolution = 1, !u.isInteger(e.stepsPerSecond)) return \"stepsPerSecond: integer expected\";\n          }\n\n          return null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.QuantizationInfo) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.QuantizationInfo();\n          return null != e.stepsPerQuarter && (t.stepsPerQuarter = 0 | e.stepsPerQuarter), null != e.stepsPerSecond && (t.stepsPerSecond = 0 | e.stepsPerSecond), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return null != e.stepsPerQuarter && e.hasOwnProperty(\"stepsPerQuarter\") && (n.stepsPerQuarter = e.stepsPerQuarter, t.oneofs && (n.resolution = \"stepsPerQuarter\")), null != e.stepsPerSecond && e.hasOwnProperty(\"stepsPerSecond\") && (n.stepsPerSecond = e.stepsPerSecond, t.oneofs && (n.resolution = \"stepsPerSecond\")), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.SubsequenceInfo = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.startTimeOffset = 0, e.prototype.endTimeOffset = 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.startTimeOffset && e.hasOwnProperty(\"startTimeOffset\") && t.uint32(9).double(e.startTimeOffset), null != e.endTimeOffset && e.hasOwnProperty(\"endTimeOffset\") && t.uint32(17).double(e.endTimeOffset), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.SubsequenceInfo(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.startTimeOffset = e.double();\n                break;\n\n              case 2:\n                r.endTimeOffset = e.double();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          return \"object\" != typeof e || null === e ? \"object expected\" : null != e.startTimeOffset && e.hasOwnProperty(\"startTimeOffset\") && \"number\" != typeof e.startTimeOffset ? \"startTimeOffset: number expected\" : null != e.endTimeOffset && e.hasOwnProperty(\"endTimeOffset\") && \"number\" != typeof e.endTimeOffset ? \"endTimeOffset: number expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.SubsequenceInfo) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.SubsequenceInfo();\n          return null != e.startTimeOffset && (t.startTimeOffset = Number(e.startTimeOffset)), null != e.endTimeOffset && (t.endTimeOffset = Number(e.endTimeOffset)), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return t.defaults && (n.startTimeOffset = 0, n.endTimeOffset = 0), null != e.startTimeOffset && e.hasOwnProperty(\"startTimeOffset\") && (n.startTimeOffset = t.json && !isFinite(e.startTimeOffset) ? String(e.startTimeOffset) : e.startTimeOffset), null != e.endTimeOffset && e.hasOwnProperty(\"endTimeOffset\") && (n.endTimeOffset = t.json && !isFinite(e.endTimeOffset) ? String(e.endTimeOffset) : e.endTimeOffset), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.SectionAnnotation = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.time = 0, e.prototype.sectionId = u.Long ? u.Long.fromBits(0, 0, !1) : 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.time && e.hasOwnProperty(\"time\") && t.uint32(9).double(e.time), null != e.sectionId && e.hasOwnProperty(\"sectionId\") && t.uint32(32).int64(e.sectionId), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.SectionAnnotation(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = e.double();\n                break;\n\n              case 4:\n                r.sectionId = u.Long ? e.int64().toNumber() : e.int64();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          return \"object\" != typeof e || null === e ? \"object expected\" : null != e.time && e.hasOwnProperty(\"time\") && \"number\" != typeof e.time ? \"time: number expected\" : null != e.sectionId && e.hasOwnProperty(\"sectionId\") && !(u.isInteger(e.sectionId) || e.sectionId && u.isInteger(e.sectionId.low) && u.isInteger(e.sectionId.high)) ? \"sectionId: integer|Long expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.SectionAnnotation) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.SectionAnnotation();\n          return null != e.time && (t.time = Number(e.time)), null != e.sectionId && (u.Long ? (t.sectionId = u.Long.fromValue(e.sectionId)).unsigned = !1 : \"string\" == typeof e.sectionId ? t.sectionId = parseInt(e.sectionId, 10) : \"number\" == typeof e.sectionId ? t.sectionId = e.sectionId : \"object\" == typeof e.sectionId && (t.sectionId = new u.LongBits(e.sectionId.low >>> 0, e.sectionId.high >>> 0).toNumber())), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          if (t.defaults) if (n.time = 0, u.Long) {\n            var r = new u.Long(0, 0, !1);\n            n.sectionId = t.longs === String ? r.toString() : t.longs === Number ? r.toNumber() : r;\n          } else n.sectionId = t.longs === String ? \"0\" : 0;\n          return null != e.time && e.hasOwnProperty(\"time\") && (n.time = t.json && !isFinite(e.time) ? String(e.time) : e.time), null != e.sectionId && e.hasOwnProperty(\"sectionId\") && (\"number\" == typeof e.sectionId ? n.sectionId = t.longs === String ? String(e.sectionId) : e.sectionId : n.sectionId = t.longs === String ? u.Long.prototype.toString.call(e.sectionId) : t.longs === Number ? new u.LongBits(e.sectionId.low >>> 0, e.sectionId.high >>> 0).toNumber() : e.sectionId), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.Section = function () {\n        function e(e) {\n          if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        var t;\n        return e.prototype.sectionId = u.Long ? u.Long.fromBits(0, 0, !1) : 0, e.prototype.sectionGroup = null, Object.defineProperty(e.prototype, \"sectionType\", {\n          get: u.oneOfGetter(t = [\"sectionId\", \"sectionGroup\"]),\n          set: u.oneOfSetter(t)\n        }), e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          return t || (t = a.create()), null != e.sectionId && e.hasOwnProperty(\"sectionId\") && t.uint32(8).int64(e.sectionId), null != e.sectionGroup && e.hasOwnProperty(\"sectionGroup\") && c.tensorflow.magenta.NoteSequence.SectionGroup.encode(e.sectionGroup, t.uint32(18).fork()).ldelim(), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.Section(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.sectionId = u.Long ? e.int64().toNumber() : e.int64();\n                break;\n\n              case 2:\n                r.sectionGroup = c.tensorflow.magenta.NoteSequence.SectionGroup.decode(e, e.uint32());\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          if (\"object\" != typeof e || null === e) return \"object expected\";\n          var t = {};\n          if (null != e.sectionId && e.hasOwnProperty(\"sectionId\") && (t.sectionType = 1, !(u.isInteger(e.sectionId) || e.sectionId && u.isInteger(e.sectionId.low) && u.isInteger(e.sectionId.high)))) return \"sectionId: integer|Long expected\";\n\n          if (null != e.sectionGroup && e.hasOwnProperty(\"sectionGroup\")) {\n            if (1 === t.sectionType) return \"sectionType: multiple values\";\n            t.sectionType = 1;\n            var n = c.tensorflow.magenta.NoteSequence.SectionGroup.verify(e.sectionGroup);\n            if (n) return \"sectionGroup.\" + n;\n          }\n\n          return null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.Section) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.Section();\n\n          if (null != e.sectionId && (u.Long ? (t.sectionId = u.Long.fromValue(e.sectionId)).unsigned = !1 : \"string\" == typeof e.sectionId ? t.sectionId = parseInt(e.sectionId, 10) : \"number\" == typeof e.sectionId ? t.sectionId = e.sectionId : \"object\" == typeof e.sectionId && (t.sectionId = new u.LongBits(e.sectionId.low >>> 0, e.sectionId.high >>> 0).toNumber())), null != e.sectionGroup) {\n            if (\"object\" != typeof e.sectionGroup) throw TypeError(\".tensorflow.magenta.NoteSequence.Section.sectionGroup: object expected\");\n            t.sectionGroup = c.tensorflow.magenta.NoteSequence.SectionGroup.fromObject(e.sectionGroup);\n          }\n\n          return t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n          return null != e.sectionId && e.hasOwnProperty(\"sectionId\") && (\"number\" == typeof e.sectionId ? n.sectionId = t.longs === String ? String(e.sectionId) : e.sectionId : n.sectionId = t.longs === String ? u.Long.prototype.toString.call(e.sectionId) : t.longs === Number ? new u.LongBits(e.sectionId.low >>> 0, e.sectionId.high >>> 0).toNumber() : e.sectionId, t.oneofs && (n.sectionType = \"sectionId\")), null != e.sectionGroup && e.hasOwnProperty(\"sectionGroup\") && (n.sectionGroup = c.tensorflow.magenta.NoteSequence.SectionGroup.toObject(e.sectionGroup, t), t.oneofs && (n.sectionType = \"sectionGroup\")), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e.SectionGroup = function () {\n        function e(e) {\n          if (this.sections = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n        }\n\n        return e.prototype.sections = u.emptyArray, e.prototype.numTimes = 0, e.create = function (t) {\n          return new e(t);\n        }, e.encode = function (e, t) {\n          if (t || (t = a.create()), null != e.sections && e.sections.length) for (var n = 0; n < e.sections.length; ++n) c.tensorflow.magenta.NoteSequence.Section.encode(e.sections[n], t.uint32(10).fork()).ldelim();\n          return null != e.numTimes && e.hasOwnProperty(\"numTimes\") && t.uint32(16).int32(e.numTimes), t;\n        }, e.encodeDelimited = function (e, t) {\n          return this.encode(e, t).ldelim();\n        }, e.decode = function (e, t) {\n          e instanceof s || (e = s.create(e));\n\n          for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.NoteSequence.SectionGroup(); e.pos < n;) {\n            var o = e.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.sections && r.sections.length || (r.sections = []), r.sections.push(c.tensorflow.magenta.NoteSequence.Section.decode(e, e.uint32()));\n                break;\n\n              case 2:\n                r.numTimes = e.int32();\n                break;\n\n              default:\n                e.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, e.decodeDelimited = function (e) {\n          return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n        }, e.verify = function (e) {\n          if (\"object\" != typeof e || null === e) return \"object expected\";\n\n          if (null != e.sections && e.hasOwnProperty(\"sections\")) {\n            if (!Array.isArray(e.sections)) return \"sections: array expected\";\n\n            for (var t = 0; t < e.sections.length; ++t) {\n              var n = c.tensorflow.magenta.NoteSequence.Section.verify(e.sections[t]);\n              if (n) return \"sections.\" + n;\n            }\n          }\n\n          return null != e.numTimes && e.hasOwnProperty(\"numTimes\") && !u.isInteger(e.numTimes) ? \"numTimes: integer expected\" : null;\n        }, e.fromObject = function (e) {\n          if (e instanceof c.tensorflow.magenta.NoteSequence.SectionGroup) return e;\n          var t = new c.tensorflow.magenta.NoteSequence.SectionGroup();\n\n          if (e.sections) {\n            if (!Array.isArray(e.sections)) throw TypeError(\".tensorflow.magenta.NoteSequence.SectionGroup.sections: array expected\");\n            t.sections = [];\n\n            for (var n = 0; n < e.sections.length; ++n) {\n              if (\"object\" != typeof e.sections[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.SectionGroup.sections: object expected\");\n              t.sections[n] = c.tensorflow.magenta.NoteSequence.Section.fromObject(e.sections[n]);\n            }\n          }\n\n          return null != e.numTimes && (t.numTimes = 0 | e.numTimes), t;\n        }, e.toObject = function (e, t) {\n          t || (t = {});\n          var n = {};\n\n          if ((t.arrays || t.defaults) && (n.sections = []), t.defaults && (n.numTimes = 0), e.sections && e.sections.length) {\n            n.sections = [];\n\n            for (var r = 0; r < e.sections.length; ++r) n.sections[r] = c.tensorflow.magenta.NoteSequence.Section.toObject(e.sections[r], t);\n          }\n\n          return null != e.numTimes && e.hasOwnProperty(\"numTimes\") && (n.numTimes = e.numTimes), n;\n        }, e.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, e;\n      }(), e;\n    }(), r.SequenceMetadata = function () {\n      function e(e) {\n        if (this.genre = [], this.composers = [], e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n      }\n\n      return e.prototype.title = \"\", e.prototype.artist = \"\", e.prototype.genre = u.emptyArray, e.prototype.composers = u.emptyArray, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (e, t) {\n        if (t || (t = a.create()), null != e.title && e.hasOwnProperty(\"title\") && t.uint32(10).string(e.title), null != e.artist && e.hasOwnProperty(\"artist\") && t.uint32(18).string(e.artist), null != e.genre && e.genre.length) for (var n = 0; n < e.genre.length; ++n) t.uint32(26).string(e.genre[n]);\n        if (null != e.composers && e.composers.length) for (n = 0; n < e.composers.length; ++n) t.uint32(34).string(e.composers[n]);\n        return t;\n      }, e.encodeDelimited = function (e, t) {\n        return this.encode(e, t).ldelim();\n      }, e.decode = function (e, t) {\n        e instanceof s || (e = s.create(e));\n\n        for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.SequenceMetadata(); e.pos < n;) {\n          var o = e.uint32();\n\n          switch (o >>> 3) {\n            case 1:\n              r.title = e.string();\n              break;\n\n            case 2:\n              r.artist = e.string();\n              break;\n\n            case 3:\n              r.genre && r.genre.length || (r.genre = []), r.genre.push(e.string());\n              break;\n\n            case 4:\n              r.composers && r.composers.length || (r.composers = []), r.composers.push(e.string());\n              break;\n\n            default:\n              e.skipType(7 & o);\n          }\n        }\n\n        return r;\n      }, e.decodeDelimited = function (e) {\n        return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n      }, e.verify = function (e) {\n        if (\"object\" != typeof e || null === e) return \"object expected\";\n        if (null != e.title && e.hasOwnProperty(\"title\") && !u.isString(e.title)) return \"title: string expected\";\n        if (null != e.artist && e.hasOwnProperty(\"artist\") && !u.isString(e.artist)) return \"artist: string expected\";\n\n        if (null != e.genre && e.hasOwnProperty(\"genre\")) {\n          if (!Array.isArray(e.genre)) return \"genre: array expected\";\n\n          for (var t = 0; t < e.genre.length; ++t) if (!u.isString(e.genre[t])) return \"genre: string[] expected\";\n        }\n\n        if (null != e.composers && e.hasOwnProperty(\"composers\")) {\n          if (!Array.isArray(e.composers)) return \"composers: array expected\";\n\n          for (t = 0; t < e.composers.length; ++t) if (!u.isString(e.composers[t])) return \"composers: string[] expected\";\n        }\n\n        return null;\n      }, e.fromObject = function (e) {\n        if (e instanceof c.tensorflow.magenta.SequenceMetadata) return e;\n        var t = new c.tensorflow.magenta.SequenceMetadata();\n\n        if (null != e.title && (t.title = String(e.title)), null != e.artist && (t.artist = String(e.artist)), e.genre) {\n          if (!Array.isArray(e.genre)) throw TypeError(\".tensorflow.magenta.SequenceMetadata.genre: array expected\");\n          t.genre = [];\n\n          for (var n = 0; n < e.genre.length; ++n) t.genre[n] = String(e.genre[n]);\n        }\n\n        if (e.composers) {\n          if (!Array.isArray(e.composers)) throw TypeError(\".tensorflow.magenta.SequenceMetadata.composers: array expected\");\n\n          for (t.composers = [], n = 0; n < e.composers.length; ++n) t.composers[n] = String(e.composers[n]);\n        }\n\n        return t;\n      }, e.toObject = function (e, t) {\n        t || (t = {});\n        var n = {};\n\n        if ((t.arrays || t.defaults) && (n.genre = [], n.composers = []), t.defaults && (n.title = \"\", n.artist = \"\"), null != e.title && e.hasOwnProperty(\"title\") && (n.title = e.title), null != e.artist && e.hasOwnProperty(\"artist\") && (n.artist = e.artist), e.genre && e.genre.length) {\n          n.genre = [];\n\n          for (var r = 0; r < e.genre.length; ++r) n.genre[r] = e.genre[r];\n        }\n\n        if (e.composers && e.composers.length) for (n.composers = [], r = 0; r < e.composers.length; ++r) n.composers[r] = e.composers[r];\n        return n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, i.util.toJSONOptions);\n      }, e;\n    }(), r.VelocityRange = function () {\n      function e(e) {\n        if (e) for (var t = Object.keys(e), n = 0; n < t.length; ++n) null != e[t[n]] && (this[t[n]] = e[t[n]]);\n      }\n\n      return e.prototype.min = 0, e.prototype.max = 0, e.create = function (t) {\n        return new e(t);\n      }, e.encode = function (e, t) {\n        return t || (t = a.create()), null != e.min && e.hasOwnProperty(\"min\") && t.uint32(8).int32(e.min), null != e.max && e.hasOwnProperty(\"max\") && t.uint32(16).int32(e.max), t;\n      }, e.encodeDelimited = function (e, t) {\n        return this.encode(e, t).ldelim();\n      }, e.decode = function (e, t) {\n        e instanceof s || (e = s.create(e));\n\n        for (var n = void 0 === t ? e.len : e.pos + t, r = new c.tensorflow.magenta.VelocityRange(); e.pos < n;) {\n          var o = e.uint32();\n\n          switch (o >>> 3) {\n            case 1:\n              r.min = e.int32();\n              break;\n\n            case 2:\n              r.max = e.int32();\n              break;\n\n            default:\n              e.skipType(7 & o);\n          }\n        }\n\n        return r;\n      }, e.decodeDelimited = function (e) {\n        return e instanceof s || (e = new s(e)), this.decode(e, e.uint32());\n      }, e.verify = function (e) {\n        return \"object\" != typeof e || null === e ? \"object expected\" : null != e.min && e.hasOwnProperty(\"min\") && !u.isInteger(e.min) ? \"min: integer expected\" : null != e.max && e.hasOwnProperty(\"max\") && !u.isInteger(e.max) ? \"max: integer expected\" : null;\n      }, e.fromObject = function (e) {\n        if (e instanceof c.tensorflow.magenta.VelocityRange) return e;\n        var t = new c.tensorflow.magenta.VelocityRange();\n        return null != e.min && (t.min = 0 | e.min), null != e.max && (t.max = 0 | e.max), t;\n      }, e.toObject = function (e, t) {\n        t || (t = {});\n        var n = {};\n        return t.defaults && (n.min = 0, n.max = 0), null != e.min && e.hasOwnProperty(\"min\") && (n.min = e.min), null != e.max && e.hasOwnProperty(\"max\") && (n.max = e.max), n;\n      }, e.prototype.toJSON = function () {\n        return this.constructor.toObject(this, i.util.toJSONOptions);\n      }, e;\n    }(), r), o), e.exports = c;\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"ChordQuality\", function () {\n      return a;\n    }), n.d(t, \"ChordSymbolException\", function () {\n      return u;\n    }), n.d(t, \"ChordEncodingException\", function () {\n      return c;\n    }), n.d(t, \"ChordSymbols\", function () {\n      return p;\n    }), n.d(t, \"ChordEncoder\", function () {\n      return l;\n    }), n.d(t, \"chordEncoderFromType\", function () {\n      return m;\n    }), n.d(t, \"MajorMinorChordEncoder\", function () {\n      return h;\n    }), n.d(t, \"TriadChordEncoder\", function () {\n      return d;\n    }), n.d(t, \"PitchChordEncoder\", function () {\n      return f;\n    });\n    var r = n(0),\n        o = n(7),\n        i = n(1);\n    const s = [[\"1P\", \"3M\", \"5P\"], [\"1P\", \"3m\", \"5P\"], [\"1P\", \"3M\", \"5A\"], [\"1P\", \"3m\", \"5d\"]];\n    var a;\n    !function (e) {\n      e[e.Major = 0] = \"Major\", e[e.Minor = 1] = \"Minor\", e[e.Augmented = 2] = \"Augmented\", e[e.Diminished = 3] = \"Diminished\", e[e.Other = 4] = \"Other\";\n    }(a || (a = {}));\n\n    class u extends Error {\n      constructor(e) {\n        super(e), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class c extends Error {\n      constructor(e) {\n        super(e), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class p {\n      static pitches(e) {\n        if (!o.Chord.tokenize(e)[0] || !o.Chord.exists(e)) throw new u(\"Unrecognized chord symbol: \".concat(e));\n        return o.Chord.notes(e).map(o.Note.chroma);\n      }\n\n      static root(e) {\n        const t = o.Chord.tokenize(e)[0];\n        if (!t) throw new u(\"Chord symbol has unknown root: \".concat(e));\n        return o.Note.chroma(t);\n      }\n\n      static quality(e) {\n        if (!o.Chord.exists(e)) throw new u(\"Unrecognized chord symbol: \".concat(e));\n        const t = o.Chord.intervals(e),\n              n = s.map(e => e.every(e => t.includes(e))),\n              r = n.indexOf(!0),\n              i = n.lastIndexOf(!0);\n        return r >= 0 && r === i ? r : a.Other;\n      }\n\n    }\n\n    class l {\n      encodeProgression(e, t) {\n        const n = e.map(e => this.encode(e)),\n              o = Array.from(Array(t).keys()).map(e => Math.floor(e * n.length / t));\n        return r.stack(o.map(e => n[e]));\n      }\n\n    }\n\n    function m(e) {\n      switch (e) {\n        case \"MajorMinorChordEncoder\":\n          return new h();\n\n        case \"TriadChordEncoder\":\n          return new d();\n\n        case \"PitchChordEncoder\":\n          return new f();\n\n        default:\n          throw new Error(\"Unknown chord encoder type: \".concat(e));\n      }\n    }\n\n    class h extends l {\n      constructor() {\n        super(...arguments), this.depth = 1 + 2 * i.NUM_PITCH_CLASSES;\n      }\n\n      index(e) {\n        if (e === i.NO_CHORD) return 0;\n        const t = p.root(e),\n              n = 1 + p.quality(e) * i.NUM_PITCH_CLASSES + t;\n        if (n >= this.depth) throw new c(\"Chord is neither major nor minor: \".concat(e));\n        return n;\n      }\n\n      encode(e) {\n        return r.tidy(() => r.oneHot(r.tensor1d([this.index(e)], \"int32\"), this.depth).as1D());\n      }\n\n    }\n\n    class d extends l {\n      constructor() {\n        super(...arguments), this.depth = 1 + 4 * i.NUM_PITCH_CLASSES;\n      }\n\n      index(e) {\n        if (e === i.NO_CHORD) return 0;\n        const t = p.root(e),\n              n = 1 + p.quality(e) * i.NUM_PITCH_CLASSES + t;\n        if (n >= this.depth) throw new c(\"Chord is not a standard triad: \".concat(e));\n        return n;\n      }\n\n      encode(e) {\n        return r.tidy(() => r.oneHot(r.tensor1d([this.index(e)], \"int32\"), this.depth).as1D());\n      }\n\n    }\n\n    class f extends l {\n      constructor() {\n        super(...arguments), this.depth = 1 + 3 * i.NUM_PITCH_CLASSES;\n      }\n\n      encode(e) {\n        return r.tidy(() => {\n          if (e === i.NO_CHORD) return r.oneHot(r.tensor1d([0], \"int32\"), this.depth).as1D();\n          const t = p.root(e),\n                n = r.oneHot(r.tensor1d([t], \"int32\"), i.NUM_PITCH_CLASSES).as1D(),\n                o = r.buffer([i.NUM_PITCH_CLASSES]);\n          p.pitches(e).forEach(e => o.set(1, e));\n          const s = o.toTensor().as1D(),\n                a = n;\n          return r.concat1d([r.tensor1d([0]), n, s, a]);\n        });\n      }\n\n    }\n  },, function (e, t) {\n    e.exports = require(\"protobufjs/minimal\");\n  }, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t), n.d(t, \"auxiliaryInputFromSpec\", function () {\n      return o;\n    }), n.d(t, \"AuxiliaryInput\", function () {\n      return i;\n    }), n.d(t, \"BinaryCounter\", function () {\n      return s;\n    });\n    var r = n(0);\n\n    function o(e) {\n      switch (e.type) {\n        case \"BinaryCounter\":\n          return new s(e.args);\n\n        default:\n          throw new Error(\"Unknown auxiliary input: \".concat(e));\n      }\n    }\n\n    class i {\n      constructor(e) {\n        this.depth = e;\n      }\n\n    }\n\n    class s extends i {\n      constructor(e) {\n        super(e.numBits);\n      }\n\n      getTensors(e) {\n        const t = r.buffer([e, this.depth]);\n\n        for (let n = 0; n < e; ++n) for (let e = 0; e < this.depth; ++e) t.set(Math.floor((n + 1) / Math.pow(2, e)) % 2 ? 1 : -1, n, e);\n\n        return t.toTensor().as2D(e, this.depth);\n      }\n\n    }\n  },,, function (e, t) {\n    e.exports = require(\"midiconvert\");\n  }, function (e, t) {\n    e.exports = require(\"staffrender\");\n  },, function (e, t, n) {\n    \"use strict\";\n\n    n.r(t);\n    var r = n(15),\n        o = n(12),\n        i = n(1),\n        s = n(9),\n        a = n(5),\n        u = n(10),\n        c = n(6),\n        p = n(3);\n    const l = 4;\n\n    class m {}\n\n    class h {\n      constructor(e, t = 1) {\n        this.clicksPerQuarter = 1, this.muted = !1, this.loClick = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.hiClick = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.loClickNote = \"c5\", this.hiClickNote = \"g5\", this.ticking = !1, this.startedAt = null, this.step = -1, this.reset(), this.callbackObject = e, this.clicksPerQuarter = t;\n      }\n\n      isTicking() {\n        return this.ticking;\n      }\n\n      getStartedAt() {\n        return this.startedAt;\n      }\n\n      getOffsetTime() {\n        return p.immediate() - this.startedAt;\n      }\n\n      start(e = 120) {\n        this.reset(), this.ticking = !0, this.callbackObject.click || (this.callbackObject.click = () => {}), this.callbackObject.quarter || (this.callbackObject.quarter = () => {}), this.callbackObject.bar || (this.callbackObject.bar = () => {});\n        let t = 0;\n        const n = l * this.clicksPerQuarter;\n        p.Transport.scheduleRepeat(e => {\n          this.startedAt || (this.startedAt = e);\n          const r = e - this.startedAt;\n          this.step++;\n          const o = this.step % n,\n                i = Math.floor(o / this.clicksPerQuarter),\n                s = o % this.clicksPerQuarter;\n          this.callbackObject.click(r, o), 0 === s && this.callbackObject.quarter(r, i), this.muted || (0 === o ? this.hiClick.triggerAttack(this.hiClickNote, e, .1) : this.loClick.triggerAttack(this.loClickNote, e, .1)), 0 === o && (this.callbackObject.bar(r, t), t++);\n        }, \"\".concat(n, \"n\")), p.Transport.bpm.value = e, p.Transport.start();\n      }\n\n      stop() {\n        this.ticking = !1, p.Transport.cancel(), p.Transport.stop();\n      }\n\n      reset() {\n        this.muted = !1, this.ticking = !1, this.step = -1, this.startedAt = null;\n      }\n\n    }\n\n    var d = n(18),\n        f = n(2);\n\n    class g extends Error {\n      constructor(e) {\n        super(e), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    function S(e) {\n      const t = d.parse(e),\n            n = f.a.create();\n      n.ticksPerQuarter = t.header.PPQ, n.sourceInfo = f.a.SourceInfo.create({\n        parser: f.a.SourceInfo.Parser.TONEJS_MIDI_CONVERT,\n        encodingType: f.a.SourceInfo.EncodingType.MIDI\n      }), t.header.timeSignature ? n.timeSignatures.push(f.a.TimeSignature.create({\n        time: 0,\n        numerator: t.header.timeSignature[0],\n        denominator: t.header.timeSignature[1]\n      })) : n.timeSignatures.push(f.a.TimeSignature.create({\n        time: 0,\n        numerator: 4,\n        denominator: 4\n      })), n.tempos.push(f.a.Tempo.create({\n        time: 0,\n        qpm: t.header.bpm\n      }));\n      let r = -1;\n\n      for (const e of t.tracks) {\n        e.notes.length > 0 && (r += 1);\n\n        for (const t of e.notes) {\n          const o = t.time,\n                s = o + t.duration;\n          n.notes.push(f.a.Note.create({\n            instrument: r,\n            program: e.instrumentNumber,\n            startTime: o,\n            endTime: s,\n            pitch: t.midi,\n            velocity: Math.floor(t.velocity * i.MIDI_VELOCITIES),\n            isDrum: e.isPercussion\n          })), s > n.totalTime && (n.totalTime = s);\n        }\n      }\n\n      return n;\n    }\n\n    function y(e) {\n      c.isQuantizedSequence(e) && (e = c.unquantizeSequence(e));\n\n      const t = e => 0 === e || void 0 === e;\n\n      if (e.tempos && 0 !== e.tempos.length || (e.tempos = [{\n        time: 0,\n        qpm: i.DEFAULT_QUARTERS_PER_MINUTE\n      }]), e.timeSignatures && 0 !== e.timeSignatures.length || (e.timeSignatures = [{\n        time: 0,\n        numerator: 4,\n        denominator: 4\n      }]), 1 !== e.tempos.length || !t(e.tempos[0].time)) throw new g(\"NoteSequence must have exactly 1 tempo at time 0\");\n      if (1 !== e.timeSignatures.length || !t(e.timeSignatures[0].time)) throw new g(\"NoteSequence must have exactly 1 time signature at time 0\");\n      const n = {\n        header: {\n          bpm: e.tempos[0].qpm,\n          PPQ: e.ticksPerQuarter ? e.ticksPerQuarter : i.DEFAULT_TICKS_PER_QUARTER,\n          timeSignature: [e.timeSignatures[0].numerator, e.timeSignatures[0].denominator]\n        },\n        tracks: []\n      },\n            r = new Map();\n\n      for (const t of e.notes) {\n        const e = t.instrument ? t.instrument : 0;\n        r.has(e) || r.set(e, []), r.get(e).push(t);\n      }\n\n      const o = Array.from(r.keys()).sort((e, t) => e - t);\n\n      for (let e = 0; e < o.length; e++) {\n        if (e !== o[e]) throw new g(\"Instrument list must be continuous and start at 0\");\n        const t = r.get(e),\n              s = {\n          id: e,\n          notes: [],\n          isPercussion: void 0 !== t[0].isDrum && t[0].isDrum,\n          channelNumber: t[0].isDrum ? i.DRUM_CHANNEL : i.DEFAULT_CHANNEL,\n          instrumentNumber: void 0 === t[0].program ? i.DEFAULT_PROGRAM : t[0].program\n        };\n        s.notes = t.map(e => {\n          const t = void 0 === e.velocity ? i.DEFAULT_VELOCITY : e.velocity;\n          return {\n            midi: e.pitch,\n            time: e.startTime,\n            duration: e.endTime - e.startTime,\n            velocity: (t + 1) / i.MIDI_VELOCITIES\n          };\n        }), n.tracks.push(s);\n      }\n\n      return new Uint8Array(d.fromJSON(n).toArray());\n    }\n\n    function w(e) {\n      return new Promise((t, n) => {\n        fetch(e).then(e => e.blob()).then(e => {\n          t(e);\n        }).catch(e => n(e));\n      });\n    }\n\n    function b(e) {\n      return new Promise((t, n) => {\n        const r = new FileReader();\n        r.onload = e => {\n          try {\n            const e = S(r.result);\n            t(e);\n          } catch (e) {\n            n(e);\n          }\n        }, r.onerror = e => n(e), r.readAsBinaryString(e);\n      });\n    }\n\n    function N(e) {\n      return w(e).then(b);\n    }\n\n    class T {\n      constructor(e) {\n        this.FADE_SECONDS = .1, this.baseURL = e, this.buffers = new p.Buffers([]), this.sourceMap = new Map(), this.initialized = !1;\n      }\n\n      async initialize() {\n        await fetch(\"\".concat(this.baseURL, \"/instrument.json\")).then(e => e.json()).then(e => {\n          this.name = e.name, this.minPitch = e.minPitch, this.maxPitch = e.maxPitch, this.durationSeconds = e.durationSeconds, this.releaseSeconds = e.releaseSeconds, this.percussive = e.percussive, this.velocities = e.velocities, this.initialized = !0;\n        });\n      }\n\n      sampleInfoToName(e) {\n        return this.velocities ? \"p\".concat(e.pitch, \"_v\").concat(e.velocity) : \"p\".concat(e.pitch);\n      }\n\n      sampleNameToURL(e) {\n        return \"\".concat(this.baseURL, \"/\").concat(e, \".mp3\");\n      }\n\n      nearestVelocity(e) {\n        if (!this.velocities) return e;\n        e || (e = i.DEFAULT_VELOCITY);\n        let t = void 0,\n            n = i.MIDI_VELOCITIES;\n        return this.velocities.forEach(r => {\n          const o = Math.abs(r - e);\n          o < n && (t = r, n = o);\n        }), t;\n      }\n\n      async loadSamples(e) {\n        this.initialized || (await this.initialize());\n        const t = e.filter(e => !(e.pitch < this.minPitch || e.pitch > this.maxPitch) || (a.log(\"Pitch \".concat(e.pitch, \" is outside the valid range for \").concat(this.name, \", ignoring.\"), \"SoundFont\"), !1)).map(e => this.sampleInfoToName({\n          pitch: e.pitch,\n          velocity: this.nearestVelocity(e.velocity)\n        })),\n              n = Array.from(new Set(t)).filter(e => !this.buffers.has(e)).map(e => ({\n          name: e,\n          url: this.sampleNameToURL(e)\n        }));\n        n.length > 0 && (n.forEach(e => this.buffers.add(e.name, e.url)), await new Promise(e => p.Buffer.on(\"load\", e)), a.log(\"Loaded samples for \".concat(this.name, \".\"), \"SoundFont\"));\n      }\n\n      playNote(e, t, n, r, o) {\n        const i = this.getBuffer(e, t);\n        r > this.durationSeconds && a.log(\"Requested note duration longer than sample duration: \".concat(r, \" > \").concat(this.durationSeconds), \"SoundFont\");\n        const s = new p.BufferSource({\n          buffer: i,\n          fadeOut: this.FADE_SECONDS\n        }).connect(o);\n\n        if (s.start(n, 0, void 0, 1, 0), !this.percussive && r < this.durationSeconds) {\n          const e = new p.BufferSource(i).connect(o);\n          s.stop(n + r + this.FADE_SECONDS), e.start(n + r, this.durationSeconds, void 0, 1, this.FADE_SECONDS);\n        }\n      }\n\n      playNoteDown(e, t, n) {\n        const r = this.getBuffer(e, t),\n              o = new p.BufferSource(r).connect(n);\n        o.start(0, 0, void 0, 1, 0), this.sourceMap.has(e) && this.sourceMap.get(e).stop(p.now() + this.FADE_SECONDS, this.FADE_SECONDS), this.sourceMap.set(e, o);\n      }\n\n      playNoteUp(e, t, n) {\n        if (!this.sourceMap.has(e)) return;\n        const r = this.getBuffer(e, t);\n        new p.BufferSource(r).connect(n).start(0, this.durationSeconds, void 0, 1, this.FADE_SECONDS), this.sourceMap.get(e).stop(p.now() + this.FADE_SECONDS, this.FADE_SECONDS), this.sourceMap.delete(e);\n      }\n\n      getBuffer(e, t) {\n        if (!this.initialized) throw new Error(\"Instrument is not initialized.\");\n        if (e < this.minPitch || e > this.maxPitch) return void a.log(\"Pitch \".concat(e, \" is outside the valid range for \").concat(this.name, \" (\").concat(this.minPitch, \"-\").concat(this.maxPitch, \")\"), \"SoundFont\");\n        const n = this.sampleInfoToName({\n          pitch: e,\n          velocity: this.nearestVelocity(t)\n        });\n        if (!this.buffers.has(n)) throw new Error(\"Buffer not found for \".concat(this.name, \": \").concat(n));\n        const r = this.buffers.get(n);\n        if (!r.loaded) throw new Error(\"Buffer not loaded for \".concat(this.name, \": \").concat(n));\n        return r;\n      }\n\n    }\n\n    class q {\n      constructor(e) {\n        this.baseURL = e, this.instruments = new Map(), this.initialized = !1;\n      }\n\n      async initialize() {\n        await fetch(\"\".concat(this.baseURL, \"/soundfont.json\")).then(e => e.json()).then(e => {\n          this.name = e.name;\n\n          for (const t in e.instruments) {\n            const n = \"\".concat(this.baseURL, \"/\").concat(e.instruments[t]);\n            this.instruments.set(\"drums\" === t ? \"drums\" : +t, new T(n));\n          }\n\n          this.initialized = !0;\n        });\n      }\n\n      async loadSamples(e) {\n        this.initialized || (await this.initialize());\n        const t = new Map();\n        e.forEach(e => {\n          e.isDrum = e.isDrum || !1, e.program = e.program || 0;\n          const n = e.isDrum ? \"drums\" : e.program,\n                r = {\n            pitch: e.pitch,\n            velocity: e.velocity\n          };\n          t.has(n) ? t.get(n).push(r) : this.instruments.has(n) ? t.set(n, [r]) : a.log(\"No instrument in \".concat(this.name, \" for: program=\").concat(e.program, \", isDrum=\").concat(e.isDrum), \"SoundFont\");\n        }), await Promise.all(Array.from(t.keys()).map(e => this.instruments.get(e).loadSamples(t.get(e))));\n      }\n\n      playNote(e, t, n, r, o = 0, i = !1, s) {\n        const u = i ? \"drums\" : o;\n        if (!this.initialized) throw new Error(\"SoundFont is not initialized.\");\n        this.instruments.has(u) ? this.instruments.get(u).playNote(e, t, n, r, s) : a.log(\"No instrument in \".concat(this.name, \" for: program=\").concat(o, \", isDrum=\").concat(i), \"SoundFont\");\n      }\n\n      playNoteDown(e, t, n = 0, r = !1, o) {\n        const i = r ? \"drums\" : n;\n        if (!this.initialized) throw new Error(\"SoundFont is not initialized.\");\n        this.instruments.has(i) ? this.instruments.get(i).playNoteDown(e, t, o) : a.log(\"No instrument in \".concat(this.name, \" for: program=\").concat(n, \", isDrum=\").concat(r), \"SoundFont\");\n      }\n\n      playNoteUp(e, t, n = 0, r = !1, o) {\n        const i = r ? \"drums\" : n;\n        if (!this.initialized) throw new Error(\"SoundFont is not initialized.\");\n        this.instruments.has(i) ? this.instruments.get(i).playNoteUp(e, t, o) : a.log(\"No instrument in \".concat(this.name, \" for: program=\").concat(n, \", isDrum=\").concat(r), \"SoundFont\");\n      }\n\n    }\n\n    function P(e, t) {\n      return e.quantizedStartStep < t.quantizedStartStep ? -1 : e.quantizedStartStep > t.quantizedStartStep ? 1 : e.pitch < t.pitch ? -1 : 1;\n    }\n\n    class O {}\n\n    class I {\n      constructor(e = !1, t) {\n        this.playClick = e, this.callbackObject = t, this.desiredQPM = void 0;\n      }\n\n      setTempo(e) {\n        this.desiredQPM = e, \"started\" === p.Transport.state && (p.Transport.bpm.value = e);\n      }\n\n      makeClickSequence(e) {\n        const t = c.clone(e),\n              n = t.notes.map(e => e.quantizedEndStep),\n              r = Math.max(...n);\n\n        for (let e = 0; e < r; e += 4) {\n          const n = {\n            pitch: e % 16 == 0 ? i.LO_CLICK_PITCH : i.HI_CLICK_PITCH,\n            quantizedStartStep: e,\n            isDrum: !0,\n            quantizedEndStep: e + 1\n          };\n          t.notes.push(n);\n        }\n\n        return t.notes.sort(P), t;\n      }\n\n      resumeContext() {\n        p.context.resume();\n      }\n\n      start(e, t) {\n        this.resumeContext();\n        const n = c.isQuantizedSequence(e);\n        if (this.playClick && n && (e = this.makeClickSequence(e)), t ? p.Transport.bpm.value = t : e.tempos && e.tempos.length > 0 && e.tempos[0].qpm > 0 ? p.Transport.bpm.value = e.tempos[0].qpm : p.Transport.bpm.value = i.DEFAULT_QUARTERS_PER_MINUTE, n) e = c.unquantizeSequence(e, t);else if (t) throw new Error(\"Cannot specify a `qpm` for a non-quantized sequence.\");\n        return this.currentPart = new p.Part((e, t) => {\n          (this.playClick || t.pitch !== i.LO_CLICK_PITCH && t.pitch !== i.HI_CLICK_PITCH) && this.playNote(e, t), this.callbackObject && p.Draw.schedule(() => {\n            this.callbackObject.run(t, e);\n          }, e);\n        }, e.notes.map(e => [e.startTime, e])), this.desiredQPM && (p.Transport.bpm.value = this.desiredQPM), this.currentPart.start(), \"started\" !== p.Transport.state && p.Transport.start(), new Promise(t => {\n          this.scheduledStop = p.Transport.schedule(() => {\n            this.stop(), t(), this.callbackObject && this.callbackObject.stop();\n          }, \"+\".concat(e.totalTime));\n        });\n      }\n\n      stop() {\n        this.currentPart && (this.currentPart.stop(), p.Transport.stop(), this.currentPart = null), p.Transport.clear(this.scheduledStop), this.scheduledStop = void 0, this.desiredQPM = void 0;\n      }\n\n      pause() {\n        p.Transport.pause();\n      }\n\n      resume() {\n        p.Transport.start();\n      }\n\n      isPlaying() {\n        return !!this.currentPart;\n      }\n\n      getPlayState() {\n        return p.Transport.state;\n      }\n\n    }\n\n    class A {\n      constructor() {\n        this.DRUM_PITCH_TO_CLASS = new Map(), this.kick = new p.MembraneSynth().toMaster(), this.tomLow = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .01,\n            decay: .5,\n            sustain: 0\n          }\n        }).toMaster(), this.tomMid = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .01,\n            decay: .5,\n            sustain: 0\n          }\n        }).toMaster(), this.tomHigh = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .01,\n            decay: .5,\n            sustain: 0\n          }\n        }).toMaster(), this.closedHihat = new p.MetalSynth({\n          frequency: 400,\n          envelope: {\n            attack: .001,\n            decay: .1,\n            release: .8\n          },\n          harmonicity: 5.1,\n          modulationIndex: 32,\n          resonance: 4e3,\n          octaves: 1\n        }).toMaster(), this.openHihat = new p.MetalSynth({\n          frequency: 400,\n          envelope: {\n            attack: .001,\n            decay: .5,\n            release: .8,\n            sustain: 1\n          },\n          harmonicity: 5.1,\n          modulationIndex: 32,\n          resonance: 4e3,\n          octaves: 1\n        }).toMaster(), this.ride = new p.MetalSynth().toMaster(), this.crash = new p.MetalSynth({\n          frequency: 300,\n          envelope: {\n            attack: .001,\n            decay: 1,\n            release: 3\n          },\n          harmonicity: 5.1,\n          modulationIndex: 64,\n          resonance: 4e3,\n          octaves: 1.5\n        }).toMaster(), this.snare = new p.NoiseSynth({\n          noise: {\n            type: \"white\"\n          },\n          envelope: {\n            attack: .005,\n            decay: .05,\n            sustain: .1,\n            release: .4\n          }\n        }).toMaster(), this.loClick = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.hiClick = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.pitchPlayers = [(e, t = 1) => this.kick.triggerAttackRelease(\"C2\", \"8n\", e, t), (e, t = 1) => this.snare.triggerAttackRelease(\"16n\", e, t), (e, t = 1) => this.closedHihat.triggerAttack(e, .3, t), (e, t = 1) => this.openHihat.triggerAttack(e, .3, t), (e, t = .5) => this.tomLow.triggerAttack(\"G3\", e, t), (e, t = .5) => this.tomMid.triggerAttack(\"C4\", e, t), (e, t = .5) => this.tomHigh.triggerAttack(\"F4\", e, t), (e, t = 1) => this.crash.triggerAttack(e, 1, t), (e, t = 1) => this.ride.triggerAttack(e, .5, t), (e, t = .5) => this.loClick.triggerAttack(\"G5\", e, t), (e, t = .5) => this.hiClick.triggerAttack(\"C6\", e, t)];\n\n        for (let e = 0; e < s.DEFAULT_DRUM_PITCH_CLASSES.length; ++e) s.DEFAULT_DRUM_PITCH_CLASSES[e].forEach(t => {\n          this.DRUM_PITCH_TO_CLASS.set(t, e);\n        });\n\n        this.DRUM_PITCH_TO_CLASS.set(i.LO_CLICK_PITCH, i.LO_CLICK_CLASS), this.DRUM_PITCH_TO_CLASS.set(i.HI_CLICK_PITCH, i.HI_CLICK_CLASS);\n      }\n\n      static getInstance() {\n        return A.instance || (A.instance = new A()), A.instance;\n      }\n\n      playNote(e, t, n) {\n        this.pitchPlayers[this.DRUM_PITCH_TO_CLASS.get(e)](t, n);\n      }\n\n    }\n\n    class v extends I {\n      constructor() {\n        super(...arguments), this.drumKit = A.getInstance(), this.bassSynth = new p.Synth({\n          volume: 5,\n          oscillator: {\n            type: \"triangle\"\n          }\n        }).toMaster(), this.polySynth = new p.PolySynth(10).toMaster();\n      }\n\n      playNote(e, t) {\n        const n = t.hasOwnProperty(\"velocity\") ? t.velocity / i.MAX_MIDI_VELOCITY : void 0;\n        if (t.isDrum) this.drumKit.playNote(t.pitch, e, n);else {\n          const r = new p.Frequency(t.pitch, \"midi\"),\n                o = t.endTime - t.startTime;\n          this.getSynth(t.instrument, t.program).triggerAttackRelease(r, o, e, n);\n        }\n      }\n\n      getSynth(e, t) {\n        return void 0 !== t && t >= 32 && t <= 39 ? this.bassSynth : this.polySynth;\n      }\n\n    }\n\n    v.tone = p;\n\n    class E extends I {\n      constructor(e, t = p.Master, n, r, o) {\n        super(!1, o), this.soundFont = new q(e), this.output = t, this.programOutputs = n, this.drumOutputs = r;\n      }\n\n      async loadSamples(e) {\n        await this.soundFont.loadSamples(e.notes.map(e => ({\n          pitch: e.pitch,\n          velocity: e.velocity,\n          program: e.program || 0,\n          isDrum: e.isDrum || !1\n        })));\n      }\n\n      async loadAllSamples(e = 0, t = !1) {\n        const n = f.a.create(),\n              r = t ? i.MIN_DRUM_PITCH : i.MIN_PIANO_PITCH,\n              o = t ? i.MAX_DRUM_PITCH : i.MAX_PIANO_PITCH;\n\n        for (let s = r; s <= o; s++) for (let r = i.MIN_MIDI_VELOCITY; r < i.MAX_MIDI_VELOCITY; r++) n.notes.push({\n          pitch: s,\n          velocity: r,\n          program: e,\n          isDrum: t\n        });\n\n        return this.loadSamples(n);\n      }\n\n      resumeContext() {\n        p.context.resume();\n      }\n\n      start(e, t) {\n        return this.resumeContext(), this.loadSamples(e).then(() => super.start(e, t));\n      }\n\n      playNote(e, t) {\n        this.soundFont.playNote(t.pitch, t.velocity, e, t.endTime - t.startTime, t.program, t.isDrum, this.getAudioNodeOutput(t));\n      }\n\n      playNoteDown(e) {\n        this.soundFont.playNoteDown(e.pitch, e.velocity, e.program, e.isDrum, this.getAudioNodeOutput(e));\n      }\n\n      playNoteUp(e) {\n        this.soundFont.playNoteUp(e.pitch, e.velocity, e.program, e.isDrum, this.getAudioNodeOutput(e));\n      }\n\n      getAudioNodeOutput(e) {\n        let t = this.output;\n        return this.programOutputs && !e.isDrum ? this.programOutputs.has(e.program) && (t = this.programOutputs.get(e.program)) : this.drumOutputs && e.isDrum && this.drumOutputs.has(e.pitch) && (t = this.drumOutputs.get(e.pitch)), t;\n      }\n\n    }\n\n    class k extends v {\n      constructor(e) {\n        super(!0, e);\n      }\n\n    }\n\n    class z extends I {\n      constructor(e) {\n        super(!1, e), this.outputs = [], this.outputChannel = 0, this.availableOutputs = [], this.NOTE_ON = 144, this.NOTE_OFF = 128;\n      }\n\n      async requestMIDIAccess() {\n        return navigator.requestMIDIAccess ? new Promise((e, t) => {\n          navigator.requestMIDIAccess().then(t => {\n            t.addEventListener(\"statechange\", e => this.initOutputs(t)), e(this.initOutputs(t));\n          }, e => console.log(\"Something went wrong\", t(e)));\n        }) : null;\n      }\n\n      initOutputs(e) {\n        const t = e.outputs.values();\n\n        for (let e = t.next(); e && !e.done; e = t.next()) this.availableOutputs.push(e.value);\n\n        return this.availableOutputs;\n      }\n\n      playNote(e, t) {\n        const n = t.velocity || 100,\n              r = 1e3 * (t.endTime - t.startTime),\n              o = [this.NOTE_ON + this.outputChannel, t.pitch, n],\n              i = [this.NOTE_OFF + this.outputChannel, t.pitch, n],\n              s = this.outputs ? this.outputs : this.availableOutputs;\n\n        for (let e = 0; e < s.length; e++) this.sendMessageToOutput(s[e], o), this.sendMessageToOutput(s[e], i, window.performance.now() + r);\n      }\n\n      sendMessageToOutput(e, t, n) {\n        e && e.send(t, n);\n      }\n\n      playNoteDown(e) {\n        const t = [this.NOTE_ON, e.pitch, e.velocity],\n              n = this.outputs ? this.outputs : this.availableOutputs;\n\n        for (let e = 0; e < n.length; e++) this.sendMessageToOutput(n[e], t);\n      }\n\n      playNoteUp(e) {\n        const t = [this.NOTE_OFF, e.pitch, e.velocity],\n              n = this.outputs ? this.outputs : this.availableOutputs;\n\n        for (let r = 0; r < n.length; r++) this.sendMessageToOutput(n[r], t, e.endTime - e.startTime);\n      }\n\n    }\n\n    class _ {}\n\n    class C {\n      constructor(e = {}, t) {\n        this.notes = [], this.midiInputs = [], this.loClick = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.hiClick = new p.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.config = {\n          playClick: e.playClick,\n          qpm: e.qpm || i.DEFAULT_QUARTERS_PER_MINUTE,\n          playCountIn: e.playCountIn,\n          startRecordingAtFirstNote: e.startRecordingAtFirstNote || !1\n        }, this.callbackObject = t, this.recording = !1, this.onNotes = new Map();\n      }\n\n      async initialize() {\n        await navigator.requestMIDIAccess().then(e => this.midiReady(e), e => console.log(\"Something went wrong\", e));\n      }\n\n      midiReady(e) {\n        a.log(\"Initialized Recorder\", \"Recorder\");\n        const t = e.inputs.values();\n\n        for (let e = t.next(); e && !e.done; e = t.next()) this.midiInputs.push(e.value);\n      }\n\n      isRecording() {\n        return this.recording;\n      }\n\n      setTempo(e) {\n        this.config.qpm = e, \"started\" === p.Transport.state && (p.Transport.bpm.value = e);\n      }\n\n      enablePlayClick(e) {\n        this.config.playClick = e;\n      }\n\n      enablePlayCountIn(e) {\n        this.config.playCountIn = e;\n      }\n\n      initClickLoop() {\n        let e = 0;\n        this.clickLoop = new p.Loop(t => {\n          e % 4 == 0 ? this.loClick.triggerAttack(\"G5\", t) : this.hiClick.triggerAttack(\"C6\", t), e++, this.config.playCountIn && 4 === e && (p.Transport.stop(), this.clickLoop.stop());\n        }, \"4n\");\n      }\n\n      getMIDIInputs() {\n        return this.midiInputs;\n      }\n\n      start(e) {\n        const t = e || this.midiInputs;\n\n        for (const e of t) e.onmidimessage = e => {\n          this.midiMessageReceived(e);\n        };\n\n        if (this.config.playClick || this.config.playCountIn ? (this.initClickLoop(), p.Transport.bpm.value = this.config.qpm, p.Transport.start(), this.clickLoop.start()) : this.clickLoop = null, this.recording = !0, this.firstNoteTimestamp = void 0, this.notes = [], this.onNotes = new Map(), !this.startRecordingAtFirstNote) {\n          const e = Date.now();\n          this.firstNoteTimestamp = e;\n        }\n      }\n\n      stop() {\n        this.recording = !1;\n        const e = Date.now();\n        this.onNotes.forEach((t, n) => {\n          this.noteOff(n, e);\n        });\n\n        for (const e of this.midiInputs) e.onmidimessage = null;\n\n        return this.clickLoop && (p.Transport.stop(), this.clickLoop.stop()), 0 === this.notes.length ? null : this.getNoteSequence();\n      }\n\n      getNoteSequence() {\n        return 0 === this.notes.length ? null : f.a.create({\n          notes: this.notes,\n          totalTime: this.notes[this.notes.length - 1].endTime\n        });\n      }\n\n      reset() {\n        const e = this.stop();\n        return this.firstNoteTimestamp = void 0, this.notes = [], this.onNotes = new Map(), e;\n      }\n\n      midiMessageReceived(e) {\n        if (!this.recording) return;\n        let t;\n        const n = (t = void 0 !== e.timeStamp && 0 !== e.timeStamp ? e.timeStamp : performance.now()) + performance.timing.navigationStart;\n        void 0 === this.firstNoteTimestamp && (this.firstNoteTimestamp = n);\n        const r = e.data[0] >> 4,\n              o = e.data[1],\n              i = e.data.length > 2 ? e.data[2] : 1,\n              s = e.srcElement;\n        8 === r || 9 === r && 0 === i ? (this.callbackObject && this.callbackObject.noteOff && this.callbackObject.noteOff(o, i, s), this.noteOff(o, n), this.callbackObject && this.callbackObject.run && this.callbackObject.run(this.getNoteSequence())) : 9 === r && (this.callbackObject && this.callbackObject.noteOn && this.callbackObject.noteOn(o, i, s), this.noteOn(o, i, n));\n      }\n\n      noteOn(e, t, n) {\n        const r = new f.a.Note();\n        r.pitch = e, r.startTime = (n - this.firstNoteTimestamp) / 1e3, r.velocity = t, this.onNotes.set(e, r);\n      }\n\n      noteOff(e, t) {\n        const n = this.onNotes.get(e);\n        n && (n.endTime = (t - this.firstNoteTimestamp) / 1e3, this.notes.push(n)), this.onNotes.delete(e);\n      }\n\n    }\n\n    var x,\n        D = n(19);\n\n    class M {\n      constructor(e, t = {}) {\n        this.noteSequence = e, this.sequenceIsQuantized = c.isQuantizedSequence(this.noteSequence);\n\n        if (this.config = {\n          noteHeight: t.noteHeight || 6,\n          noteSpacing: t.noteSpacing || 1,\n          pixelsPerTimeStep: t.pixelsPerTimeStep || 30,\n          noteRGB: t.noteRGB || \"8, 41, 64\",\n          activeNoteRGB: t.activeNoteRGB || \"240, 84, 119\",\n          minPitch: t.minPitch,\n          maxPitch: t.maxPitch\n        }, this.sequenceIsQuantized) {\n          const t = e.quantizationInfo.stepsPerQuarter;\n          this.config.pixelsPerTimeStep = t ? this.config.pixelsPerTimeStep / t : 7;\n        }\n\n        const n = this.getSize();\n        this.width = n.width, this.height = n.height;\n      }\n\n      getSize() {\n        if (void 0 === this.config.minPitch || void 0 === this.config.maxPitch) {\n          this.config.minPitch = i.MAX_MIDI_PITCH, this.config.maxPitch = i.MIN_MIDI_PITCH;\n\n          for (const e of this.noteSequence.notes) this.config.minPitch = Math.min(e.pitch, this.config.minPitch), this.config.maxPitch = Math.max(e.pitch, this.config.maxPitch);\n\n          this.config.minPitch -= 2, this.config.maxPitch += 2;\n        }\n\n        const e = (this.config.maxPitch - this.config.minPitch) * this.config.noteHeight,\n              t = this.sequenceIsQuantized ? this.noteSequence.totalQuantizedSteps : this.noteSequence.totalTime;\n        if (!t) throw new Error(\"The sequence you are using with the mm.PianoRollSVGVisualizer does not have a \" + (this.sequenceIsQuantized ? \"totalQuantizedSteps\" : \"totalTime\") + \" field set, so the visualizer can't be horizontally sized correctly.\");\n        return {\n          width: t * this.config.pixelsPerTimeStep,\n          height: e\n        };\n      }\n\n      getNotePosition(e, t) {\n        const n = this.getNoteStartTime(e) * this.config.pixelsPerTimeStep,\n              r = this.config.pixelsPerTimeStep * (this.getNoteEndTime(e) - this.getNoteStartTime(e)) - this.config.noteSpacing;\n        return {\n          x: n,\n          y: this.height - (e.pitch - this.config.minPitch) * this.config.noteHeight,\n          w: r,\n          h: this.config.noteHeight\n        };\n      }\n\n      scrollIntoViewIfNeeded(e, t) {\n        if (e && this.parentElement) {\n          const e = this.parentElement.getBoundingClientRect().width;\n          t > this.parentElement.scrollLeft + e && (this.parentElement.scrollLeft = t - 20);\n        }\n      }\n\n      getNoteStartTime(e) {\n        return this.sequenceIsQuantized ? e.quantizedStartStep : Math.round(1e8 * e.startTime) / 1e8;\n      }\n\n      getNoteEndTime(e) {\n        return this.sequenceIsQuantized ? e.quantizedEndStep : Math.round(1e8 * e.endTime) / 1e8;\n      }\n\n      isPaintingActiveNote(e, t) {\n        const n = this.getNoteStartTime(e) === this.getNoteStartTime(t),\n              r = this.getNoteStartTime(e) <= this.getNoteStartTime(t) && this.getNoteEndTime(e) >= this.getNoteEndTime(t);\n        return n || r;\n      }\n\n    }\n\n    class L extends M {\n      constructor(e, t, n = {}) {\n        super(e, n), this.ctx = t.getContext(\"2d\"), this.parentElement = t.parentElement;\n        const r = window.devicePixelRatio || 1;\n        this.ctx && (this.ctx.canvas.width = r * this.width, this.ctx.canvas.height = r * this.height, t.style.width = \"\".concat(this.width, \"px\"), t.style.height = \"\".concat(this.height, \"px\"), this.ctx.scale(r, r)), this.redraw();\n      }\n\n      redraw(e, t) {\n        let n;\n        this.clear();\n\n        for (let t = 0; t < this.noteSequence.notes.length; t++) {\n          const r = this.noteSequence.notes[t],\n                o = this.getNotePosition(r, t),\n                i = .2,\n                s = r.velocity ? r.velocity / 100 + i : 1,\n                a = e && this.isPaintingActiveNote(r, e),\n                u = \"rgba(\".concat(a ? this.config.activeNoteRGB : this.config.noteRGB, \",\\n  \").concat(s, \")\");\n          this.redrawNote(o.x, o.y, o.w, o.h, u), a && r === e && (n = o.x);\n        }\n\n        return this.scrollIntoViewIfNeeded(t, n), n;\n      }\n\n      clear() {\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      }\n\n      redrawNote(e, t, n, r, o) {\n        this.ctx.fillStyle = o, this.ctx.fillRect(Math.round(e), Math.round(t), Math.round(n), Math.round(r));\n      }\n\n    }\n\n    class j extends L {\n      constructor(e, t, n = {}) {\n        super(e, t, n), a.log(\"mm.Visualizer is deprecated, and will be removed in a future          version. Please use mm.PianoRollCanvasVisualizer instead\", \"mm.Visualizer\", 5);\n      }\n\n    }\n\n    class R extends M {\n      constructor(e, t, n = {}) {\n        if (super(e, n), !(t instanceof SVGSVGElement)) throw new Error(\"mm.PianoRollSVGVisualizer requires an <svg> element to display the visualization\");\n        this.svg = t, this.parentElement = t.parentElement, this.drawn = !1, this.svg.style.width = \"\".concat(this.width, \"px\"), this.svg.style.height = \"\".concat(this.height, \"px\"), this.clear(), this.draw();\n      }\n\n      redraw(e, t) {\n        if (this.drawn || this.draw(), !e) return null;\n        const n = this.svg.querySelectorAll(\"rect.active\");\n\n        for (let e = 0; e < n.length; ++e) {\n          const t = n[e],\n                r = this.getNoteFillColor(this.noteSequence.notes[parseInt(t.getAttribute(\"data-index\"), 10)], !1);\n          t.setAttribute(\"fill\", r), t.removeAttribute(\"class\");\n        }\n\n        let r;\n\n        for (let t = 0; t < this.noteSequence.notes.length; t++) {\n          const n = this.noteSequence.notes[t];\n          if (!(e && this.isPaintingActiveNote(n, e))) continue;\n          const o = this.svg.querySelector(\"rect[data-index=\\\"\".concat(t, \"\\\"]\")),\n                i = this.getNoteFillColor(n, !0);\n          o.setAttribute(\"fill\", i), o.setAttribute(\"class\", \"active\"), n === e && (r = parseFloat(o.getAttribute(\"x\")));\n        }\n\n        return this.scrollIntoViewIfNeeded(t, r), r;\n      }\n\n      draw() {\n        for (let e = 0; e < this.noteSequence.notes.length; e++) {\n          const t = this.noteSequence.notes[e],\n                n = this.getNotePosition(t, e),\n                r = this.getNoteFillColor(t, !1);\n          this.drawNote(n.x, n.y, n.w, n.h, r, e);\n        }\n\n        this.drawn = !0;\n      }\n\n      getNoteFillColor(e, t) {\n        const n = e.velocity ? e.velocity / 100 + .2 : 1;\n        return \"rgba(\".concat(t ? this.config.activeNoteRGB : this.config.noteRGB, \",\\n  \").concat(n, \")\");\n      }\n\n      drawNote(e, t, n, r, o, i) {\n        if (!this.svg) return;\n        const s = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n        s.setAttribute(\"fill\", o), s.setAttribute(\"x\", \"\".concat(Math.round(e))), s.setAttribute(\"y\", \"\".concat(Math.round(t))), s.setAttribute(\"width\", \"\".concat(Math.round(n))), s.setAttribute(\"height\", \"\".concat(Math.round(r))), s.setAttribute(\"data-index\", \"\".concat(i)), this.svg.appendChild(s);\n      }\n\n      clear() {\n        this.svg.innerHTML = \"\", this.drawn = !1;\n      }\n\n    }\n\n    !function (e) {\n      e[e.PAGE = 0] = \"PAGE\", e[e.NOTE = 1] = \"NOTE\", e[e.BAR = 2] = \"BAR\";\n    }(x || (x = {}));\n\n    class Q extends M {\n      constructor(e, t, n = {}) {\n        super(e, n), (void 0 === n.pixelsPerTimeStep || n.pixelsPerTimeStep <= 0) && (this.config.pixelsPerTimeStep = 0), this.instruments = n.instruments || [], this.render = new D.StaffSVGRender(this.getScoreInfo(e), {\n          noteHeight: this.config.noteHeight,\n          noteSpacing: this.config.noteSpacing,\n          pixelsPerTimeStep: this.config.pixelsPerTimeStep,\n          noteRGB: this.config.noteRGB,\n          activeNoteRGB: this.config.activeNoteRGB,\n          defaultKey: n.defaultKey || 0,\n          scrollType: n.scrollType || x.PAGE\n        }, t), this.drawnNotes = e.notes.length, this.clear(), this.redraw();\n      }\n\n      clear() {\n        this.render.clear();\n      }\n\n      redraw(e, t) {\n        this.drawnNotes !== this.noteSequence.notes.length && (this.render.scoreInfo = this.getScoreInfo(this.noteSequence));\n        const n = e ? this.getNoteInfo(e) : void 0;\n        return this.render.redraw(n, t);\n      }\n\n      isNoteInInstruments(e) {\n        return void 0 === e.instrument || 0 === this.instruments.length || this.instruments.indexOf(e.instrument) >= 0;\n      }\n\n      timeToQuarters(e) {\n        const t = e * this.noteSequence.tempos[0].qpm / 60;\n        return Math.round(16 * t) / 16;\n      }\n\n      quantizedStepsToQuarters(e) {\n        const t = e / this.noteSequence.quantizationInfo.stepsPerQuarter;\n        return Math.round(16 * t) / 16;\n      }\n\n      getNoteInfo(e) {\n        const t = this.sequenceIsQuantized ? this.quantizedStepsToQuarters(e.quantizedStartStep) : this.timeToQuarters(e.startTime);\n        return {\n          start: t,\n          length: (this.sequenceIsQuantized ? this.quantizedStepsToQuarters(e.quantizedEndStep) : this.timeToQuarters(e.endTime)) - t,\n          pitch: e.pitch,\n          intensity: e.velocity\n        };\n      }\n\n      getScoreInfo(e) {\n        const t = [];\n        return e.notes.forEach(e => {\n          this.isNoteInInstruments(e) && t.push(this.getNoteInfo(e));\n        }), {\n          notes: t,\n          tempos: e.tempos ? e.tempos.map(e => ({\n            start: this.timeToQuarters(e.time),\n            qpm: e.qpm\n          })) : [],\n          keySignatures: e.keySignatures ? e.keySignatures.map(e => ({\n            start: this.timeToQuarters(e.time),\n            key: e.key\n          })) : [],\n          timeSignatures: e.timeSignatures ? e.timeSignatures.map(e => ({\n            start: this.timeToQuarters(e.time),\n            numerator: e.numerator,\n            denominator: e.denominator\n          })) : []\n        };\n      }\n\n    }\n\n    n.d(t, \"aux_inputs\", function () {\n      return r;\n    }), n.d(t, \"chords\", function () {\n      return o;\n    }), n.d(t, \"constants\", function () {\n      return i;\n    }), n.d(t, \"data\", function () {\n      return s;\n    }), n.d(t, \"logging\", function () {\n      return a;\n    }), n.d(t, \"performance\", function () {\n      return u;\n    }), n.d(t, \"sequences\", function () {\n      return c;\n    }), n.d(t, \"MetronomeCallbackObject\", function () {\n      return m;\n    }), n.d(t, \"Metronome\", function () {\n      return h;\n    }), n.d(t, \"MidiConversionError\", function () {\n      return g;\n    }), n.d(t, \"midiToSequenceProto\", function () {\n      return S;\n    }), n.d(t, \"sequenceProtoToMidi\", function () {\n      return y;\n    }), n.d(t, \"urlToBlob\", function () {\n      return w;\n    }), n.d(t, \"blobToNoteSequence\", function () {\n      return b;\n    }), n.d(t, \"urlToNoteSequence\", function () {\n      return N;\n    }), n.d(t, \"BasePlayerCallback\", function () {\n      return O;\n    }), n.d(t, \"BasePlayer\", function () {\n      return I;\n    }), n.d(t, \"Player\", function () {\n      return v;\n    }), n.d(t, \"SoundFontPlayer\", function () {\n      return E;\n    }), n.d(t, \"PlayerWithClick\", function () {\n      return k;\n    }), n.d(t, \"MIDIPlayer\", function () {\n      return z;\n    }), n.d(t, \"BaseRecorderCallback\", function () {\n      return _;\n    }), n.d(t, \"Recorder\", function () {\n      return C;\n    }), n.d(t, \"BaseVisualizer\", function () {\n      return M;\n    }), n.d(t, \"PianoRollCanvasVisualizer\", function () {\n      return L;\n    }), n.d(t, \"Visualizer\", function () {\n      return j;\n    }), n.d(t, \"PianoRollSVGVisualizer\", function () {\n      return R;\n    }), n.d(t, \"ScrollType\", function () {\n      return x;\n    }), n.d(t, \"StaffSVGVisualizer\", function () {\n      return Q;\n    });\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}