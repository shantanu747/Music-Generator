{"ast":null,"code":"var _slicedToArray = require(\"/home/oem/Desktop/Client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e(require(\"@tensorflow/tfjs\"), require(\"tone\")) : \"function\" == typeof define && define.amd ? define([\"tf\", \"Tone\"], e) : \"object\" == typeof exports ? exports.index = e(require(\"@tensorflow/tfjs\"), require(\"tone\")) : t.index = e(t.tf, t.Tone);\n}(self, function (__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__3__) {\n  return function (t) {\n    var e = {};\n\n    function n(r) {\n      if (e[r]) return e[r].exports;\n      var o = e[r] = {\n        i: r,\n        l: !1,\n        exports: {}\n      };\n      return t[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n\n    return n.m = t, n.c = e, n.d = function (t, e, r) {\n      n.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: r\n      });\n    }, n.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (t, e) {\n      if (1 & e && (t = n(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var r = Object.create(null);\n      if (n.r(r), Object.defineProperty(r, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var o in t) n.d(r, o, function (e) {\n        return t[e];\n      }.bind(null, o));\n      return r;\n    }, n.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return n.d(e, \"a\", e), e;\n    }, n.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, n.p = \"\", n(n.s = 75);\n  }([function (t, e) {\n    t.exports = __WEBPACK_EXTERNAL_MODULE__0__;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e), n.d(e, \"DEFAULT_QUARTERS_PER_MINUTE\", function () {\n      return r;\n    }), n.d(e, \"DEFAULT_STEPS_PER_BAR\", function () {\n      return o;\n    }), n.d(e, \"DEFAULT_STEPS_PER_QUARTER\", function () {\n      return i;\n    }), n.d(e, \"DEFAULT_STEPS_PER_SECOND\", function () {\n      return a;\n    }), n.d(e, \"DEFAULT_VELOCITY\", function () {\n      return s;\n    }), n.d(e, \"DEFAULT_PROGRAM\", function () {\n      return u;\n    }), n.d(e, \"DEFAULT_TICKS_PER_QUARTER\", function () {\n      return c;\n    }), n.d(e, \"DEFAULT_CHANNEL\", function () {\n      return l;\n    }), n.d(e, \"DRUM_CHANNEL\", function () {\n      return h;\n    }), n.d(e, \"MIN_MIDI_VELOCITY\", function () {\n      return p;\n    }), n.d(e, \"MAX_MIDI_VELOCITY\", function () {\n      return f;\n    }), n.d(e, \"MIDI_VELOCITIES\", function () {\n      return d;\n    }), n.d(e, \"NO_CHORD\", function () {\n      return m;\n    }), n.d(e, \"NUM_PITCH_CLASSES\", function () {\n      return g;\n    }), n.d(e, \"MIN_MIDI_PITCH\", function () {\n      return v;\n    }), n.d(e, \"MAX_MIDI_PITCH\", function () {\n      return y;\n    }), n.d(e, \"MIDI_PITCHES\", function () {\n      return b;\n    }), n.d(e, \"MIN_PIANO_PITCH\", function () {\n      return w;\n    }), n.d(e, \"MAX_PIANO_PITCH\", function () {\n      return x;\n    }), n.d(e, \"MIN_DRUM_PITCH\", function () {\n      return S;\n    }), n.d(e, \"MAX_DRUM_PITCH\", function () {\n      return E;\n    }), n.d(e, \"MIN_MIDI_PROGRAM\", function () {\n      return C;\n    }), n.d(e, \"MAX_MIDI_PROGRAM\", function () {\n      return I;\n    }), n.d(e, \"LO_CLICK_PITCH\", function () {\n      return A;\n    }), n.d(e, \"HI_CLICK_PITCH\", function () {\n      return k;\n    }), n.d(e, \"LO_CLICK_CLASS\", function () {\n      return T;\n    }), n.d(e, \"HI_CLICK_CLASS\", function () {\n      return N;\n    });\n    const r = 120,\n          o = 16,\n          i = 4,\n          a = 100,\n          s = 80,\n          u = 0,\n          c = 220,\n          l = 0,\n          h = 9,\n          p = 0,\n          f = 127,\n          d = f - p + 1,\n          m = \"N.C.\",\n          g = 12,\n          v = 0,\n          y = 127,\n          b = y - v + 1,\n          w = 21,\n          x = 108,\n          S = 35,\n          E = 81,\n          C = 0,\n          I = 127,\n          A = 89,\n          k = 90,\n          T = 9,\n          N = 10;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.d(e, \"a\", function () {\n      return o;\n    });\n    var r = n(14),\n        o = r.tensorflow.magenta.NoteSequence;\n  }, function (t, e) {\n    t.exports = __WEBPACK_EXTERNAL_MODULE__3__;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    (function (t, r, o, i) {\n      n.d(e, \"a\", function () {\n        return Qs;\n      }), n.d(e, \"b\", function () {\n        return zs;\n      }), n.d(e, \"c\", function () {\n        return Vn;\n      }), n.d(e, \"d\", function () {\n        return jn;\n      }), n.d(e, \"e\", function () {\n        return En;\n      }), n.d(e, \"f\", function () {\n        return Fu;\n      }), n.d(e, \"g\", function () {\n        return Gn;\n      }), n.d(e, \"h\", function () {\n        return qu;\n      }), n.d(e, \"i\", function () {\n        return je;\n      }), n.d(e, \"j\", function () {\n        return Ph;\n      }), n.d(e, \"k\", function () {\n        return Hu;\n      }), n.d(e, \"l\", function () {\n        return nc;\n      }), n.d(e, \"m\", function () {\n        return Yh;\n      }), n.d(e, \"n\", function () {\n        return Xn;\n      }), n.d(e, \"o\", function () {\n        return lu;\n      }), n.d(e, \"p\", function () {\n        return ir;\n      }), n.d(e, \"q\", function () {\n        return pn;\n      }), n.d(e, \"r\", function () {\n        return ju;\n      }), n.d(e, \"s\", function () {\n        return Tn;\n      }), n.d(e, \"t\", function () {\n        return ur;\n      }), n.d(e, \"u\", function () {\n        return ln;\n      }), n.d(e, \"v\", function () {\n        return Ue;\n      }), n.d(e, \"w\", function () {\n        return lr;\n      }), n.d(e, \"x\", function () {\n        return $s;\n      }), n.d(e, \"y\", function () {\n        return yn;\n      }), n.d(e, \"z\", function () {\n        return Sn;\n      });\n      /**\n       * @license\n       * Copyright 2019 Google LLC. All Rights Reserved.\n       * Licensed under the Apache License, Version 2.0 (the \"License\");\n       * you may not use this file except in compliance with the License.\n       * You may obtain a copy of the License at\n       *\n       * http://www.apache.org/licenses/LICENSE-2.0\n       *\n       * Unless required by applicable law or agreed to in writing, software\n       * distributed under the License is distributed on an \"AS IS\" BASIS,\n       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n       * See the License for the specific language governing permissions and\n       * limitations under the License.\n       * =============================================================================\n       */\n\n      var a = function (t, e) {\n        return (a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (t, e) {\n          t.__proto__ = e;\n        } || function (t, e) {\n          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);\n        })(t, e);\n      };\n\n      function s(t, e) {\n        function n() {\n          this.constructor = t;\n        }\n\n        a(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());\n      }\n\n      function u(t, e, n, r) {\n        return new (n || (n = Promise))(function (o, i) {\n          function a(t) {\n            try {\n              u(r.next(t));\n            } catch (t) {\n              i(t);\n            }\n          }\n\n          function s(t) {\n            try {\n              u(r.throw(t));\n            } catch (t) {\n              i(t);\n            }\n          }\n\n          function u(t) {\n            t.done ? o(t.value) : new n(function (e) {\n              e(t.value);\n            }).then(a, s);\n          }\n\n          u((r = r.apply(t, e || [])).next());\n        });\n      }\n\n      function c(t, e) {\n        var n,\n            r,\n            o,\n            i,\n            a = {\n          label: 0,\n          sent: function () {\n            if (1 & o[0]) throw o[1];\n            return o[1];\n          },\n          trys: [],\n          ops: []\n        };\n        return i = {\n          next: s(0),\n          throw: s(1),\n          return: s(2)\n        }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n          return this;\n        }), i;\n\n        function s(i) {\n          return function (s) {\n            return function (i) {\n              if (n) throw new TypeError(\"Generator is already executing.\");\n\n              for (; a;) try {\n                if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;\n\n                switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n                  case 0:\n                  case 1:\n                    o = i;\n                    break;\n\n                  case 4:\n                    return a.label++, {\n                      value: i[1],\n                      done: !1\n                    };\n\n                  case 5:\n                    a.label++, r = i[1], i = [0];\n                    continue;\n\n                  case 7:\n                    i = a.ops.pop(), a.trys.pop();\n                    continue;\n\n                  default:\n                    if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                      a = 0;\n                      continue;\n                    }\n\n                    if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                      a.label = i[1];\n                      break;\n                    }\n\n                    if (6 === i[0] && a.label < o[1]) {\n                      a.label = o[1], o = i;\n                      break;\n                    }\n\n                    if (o && a.label < o[2]) {\n                      a.label = o[2], a.ops.push(i);\n                      break;\n                    }\n\n                    o[2] && a.ops.pop(), a.trys.pop();\n                    continue;\n                }\n\n                i = e.call(t, a);\n              } catch (t) {\n                i = [6, t], r = 0;\n              } finally {\n                n = o = 0;\n              }\n\n              if (5 & i[0]) throw i[1];\n              return {\n                value: i[0] ? i[1] : void 0,\n                done: !0\n              };\n            }([i, s]);\n          };\n        }\n      }\n\n      var l = function () {\n        function t(t) {\n          this.global = t, this.flags = {}, this.flagRegistry = {}, this.urlFlags = {}, this.populateURLFlags();\n        }\n\n        return t.prototype.setPlatform = function (t, e) {\n          null != this.platform && console.warn(\"Platform \" + this.platformName + \" has already been set. Overwriting the platform with \" + e + \".\"), this.platformName = t, this.platform = e;\n        }, t.prototype.registerFlag = function (t, e, n) {\n          if (this.flagRegistry[t] = {\n            evaluationFn: e,\n            setHook: n\n          }, null != this.urlFlags[t]) {\n            var r = this.urlFlags[t];\n            console.warn(\"Setting feature override from URL \" + t + \": \" + r + \".\"), this.set(t, r);\n          }\n        }, t.prototype.get = function (t) {\n          return t in this.flags ? this.flags[t] : (this.flags[t] = this.evaluateFlag(t), this.flags[t]);\n        }, t.prototype.getNumber = function (t) {\n          return this.get(t);\n        }, t.prototype.getBool = function (t) {\n          return this.get(t);\n        }, t.prototype.getFlags = function () {\n          return this.flags;\n        }, Object.defineProperty(t.prototype, \"features\", {\n          get: function () {\n            return this.flags;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.set = function (t, e) {\n          if (null == this.flagRegistry[t]) throw new Error(\"Cannot set flag \" + t + \" as it has not been registered.\");\n          this.flags[t] = e, null != this.flagRegistry[t].setHook && this.flagRegistry[t].setHook(e);\n        }, t.prototype.evaluateFlag = function (t) {\n          if (null == this.flagRegistry[t]) throw new Error(\"Cannot evaluate flag '\" + t + \"': no evaluation function found.\");\n          return this.flagRegistry[t].evaluationFn();\n        }, t.prototype.setFlags = function (t) {\n          this.flags = Object.assign({}, t);\n        }, t.prototype.reset = function () {\n          this.flags = {}, this.urlFlags = {}, this.populateURLFlags();\n        }, t.prototype.populateURLFlags = function () {\n          var t = this;\n\n          if (void 0 !== this.global && void 0 !== this.global.location && void 0 !== this.global.location.search) {\n            var e,\n                n,\n                r = (e = this.global.location.search, n = {}, e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (t) {\n              for (var e = [], r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];\n\n              return function (t, e, n) {\n                t[decodeURIComponent(e)] = decodeURIComponent(n || \"\");\n              }(n, e[0], e[1]), e.join(\"=\");\n            }), n);\n            \"tfjsflags\" in r && r.tfjsflags.split(\",\").forEach(function (e) {\n              var n = e.split(\":\"),\n                  r = n[0],\n                  o = n[1];\n\n              t.urlFlags[r] = function (t, e) {\n                if (\"true\" === (e = e.toLowerCase()) || \"false\" === e) return \"true\" === e;\n                if (\"\" + +e === e) return +e;\n                throw new Error(\"Could not parse value flag value \" + e + \" for flag \" + t + \".\");\n              }(r, o);\n            });\n          }\n        }, t;\n      }();\n\n      function h() {\n        return p;\n      }\n\n      var p = null,\n          f = new Map();\n\n      function d(t, e) {\n        var n = v(t, e);\n        return f.get(n);\n      }\n\n      function m(t) {\n        for (var e = f.entries(), n = [];;) {\n          var r = e.next(),\n              o = r.done,\n              i = r.value;\n          if (o) break;\n          var a = i[0],\n              s = i[1];\n          a.split(\"_\")[0] === t && n.push(s);\n        }\n\n        return n;\n      }\n\n      function g(t) {\n        var e = t.kernelName,\n            n = t.backendName,\n            r = v(e, n);\n        if (f.has(r)) throw new Error(\"The kernel '\" + e + \"' for backend '\" + n + \"' is already registered\");\n        f.set(r, t);\n      }\n\n      function v(t, e) {\n        return e + \"_\" + t;\n      }\n\n      function y(t) {\n        for (var e = t.length, n = 0, r = 0; e > 0;) r = Math.random() * e | 0, n = t[--e], t[e] = t[r], t[r] = n;\n      }\n\n      function b(t, e, n) {\n        return Math.max(t, Math.min(e, n));\n      }\n\n      function w(t) {\n        return t % 2 == 0 ? t : t + 1;\n      }\n\n      function x(t) {\n        for (var e = 0, n = 0; n < t.length; n++) e += t[n];\n\n        return e;\n      }\n\n      function S(t, e) {\n        if (!t) throw new Error(\"string\" == typeof e ? e : e());\n      }\n\n      function E(t, e, n) {\n        void 0 === n && (n = \"\"), S(k(t, e), function () {\n          return n + \" Shapes \" + t + \" and \" + e + \" must match\";\n        });\n      }\n\n      function C(t) {\n        S(null != t, function () {\n          return \"The input to the tensor constructor must be a non-null value.\";\n        });\n      }\n\n      function I(t, e, n) {\n        if (void 0 === e && (e = []), void 0 === n && (n = !1), null == e && (e = []), Array.isArray(t) || V(t) && !n) for (var r = 0; r < t.length; ++r) I(t[r], e, n);else e.push(t);\n        return e;\n      }\n\n      function A(t) {\n        if (0 === t.length) return 1;\n\n        for (var e = t[0], n = 1; n < t.length; n++) e *= t[n];\n\n        return e;\n      }\n\n      function k(t, e) {\n        if (t === e) return !0;\n        if (null == t || null == e) return !1;\n        if (t.length !== e.length) return !1;\n\n        for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;\n\n        return !0;\n      }\n\n      function T(t) {\n        return t % 1 == 0;\n      }\n\n      function N(t) {\n        if (null != Math.tanh) return Math.tanh(t);\n        if (t === 1 / 0) return 1;\n        if (t === -1 / 0) return -1;\n        var e = Math.exp(2 * t);\n        return (e - 1) / (e + 1);\n      }\n\n      function P(t) {\n        var e = Math.ceil(Math.sqrt(t));\n        return [e, Math.ceil(t / e)];\n      }\n\n      function R(t, e) {\n        return e <= t.length ? t : t + \" \".repeat(e - t.length);\n      }\n\n      function _(t, e, n) {\n        return void 0 === e && (e = function (t) {\n          return 0;\n        }), new Promise(function (r, o) {\n          var i = 0,\n              a = function () {\n            if (t()) r();else {\n              var s = e(++i);\n              null != n && i >= n ? o() : setTimeout(a, s);\n            }\n          };\n\n          a();\n        });\n      }\n\n      function M(t, e) {\n        for (var n = 1, r = -1, o = 0; o < t.length; ++o) if (t[o] >= 0) n *= t[o];else if (-1 === t[o]) {\n          if (-1 !== r) throw Error(\"Shapes can only have 1 implicit size. Found -1 at dim \" + r + \" and dim \" + o);\n          r = o;\n        } else if (t[o] < 0) throw Error(\"Shapes can not be < 0. Found \" + t[o] + \" at dim \" + o);\n\n        if (-1 === r) {\n          if (e > 0 && e !== n) throw Error(\"Size(\" + e + \") must match the product of shape \" + t);\n          return t;\n        }\n\n        if (0 === n) throw Error(\"Cannot infer the missing size in [\" + t + \"] when there are 0 elements\");\n        if (e % n != 0) throw Error(\"The implicit shape can't be a fractional number. Got \" + e + \" / \" + n);\n        var i = t.slice();\n        return i[r] = e / n, i;\n      }\n\n      function O(t, e) {\n        var n = e.length;\n        return S((t = null == t ? e.map(function (t, e) {\n          return e;\n        }) : [].concat(t)).every(function (t) {\n          return t >= -n && t < n;\n        }), function () {\n          return \"All values in axis param must be in range [-\" + n + \", \" + n + \") but got axis \" + t;\n        }), S(t.every(function (t) {\n          return T(t);\n        }), function () {\n          return \"All values in axis param must be integers but got axis \" + t;\n        }), t.map(function (t) {\n          return t < 0 ? n + t : t;\n        });\n      }\n\n      function D(t, e) {\n        for (var n = [], r = [], o = null != e && Array.isArray(e) && 0 === e.length, i = null == e || o ? null : O(e, t).sort(), a = 0, s = 0; s < t.length; ++s) {\n          if (null != i) {\n            if (i[a] === s && 1 !== t[s]) throw new Error(\"Can't squeeze axis \" + s + \" since its dim '\" + t[s] + \"' is not 1\");\n            (null == i[a] || i[a] > s) && 1 === t[s] && (n.push(t[s]), r.push(s)), i[a] <= s && a++;\n          }\n\n          1 !== t[s] && (n.push(t[s]), r.push(s));\n        }\n\n        return {\n          newShape: n,\n          keptDims: r\n        };\n      }\n\n      function F(t, e) {\n        var n = null;\n        if (null == t || \"float32\" === t) n = new Float32Array(e);else if (\"int32\" === t) n = new Int32Array(e);else {\n          if (\"bool\" !== t) throw new Error(\"Unknown data type \" + t);\n          n = new Uint8Array(e);\n        }\n        return n;\n      }\n\n      function L(t, e) {\n        var n = null;\n        if (null == t || \"float32\" === t) n = new Float32Array(e);else if (\"int32\" === t) n = new Int32Array(e);else if (\"bool\" === t) n = new Uint8Array(e);else {\n          if (\"string\" !== t) throw new Error(\"Unknown data type \" + t);\n          n = new Array(e);\n        }\n        return n;\n      }\n\n      function B(t, e) {\n        for (var n = 0; n < t.length; n++) {\n          var r = t[n];\n          if (isNaN(r) || !isFinite(r)) throw Error(\"A tensor of type \" + e + \" being uploaded contains \" + r + \".\");\n        }\n      }\n\n      function z(t) {\n        return \"bool\" === t || \"complex64\" === t || \"float32\" === t || \"int32\" === t || \"string\" === t;\n      }\n\n      function q(t, e) {\n        return !(\"complex64\" === e || \"float32\" === e && \"complex64\" !== t || \"int32\" === e && \"float32\" !== t && \"complex64\" !== t || \"bool\" === e && \"bool\" === t);\n      }\n\n      function V(t) {\n        return t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array;\n      }\n\n      function U(t) {\n        if (\"float32\" === t || \"int32\" === t) return 4;\n        if (\"complex64\" === t) return 8;\n        if (\"bool\" === t) return 1;\n        throw new Error(\"Unknown dtype \" + t);\n      }\n\n      function j(t) {\n        if (null == t) return 0;\n        var e = 0;\n        return t.forEach(function (t) {\n          return e += t.length;\n        }), e;\n      }\n\n      function W(t) {\n        return \"string\" == typeof t || t instanceof String;\n      }\n\n      function G(t) {\n        return \"boolean\" == typeof t;\n      }\n\n      function H(t) {\n        return \"number\" == typeof t;\n      }\n\n      function $(t) {\n        return Array.isArray(t) ? $(t[0]) : t instanceof Float32Array ? \"float32\" : t instanceof Int32Array || t instanceof Uint8Array ? \"int32\" : H(t) ? \"float32\" : W(t) ? \"string\" : G(t) ? \"bool\" : \"float32\";\n      }\n\n      function K(t) {\n        return !!(t && t.constructor && t.call && t.apply);\n      }\n\n      function Q(t, e) {\n        for (var n = e; n < t; ++n) if (t % n == 0) return n;\n\n        return t;\n      }\n\n      function X(t) {\n        var e = t.length;\n        if (e < 2) return [];\n        var n = new Array(e - 1);\n        n[e - 2] = t[e - 1];\n\n        for (var r = e - 3; r >= 0; --r) n[r] = n[r + 1] * t[r + 1];\n\n        return n;\n      }\n\n      function Y(t, e, n) {\n        if (\"string\" === e) throw new Error(\"Cannot convert a string[] to a TypedArray\");\n        if (Array.isArray(t) && (t = I(t)), n && B(t, e), function (t, e) {\n          return t instanceof Float32Array && \"float32\" === e || t instanceof Int32Array && \"int32\" === e || t instanceof Uint8Array && \"bool\" === e;\n        }(t, e)) return t;\n        if (null == e || \"float32\" === e || \"complex64\" === e) return new Float32Array(t);\n        if (\"int32\" === e) return new Int32Array(t);\n\n        if (\"bool\" === e) {\n          for (var r = new Uint8Array(t.length), o = 0; o < r.length; ++o) 0 !== Math.round(t[o]) && (r[o] = 1);\n\n          return r;\n        }\n\n        throw new Error(\"Unknown data type \" + e);\n      }\n\n      function J(t, e) {\n        if (0 === t.length) return e[0];\n        var n = t.reduce(function (t, e) {\n          return t * e;\n        });\n        if (0 === n) return [];\n        if (n !== e.length) throw new Error(\"[\" + t + \"] does not match the input size.\");\n        return function t(e, n, r) {\n          var o = new Array();\n          if (1 === n.length) for (var i = n[0], a = 0; a < i; a++) o[a] = r[e + a];else {\n            i = n[0];\n            var s = n.slice(1),\n                u = s.reduce(function (t, e) {\n              return t * e;\n            });\n\n            for (a = 0; a < i; a++) o[a] = t(e + a * u, s, r);\n          }\n          return o;\n        }(0, t, e);\n      }\n\n      function Z(t, e) {\n        for (var n = tt(t, e), r = 0; r < n.length; r++) n[r] = 1;\n\n        return n;\n      }\n\n      function tt(t, e) {\n        if (null == e || \"float32\" === e || \"complex64\" === e) return new Float32Array(t);\n        if (\"int32\" === e) return new Int32Array(t);\n        if (\"bool\" === e) return new Uint8Array(t);\n        throw new Error(\"Unknown data type \" + e);\n      }\n\n      function et() {\n        return h().platform.now();\n      }\n\n      function nt(t) {\n        t.forEach(function (e) {\n          S(Number.isInteger(e) && e >= 0, function () {\n            return \"Tensor must have a shape comprised of positive integers but got shape [\" + t + \"].\";\n          });\n        });\n      }\n\n      function rt(t, e) {\n        return void 0 === e && (e = \"utf-8\"), e = e || \"utf-8\", h().platform.encode(t, e);\n      }\n\n      function ot(t, e) {\n        return void 0 === e && (e = \"utf-8\"), e = e || \"utf-8\", h().platform.decode(t, e);\n      }\n\n      Object.freeze({\n        shuffle: y,\n        clamp: b,\n        nearestLargerEven: w,\n        sum: x,\n        randUniform: function (t, e) {\n          var n = Math.random();\n          return e * n + (1 - n) * t;\n        },\n        distSquared: function (t, e) {\n          for (var n = 0, r = 0; r < t.length; r++) {\n            var o = Number(t[r]) - Number(e[r]);\n            n += o * o;\n          }\n\n          return n;\n        },\n        assert: S,\n        assertShapesMatch: E,\n        assertNonNull: C,\n        flatten: I,\n        sizeFromShape: A,\n        isScalarShape: function (t) {\n          return 0 === t.length;\n        },\n        arraysEqual: k,\n        isInt: T,\n        tanh: N,\n        sizeToSquarishShape: P,\n        createShuffledIndices: function (t) {\n          for (var e = new Uint32Array(t), n = 0; n < t; ++n) e[n] = n;\n\n          return y(e), e;\n        },\n        rightPad: R,\n        repeatedTry: _,\n        inferFromImplicitShape: M,\n        parseAxisParam: O,\n        squeezeShape: D,\n        getTypedArrayFromDType: F,\n        getArrayFromDType: L,\n        checkConversionForErrors: B,\n        isValidDtype: z,\n        hasEncodingLoss: q,\n        isTypedArray: V,\n        bytesPerElement: U,\n        bytesFromStringArray: j,\n        isString: W,\n        isBoolean: G,\n        isNumber: H,\n        inferDtype: $,\n        isFunction: K,\n        nearestDivisor: Q,\n        computeStrides: X,\n        toTypedArray: Y,\n        toNestedArray: J,\n        makeOnesTypedArray: Z,\n        makeZerosTypedArray: tt,\n        now: et,\n        assertNonNegativeIntegerDimensions: nt,\n        fetch: function (t, e) {\n          return h().platform.fetch(t, e);\n        },\n        encodeString: rt,\n        decodeString: ot\n      });\n\n      var it = function () {\n        function t(t, e) {\n          this.backendTimer = t, this.logger = e, null == e && (this.logger = new at());\n        }\n\n        return t.prototype.profileKernel = function (t, e, n) {\n          var r,\n              o = this,\n              i = this.backendTimer.time(function () {\n            r = n();\n          });\n          return r.forEach(function (n) {\n            n.data().then(function (r) {\n              !function (t, e, n) {\n                if (\"float32\" !== e) return !1;\n\n                for (var r = 0; r < t.length; r++) {\n                  var o = t[r];\n                  if (isNaN(o) || !isFinite(o)) return console.warn(\"Found \" + o + \" in the result of '\" + n + \"'\"), !0;\n                }\n              }(r, n.dtype, t), i.then(function (i) {\n                var a = \"\";\n                null != i.getExtraProfileInfo && (a = i.getExtraProfileInfo()), o.logger.logKernelProfile(t, n, r, i.kernelMs, e, a);\n              });\n            });\n          }), r;\n        }, t;\n      }(),\n          at = function () {\n        function t() {}\n\n        return t.prototype.logKernelProfile = function (t, e, n, r, o, i) {\n          var a = R(r + \"ms\", 9),\n              s = R(t, 25),\n              u = e.rank,\n              c = e.size,\n              l = R(e.shape.toString(), 14),\n              h = \"\";\n\n          for (var p in o) {\n            var f = o[p].shape,\n                d = f.length;\n            h += p + \": \" + d + \"D \" + (d > 0 ? f : \"\") + \" \";\n          }\n\n          console.log(\"%c\" + s + \"\\t%c\" + a + \"\\t%c\" + u + \"D \" + l + \"\\t%c\" + c + \"\\t%c\" + h + \"\\t%c\" + i, \"font-weight:bold\", \"color:red\", \"color:blue\", \"color: orange\", \"color: green\", \"color: steelblue\");\n        }, t;\n      }(),\n          st = 20,\n          ut = 3,\n          ct = 7;\n\n      function lt(t, e, n) {\n        return R(Array.isArray(t) ? parseFloat(t[0].toFixed(ct)) + \" + \" + parseFloat(t[1].toFixed(ct)) + \"j\" : W(t) ? \"'\" + t + \"'\" : \"bool\" === n ? ht(t) : parseFloat(t.toFixed(ct)).toString(), e);\n      }\n\n      function ht(t) {\n        return 0 === t ? \"false\" : \"true\";\n      }\n\n      function pt(t) {\n        for (var e = [], n = 0; n < t.length; n += 2) e.push([t[n], t[n + 1]]);\n\n        return e;\n      }\n\n      var ft = function () {\n        function t(t, e, n) {\n          var r = this;\n\n          if (this.dtype = e, this.shape = t.slice(), this.size = A(t), null != n) {\n            var o = n.length;\n            S(o === this.size, function () {\n              return \"Length of values '\" + o + \"' does not match the size inferred by the shape '\" + r.size + \"'.\";\n            });\n          }\n\n          if (\"complex64\" === e) throw new Error(\"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).\");\n          this.values = n || L(e, this.size), this.strides = X(t);\n        }\n\n        return t.prototype.set = function (t) {\n          for (var e = this, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];\n\n          0 === n.length && (n = [0]), S(n.length === this.rank, function () {\n            return \"The number of provided coordinates (\" + n.length + \") must match the rank (\" + e.rank + \")\";\n          });\n          var o = this.locToIndex(n);\n          this.values[o] = t;\n        }, t.prototype.get = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          0 === t.length && (t = [0]);\n\n          for (var n = 0, r = 0, o = t; r < o.length; r++) {\n            var i = o[r];\n\n            if (i < 0 || i >= this.shape[n]) {\n              var a = \"Requested out of range element at \" + t + \".   Buffer shape=\" + this.shape;\n              throw new Error(a);\n            }\n\n            n++;\n          }\n\n          for (var s = t[t.length - 1], u = 0; u < t.length - 1; ++u) s += this.strides[u] * t[u];\n\n          return this.values[s];\n        }, t.prototype.locToIndex = function (t) {\n          if (0 === this.rank) return 0;\n          if (1 === this.rank) return t[0];\n\n          for (var e = t[t.length - 1], n = 0; n < t.length - 1; ++n) e += this.strides[n] * t[n];\n\n          return e;\n        }, t.prototype.indexToLoc = function (t) {\n          if (0 === this.rank) return [];\n          if (1 === this.rank) return [t];\n\n          for (var e = new Array(this.shape.length), n = 0; n < e.length - 1; ++n) e[n] = Math.floor(t / this.strides[n]), t -= e[n] * this.strides[n];\n\n          return e[e.length - 1] = t, e;\n        }, Object.defineProperty(t.prototype, \"rank\", {\n          get: function () {\n            return this.shape.length;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.toTensor = function () {\n          return dt().makeTensor(this.values, this.shape, this.dtype);\n        }, t;\n      }(),\n          dt = null,\n          mt = null,\n          gt = null,\n          vt = function () {\n        function t(t, e, n, r) {\n          this.kept = !1, this.isDisposedInternal = !1, this.shape = t.slice(), this.dtype = e || \"float32\", this.size = A(t), this.strides = X(t), this.dataId = n, this.id = r, this.rankType = this.rank < 5 ? this.rank.toString() : \"higher\";\n        }\n\n        return t.prototype.flatten = function () {\n          return this.throwIfDisposed(), this.as1D();\n        }, t.prototype.asScalar = function () {\n          return this.throwIfDisposed(), S(1 === this.size, function () {\n            return \"The array must have only 1 element.\";\n          }), this.reshape([]);\n        }, t.prototype.as1D = function () {\n          return this.throwIfDisposed(), this.reshape([this.size]);\n        }, t.prototype.as2D = function (t, e) {\n          return this.throwIfDisposed(), this.reshape([t, e]);\n        }, t.prototype.as3D = function (t, e, n) {\n          return this.throwIfDisposed(), this.reshape([t, e, n]);\n        }, t.prototype.as4D = function (t, e, n, r) {\n          return this.throwIfDisposed(), this.reshape([t, e, n, r]);\n        }, t.prototype.as5D = function (t, e, n, r, o) {\n          return this.throwIfDisposed(), this.reshape([t, e, n, r, o]);\n        }, t.prototype.asType = function (t) {\n          return this.throwIfDisposed(), mt.cast(this, t);\n        }, Object.defineProperty(t.prototype, \"rank\", {\n          get: function () {\n            return this.shape.length;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.buffer = function () {\n          return u(this, void 0, void 0, function () {\n            var t;\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return [4, this.data()];\n\n                case 1:\n                  return t = e.sent(), [2, mt.buffer(this.shape, this.dtype, t)];\n              }\n            });\n          });\n        }, t.prototype.bufferSync = function () {\n          return mt.buffer(this.shape, this.dtype, this.dataSync());\n        }, t.prototype.array = function () {\n          return u(this, void 0, void 0, function () {\n            var t;\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return [4, this.data()];\n\n                case 1:\n                  return t = e.sent(), [2, J(this.shape, t)];\n              }\n            });\n          });\n        }, t.prototype.arraySync = function () {\n          return J(this.shape, this.dataSync());\n        }, t.prototype.data = function () {\n          return u(this, void 0, void 0, function () {\n            var t, e;\n            return c(this, function (n) {\n              switch (n.label) {\n                case 0:\n                  return this.throwIfDisposed(), t = dt().read(this.dataId), \"string\" !== this.dtype ? [3, 2] : [4, t];\n\n                case 1:\n                  e = n.sent();\n\n                  try {\n                    return [2, e.map(function (t) {\n                      return ot(t);\n                    })];\n                  } catch (t) {\n                    throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\");\n                  }\n\n                  n.label = 2;\n\n                case 2:\n                  return [2, t];\n              }\n            });\n          });\n        }, t.prototype.dataSync = function () {\n          this.throwIfDisposed();\n          var t = dt().readSync(this.dataId);\n          if (\"string\" === this.dtype) try {\n            return t.map(function (t) {\n              return ot(t);\n            });\n          } catch (t) {\n            throw new Error(\"Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().\");\n          }\n          return t;\n        }, t.prototype.bytes = function () {\n          return u(this, void 0, void 0, function () {\n            var t;\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return this.throwIfDisposed(), [4, dt().read(this.dataId)];\n\n                case 1:\n                  return t = e.sent(), \"string\" === this.dtype ? [2, t] : [2, new Uint8Array(t.buffer)];\n              }\n            });\n          });\n        }, t.prototype.dispose = function () {\n          this.isDisposed || (dt().disposeTensor(this), this.isDisposedInternal = !0);\n        }, Object.defineProperty(t.prototype, \"isDisposed\", {\n          get: function () {\n            return this.isDisposedInternal;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.throwIfDisposed = function () {\n          if (this.isDisposed) throw new Error(\"Tensor is disposed.\");\n        }, t.prototype.toFloat = function () {\n          return this.asType(\"float32\");\n        }, t.prototype.toInt = function () {\n          return this.asType(\"int32\");\n        }, t.prototype.toBool = function () {\n          return this.asType(\"bool\");\n        }, t.prototype.print = function (t) {\n          return void 0 === t && (t = !1), mt.print(this, t);\n        }, t.prototype.reshape = function (t) {\n          return this.throwIfDisposed(), mt.reshape(this, t);\n        }, t.prototype.reshapeAs = function (t) {\n          return this.throwIfDisposed(), this.reshape(t.shape);\n        }, t.prototype.expandDims = function (t) {\n          return void 0 === t && (t = 0), mt.expandDims(this, t);\n        }, t.prototype.cumsum = function (t, e, n) {\n          return void 0 === t && (t = 0), void 0 === e && (e = !1), void 0 === n && (n = !1), mt.cumsum(this, t, e, n);\n        }, t.prototype.squeeze = function (t) {\n          return this.throwIfDisposed(), mt.squeeze(this, t);\n        }, t.prototype.clone = function () {\n          return this.throwIfDisposed(), mt.clone(this);\n        }, t.prototype.oneHot = function (t, e, n) {\n          return this.throwIfDisposed(), mt.oneHot(this, t, e, n);\n        }, t.prototype.toString = function (t) {\n          return void 0 === t && (t = !1), function (t, e, n, r) {\n            var o = X(e),\n                i = function (t, e, n, r) {\n              var o = A(e),\n                  i = r[r.length - 1],\n                  a = new Array(i).fill(0),\n                  s = e.length,\n                  u = \"complex64\" === n ? pt(t) : t;\n              if (s > 1) for (var c = 0; c < o / i; c++) for (var l = c * i, h = 0; h < i; h++) a[h] = Math.max(a[h], lt(u[l + h], 0, n).length);\n              return a;\n            }(t, e, n, o),\n                a = e.length,\n                s = function t(e, n, r, o, i, a) {\n              void 0 === a && (a = !0);\n              var s = \"complex64\" === r ? 2 : 1,\n                  u = n[0],\n                  c = n.length;\n              if (0 === c) return \"complex64\" === r ? [lt(pt(e)[0], 0, r)] : \"bool\" === r ? [ht(e[0])] : [e[0].toString()];\n\n              if (1 === c) {\n                if (u > st) {\n                  var l = ut * s,\n                      h = Array.from(e.slice(0, l)),\n                      p = Array.from(e.slice(u - ut * s, u));\n                  return \"complex64\" === r && (h = pt(h), p = pt(p)), [\"[\" + h.map(function (t, e) {\n                    return lt(t, i[e], r);\n                  }).join(\", \") + \", ..., \" + p.map(function (t, e) {\n                    return lt(t, i[u - ut + e], r);\n                  }).join(\", \") + \"]\"];\n                }\n\n                return [\"[\" + (\"complex64\" === r ? pt(e) : Array.from(e)).map(function (t, e) {\n                  return lt(t, i[e], r);\n                }).join(\", \") + \"]\"];\n              }\n\n              var f = n.slice(1),\n                  d = o.slice(1),\n                  m = o[0] * s,\n                  g = [];\n\n              if (u > st) {\n                for (var v = 0; v < ut; v++) {\n                  var y = (b = v * m) + m;\n                  g.push.apply(g, t(e.slice(b, y), f, r, d, i, !1));\n                }\n\n                g.push(\"...\");\n\n                for (v = u - ut; v < u; v++) {\n                  y = (b = v * m) + m;\n                  g.push.apply(g, t(e.slice(b, y), f, r, d, i, v === u - 1));\n                }\n              } else for (v = 0; v < u; v++) {\n                var b;\n                y = (b = v * m) + m;\n                g.push.apply(g, t(e.slice(b, y), f, r, d, i, v === u - 1));\n              }\n\n              var w = 2 === c ? \",\" : \"\";\n              g[0] = \"[\" + g[0] + w;\n\n              for (v = 1; v < g.length - 1; v++) g[v] = \" \" + g[v] + w;\n\n              var x = \",\\n\";\n\n              for (v = 2; v < c; v++) x += \"\\n\";\n\n              return g[g.length - 1] = \" \" + g[g.length - 1] + \"]\" + (a ? \"\" : x), g;\n            }(t, e, n, o, i),\n                u = [\"Tensor\"];\n\n            return r && (u.push(\"  dtype: \" + n), u.push(\"  rank: \" + a), u.push(\"  shape: [\" + e + \"]\"), u.push(\"  values:\")), u.push(s.map(function (t) {\n              return \"    \" + t;\n            }).join(\"\\n\")), u.join(\"\\n\");\n          }(this.dataSync(), this.shape, this.dtype, t);\n        }, t.prototype.tile = function (t) {\n          return this.throwIfDisposed(), mt.tile(this, t);\n        }, t.prototype.gather = function (t, e) {\n          return void 0 === e && (e = 0), this.throwIfDisposed(), mt.gather(this, t, e);\n        }, t.prototype.matMul = function (t, e, n) {\n          return void 0 === e && (e = !1), void 0 === n && (n = !1), this.throwIfDisposed(), mt.matMul(this, t, e, n);\n        }, t.prototype.dot = function (t) {\n          return this.throwIfDisposed(), mt.dot(this, t);\n        }, t.prototype.norm = function (t, e, n) {\n          return void 0 === t && (t = \"euclidean\"), void 0 === e && (e = null), void 0 === n && (n = !1), this.throwIfDisposed(), mt.norm(this, t, e, n);\n        }, t.prototype.slice = function (t, e) {\n          return this.throwIfDisposed(), mt.slice(this, t, e);\n        }, t.prototype.reverse = function (t) {\n          return this.throwIfDisposed(), mt.reverse(this, t);\n        }, t.prototype.concat = function (e, n) {\n          return void 0 === n && (n = 0), this.throwIfDisposed(), e instanceof t && (e = [e]), mt.concat([this].concat(e), n);\n        }, t.prototype.split = function (t, e) {\n          return void 0 === e && (e = 0), this.throwIfDisposed(), mt.split(this, t, e);\n        }, t.prototype.stack = function (t, e) {\n          return void 0 === e && (e = 0), mt.stack([this, t], e);\n        }, t.prototype.unstack = function (t) {\n          return void 0 === t && (t = 0), mt.unstack(this, t);\n        }, t.prototype.pad = function (t, e) {\n          return void 0 === e && (e = 0), mt.pad(this, t, e);\n        }, t.prototype.batchNormalization = function (t, e, n, r, o) {\n          return void 0 === n && (n = .001), gt(\"tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon\"), this.batchNorm(t, e, o, r, n);\n        }, t.prototype.batchNorm = function (t, e, n, r, o) {\n          return void 0 === o && (o = .001), this.throwIfDisposed(), mt.batchNorm(this, t, e, n, r, o);\n        }, t.prototype.all = function (t, e) {\n          return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.all(this, t, e);\n        }, t.prototype.any = function (t, e) {\n          return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.any(this, t, e);\n        }, t.prototype.logSumExp = function (t, e) {\n          return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.logSumExp(this, t, e);\n        }, t.prototype.sum = function (t, e) {\n          return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.sum(this, t, e);\n        }, t.prototype.prod = function (t, e) {\n          return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.prod(this, t, e);\n        }, t.prototype.mean = function (t, e) {\n          return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.mean(this, t, e);\n        }, t.prototype.min = function (t, e) {\n          return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.min(this, t, e);\n        }, t.prototype.max = function (t, e) {\n          return void 0 === t && (t = null), void 0 === e && (e = !1), this.throwIfDisposed(), mt.max(this, t, e);\n        }, t.prototype.argMin = function (t) {\n          return void 0 === t && (t = null), this.throwIfDisposed(), mt.argMin(this, t);\n        }, t.prototype.argMax = function (t) {\n          return void 0 === t && (t = null), this.throwIfDisposed(), mt.argMax(this, t);\n        }, t.prototype.cast = function (t) {\n          return this.throwIfDisposed(), mt.cast(this, t);\n        }, t.prototype.add = function (t) {\n          return this.throwIfDisposed(), mt.add(this, t);\n        }, t.prototype.addStrict = function (t) {\n          return this.throwIfDisposed(), mt.addStrict(this, t);\n        }, t.prototype.atan2 = function (t) {\n          return this.throwIfDisposed(), mt.atan2(this, t);\n        }, t.prototype.sub = function (t) {\n          return this.throwIfDisposed(), mt.sub(this, t);\n        }, t.prototype.subStrict = function (t) {\n          return this.throwIfDisposed(), mt.subStrict(this, t);\n        }, t.prototype.pow = function (t) {\n          return this.throwIfDisposed(), mt.pow(this, t);\n        }, t.prototype.powStrict = function (t) {\n          return this.throwIfDisposed(), mt.powStrict(this, t);\n        }, t.prototype.mul = function (t) {\n          return this.throwIfDisposed(), mt.mul(this, t);\n        }, t.prototype.mulStrict = function (t) {\n          return this.throwIfDisposed(), mt.mulStrict(this, t);\n        }, t.prototype.div = function (t) {\n          return this.throwIfDisposed(), mt.div(this, t);\n        }, t.prototype.floorDiv = function (t) {\n          return this.throwIfDisposed(), mt.floorDiv(this, t);\n        }, t.prototype.divStrict = function (t) {\n          return this.throwIfDisposed(), mt.divStrict(this, t);\n        }, t.prototype.minimum = function (t) {\n          return this.throwIfDisposed(), mt.minimum(this, t);\n        }, t.prototype.minimumStrict = function (t) {\n          return this.throwIfDisposed(), mt.minimumStrict(this, t);\n        }, t.prototype.maximum = function (t) {\n          return this.throwIfDisposed(), mt.maximum(this, t);\n        }, t.prototype.maximumStrict = function (t) {\n          return this.throwIfDisposed(), mt.maximumStrict(this, t);\n        }, t.prototype.mod = function (t) {\n          return this.throwIfDisposed(), mt.mod(this, t);\n        }, t.prototype.modStrict = function (t) {\n          return this.throwIfDisposed(), mt.modStrict(this, t);\n        }, t.prototype.squaredDifference = function (t) {\n          return this.throwIfDisposed(), mt.squaredDifference(this, t);\n        }, t.prototype.squaredDifferenceStrict = function (t) {\n          return this.throwIfDisposed(), mt.squaredDifferenceStrict(this, t);\n        }, t.prototype.transpose = function (t) {\n          return this.throwIfDisposed(), mt.transpose(this, t);\n        }, t.prototype.notEqual = function (t) {\n          return this.throwIfDisposed(), mt.notEqual(this, t);\n        }, t.prototype.notEqualStrict = function (t) {\n          return this.throwIfDisposed(), mt.notEqualStrict(this, t);\n        }, t.prototype.less = function (t) {\n          return this.throwIfDisposed(), mt.less(this, t);\n        }, t.prototype.lessStrict = function (t) {\n          return this.throwIfDisposed(), mt.lessStrict(this, t);\n        }, t.prototype.equal = function (t) {\n          return this.throwIfDisposed(), mt.equal(this, t);\n        }, t.prototype.equalStrict = function (t) {\n          return this.throwIfDisposed(), mt.equalStrict(this, t);\n        }, t.prototype.lessEqual = function (t) {\n          return this.throwIfDisposed(), mt.lessEqual(this, t);\n        }, t.prototype.lessEqualStrict = function (t) {\n          return this.throwIfDisposed(), mt.lessEqualStrict(this, t);\n        }, t.prototype.greater = function (t) {\n          return this.throwIfDisposed(), mt.greater(this, t);\n        }, t.prototype.greaterStrict = function (t) {\n          return this.throwIfDisposed(), mt.greaterStrict(this, t);\n        }, t.prototype.greaterEqual = function (t) {\n          return this.throwIfDisposed(), mt.greaterEqual(this, t);\n        }, t.prototype.greaterEqualStrict = function (t) {\n          return this.throwIfDisposed(), mt.greaterEqualStrict(this, t);\n        }, t.prototype.logicalAnd = function (t) {\n          return this.throwIfDisposed(), mt.logicalAnd(this, t);\n        }, t.prototype.logicalOr = function (t) {\n          return this.throwIfDisposed(), mt.logicalOr(this, t);\n        }, t.prototype.logicalNot = function () {\n          return this.throwIfDisposed(), mt.logicalNot(this);\n        }, t.prototype.logicalXor = function (t) {\n          return this.throwIfDisposed(), mt.logicalXor(this, t);\n        }, t.prototype.where = function (t, e) {\n          return this.throwIfDisposed(), mt.where(t, this, e);\n        }, t.prototype.neg = function () {\n          return this.throwIfDisposed(), mt.neg(this);\n        }, t.prototype.ceil = function () {\n          return this.throwIfDisposed(), mt.ceil(this);\n        }, t.prototype.floor = function () {\n          return this.throwIfDisposed(), mt.floor(this);\n        }, t.prototype.sign = function () {\n          return this.throwIfDisposed(), mt.sign(this);\n        }, t.prototype.isNaN = function () {\n          return this.throwIfDisposed(), mt.isNaN(this);\n        }, t.prototype.isInf = function () {\n          return this.throwIfDisposed(), mt.isInf(this);\n        }, t.prototype.isFinite = function () {\n          return this.throwIfDisposed(), mt.isFinite(this);\n        }, t.prototype.exp = function () {\n          return this.throwIfDisposed(), mt.exp(this);\n        }, t.prototype.expm1 = function () {\n          return this.throwIfDisposed(), mt.expm1(this);\n        }, t.prototype.log = function () {\n          return this.throwIfDisposed(), mt.log(this);\n        }, t.prototype.log1p = function () {\n          return this.throwIfDisposed(), mt.log1p(this);\n        }, t.prototype.sqrt = function () {\n          return this.throwIfDisposed(), mt.sqrt(this);\n        }, t.prototype.rsqrt = function () {\n          return this.throwIfDisposed(), mt.rsqrt(this);\n        }, t.prototype.square = function () {\n          return this.throwIfDisposed(), mt.square(this);\n        }, t.prototype.reciprocal = function () {\n          return this.throwIfDisposed(), mt.reciprocal(this);\n        }, t.prototype.abs = function () {\n          return this.throwIfDisposed(), mt.abs(this);\n        }, t.prototype.clipByValue = function (t, e) {\n          return this.throwIfDisposed(), mt.clipByValue(this, t, e);\n        }, t.prototype.relu = function () {\n          return this.throwIfDisposed(), mt.relu(this);\n        }, t.prototype.relu6 = function () {\n          return this.throwIfDisposed(), mt.relu6(this);\n        }, t.prototype.elu = function () {\n          return this.throwIfDisposed(), mt.elu(this);\n        }, t.prototype.selu = function () {\n          return this.throwIfDisposed(), mt.selu(this);\n        }, t.prototype.leakyRelu = function (t) {\n          return void 0 === t && (t = .2), this.throwIfDisposed(), mt.leakyRelu(this, t);\n        }, t.prototype.prelu = function (t) {\n          return this.throwIfDisposed(), mt.prelu(this, t);\n        }, t.prototype.sigmoid = function () {\n          return this.throwIfDisposed(), mt.sigmoid(this);\n        }, t.prototype.logSigmoid = function () {\n          return this.throwIfDisposed(), mt.logSigmoid(this);\n        }, t.prototype.softplus = function () {\n          return this.throwIfDisposed(), mt.softplus(this);\n        }, t.prototype.zerosLike = function () {\n          return this.throwIfDisposed(), mt.zerosLike(this);\n        }, t.prototype.onesLike = function () {\n          return this.throwIfDisposed(), mt.onesLike(this);\n        }, t.prototype.sin = function () {\n          return this.throwIfDisposed(), mt.sin(this);\n        }, t.prototype.cos = function () {\n          return this.throwIfDisposed(), mt.cos(this);\n        }, t.prototype.tan = function () {\n          return this.throwIfDisposed(), mt.tan(this);\n        }, t.prototype.asin = function () {\n          return this.throwIfDisposed(), mt.asin(this);\n        }, t.prototype.acos = function () {\n          return this.throwIfDisposed(), mt.acos(this);\n        }, t.prototype.atan = function () {\n          return this.throwIfDisposed(), mt.atan(this);\n        }, t.prototype.sinh = function () {\n          return this.throwIfDisposed(), mt.sinh(this);\n        }, t.prototype.cosh = function () {\n          return this.throwIfDisposed(), mt.cosh(this);\n        }, t.prototype.tanh = function () {\n          return this.throwIfDisposed(), mt.tanh(this);\n        }, t.prototype.asinh = function () {\n          return this.throwIfDisposed(), mt.asinh(this);\n        }, t.prototype.acosh = function () {\n          return this.throwIfDisposed(), mt.acosh(this);\n        }, t.prototype.atanh = function () {\n          return this.throwIfDisposed(), mt.atanh(this);\n        }, t.prototype.erf = function () {\n          return this.throwIfDisposed(), mt.erf(this);\n        }, t.prototype.round = function () {\n          return this.throwIfDisposed(), mt.round(this);\n        }, t.prototype.step = function (t) {\n          return void 0 === t && (t = 0), this.throwIfDisposed(), mt.step(this, t);\n        }, t.prototype.softmax = function (t) {\n          return void 0 === t && (t = -1), this.throwIfDisposed(), mt.softmax(this, t);\n        }, t.prototype.logSoftmax = function (t) {\n          return void 0 === t && (t = -1), this.throwIfDisposed(), mt.logSoftmax(this, t);\n        }, t.prototype.resizeBilinear = function (t, e) {\n          return void 0 === e && (e = !1), this.throwIfDisposed(), mt.image.resizeBilinear(this, t, e);\n        }, t.prototype.resizeNearestNeighbor = function (t, e) {\n          return void 0 === e && (e = !1), this.throwIfDisposed(), mt.image.resizeNearestNeighbor(this, t, e);\n        }, t.prototype.conv1d = function (t, e, n, r, o, i) {\n          return void 0 === r && (r = \"NWC\"), void 0 === o && (o = 1), this.throwIfDisposed(), mt.conv1d(this, t, e, n, r, o, i);\n        }, t.prototype.conv2d = function (t, e, n, r, o, i) {\n          return void 0 === r && (r = \"NHWC\"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), mt.conv2d(this, t, e, n, r, o, i);\n        }, t.prototype.conv2dTranspose = function (t, e, n, r, o) {\n          return this.throwIfDisposed(), mt.conv2dTranspose(this, t, e, n, r, o);\n        }, t.prototype.depthwiseConv2D = function (t, e, n, r, o, i) {\n          return void 0 === r && (r = \"NHWC\"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), mt.depthwiseConv2d(this, t, e, n, r, o, i);\n        }, t.prototype.separableConv2d = function (t, e, n, r, o, i) {\n          return void 0 === o && (o = [1, 1]), void 0 === i && (i = \"NHWC\"), this.throwIfDisposed(), mt.separableConv2d(this, t, e, n, r, o, i);\n        }, t.prototype.avgPool = function (t, e, n, r) {\n          return this.throwIfDisposed(), mt.avgPool(this, t, e, n, r);\n        }, t.prototype.maxPool = function (t, e, n, r) {\n          return this.throwIfDisposed(), mt.maxPool(this, t, e, n, r);\n        }, t.prototype.localResponseNormalization = function (t, e, n, r) {\n          return void 0 === t && (t = 5), void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === r && (r = .5), mt.localResponseNormalization(this, t, e, n, r);\n        }, t.prototype.pool = function (t, e, n, r, o) {\n          return this.throwIfDisposed(), mt.pool(this, t, e, n, r, o);\n        }, t.prototype.variable = function (t, e, n) {\n          return void 0 === t && (t = !0), this.throwIfDisposed(), dt().makeVariable(this, t, e, n);\n        }, t.prototype.unsortedSegmentSum = function (t, e) {\n          return this.throwIfDisposed(), mt.unsortedSegmentSum(this, t, e);\n        }, t.prototype.batchToSpaceND = function (t, e) {\n          return this.throwIfDisposed(), mt.batchToSpaceND(this, t, e);\n        }, t.prototype.spaceToBatchND = function (t, e) {\n          return this.throwIfDisposed(), mt.spaceToBatchND(this, t, e);\n        }, t.prototype.topk = function (t, e) {\n          return void 0 === t && (t = 1), void 0 === e && (e = !0), this.throwIfDisposed(), mt.topk(this, t, e);\n        }, t.prototype.stridedSlice = function (t, e, n, r, o, i, a, s) {\n          return void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === i && (i = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), this.throwIfDisposed(), mt.stridedSlice(this, t, e, n, r, o, i, a, s);\n        }, t.prototype.depthToSpace = function (t, e) {\n          return this.throwIfDisposed(), mt.depthToSpace(this, t, e);\n        }, t.prototype.fft = function () {\n          return this.throwIfDisposed(), mt.spectral.fft(this);\n        }, t.prototype.ifft = function () {\n          return this.throwIfDisposed(), mt.spectral.ifft(this);\n        }, t.prototype.rfft = function () {\n          return this.throwIfDisposed(), mt.spectral.rfft(this);\n        }, t.prototype.irfft = function () {\n          return this.throwIfDisposed(), mt.spectral.irfft(this);\n        }, t;\n      }();\n\n      Object.defineProperty(vt, Symbol.hasInstance, {\n        value: function (t) {\n          return !!t && null != t.dataId && null != t.shape && null != t.dtype;\n        }\n      });\n\n      var yt,\n          bt,\n          wt,\n          xt,\n          St,\n          Et = function (t) {\n        function e(e, n, r, o) {\n          var i = t.call(this, e.shape, e.dtype, e.dataId, o) || this;\n          return i.trainable = n, i.name = r, i;\n        }\n\n        return s(e, t), e.prototype.assign = function (t) {\n          if (t.dtype !== this.dtype) throw new Error(\"dtype of the new value (\" + t.dtype + \") and previous value (\" + this.dtype + \") must match\");\n          if (!k(t.shape, this.shape)) throw new Error(\"shape of the new value (\" + t.shape + \") and previous value (\" + this.shape + \") must match\");\n          dt().disposeTensor(this), this.dataId = t.dataId, dt().incRef(this, null);\n        }, e.prototype.dispose = function () {\n          dt().disposeVariable(this), this.isDisposedInternal = !0;\n        }, e;\n      }(vt);\n\n      Object.defineProperty(Et, Symbol.hasInstance, {\n        value: function (t) {\n          return t instanceof vt && null != t.assign && t.assign instanceof Function;\n        }\n      }), function (t) {\n        t.R0 = \"R0\", t.R1 = \"R1\", t.R2 = \"R2\", t.R3 = \"R3\", t.R4 = \"R4\", t.R5 = \"R5\", t.R6 = \"R6\";\n      }(yt || (yt = {})), function (t) {\n        t.float32 = \"float32\", t.int32 = \"int32\", t.bool = \"int32\", t.complex64 = \"complex64\";\n      }(bt || (bt = {})), function (t) {\n        t.float32 = \"float32\", t.int32 = \"int32\", t.bool = \"bool\", t.complex64 = \"complex64\";\n      }(wt || (wt = {})), function (t) {\n        t.float32 = \"float32\", t.int32 = \"float32\", t.bool = \"float32\", t.complex64 = \"complex64\";\n      }(xt || (xt = {})), function (t) {\n        t.float32 = \"complex64\", t.int32 = \"complex64\", t.bool = \"complex64\", t.complex64 = \"complex64\";\n      }(St || (St = {}));\n      var Ct = {\n        float32: xt,\n        int32: bt,\n        bool: wt,\n        complex64: St\n      };\n\n      function It(t, e) {\n        if (\"string\" === t || \"string\" === e) {\n          if (\"string\" === t && \"string\" === e) return \"string\";\n          throw new Error(\"Can not upcast \" + t + \" with \" + e);\n        }\n\n        return Ct[t][e];\n      }\n\n      function At(t) {\n        return It(t, \"int32\");\n      }\n\n      function kt(t, e) {\n        if (t.dtype === e.dtype) return [t, e];\n        var n = It(t.dtype, e.dtype);\n        return [t.cast(n), e.cast(n)];\n      }\n\n      function Tt(t, e) {\n        S(t.dtype === e.dtype, function () {\n          return \"The dtypes of the first(\" + t.dtype + \") and second(\" + e.dtype + \") input must match\";\n        });\n      }\n\n      function Nt(t) {\n        var e = [];\n        return function t(e, n, r) {\n          if (null != e) if (e instanceof vt) n.push(e);else if (o = e, Array.isArray(o) || \"object\" == typeof o) {\n            var o,\n                i = e;\n\n            for (var a in i) {\n              var s = i[a];\n              r.has(s) || (r.add(s), t(s, n, r));\n            }\n          }\n        }(t, e, new Set()), e;\n      }\n\n      Object.freeze({\n        makeTypesMatch: kt,\n        assertTypesMatch: Tt,\n        isTensorInList: function (t, e) {\n          for (var n = 0; n < e.length; n++) if (e[n].id === t.id) return !0;\n\n          return !1;\n        },\n        getTensorsInContainer: Nt\n      });\n\n      var Pt,\n          Rt = function () {\n        function t() {\n          this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.gradientDepth = 0, this.kernelDepth = 0, this.scopeStack = [], this.numDataMovesStack = [], this.nextScopeId = 0, this.tensorInfo = new WeakMap(), this.profiling = !1, this.activeProfile = {\n            newBytes: 0,\n            newTensors: 0,\n            peakBytes: 0,\n            kernels: [],\n            result: null\n          };\n        }\n\n        return t.prototype.dispose = function () {\n          for (var t in this.registeredVariables) this.registeredVariables[t].dispose();\n        }, t;\n      }(),\n          _t = function () {\n        function t(t) {\n          this.ENV = t, this.registry = {}, this.registryFactory = {}, this.pendingBackendInitId = 0, this.state = new Rt();\n        }\n\n        return t.prototype.ready = function () {\n          return u(this, void 0, void 0, function () {\n            var t, e, n;\n            return c(this, function (r) {\n              switch (r.label) {\n                case 0:\n                  if (null != this.pendingBackendInit) return [2, this.pendingBackendInit.then(function () {})];\n                  if (null != this.backendInstance) return [2];\n                  t = this.getSortedBackends(), e = 0, r.label = 1;\n\n                case 1:\n                  return e < t.length ? (n = t[e], [4, this.initializeBackend(n).success]) : [3, 5];\n\n                case 2:\n                  return r.sent() ? [4, this.setBackend(n)] : [3, 4];\n\n                case 3:\n                  return r.sent(), [2];\n\n                case 4:\n                  return e++, [3, 1];\n\n                case 5:\n                  throw new Error(\"Could not initialize any backends, all backend initializations failed.\");\n              }\n            });\n          });\n        }, Object.defineProperty(t.prototype, \"backend\", {\n          get: function () {\n            if (null != this.pendingBackendInit) throw new Error(\"Backend '\" + this.backendName + \"' has not yet been initialized. Make sure to await tf.ready() before calling other methods\");\n\n            if (null == this.backendInstance) {\n              var t = this.initializeBackendsAndReturnBest(),\n                  e = t.name;\n              if (t.asyncInit) throw new Error(\"The highest priority backend '\" + e + \"' has not yet been initialized. Make sure to await tf.ready() before calling other methods\");\n              this.setBackend(e);\n            }\n\n            return this.backendInstance;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.backendNames = function () {\n          return Object.keys(this.registryFactory);\n        }, t.prototype.findBackend = function (t) {\n          if (!(t in this.registry)) {\n            if (!(t in this.registryFactory)) return null;\n            if (this.initializeBackend(t).asyncInit) return null;\n          }\n\n          return this.registry[t];\n        }, t.prototype.findBackendFactory = function (t) {\n          return t in this.registryFactory ? this.registryFactory[t].factory : null;\n        }, t.prototype.registerBackend = function (t, e, n) {\n          return void 0 === n && (n = 1), t in this.registryFactory ? (console.warn(t + \" backend was already registered. Reusing existing backend factory.\"), !1) : (this.registryFactory[t] = {\n            factory: e,\n            priority: n\n          }, !0);\n        }, t.prototype.setBackend = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n, r;\n            return c(this, function (o) {\n              switch (o.label) {\n                case 0:\n                  if (null == this.registryFactory[t]) throw new Error(\"Backend name '\" + t + \"' not found in registry\");\n                  return this.backendName = t, null != this.registry[t] ? [3, 4] : (this.backendInstance = null, e = this.initializeBackend(t), n = e.success, e.asyncInit ? [4, n] : [3, 2]);\n\n                case 1:\n                  return r = o.sent(), [3, 3];\n\n                case 2:\n                  r = n, o.label = 3;\n\n                case 3:\n                  if (!r) return [2, !1];\n                  o.label = 4;\n\n                case 4:\n                  return this.backendInstance = this.registry[t], this.setupRegisteredKernels(), this.profiler = new it(this.backendInstance), [2, !0];\n              }\n            });\n          });\n        }, t.prototype.setupRegisteredKernels = function () {\n          var t = this;\n          m(this.backendName).forEach(function (e) {\n            null != e.setupFunc && e.setupFunc(t.backendInstance);\n          });\n        }, t.prototype.disposeRegisteredKernels = function (t) {\n          var e = this;\n          m(t).forEach(function (n) {\n            null != n.disposeFunc && n.disposeFunc(e.registry[t]);\n          });\n        }, t.prototype.initializeBackend = function (t) {\n          var e = this,\n              n = this.registryFactory[t];\n          if (null == n) throw new Error(\"Cannot initialize backend \" + t + \", no registration found.\");\n\n          try {\n            var r = n.factory();\n\n            if (Promise.resolve(r) === r) {\n              var o = ++this.pendingBackendInitId,\n                  i = r.then(function (n) {\n                return !(o < e.pendingBackendInitId || (e.registry[t] = n, e.pendingBackendInit = null, 0));\n              }).catch(function (n) {\n                return !(o < e.pendingBackendInitId || (e.pendingBackendInit = null, console.warn(\"Initialization of backend \" + t + \" failed\"), console.warn(n.stack || n.message), 1));\n              });\n              return this.pendingBackendInit = i, {\n                success: i,\n                asyncInit: !0\n              };\n            }\n\n            return this.registry[t] = r, {\n              success: !0,\n              asyncInit: !1\n            };\n          } catch (e) {\n            return console.warn(\"Initialization of backend \" + t + \" failed\"), console.warn(e.stack || e.message), {\n              success: !1,\n              asyncInit: !1\n            };\n          }\n        }, t.prototype.removeBackend = function (t) {\n          if (!(t in this.registryFactory)) throw new Error(t + \" backend not found in registry\");\n          this.backendName === t && null != this.pendingBackendInit && this.pendingBackendInitId++, t in this.registry && (this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t]), delete this.registryFactory[t], this.backendName === t && (this.pendingBackendInit = null, this.backendName = null, this.backendInstance = null);\n        }, t.prototype.getSortedBackends = function () {\n          var t = this;\n          if (0 === Object.keys(this.registryFactory).length) throw new Error(\"No backend found in registry.\");\n          return Object.keys(this.registryFactory).sort(function (e, n) {\n            return t.registryFactory[n].priority - t.registryFactory[e].priority;\n          });\n        }, t.prototype.initializeBackendsAndReturnBest = function () {\n          for (var t = this.getSortedBackends(), e = 0; e < t.length; e++) {\n            var n = t[e],\n                r = this.initializeBackend(n),\n                o = r.success,\n                i = r.asyncInit;\n            if (i || o) return {\n              name: n,\n              asyncInit: i\n            };\n          }\n\n          throw new Error(\"Could not initialize any backends, all backend initializations failed.\");\n        }, t.prototype.moveData = function (t, e) {\n          var n = this.state.tensorInfo.get(e),\n              r = n.backend,\n              o = this.readSync(e);\n          r.disposeData(e), n.backend = t, t.move(e, o, n.shape, n.dtype), this.shouldCheckForMemLeaks() && this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;\n        }, t.prototype.tidy = function (t, e) {\n          var n,\n              r = this,\n              o = null;\n\n          if (null == e) {\n            if (\"function\" != typeof t) throw new Error(\"Please provide a function to tidy()\");\n            e = t;\n          } else {\n            if (\"string\" != typeof t && !(t instanceof String)) throw new Error(\"When calling with two arguments, the first argument to tidy() must be a string\");\n            if (\"function\" != typeof e) throw new Error(\"When calling with two arguments, the 2nd argument to tidy() must be a function\");\n            o = t;\n          }\n\n          return this.scopedRun(function () {\n            return r.startScope(o);\n          }, function () {\n            return r.endScope(n);\n          }, function () {\n            return (n = e()) instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), n;\n          });\n        }, t.prototype.scopedRun = function (t, e, n) {\n          t();\n\n          try {\n            var r = n();\n            return e(), r;\n          } catch (t) {\n            throw e(), t;\n          }\n        }, t.prototype.nextTensorId = function () {\n          return t.nextTensorId++;\n        }, t.prototype.nextVariableId = function () {\n          return t.nextVariableId++;\n        }, t.prototype.clone = function (t) {\n          var e = this.makeTensorFromDataId(t.dataId, t.shape, t.dtype),\n              n = {\n            x: t\n          };\n          return this.addTapeNode(this.state.activeScope.name, n, [e], function (t) {\n            return {\n              x: function () {\n                return t.toFloat();\n              }\n            };\n          }, []), e;\n        }, t.prototype.runKernel = function (t, e, n, r, o) {\n          return this.runKernelFunc(null, e, null, t, n, r, o);\n        }, t.prototype.shouldCheckForMemLeaks = function () {\n          return this.ENV.getBool(\"IS_TEST\");\n        }, t.prototype.checkKernelForMemLeak = function (t, e, n) {\n          var r = this.backend.numDataIds(),\n              o = 0;\n          n.forEach(function (t) {\n            o += \"complex64\" === t.dtype ? 3 : 1;\n          });\n          var i = this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1],\n              a = r - e - o - i;\n          if (a > 0) throw new Error(\"Backend '\" + this.backendName + \"' has an internal memory leak (\" + a + \" data ids) after running '\" + t + \"'\");\n        }, t.prototype.runKernelFunc = function (t, e, n, r, o, i, a) {\n          var s,\n              u = this;\n          void 0 === i && (i = []), void 0 === a && (a = []);\n\n          var c,\n              l = [],\n              h = this.isTapeOn(),\n              p = null != this.state.activeScope ? this.state.activeScope.name : \"\",\n              f = function (t) {\n            h && (l = t.map(function (t) {\n              return u.keep(u.clone(t));\n            }));\n          },\n              m = this.state.numBytes,\n              g = this.state.numTensors;\n\n          this.shouldCheckForMemLeaks() && this.state.numDataMovesStack.push(0);\n          var v,\n              y = d(r, this.backendName);\n          return c = null != y ? function () {\n            var t = u.backend.numDataIds();\n            v = y.kernelFunc({\n              inputs: e,\n              attrs: o,\n              backend: u.backend\n            });\n            var n = Array.isArray(v) ? v : [v];\n            u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(p, t, n);\n            var r = n.map(function (t) {\n              var e = t.dataId,\n                  n = t.shape,\n                  r = t.dtype;\n              return u.makeTensorFromDataId(e, n, r);\n            }),\n                s = r.filter(function (t, e) {\n              return a[e];\n            });\n            return f(i.slice().concat(s)), r;\n          } : function () {\n            var e = u.backend.numDataIds();\n            v = u.tidy(function () {\n              return t(u.backend, f);\n            });\n            var n = Array.isArray(v) ? v : [v];\n            return u.shouldCheckForMemLeaks() && u.checkKernelForMemLeak(p, e, n), n;\n          }, this.scopedRun(function () {\n            return u.state.kernelDepth++;\n          }, function () {\n            return u.state.kernelDepth--;\n          }, function () {\n            s = u.ENV.getBool(\"DEBUG\") ? u.profiler.profileKernel(p, e, function () {\n              return c();\n            }) : c();\n          }), h && this.addTapeNode(p, e, s, n, l), this.state.profiling && this.state.activeProfile.kernels.push({\n            name: p,\n            bytesAdded: this.state.numBytes - m,\n            totalBytesSnapshot: this.state.numBytes,\n            tensorsAdded: this.state.numTensors - g,\n            totalTensorsSnapshot: this.state.numTensors,\n            inputShapes: Object.keys(e).map(function (t) {\n              return e[t].shape;\n            }),\n            outputShapes: s.map(function (t) {\n              return t.shape;\n            })\n          }), Array.isArray(v) ? s : s[0];\n        }, t.prototype.makeTensor = function (t, e, n, r) {\n          if (null == t) throw new Error(\"Values passed to engine.makeTensor() are null\");\n          n = n || \"float32\", r = r || this.backend;\n          var o = t;\n          \"string\" === n && W(t[0]) && (o = t.map(function (t) {\n            return rt(t);\n          }));\n          var i = r.write(o, e, n),\n              a = new vt(e, n, i, this.nextTensorId());\n\n          if (this.incRef(a, r), \"string\" === n) {\n            var s = this.state.tensorInfo.get(i),\n                u = j(o);\n            this.state.numBytes += u - s.bytes, s.bytes = u;\n          }\n\n          return a;\n        }, t.prototype.makeTensorFromDataId = function (t, e, n, r) {\n          var o = new vt(e, n = n || \"float32\", t, this.nextTensorId());\n          return this.incRef(o, r), o;\n        }, t.prototype.makeVariable = function (t, e, n, r) {\n          void 0 === e && (e = !0), n = n || this.nextVariableId().toString(), null != r && r !== t.dtype && (t = t.asType(r));\n          var o = new Et(t, e, n, this.nextTensorId());\n          if (null != this.state.registeredVariables[o.name]) throw new Error(\"Variable with name \" + o.name + \" was already registered\");\n          return this.state.registeredVariables[o.name] = o, this.incRef(o, this.backend), o;\n        }, t.prototype.incRef = function (t, e) {\n          var n = this.state.tensorInfo.has(t.dataId) ? this.state.tensorInfo.get(t.dataId).refCount : 0;\n\n          if (this.state.numTensors++, \"string\" === t.dtype && this.state.numStringTensors++, 0 === n) {\n            this.state.numDataBuffers++;\n            var r = 0;\n            \"complex64\" !== t.dtype && \"string\" !== t.dtype && (r = t.size * U(t.dtype)), this.state.tensorInfo.set(t.dataId, {\n              backend: e || this.backend,\n              dtype: t.dtype,\n              shape: t.shape,\n              bytes: r,\n              refCount: 0\n            }), this.state.numBytes += r;\n          }\n\n          this.state.tensorInfo.get(t.dataId).refCount++, t instanceof Et || this.track(t);\n        }, t.prototype.disposeTensor = function (t) {\n          if (this.state.tensorInfo.has(t.dataId)) {\n            this.state.numTensors--, \"string\" === t.dtype && this.state.numStringTensors--;\n            var e = this.state.tensorInfo.get(t.dataId);\n            e.refCount <= 1 ? (\"complex64\" !== t.dtype && (this.state.numBytes -= e.bytes), this.state.numDataBuffers--, e.backend.disposeData(t.dataId), this.state.tensorInfo.delete(t.dataId)) : this.state.tensorInfo.get(t.dataId).refCount--;\n          }\n        }, t.prototype.disposeVariables = function () {\n          for (var t in this.state.registeredVariables) {\n            var e = this.state.registeredVariables[t];\n            this.disposeVariable(e);\n          }\n        }, t.prototype.disposeVariable = function (t) {\n          this.disposeTensor(t), null != this.state.registeredVariables[t.name] && delete this.state.registeredVariables[t.name];\n        }, t.prototype.memory = function () {\n          var t = this.backend.memory();\n          return t.numTensors = this.state.numTensors, t.numDataBuffers = this.state.numDataBuffers, t.numBytes = this.state.numBytes, this.state.numStringTensors > 0 && (t.unreliable = !0, null == t.reasons && (t.reasons = []), t.reasons.push(\"Memory usage by string tensors is approximate (2 bytes per character)\")), t;\n        }, t.prototype.profile = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n;\n            return c(this, function (r) {\n              return this.state.profiling = !0, e = this.state.numBytes, n = this.state.numTensors, this.state.activeProfile.kernels = [], this.state.activeProfile.result = t(), this.state.profiling = !1, this.state.activeProfile.peakBytes = Math.max.apply(Math, this.state.activeProfile.kernels.map(function (t) {\n                return t.totalBytesSnapshot;\n              })), this.state.activeProfile.newBytes = this.state.numBytes - e, this.state.activeProfile.newTensors = this.state.numTensors - n, [2, this.state.activeProfile];\n            });\n          });\n        }, t.prototype.isTapeOn = function () {\n          return this.state.gradientDepth > 0 && 0 === this.state.kernelDepth;\n        }, t.prototype.addTapeNode = function (t, e, n, r, o) {\n          var i = this,\n              a = {\n            id: this.state.nextTapeNodeId++,\n            name: t,\n            inputs: e,\n            outputs: n,\n            saved: o\n          };\n          null != r && (a.gradient = function (t) {\n            return t = t.map(function (t, e) {\n              if (null == t) {\n                var r = n[e],\n                    o = tt(r.size, r.dtype);\n                return i.makeTensor(o, r.shape, r.dtype);\n              }\n\n              return t;\n            }), r(t.length > 1 ? t : t[0], o);\n          }), this.state.activeTape.push(a);\n        }, t.prototype.keep = function (t) {\n          return t.kept = !0, t;\n        }, t.prototype.startTape = function () {\n          0 === this.state.gradientDepth && (this.state.activeTape = []), this.state.gradientDepth++;\n        }, t.prototype.endTape = function () {\n          this.state.gradientDepth--;\n        }, t.prototype.startScope = function (t) {\n          var e = {\n            track: [],\n            name: \"unnamed scope\",\n            id: this.state.nextScopeId++\n          };\n          t && (e.name = t), this.state.scopeStack.push(e), this.state.activeScope = e;\n        }, t.prototype.endScope = function (t) {\n          for (var e = this, n = Nt(t), r = new Set(n.map(function (t) {\n            return t.id;\n          })), o = 0; o < this.state.activeScope.track.length; o++) {\n            var i = this.state.activeScope.track[o];\n            i.kept || r.has(i.id) || i.dispose();\n          }\n\n          var a = this.state.scopeStack.pop();\n          this.state.activeScope = 0 === this.state.scopeStack.length ? null : this.state.scopeStack[this.state.scopeStack.length - 1], n.forEach(function (t) {\n            t.kept || t.scopeId !== a.id || e.track(t);\n          });\n        }, t.prototype.gradients = function (t, e, n, r) {\n          var o = this;\n          if (void 0 === r && (r = !1), S(e.length > 0, function () {\n            return \"gradients() received an empty list of xs.\";\n          }), null != n && \"float32\" !== n.dtype) throw new Error(\"dy must have 'float32' dtype, but has '\" + n.dtype + \"'\");\n          var i = this.scopedRun(function () {\n            return o.startTape();\n          }, function () {\n            return o.endTape();\n          }, function () {\n            return o.tidy(\"forward\", t);\n          });\n          S(i instanceof vt, function () {\n            return \"The result y returned by f() must be a tensor.\";\n          });\n\n          var a = function (t, e, n) {\n            for (var r = {}, o = {}, i = 0; i < e.length; i++) r[e[i].id] = !0;\n\n            for (i = 0; i < t.length; i++) {\n              var a = (d = t[i]).inputs;\n\n              for (var s in a) {\n                for (var u = a[s], c = !1, l = 0; l < e.length; l++) if (r[u.id]) {\n                  d.outputs.forEach(function (t) {\n                    return r[t.id] = !0;\n                  }), c = !0, o[d.id] = !0;\n                  break;\n                }\n\n                if (c) break;\n              }\n            }\n\n            var h = {};\n            h[n.id] = !0;\n            var p = {};\n\n            for (i = t.length - 1; i >= 0; i--) for (a = (d = t[i]).inputs, l = 0; l < d.outputs.length; l++) if (h[d.outputs[l].id]) {\n              for (var s in a) h[a[s].id] = !0, p[d.id] = !0;\n\n              break;\n            }\n\n            var f = [];\n\n            for (i = 0; i < t.length; i++) {\n              var d;\n\n              if (o[(d = t[i]).id] && p[d.id]) {\n                var m = {};\n\n                for (var s in d.inputs) {\n                  var g = d.inputs[s];\n                  r[g.id] && (m[s] = g);\n                }\n\n                var v = Object.assign({}, d);\n                v.inputs = m, v.outputs = d.outputs, f.push(v);\n              }\n            }\n\n            return f;\n          }(this.state.activeTape, e, i);\n\n          if (!r && 0 === a.length && e.length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.\");\n          return this.tidy(\"backward\", function () {\n            var t,\n                r,\n                s = {};\n            s[i.id] = null == n ? (r = Z(A(t = i.shape), \"float32\"), Mt.makeTensor(r, t, \"float32\")) : n, function (t, e, n) {\n              for (var r = function (r) {\n                var o = e[r],\n                    i = [];\n                if (o.outputs.forEach(function (e) {\n                  var n = t[e.id];\n                  null != n ? i.push(n) : i.push(null);\n                }), null == o.gradient) throw new Error(\"Cannot compute gradient: gradient function not found for \" + o.name + \".\");\n\n                var a = o.gradient(i),\n                    s = function (e) {\n                  if (!(e in a)) throw new Error(\"Cannot backprop through input \" + e + \". Available gradients found: \" + Object.keys(a) + \".\");\n                  var r = n(function () {\n                    return a[e]();\n                  });\n                  if (\"float32\" !== r.dtype) throw new Error(\"Error in gradient for op \" + o.name + \". The gradient of input \" + e + \" must have 'float32' dtype, but has '\" + r.dtype + \"'\");\n                  var i = o.inputs[e];\n                  if (!k(r.shape, i.shape)) throw new Error(\"Error in gradient for op \" + o.name + \". The gradient of input '\" + e + \"' has shape '\" + r.shape + \"', which does not match the shape of the input '\" + i.shape + \"'\");\n                  if (null == t[i.id]) t[i.id] = r;else {\n                    var s = t[i.id];\n                    t[i.id] = s.add(r), s.dispose();\n                  }\n                };\n\n                for (var u in o.inputs) s(u);\n              }, o = e.length - 1; o >= 0; o--) r(o);\n            }(s, a, function (t) {\n              return o.tidy(t);\n            });\n            var u = e.map(function (t) {\n              return s[t.id];\n            });\n            return 0 === o.state.gradientDepth && (o.state.activeTape.forEach(function (t) {\n              for (var e in t.saved) t.saved[e].dispose();\n            }), o.state.activeTape = null), {\n              value: i,\n              grads: u\n            };\n          });\n        }, t.prototype.customGrad = function (t) {\n          var e = this;\n          return S(K(t), function () {\n            return \"The f passed in customGrad(f) must be a function.\";\n          }), function () {\n            for (var n, r = [], o = 0; o < arguments.length; o++) r[o] = arguments[o];\n\n            S(r.every(function (t) {\n              return t instanceof vt;\n            }), function () {\n              return \"The args passed in customGrad(f)(x1, x2,...) must all be tensors\";\n            });\n            var i = {};\n            return r.forEach(function (t, e) {\n              i[e] = t;\n            }), e.runKernelFunc(function (e, o) {\n              return S((n = t.apply(void 0, r.concat([o]))).value instanceof vt, function () {\n                return \"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor\";\n              }), S(K(n.gradFunc), function () {\n                return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.\";\n              }), n.value;\n            }, i, function (t, e) {\n              var o = n.gradFunc(t, e),\n                  i = Array.isArray(o) ? o : [o];\n              S(i.length === r.length, function () {\n                return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).\";\n              }), S(i.every(function (t) {\n                return t instanceof vt;\n              }), function () {\n                return \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.\";\n              });\n              var a = {};\n              return i.forEach(function (t, e) {\n                a[e] = function () {\n                  return t;\n                };\n              }), a;\n            });\n          };\n        }, t.prototype.readSync = function (t) {\n          return this.state.tensorInfo.get(t).backend.readSync(t);\n        }, t.prototype.read = function (t) {\n          return this.state.tensorInfo.get(t).backend.read(t);\n        }, t.prototype.fromPixels = function (t, e) {\n          return this.backend.fromPixels(t, e);\n        }, t.prototype.time = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n;\n            return c(this, function (r) {\n              switch (r.label) {\n                case 0:\n                  return e = et(), [4, this.backend.time(t)];\n\n                case 1:\n                  return (n = r.sent()).wallMs = et() - e, [2, n];\n              }\n            });\n          });\n        }, t.prototype.track = function (t) {\n          return null != this.state.activeScope && (t.scopeId = this.state.activeScope.id, this.state.activeScope.track.push(t)), t;\n        }, Object.defineProperty(t.prototype, \"registeredVariables\", {\n          get: function () {\n            return this.state.registeredVariables;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.reset = function () {\n          for (var t in this.pendingBackendInitId++, this.state.dispose(), this.ENV.reset(), this.state = new Rt(), this.registry) this.disposeRegisteredKernels(t), this.registry[t].dispose(), delete this.registry[t];\n\n          this.backendName = null, this.backendInstance = null, this.pendingBackendInit = null;\n        }, t.nextTensorId = 0, t.nextVariableId = 0, t;\n      }(),\n          Mt = function () {\n        var e = function () {\n          if (null == Pt) {\n            var e = void 0;\n            if (\"undefined\" != typeof window) e = window;else if (void 0 !== t) e = t;else if (void 0 !== r) e = r;else {\n              if (\"undefined\" == typeof self) throw new Error(\"Could not find a global object\");\n              e = self;\n            }\n            Pt = e;\n          }\n\n          return Pt;\n        }();\n\n        if (null == e._tfengine) {\n          var n = new l(e);\n          e._tfengine = new _t(n);\n        }\n\n        return function (t) {\n          p = t;\n        }(e._tfengine.ENV), dt = function () {\n          return e._tfengine;\n        }, e._tfengine;\n      }();\n\n      function Ot() {\n        return \"undefined\" != typeof window && null != window.document || \"undefined\" != typeof WorkerGlobalScope;\n      }\n\n      var Dt = h();\n      Dt.registerFlag(\"DEBUG\", function () {\n        return !1;\n      }, function (t) {\n        t && console.warn(\"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.\");\n      }), Dt.registerFlag(\"IS_BROWSER\", function () {\n        return Ot();\n      }), Dt.registerFlag(\"IS_NODE\", function () {\n        return void 0 !== r && void 0 !== r.versions && void 0 !== r.versions.node;\n      }), Dt.registerFlag(\"IS_CHROME\", function () {\n        return \"undefined\" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n      }), Dt.registerFlag(\"PROD\", function () {\n        return !1;\n      }), Dt.registerFlag(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\", function () {\n        return Dt.getBool(\"DEBUG\");\n      }), Dt.registerFlag(\"DEPRECATION_WARNINGS_ENABLED\", function () {\n        return !0;\n      }), Dt.registerFlag(\"IS_TEST\", function () {\n        return !1;\n      });\n      var Ft,\n          Lt,\n          Bt,\n          zt = {},\n          qt = {\n        alpha: !1,\n        antialias: !1,\n        premultipliedAlpha: !1,\n        preserveDrawingBuffer: !1,\n        depth: !1,\n        stencil: !1,\n        failIfMajorPerformanceCaveat: !0\n      };\n\n      function Vt(t, e) {\n        zt[t] = e;\n      }\n\n      function Ut(t) {\n        t in zt || (zt[t] = function (t) {\n          if (1 !== t && 2 !== t) throw new Error(\"Cannot get WebGL rendering context, WebGL is disabled.\");\n          var e = jt(t);\n          return e.addEventListener(\"webglcontextlost\", function (e) {\n            e.preventDefault(), delete zt[t];\n          }, !1), 1 === t ? e.getContext(\"webgl\", qt) || e.getContext(\"experimental-webgl\", qt) : e.getContext(\"webgl2\", qt);\n        }(t));\n        var e = zt[t];\n        return e.isContextLost() ? (delete zt[t], Ut(t)) : (e.disable(e.DEPTH_TEST), e.disable(e.STENCIL_TEST), e.disable(e.BLEND), e.disable(e.DITHER), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SAMPLE_COVERAGE), e.enable(e.SCISSOR_TEST), e.enable(e.CULL_FACE), e.cullFace(e.BACK), zt[t]);\n      }\n\n      function jt(t) {\n        if (\"undefined\" != typeof OffscreenCanvas && 2 === t) return new OffscreenCanvas(300, 150);\n        if (\"undefined\" != typeof document) return document.createElement(\"canvas\");\n        throw new Error(\"Cannot create a canvas in this context\");\n      }\n\n      function Wt(t, e) {\n        return [e, t];\n      }\n\n      function Gt(t) {\n        var e = A(t);\n        return P(Math.ceil(e / 4));\n      }\n\n      function Ht(t, e) {\n        return [Math.max(1, Math.ceil(e / 2)), Math.max(1, Math.ceil(t / 2))];\n      }\n\n      function $t(t, e) {\n        var n,\n            r,\n            o,\n            i,\n            a,\n            s,\n            u,\n            c,\n            l,\n            p = t;\n        return 2 === h().getNumber(\"WEBGL_VERSION\") ? (n = p.R32F, r = p.R16F, o = p.RGBA16F, i = p.RGBA32F, a = p.RED, s = 4, u = 1, c = p.HALF_FLOAT, l = p.FLOAT) : (n = t.RGBA, r = t.RGBA, o = t.RGBA, i = p.RGBA, a = t.RGBA, s = 4, u = 4, c = null != e ? e.HALF_FLOAT_OES : null, l = t.FLOAT), {\n          internalFormatFloat: n,\n          internalFormatHalfFloat: r,\n          internalFormatPackedHalfFloat: o,\n          internalFormatPackedFloat: i,\n          textureFormatFloat: a,\n          downloadTextureFormat: t.RGBA,\n          downloadUnpackNumChannels: s,\n          defaultNumChannels: u,\n          textureTypeHalfFloat: c,\n          textureTypeFloat: l\n        };\n      }\n\n      function Kt(t, e, n) {\n        var r = n();\n        return e && function (t) {\n          var e = t.getError();\n          if (e !== t.NO_ERROR) throw new Error(\"WebGL Error: \" + Jt(t, e));\n        }(t), r;\n      }\n\n      !function (t) {\n        t[t.DENSE = 0] = \"DENSE\", t[t.SHARED_BATCH = 1] = \"SHARED_BATCH\";\n      }(Ft || (Ft = {})), function (t) {\n        t[t.RENDER = 0] = \"RENDER\", t[t.UPLOAD = 1] = \"UPLOAD\", t[t.PIXELS = 2] = \"PIXELS\", t[t.DOWNLOAD = 3] = \"DOWNLOAD\";\n      }(Lt || (Lt = {})), function (t) {\n        t[t.UNPACKED_FLOAT16 = 0] = \"UNPACKED_FLOAT16\", t[t.UNPACKED_FLOAT32 = 1] = \"UNPACKED_FLOAT32\", t[t.PACKED_4X1_UNSIGNED_BYTE = 2] = \"PACKED_4X1_UNSIGNED_BYTE\", t[t.PACKED_2X2_FLOAT32 = 3] = \"PACKED_2X2_FLOAT32\", t[t.PACKED_2X2_FLOAT16 = 4] = \"PACKED_2X2_FLOAT16\";\n      }(Bt || (Bt = {}));\n      var Qt = 5.96e-8,\n          Xt = 65504;\n\n      function Yt(t) {\n        return !!(h().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") || 0 === t || Qt < Math.abs(t) && Math.abs(t) < Xt);\n      }\n\n      function Jt(t, e) {\n        switch (e) {\n          case t.NO_ERROR:\n            return \"NO_ERROR\";\n\n          case t.INVALID_ENUM:\n            return \"INVALID_ENUM\";\n\n          case t.INVALID_VALUE:\n            return \"INVALID_VALUE\";\n\n          case t.INVALID_OPERATION:\n            return \"INVALID_OPERATION\";\n\n          case t.INVALID_FRAMEBUFFER_OPERATION:\n            return \"INVALID_FRAMEBUFFER_OPERATION\";\n\n          case t.OUT_OF_MEMORY:\n            return \"OUT_OF_MEMORY\";\n\n          case t.CONTEXT_LOST_WEBGL:\n            return \"CONTEXT_LOST_WEBGL\";\n\n          default:\n            return \"Unknown error code \" + e;\n        }\n      }\n\n      function Zt(t, e, n) {\n        return Se(t, e, function () {\n          return t.getExtension(n);\n        }, 'Extension \"' + n + '\" not supported on this browser.');\n      }\n\n      function te(t, e, n) {\n        var r = Se(t, e, function () {\n          return t.createShader(t.VERTEX_SHADER);\n        }, \"Unable to create vertex WebGLShader.\");\n        if (Kt(t, e, function () {\n          return t.shaderSource(r, n);\n        }), Kt(t, e, function () {\n          return t.compileShader(r);\n        }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw console.log(t.getShaderInfoLog(r)), new Error(\"Failed to compile vertex shader.\");\n        return r;\n      }\n\n      function ee(t, e, n) {\n        var r = Se(t, e, function () {\n          return t.createShader(t.FRAGMENT_SHADER);\n        }, \"Unable to create fragment WebGLShader.\");\n        if (Kt(t, e, function () {\n          return t.shaderSource(r, n);\n        }), Kt(t, e, function () {\n          return t.compileShader(r);\n        }), !1 === t.getShaderParameter(r, t.COMPILE_STATUS)) throw function (t, e) {\n          var n = oe.exec(e);\n          if (null == n) return console.log(\"Couldn't parse line number in error: \" + e), void console.log(t);\n\n          for (var r = +n[1], o = t.split(\"\\n\"), i = o.length.toString().length + 2, a = o.map(function (t, e) {\n            return R((e + 1).toString(), i) + t;\n          }), s = 0, u = 0; u < a.length; u++) s = Math.max(a[u].length, s);\n\n          var c = a.slice(0, r - 1),\n              l = a.slice(r - 1, r),\n              h = a.slice(r);\n          console.log(c.join(\"\\n\")), console.log(e.split(\"\\n\")[0]), console.log(\"%c \" + R(l[0], s), \"border:1px solid red; background-color:#e3d2d2; color:#a61717\"), console.log(h.join(\"\\n\"));\n        }(n, t.getShaderInfoLog(r)), new Error(\"Failed to compile fragment shader.\");\n        return r;\n      }\n\n      var ne,\n          re,\n          oe = /ERROR: [0-9]+:([0-9]+):/g;\n\n      function ie(t, e) {\n        return Se(t, e, function () {\n          return t.createProgram();\n        }, \"Unable to create WebGLProgram.\");\n      }\n\n      function ae(t, e, n) {\n        if (Kt(t, e, function () {\n          return t.linkProgram(n);\n        }), !1 === t.getProgramParameter(n, t.LINK_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error(\"Failed to link vertex and fragment shaders.\");\n      }\n\n      function se(t, e, n) {\n        if (Kt(t, e, function () {\n          return t.validateProgram(n);\n        }), !1 === t.getProgramParameter(n, t.VALIDATE_STATUS)) throw console.log(t.getProgramInfoLog(n)), new Error(\"Shader program validation failed.\");\n      }\n\n      function ue(t, e, n) {\n        var r = Se(t, e, function () {\n          return t.createBuffer();\n        }, \"Unable to create WebGLBuffer\");\n        return Kt(t, e, function () {\n          return t.bindBuffer(t.ARRAY_BUFFER, r);\n        }), Kt(t, e, function () {\n          return t.bufferData(t.ARRAY_BUFFER, n, t.STATIC_DRAW);\n        }), r;\n      }\n\n      function ce(t, e, n) {\n        var r = Se(t, e, function () {\n          return t.createBuffer();\n        }, \"Unable to create WebGLBuffer\");\n        return Kt(t, e, function () {\n          return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, r);\n        }), Kt(t, e, function () {\n          return t.bufferData(t.ELEMENT_ARRAY_BUFFER, n, t.STATIC_DRAW);\n        }), r;\n      }\n\n      function le(t, e) {\n        return Se(t, e, function () {\n          return t.createTexture();\n        }, \"Unable to create WebGLTexture.\");\n      }\n\n      function he(t, e) {\n        var n = h().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\");\n\n        if (t <= 0 || e <= 0) {\n          var r = \"[\" + t + \"x\" + e + \"]\";\n          throw new Error(\"Requested texture size \" + r + \" is invalid.\");\n        }\n\n        if (t > n || e > n) throw r = \"[\" + t + \"x\" + e + \"]\", new Error(\"Requested texture size \" + r + \" greater than WebGL maximum on this browser / GPU [\" + n + \"x\" + n + \"].\");\n      }\n\n      function pe(t, e) {\n        return Se(t, e, function () {\n          return t.createFramebuffer();\n        }, \"Unable to create WebGLFramebuffer.\");\n      }\n\n      function fe(t, e, n, r, o, i, a, s) {\n        var u = t.getAttribLocation(n, r);\n        return -1 !== u && (Kt(t, e, function () {\n          return t.bindBuffer(t.ARRAY_BUFFER, o);\n        }), Kt(t, e, function () {\n          return t.vertexAttribPointer(u, i, t.FLOAT, !1, a, s);\n        }), Kt(t, e, function () {\n          return t.enableVertexAttribArray(u);\n        }), !0);\n      }\n\n      function de(t, e, n, r) {\n        Ee(t, r), Kt(t, e, function () {\n          return t.activeTexture(t.TEXTURE0 + r);\n        }), Kt(t, e, function () {\n          return t.bindTexture(t.TEXTURE_2D, n);\n        });\n      }\n\n      function me(t, e, n, r) {\n        return Se(t, e, function () {\n          return t.getUniformLocation(n, r);\n        }, 'uniform \"' + r + '\" not present in program.');\n      }\n\n      function ge(t, e, n) {\n        return t.getUniformLocation(e, n);\n      }\n\n      function ve(t, e, n, r, o, i) {\n        Kt(t, e, function () {\n          return de(t, e, r, i);\n        }), Kt(t, e, function () {\n          return t.uniform1i(o, i);\n        });\n      }\n\n      function ye(t, e, n, r) {\n        Kt(t, e, function () {\n          return t.bindFramebuffer(t.FRAMEBUFFER, r);\n        }), Kt(t, e, function () {\n          return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);\n        });\n      }\n\n      function be(t, e, n) {\n        Kt(t, e, function () {\n          return t.bindFramebuffer(t.FRAMEBUFFER, n);\n        }), Kt(t, e, function () {\n          return t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0);\n        });\n      }\n\n      function we(t) {\n        var e = t.checkFramebufferStatus(t.FRAMEBUFFER);\n        if (e !== t.FRAMEBUFFER_COMPLETE) throw new Error(\"Error binding framebuffer: \" + xe(t, e));\n      }\n\n      function xe(t, e) {\n        switch (e) {\n          case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";\n\n          case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";\n\n          case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";\n\n          case t.FRAMEBUFFER_UNSUPPORTED:\n            return \"FRAMEBUFFER_UNSUPPORTED\";\n\n          default:\n            return \"unknown error \" + e;\n        }\n      }\n\n      function Se(t, e, n, r) {\n        var o = Kt(t, e, function () {\n          return n();\n        });\n        if (null == o) throw new Error(r);\n        return o;\n      }\n\n      function Ee(t, e) {\n        var n = t.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,\n            r = e + t.TEXTURE0;\n        if (r < t.TEXTURE0 || r > n) throw new Error(\"textureUnit must be in [gl.TEXTURE0, gl.TEXTURE\" + n + \"].\");\n      }\n\n      function Ce(t, e) {\n        return void 0 === e && (e = 2), A(t.slice(0, t.length - e));\n      }\n\n      function Ie(t) {\n        if (0 === t.length) throw Error(\"Cannot get rows and columns of an empty shape array.\");\n        return [t.length > 1 ? t[t.length - 2] : 1, t[t.length - 1]];\n      }\n\n      function Ae(t) {\n        var e = [1, 1, 1];\n        return 0 === t.length || 1 === t.length && 1 === t[0] || (e = [Ce(t)].concat(Ie(t))), e;\n      }\n\n      function ke(t, e) {\n        var n;\n        void 0 === e && (e = !1);\n        var r = h().getNumber(\"WEBGL_MAX_TEXTURE_SIZE\");\n\n        if (e && (r *= 2, 1 === (t = t.map(function (e, n) {\n          return n >= t.length - 2 ? w(t[n]) : t[n];\n        })).length && (t = [2, t[0]])), 2 !== t.length) {\n          var o = D(t);\n          t = o.newShape;\n        }\n\n        var i = A(t);\n        if (t.length <= 1 && i <= r) return [1, i];\n        if (2 === t.length && t[0] <= r && t[1] <= r) return t;\n        if (3 === t.length && t[0] * t[1] <= r && t[2] <= r) return [t[0] * t[1], t[2]];\n        if (3 === t.length && t[0] <= r && t[1] * t[2] <= r) return [t[0], t[1] * t[2]];\n        if (4 === t.length && t[0] * t[1] * t[2] <= r && t[3] <= r) return [t[0] * t[1] * t[2], t[3]];\n        if (4 === t.length && t[0] <= r && t[1] * t[2] * t[3] <= r) return [t[0], t[1] * t[2] * t[3]];\n\n        if (e) {\n          var a = Ce(t),\n              s = 2,\n              u = 2;\n          return t.length && (s = (n = Ie(t))[0], u = n[1]), P(i = a * (s / 2) * (u / 2)).map(function (t) {\n            return 2 * t;\n          });\n        }\n\n        return P(i);\n      }\n\n      function Te(t) {\n        return t % 2 == 0;\n      }\n\n      function Ne(t, e) {\n        if (k(t = t.slice(-2), e = e.slice(-2))) return !0;\n        if (!t.length || !e.length) return !0;\n        if (0 === t[0] || 0 === t[1] || 0 === e[0] || 0 === e[1]) return !0;\n\n        if (t.length !== e.length) {\n          var n = t.slice(-1)[0],\n              r = e.slice(-1)[0];\n          if (n === r) return !0;\n          if (Te(n) && Te(r) && (1 === t[0] || 1 === e[0])) return !0;\n        }\n\n        return t[1] === e[1] && Te(t[0]) && Te(e[0]);\n      }\n\n      function Pe(t) {\n        if (null == ne) {\n          var e = Ut(t);\n          ne = e.getParameter(e.MAX_TEXTURE_SIZE);\n        }\n\n        return ne;\n      }\n\n      function Re(t) {\n        if (null == re) {\n          var e = Ut(t);\n          re = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);\n        }\n\n        return Math.min(16, re);\n      }\n\n      function _e(t) {\n        if (0 === t) return 0;\n        var e = Ut(t);\n        return Me(e, \"EXT_disjoint_timer_query_webgl2\") && 2 === t ? 2 : Me(e, \"EXT_disjoint_timer_query\") ? 1 : 0;\n      }\n\n      function Me(t, e) {\n        return null != t.getExtension(e);\n      }\n\n      function Oe(t) {\n        try {\n          if (null != Ut(t)) return !0;\n        } catch (t) {\n          return !1;\n        }\n\n        return !1;\n      }\n\n      function De(t) {\n        if (0 === t) return !1;\n        var e = Ut(t);\n\n        if (1 === t) {\n          if (!Me(e, \"OES_texture_float\")) return !1;\n        } else if (!Me(e, \"EXT_color_buffer_float\")) return !1;\n\n        return Le(e);\n      }\n\n      function Fe(t) {\n        if (0 === t) return !1;\n        var e = Ut(t);\n\n        if (1 !== t) {\n          if (Me(e, \"EXT_color_buffer_float\")) return Le(e);\n\n          if (Me(e, \"EXT_color_buffer_half_float\")) {\n            var n = e.getExtension(\"EXT_color_buffer_half_float\");\n            return function (t, e) {\n              var n = $t(t, e),\n                  r = t.createTexture();\n              t.bindTexture(t.TEXTURE_2D, r), t.texImage2D(t.TEXTURE_2D, 0, n.internalFormatHalfFloat, 1, 1, 0, n.textureFormatFloat, n.textureTypeHalfFloat, null);\n              var o = t.createFramebuffer();\n              t.bindFramebuffer(t.FRAMEBUFFER, o), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, r, 0);\n              var i = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;\n              return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(r), t.deleteFramebuffer(o), i;\n            }(e, n);\n          }\n\n          return !1;\n        }\n\n        return !!Me(e, \"OES_texture_float\") && !!Me(e, \"WEBGL_color_buffer_float\") && Le(e);\n      }\n\n      function Le(t) {\n        var e = $t(t),\n            n = t.createTexture();\n        t.bindTexture(t.TEXTURE_2D, n), t.texImage2D(t.TEXTURE_2D, 0, e.internalFormatFloat, 1, 1, 0, e.textureFormatFloat, e.textureTypeFloat, null);\n        var r = t.createFramebuffer();\n        t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, n, 0);\n        var o = t.checkFramebufferStatus(t.FRAMEBUFFER) === t.FRAMEBUFFER_COMPLETE;\n        return t.bindTexture(t.TEXTURE_2D, null), t.bindFramebuffer(t.FRAMEBUFFER, null), t.deleteTexture(n), t.deleteFramebuffer(r), o;\n      }\n\n      function Be(t) {\n        return 2 === t && null != Ut(t).fenceSync;\n      }\n\n      var ze = Object.freeze({\n        callAndCheck: Kt,\n        canBeRepresented: Yt,\n        getWebGLErrorMessage: Jt,\n        getExtensionOrThrow: Zt,\n        createVertexShader: te,\n        createFragmentShader: ee,\n        createProgram: ie,\n        linkProgram: ae,\n        validateProgram: se,\n        createStaticVertexBuffer: ue,\n        createStaticIndexBuffer: ce,\n        getNumChannels: function () {\n          return 2 === h().getNumber(\"WEBGL_VERSION\") ? 1 : 4;\n        },\n        createTexture: le,\n        validateTextureSize: he,\n        createFramebuffer: pe,\n        bindVertexBufferToProgramAttribute: fe,\n        bindTextureUnit: de,\n        unbindTextureUnit: function (t, e, n) {\n          Ee(t, n), Kt(t, e, function () {\n            return t.activeTexture(t.TEXTURE0 + n);\n          }), Kt(t, e, function () {\n            return t.bindTexture(t.TEXTURE_2D, null);\n          });\n        },\n        getProgramUniformLocationOrThrow: me,\n        getProgramUniformLocation: ge,\n        bindTextureToProgramUniformSampler: ve,\n        bindCanvasToFramebuffer: function (t, e) {\n          Kt(t, e, function () {\n            return t.bindFramebuffer(t.FRAMEBUFFER, null);\n          }), Kt(t, e, function () {\n            return t.viewport(0, 0, t.canvas.width, t.canvas.height);\n          }), Kt(t, e, function () {\n            return t.scissor(0, 0, t.canvas.width, t.canvas.height);\n          });\n        },\n        bindColorTextureToFramebuffer: ye,\n        unbindColorTextureFromFramebuffer: be,\n        validateFramebuffer: we,\n        getFramebufferErrorMessage: xe,\n        getBatchDim: Ce,\n        getRowsCols: Ie,\n        getShapeAs3D: Ae,\n        getTextureShapeFromLogicalShape: ke,\n        isReshapeFree: Ne,\n        getWebGLMaxTextureSize: Pe,\n        resetMaxTextureSize: function () {\n          ne = null;\n        },\n        resetMaxTexturesInShader: function () {\n          re = null;\n        },\n        getMaxTexturesInShader: Re,\n        getWebGLDisjointQueryTimerVersion: _e,\n        hasExtension: Me,\n        isWebGLVersionEnabled: Oe,\n        isCapableOfRenderingToFloatTexture: De,\n        isDownloadFloatTextureEnabled: Fe,\n        isWebGLFenceEnabled: Be\n      }),\n          qe = h();\n\n      function Ve(t) {\n        h().getBool(\"DEPRECATION_WARNINGS_ENABLED\") && console.warn(t + \" You can disable deprecation warnings with tf.disableDeprecationWarnings().\");\n      }\n\n      function Ue(t, e) {\n        return Mt.tidy(t, e);\n      }\n\n      function je(t) {\n        Nt(t).forEach(function (t) {\n          return t.dispose();\n        });\n      }\n\n      function We() {\n        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n        h().getBool(\"IS_TEST\") || console.warn.apply(console, t);\n      }\n\n      function Ge(t, e) {\n        var n = t;\n        if (V(t)) return \"string\" === e ? [] : [t.length];\n        if (!Array.isArray(t)) return [];\n\n        for (var r = []; Array.isArray(n) || V(n) && \"string\" !== e;) r.push(n.length), n = n[0];\n\n        return Array.isArray(t) && h().getBool(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\") && function t(e, n, r) {\n          if (r = r || [], Array.isArray(e) || V(e)) {\n            S(n.length > 0, function () {\n              return \"Element arr[\" + r.join(\"][\") + \"] should be a primitive, but is an array of \" + e.length + \" elements\";\n            }), S(e.length === n[0], function () {\n              return \"Element arr[\" + r.join(\"][\") + \"] should have \" + n[0] + \" elements, but has \" + e.length + \" elements\";\n            });\n\n            for (var o = n.slice(1), i = 0; i < e.length; ++i) t(e[i], o, r.concat(i));\n          } else S(0 === n.length, function () {\n            return \"Element arr[\" + r.join(\"][\") + \"] is a primitive, but should be an array/TypedArray of \" + n[0] + \" elements\";\n          });\n        }(t, r, []), r;\n      }\n\n      function He(t, e, n, r) {\n        if (null != t && (\"numeric\" !== t && t !== e || \"numeric\" === t && \"string\" === e)) throw new Error(\"Argument '\" + n + \"' passed to '\" + r + \"' must be \" + t + \" tensor, but got \" + e + \" tensor\");\n      }\n\n      function $e(t, e, n, r) {\n        if (void 0 === r && (r = \"numeric\"), t instanceof vt) return He(r, t.dtype, e, n), t;\n        var o = $(t);\n\n        if (\"string\" !== o && [\"bool\", \"int32\", \"float32\"].indexOf(r) >= 0 && (o = r), He(r, o, e, n), null == t || !V(t) && !Array.isArray(t) && \"number\" != typeof t && \"boolean\" != typeof t && \"string\" != typeof t) {\n          var i = null == t ? \"null\" : t.constructor.name;\n          throw new Error(\"Argument '\" + e + \"' passed to '\" + n + \"' must be a Tensor or TensorLike, but got '\" + i + \"'\");\n        }\n\n        var a = Ge(t, o);\n        V(t) || Array.isArray(t) || (t = [t]);\n        var s = \"string\" !== o ? Y(t, o, h().getBool(\"DEBUG\")) : I(t, [], !0);\n        return Mt.makeTensor(s, a, o);\n      }\n\n      function Ke(t, e, n, r) {\n        if (void 0 === r && (r = \"numeric\"), !Array.isArray(t)) throw new Error(\"Argument \" + e + \" passed to \" + n + \" must be a `Tensor[]` or `TensorLike[]`\");\n        return t.map(function (t, r) {\n          return $e(t, e + \"[\" + r + \"]\", n);\n        }, r);\n      }\n\n      function Qe(t, e) {\n        for (var n = 0; n < t.length; ++n) if (t[t.length - n - 1] !== e - 1 - n) return !1;\n\n        return !0;\n      }\n\n      function Xe(t, e, n) {\n        for (var r = t.length + e.length, o = [], i = 0, a = 0, s = 0; s < r; s++) -1 === n.indexOf(s) ? o.push(t[i++]) : o.push(e[a++]);\n\n        return o;\n      }\n\n      function Ye(t, e) {\n        for (var n = [], r = t.length, o = 0; o < r; o++) -1 === e.indexOf(o) && n.push(t[o]);\n\n        return [n, e.map(function (e) {\n          return t[e];\n        })];\n      }\n\n      function Je(t, e) {\n        return Xe(t, e.map(function (t) {\n          return 1;\n        }), e);\n      }\n\n      function Ze(t, e, n) {\n        S(Qe(e, n), function () {\n          return t + \" supports only inner-most axes for now. Got axes \" + e + \" and rank-\" + n + \" input.\";\n        });\n      }\n\n      function tn(t, e) {\n        if (Qe(t, e)) return null;\n\n        for (var n = [], r = 0; r < e; ++r) -1 === t.indexOf(r) && n.push(r);\n\n        return t.forEach(function (t) {\n          return n.push(t);\n        }), n;\n      }\n\n      function en(t) {\n        return t.map(function (t, e) {\n          return [e, t];\n        }).sort(function (t, e) {\n          return t[1] - e[1];\n        }).map(function (t) {\n          return t[0];\n        });\n      }\n\n      function nn(t, e) {\n        for (var n = [], r = e - t; r < e; ++r) n.push(r);\n\n        return n;\n      }\n\n      function rn(t, e) {\n        var n = t[0].length;\n        t.forEach(function (t, e) {\n          S(t.length === n, function () {\n            return \"Error in concat\" + n + \"D: rank of tensors[\" + e + \"] must be the same as the rank of the rest (\" + n + \")\";\n          });\n        }), S(e >= 0 && e < n, function () {\n          return \"Error in concat\" + n + \"D: axis must be between 0 and \" + (n - 1) + \".\";\n        });\n        var r = t[0];\n        t.forEach(function (t, o) {\n          for (var i = 0; i < n; i++) S(i === e || t[i] === r[i], function () {\n            return \"Error in concat\" + n + \"D: Shape of tensors[\" + o + \"] (\" + t + \") does not match the shape of the rest (\" + r + \") along the non-concatenated axis \" + o + \".\";\n          });\n        });\n      }\n\n      function on(t, e) {\n        for (var n = t[0].slice(), r = 1; r < t.length; r++) n[e] += t[r][e];\n\n        return n;\n      }\n\n      function an(t) {\n        var e = Object.keys(t);\n        if (1 !== e.length) throw new Error(\"Please provide an object with a single key (operation name) mapping to a function. Got an object with \" + e.length + \" keys.\");\n        var n = e[0],\n            r = t[n];\n        n.endsWith(\"_\") && (n = n.substring(0, n.length - 1));\n\n        var o = function () {\n          for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];\n\n          Mt.startScope(n);\n\n          try {\n            var o = r.apply(void 0, t);\n            return o instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), Mt.endScope(o), o;\n          } catch (t) {\n            throw Mt.endScope(null), t;\n          }\n        };\n\n        return Object.defineProperty(o, \"name\", {\n          value: n,\n          configurable: !0\n        }), o;\n      }\n\n      qe.registerFlag(\"HAS_WEBGL\", function () {\n        return qe.getNumber(\"WEBGL_VERSION\") > 0;\n      }), qe.registerFlag(\"WEBGL_VERSION\", function () {\n        return Oe(2) ? 2 : Oe(1) ? 1 : 0;\n      }), qe.registerFlag(\"WEBGL_BUFFER_SUPPORTED\", function () {\n        return 2 === qe.get(\"WEBGL_VERSION\");\n      }), qe.registerFlag(\"WEBGL_CPU_FORWARD\", function () {\n        return !0;\n      }), qe.registerFlag(\"WEBGL_FORCE_F16_TEXTURES\", function () {\n        return !1;\n      }), qe.registerFlag(\"WEBGL_PACK\", function () {\n        return qe.getBool(\"HAS_WEBGL\");\n      }), qe.registerFlag(\"WEBGL_PACK_NORMALIZATION\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_PACK_CLIP\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_PACK_DEPTHWISECONV\", function () {\n        return !1;\n      }), qe.registerFlag(\"WEBGL_PACK_BINARY_OPERATIONS\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_PACK_UNARY_OPERATIONS\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_PACK_ARRAY_OPERATIONS\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_PACK_IMAGE_OPERATIONS\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_PACK_REDUCE\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_LAZILY_UNPACK\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_CONV_IM2COL\", function () {\n        return qe.getBool(\"WEBGL_PACK\");\n      }), qe.registerFlag(\"WEBGL_MAX_TEXTURE_SIZE\", function () {\n        return Pe(qe.getNumber(\"WEBGL_VERSION\"));\n      }), qe.registerFlag(\"WEBGL_MAX_TEXTURES_IN_SHADER\", function () {\n        return Re(qe.getNumber(\"WEBGL_VERSION\"));\n      }), qe.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\", function () {\n        var t = qe.getNumber(\"WEBGL_VERSION\");\n        return 0 === t ? 0 : _e(t);\n      }), qe.registerFlag(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\", function () {\n        return qe.getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 && (t = navigator.userAgent || navigator.vendor || window.opera, !(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(t.substr(0, 4))));\n        var t;\n      }), qe.registerFlag(\"WEBGL_RENDER_FLOAT32_CAPABLE\", function () {\n        return De(qe.getNumber(\"WEBGL_VERSION\"));\n      }), qe.registerFlag(\"WEBGL_RENDER_FLOAT32_ENABLED\", function () {\n        return !qe.getBool(\"WEBGL_FORCE_F16_TEXTURES\") && qe.getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\");\n      }), qe.registerFlag(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\", function () {\n        return Fe(qe.getNumber(\"WEBGL_VERSION\"));\n      }), qe.registerFlag(\"WEBGL_FENCE_API_ENABLED\", function () {\n        return Be(qe.getNumber(\"WEBGL_VERSION\"));\n      }), qe.registerFlag(\"WEBGL_SIZE_UPLOAD_UNIFORM\", function () {\n        return qe.getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? 4 : 0;\n      }), gt = Ve;\n      var sn = an({\n        complex_: function (t, e) {\n          var n = $e(t, \"real\", \"complex\"),\n              r = $e(e, \"imag\", \"complex\");\n          return E(n.shape, r.shape, \"real and imag shapes, \" + n.shape + \" and \" + r.shape + \", must match in call to tf.complex().\"), Mt.runKernelFunc(function (t) {\n            return t.complex(n, r);\n          }, {\n            $real: n,\n            $imag: r\n          });\n        }\n      }),\n          un = an({\n        real_: function (t) {\n          var e = $e(t, \"input\", \"real\");\n          return Mt.runKernelFunc(function (t) {\n            return t.real(e);\n          }, {\n            $input: e\n          });\n        }\n      }),\n          cn = an({\n        imag_: function (t) {\n          var e = $e(t, \"input\", \"imag\");\n          return Mt.runKernelFunc(function (t) {\n            return t.imag(e);\n          }, {\n            $input: e\n          });\n        }\n      });\n\n      function ln(t, e, n) {\n        return hn(t, e, Ge(t, n), n);\n      }\n\n      function hn(t, e, n, r) {\n        if (null == r && (r = $(t)), \"complex64\" === r) throw new Error(\"Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).\");\n        if (!V(t) && !Array.isArray(t) && \"number\" != typeof t && \"boolean\" != typeof t && \"string\" != typeof t) throw new Error(\"values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray\");\n\n        if (null != e) {\n          nt(e);\n          var o = A(e),\n              i = A(n);\n          S(o === i, function () {\n            return \"Based on the provided shape, [\" + e + \"], the tensor should have \" + o + \" values but has \" + i;\n          });\n\n          for (var a = 0; a < n.length; ++a) {\n            var s = n[a],\n                u = a !== n.length - 1 || s !== A(e.slice(a));\n            S(n[a] === e[a] || !u, function () {\n              return \"Error creating a new Tensor. Inferred shape (\" + n + \") does not match the provided shape (\" + e + \"). \";\n            });\n          }\n        }\n\n        return V(t) || Array.isArray(t) || (t = [t]), e = e || n, t = \"string\" !== r ? Y(t, r, h().getBool(\"DEBUG\")) : I(t, [], !0), Mt.makeTensor(t, e, r);\n      }\n\n      function pn(t, e) {\n        if ((V(t) && \"string\" !== e || Array.isArray(t)) && \"complex64\" !== e) throw new Error(\"Error creating a new Scalar: value must be a primitive (number|boolean|string)\");\n        if (\"string\" === e && V(t) && !(t instanceof Uint8Array)) throw new Error(\"When making a scalar from encoded string, the value must be `Uint8Array`.\");\n        return hn(t, [], [], e);\n      }\n\n      function fn(t, e) {\n        C(t);\n        var n = Ge(t, e);\n        if (1 !== n.length) throw new Error(\"tensor1d() requires values to be a flat/TypedArray\");\n        return hn(t, null, n, e);\n      }\n\n      function dn(t, e, n) {\n        if (C(t), null != e && 2 !== e.length) throw new Error(\"tensor2d() requires shape to have two numbers\");\n        var r = Ge(t, n);\n        if (2 !== r.length && 1 !== r.length) throw new Error(\"tensor2d() requires values to be number[][] or flat/TypedArray\");\n        if (1 === r.length && null == e) throw new Error(\"tensor2d() requires shape to be provided when `values` are a flat/TypedArray\");\n        return hn(t, e, r, n);\n      }\n\n      function mn(t, e, n) {\n        if (C(t), null != e && 3 !== e.length) throw new Error(\"tensor3d() requires shape to have three numbers\");\n        var r = Ge(t, n);\n        if (3 !== r.length && 1 !== r.length) throw new Error(\"tensor3d() requires values to be number[][][] or flat/TypedArray\");\n        if (1 === r.length && null == e) throw new Error(\"tensor3d() requires shape to be provided when `values` are a flat array\");\n        return hn(t, e, r, n);\n      }\n\n      function gn(t, e, n) {\n        if (C(t), null != e && 4 !== e.length) throw new Error(\"tensor4d() requires shape to have four numbers\");\n        var r = Ge(t, n);\n        if (4 !== r.length && 1 !== r.length) throw new Error(\"tensor4d() requires values to be number[][][][] or flat/TypedArray\");\n        if (1 === r.length && null == e) throw new Error(\"tensor4d() requires shape to be provided when `values` are a flat array\");\n        return hn(t, e, r, n);\n      }\n\n      function vn(t, e) {\n        if (void 0 === e && (e = \"float32\"), \"complex64\" === e) {\n          var n = vn(t, \"float32\"),\n              r = yn(t, \"float32\");\n          return sn(n, r);\n        }\n\n        var o = Z(A(t), e);\n        return Mt.makeTensor(o, t, e);\n      }\n\n      function yn(t, e) {\n        if (void 0 === e && (e = \"float32\"), \"complex64\" === e) {\n          var n = yn(t, \"float32\"),\n              r = yn(t, \"float32\");\n          return sn(n, r);\n        }\n\n        var o = tt(A(t), e);\n        return Mt.makeTensor(o, t, e);\n      }\n\n      function bn(t, e, n) {\n        return Mt.runKernelFunc(function (r) {\n          return r.fill(t, e, n);\n        }, {});\n      }\n\n      function wn(t, e, n, r) {\n        if (void 0 === n && (n = 1), void 0 === r && (r = \"float32\"), 0 === n) throw new Error(\"Cannot have a step of zero\");\n        if (t === e || t < e && n < 0 || e < t && n > 1) return yn([0], r);\n        var o = tt(Math.abs(Math.ceil((e - t) / n)), r);\n        e < t && 1 === n && (n = -1), o[0] = t;\n\n        for (var i = 1; i < o.length; i++) o[i] = o[i - 1] + n;\n\n        return fn(o, r);\n      }\n\n      var xn = an({\n        onesLike_: function (t) {\n          var e = $e(t, \"x\", \"onesLike\");\n\n          if (\"complex64\" === e.dtype) {\n            var n = xn(un(e)),\n                r = Sn(cn(e));\n            return sn(n, r);\n          }\n\n          return Mt.runKernelFunc(function (t) {\n            return t.onesLike(e);\n          }, {\n            $x: e\n          }, function (t, e) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          Sn = an({\n        zerosLike_: function (t) {\n          var e = $e(t, \"x\", \"zerosLike\");\n          return Mt.runKernelFunc(function (t) {\n            return t.zerosLike(e);\n          }, {\n            $x: e\n          }, function (t, e) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          En = an({\n        concat_: function (t, e) {\n          void 0 === e && (e = 0), S(t.length >= 1, function () {\n            return \"Pass at least one tensor to concat\";\n          });\n          var n = Ke(t, \"tensors\", \"concat\");\n          \"complex64\" === n[0].dtype && n.forEach(function (t) {\n            if (\"complex64\" !== t.dtype) throw new Error(\"Cannot concatenate complex64 tensors with a tensor\\n          with dtype \" + t.dtype + \". \");\n          }), e = O(e, n[0].shape)[0];\n          var r = on(n.map(function (t) {\n            return t.shape;\n          }), e);\n          if (0 === A(r)) return ln([], r);\n          if (1 === (n = n.filter(function (t) {\n            return t.size > 0;\n          })).length) return n[0];\n          var o = n.map(function (t) {\n            return t.shape;\n          });\n          rn(o, e);\n          var i = n;\n          return Mt.runKernelFunc(function (t) {\n            return t.concat(n, e);\n          }, i, function (t) {\n            var n = o.map(function (t) {\n              return t[e];\n            });\n            return Tn(t, n, e).map(function (t) {\n              return function () {\n                return t;\n              };\n            });\n          });\n        }\n      }),\n          Cn = an({\n        concat1d_: function (t) {\n          return En(t, 0);\n        }\n      }),\n          In = an({\n        concat2d_: function (t, e) {\n          return En(t, e);\n        }\n      }),\n          An = an({\n        concat3d_: function (t, e) {\n          return En(t, e);\n        }\n      }),\n          kn = an({\n        concat4d_: function (t, e) {\n          return En(t, e);\n        }\n      }),\n          Tn = an({\n        split_: function (t, e, n) {\n          void 0 === n && (n = 0);\n          var r,\n              o = $e(t, \"x\", \"split\");\n          return n = O(n, o.shape)[0], \"number\" == typeof e ? (S(o.shape[n] % e == 0, function () {\n            return \"Number of splits must evenly divide the axis.\";\n          }), r = new Array(e).fill(o.shape[n] / e)) : (S(o.shape[n] === e.reduce(function (t, e) {\n            return t + e;\n          }), function () {\n            return \"The sum of sizes must match the size of the axis dimension.\";\n          }), r = e), Mt.runKernelFunc(function (t) {\n            return t.split(o, r, n);\n          }, {\n            $x: o\n          }, function (t) {\n            return {\n              $x: function () {\n                return En(t, n);\n              }\n            };\n          });\n        }\n      });\n\n      function Nn(t, e) {\n        return t(e = {\n          exports: {}\n        }, e.exports), e.exports;\n      }\n\n      \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : void 0 !== t || \"undefined\" != typeof self && self;\n\n      var Pn = Nn(function (t) {\n        !function (t, e, n) {\n          function r(t) {\n            var e,\n                n = this,\n                r = (e = 4022871197, function (t) {\n              t = t.toString();\n\n              for (var n = 0; n < t.length; n++) {\n                var r = .02519603282416938 * (e += t.charCodeAt(n));\n                r -= e = r >>> 0, e = (r *= e) >>> 0, e += 4294967296 * (r -= e);\n              }\n\n              return 2.3283064365386963e-10 * (e >>> 0);\n            });\n            n.next = function () {\n              var t = 2091639 * n.s0 + 2.3283064365386963e-10 * n.c;\n              return n.s0 = n.s1, n.s1 = n.s2, n.s2 = t - (n.c = 0 | t);\n            }, n.c = 1, n.s0 = r(\" \"), n.s1 = r(\" \"), n.s2 = r(\" \"), n.s0 -= r(t), n.s0 < 0 && (n.s0 += 1), n.s1 -= r(t), n.s1 < 0 && (n.s1 += 1), n.s2 -= r(t), n.s2 < 0 && (n.s2 += 1), r = null;\n          }\n\n          function o(t, e) {\n            return e.c = t.c, e.s0 = t.s0, e.s1 = t.s1, e.s2 = t.s2, e;\n          }\n\n          function i(t, e) {\n            var n = new r(t),\n                i = e && e.state,\n                a = n.next;\n            return a.int32 = function () {\n              return 4294967296 * n.next() | 0;\n            }, a.double = function () {\n              return a() + 11102230246251565e-32 * (2097152 * a() | 0);\n            }, a.quick = a, i && (\"object\" == typeof i && o(i, n), a.state = function () {\n              return o(n, {});\n            }), a;\n          }\n\n          e && e.exports ? e.exports = i : this.alea = i;\n        }(0, t);\n      }),\n          Rn = Nn(function (t) {\n        !function (t, e, n) {\n          function r(t) {\n            var e = this,\n                n = \"\";\n            e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.next = function () {\n              var t = e.x ^ e.x << 11;\n              return e.x = e.y, e.y = e.z, e.z = e.w, e.w ^= e.w >>> 19 ^ t ^ t >>> 8;\n            }, t === (0 | t) ? e.x = t : n += t;\n\n            for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), e.next();\n          }\n\n          function o(t, e) {\n            return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e;\n          }\n\n          function i(t, e) {\n            var n = new r(t),\n                i = e && e.state,\n                a = function () {\n              return (n.next() >>> 0) / 4294967296;\n            };\n\n            return a.double = function () {\n              do {\n                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n              } while (0 === t);\n\n              return t;\n            }, a.int32 = n.next, a.quick = a, i && (\"object\" == typeof i && o(i, n), a.state = function () {\n              return o(n, {});\n            }), a;\n          }\n\n          e && e.exports ? e.exports = i : this.xor128 = i;\n        }(0, t);\n      }),\n          _n = Nn(function (t) {\n        !function (t, e, n) {\n          function r(t) {\n            var e = this,\n                n = \"\";\n            e.next = function () {\n              var t = e.x ^ e.x >>> 2;\n              return e.x = e.y, e.y = e.z, e.z = e.w, e.w = e.v, (e.d = e.d + 362437 | 0) + (e.v = e.v ^ e.v << 4 ^ t ^ t << 1) | 0;\n            }, e.x = 0, e.y = 0, e.z = 0, e.w = 0, e.v = 0, t === (0 | t) ? e.x = t : n += t;\n\n            for (var r = 0; r < n.length + 64; r++) e.x ^= 0 | n.charCodeAt(r), r == n.length && (e.d = e.x << 10 ^ e.x >>> 4), e.next();\n          }\n\n          function o(t, e) {\n            return e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w, e.v = t.v, e.d = t.d, e;\n          }\n\n          function i(t, e) {\n            var n = new r(t),\n                i = e && e.state,\n                a = function () {\n              return (n.next() >>> 0) / 4294967296;\n            };\n\n            return a.double = function () {\n              do {\n                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n              } while (0 === t);\n\n              return t;\n            }, a.int32 = n.next, a.quick = a, i && (\"object\" == typeof i && o(i, n), a.state = function () {\n              return o(n, {});\n            }), a;\n          }\n\n          e && e.exports ? e.exports = i : this.xorwow = i;\n        }(0, t);\n      }),\n          Mn = Nn(function (t) {\n        !function (t, e, n) {\n          function r(t) {\n            var e = this;\n            e.next = function () {\n              var t,\n                  n,\n                  r = e.x,\n                  o = e.i;\n              return t = r[o], n = (t ^= t >>> 7) ^ t << 24, n ^= (t = r[o + 1 & 7]) ^ t >>> 10, n ^= (t = r[o + 3 & 7]) ^ t >>> 3, n ^= (t = r[o + 4 & 7]) ^ t << 7, t = r[o + 7 & 7], n ^= (t ^= t << 13) ^ t << 9, r[o] = n, e.i = o + 1 & 7, n;\n            }, function (t, e) {\n              var n,\n                  r = [];\n              if (e === (0 | e)) r[0] = e;else for (e = \"\" + e, n = 0; n < e.length; ++n) r[7 & n] = r[7 & n] << 15 ^ e.charCodeAt(n) + r[n + 1 & 7] << 13;\n\n              for (; r.length < 8;) r.push(0);\n\n              for (n = 0; n < 8 && 0 === r[n]; ++n);\n\n              for (8 == n ? r[7] = -1 : r[n], t.x = r, t.i = 0, n = 256; n > 0; --n) t.next();\n            }(e, t);\n          }\n\n          function o(t, e) {\n            return e.x = t.x.slice(), e.i = t.i, e;\n          }\n\n          function i(t, e) {\n            null == t && (t = +new Date());\n\n            var n = new r(t),\n                i = e && e.state,\n                a = function () {\n              return (n.next() >>> 0) / 4294967296;\n            };\n\n            return a.double = function () {\n              do {\n                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n              } while (0 === t);\n\n              return t;\n            }, a.int32 = n.next, a.quick = a, i && (i.x && o(i, n), a.state = function () {\n              return o(n, {});\n            }), a;\n          }\n\n          e && e.exports ? e.exports = i : this.xorshift7 = i;\n        }(0, t);\n      }),\n          On = Nn(function (t) {\n        !function (t, e, n) {\n          function r(t) {\n            var e = this;\n            e.next = function () {\n              var t,\n                  n,\n                  r = e.w,\n                  o = e.X,\n                  i = e.i;\n              return e.w = r = r + 1640531527 | 0, n = o[i + 34 & 127], t = o[i = i + 1 & 127], n ^= n << 13, t ^= t << 17, n ^= n >>> 15, t ^= t >>> 12, n = o[i] = n ^ t, e.i = i, n + (r ^ r >>> 16) | 0;\n            }, function (t, e) {\n              var n,\n                  r,\n                  o,\n                  i,\n                  a,\n                  s = [],\n                  u = 128;\n\n              for (e === (0 | e) ? (r = e, e = null) : (e += \"\\0\", r = 0, u = Math.max(u, e.length)), o = 0, i = -32; i < u; ++i) e && (r ^= e.charCodeAt((i + 32) % e.length)), 0 === i && (a = r), r ^= r << 10, r ^= r >>> 15, r ^= r << 4, r ^= r >>> 13, i >= 0 && (a = a + 1640531527 | 0, o = 0 == (n = s[127 & i] ^= r + a) ? o + 1 : 0);\n\n              for (o >= 128 && (s[127 & (e && e.length || 0)] = -1), o = 127, i = 512; i > 0; --i) r = s[o + 34 & 127], n = s[o = o + 1 & 127], r ^= r << 13, n ^= n << 17, r ^= r >>> 15, n ^= n >>> 12, s[o] = r ^ n;\n\n              t.w = a, t.X = s, t.i = o;\n            }(e, t);\n          }\n\n          function o(t, e) {\n            return e.i = t.i, e.w = t.w, e.X = t.X.slice(), e;\n          }\n\n          function i(t, e) {\n            null == t && (t = +new Date());\n\n            var n = new r(t),\n                i = e && e.state,\n                a = function () {\n              return (n.next() >>> 0) / 4294967296;\n            };\n\n            return a.double = function () {\n              do {\n                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n              } while (0 === t);\n\n              return t;\n            }, a.int32 = n.next, a.quick = a, i && (i.X && o(i, n), a.state = function () {\n              return o(n, {});\n            }), a;\n          }\n\n          e && e.exports ? e.exports = i : this.xor4096 = i;\n        }(0, t);\n      }),\n          Dn = Nn(function (t) {\n        !function (t, e, n) {\n          function r(t) {\n            var e = this,\n                n = \"\";\n            e.next = function () {\n              var t = e.b,\n                  n = e.c,\n                  r = e.d,\n                  o = e.a;\n              return t = t << 25 ^ t >>> 7 ^ n, n = n - r | 0, r = r << 24 ^ r >>> 8 ^ o, o = o - t | 0, e.b = t = t << 20 ^ t >>> 12 ^ n, e.c = n = n - r | 0, e.d = r << 16 ^ n >>> 16 ^ o, e.a = o - t | 0;\n            }, e.a = 0, e.b = 0, e.c = -1640531527, e.d = 1367130551, t === Math.floor(t) ? (e.a = t / 4294967296 | 0, e.b = 0 | t) : n += t;\n\n            for (var r = 0; r < n.length + 20; r++) e.b ^= 0 | n.charCodeAt(r), e.next();\n          }\n\n          function o(t, e) {\n            return e.a = t.a, e.b = t.b, e.c = t.c, e.d = t.d, e;\n          }\n\n          function i(t, e) {\n            var n = new r(t),\n                i = e && e.state,\n                a = function () {\n              return (n.next() >>> 0) / 4294967296;\n            };\n\n            return a.double = function () {\n              do {\n                var t = ((n.next() >>> 11) + (n.next() >>> 0) / 4294967296) / (1 << 21);\n              } while (0 === t);\n\n              return t;\n            }, a.int32 = n.next, a.quick = a, i && (\"object\" == typeof i && o(i, n), a.state = function () {\n              return o(n, {});\n            }), a;\n          }\n\n          e && e.exports ? e.exports = i : this.tychei = i;\n        }(0, t);\n      }),\n          Fn = Nn(function (t) {\n        !function (e, r) {\n          var o,\n              i = this,\n              a = 256,\n              s = 6,\n              u = \"random\",\n              c = r.pow(a, s),\n              l = r.pow(2, 52),\n              h = 2 * l,\n              p = a - 1;\n\n          function f(t, n, p) {\n            var f = [],\n                y = g(function t(e, n) {\n              var r,\n                  o = [],\n                  i = typeof e;\n              if (n && \"object\" == i) for (r in e) try {\n                o.push(t(e[r], n - 1));\n              } catch (t) {}\n              return o.length ? o : \"string\" == i ? e : e + \"\\0\";\n            }((n = 1 == n ? {\n              entropy: !0\n            } : n || {}).entropy ? [t, v(e)] : null == t ? function () {\n              try {\n                var t;\n                return o && (t = o.randomBytes) ? t = t(a) : (t = new Uint8Array(a), (i.crypto || i.msCrypto).getRandomValues(t)), v(t);\n              } catch (t) {\n                var n = i.navigator,\n                    r = n && n.plugins;\n                return [+new Date(), i, r, i.screen, v(e)];\n              }\n            }() : t, 3), f),\n                b = new d(f),\n                w = function () {\n              for (var t = b.g(s), e = c, n = 0; t < l;) t = (t + n) * a, e *= a, n = b.g(1);\n\n              for (; t >= h;) t /= 2, e /= 2, n >>>= 1;\n\n              return (t + n) / e;\n            };\n\n            return w.int32 = function () {\n              return 0 | b.g(4);\n            }, w.quick = function () {\n              return b.g(4) / 4294967296;\n            }, w.double = w, g(v(b.S), e), (n.pass || p || function (t, e, n, o) {\n              return o && (o.S && m(o, b), t.state = function () {\n                return m(b, {});\n              }), n ? (r[u] = t, e) : t;\n            })(w, y, \"global\" in n ? n.global : this == r, n.state);\n          }\n\n          function d(t) {\n            var e,\n                n = t.length,\n                r = this,\n                o = 0,\n                i = r.i = r.j = 0,\n                s = r.S = [];\n\n            for (n || (t = [n++]); o < a;) s[o] = o++;\n\n            for (o = 0; o < a; o++) s[o] = s[i = p & i + t[o % n] + (e = s[o])], s[i] = e;\n\n            (r.g = function (t) {\n              for (var e, n = 0, o = r.i, i = r.j, s = r.S; t--;) e = s[o = p & o + 1], n = n * a + s[p & (s[o] = s[i = p & i + e]) + (s[i] = e)];\n\n              return r.i = o, r.j = i, n;\n            })(a);\n          }\n\n          function m(t, e) {\n            return e.i = t.i, e.j = t.j, e.S = t.S.slice(), e;\n          }\n\n          function g(t, e) {\n            for (var n, r = t + \"\", o = 0; o < r.length;) e[p & o] = p & (n ^= 19 * e[p & o]) + r.charCodeAt(o++);\n\n            return v(e);\n          }\n\n          function v(t) {\n            return String.fromCharCode.apply(0, t);\n          }\n\n          if (r[\"seed\" + u] = f, g(r.random(), e), t.exports) {\n            t.exports = f;\n\n            try {\n              o = n(71);\n            } catch (t) {}\n          }\n        }([], Math);\n      });\n\n      Fn.alea = Pn, Fn.xor128 = Rn, Fn.xorwow = _n, Fn.xorshift7 = Mn, Fn.xor4096 = On, Fn.tychei = Dn;\n\n      var Ln = Fn.alea,\n          Bn = function () {\n        function t(t, e, n, r, o) {\n          this.mean = t, this.stdDev = e, this.dtype = n, this.nextVal = NaN, this.truncated = r, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);\n          var i = o || Math.random();\n          this.random = Ln(i.toString());\n        }\n\n        return t.prototype.nextValue = function () {\n          if (!isNaN(this.nextVal)) {\n            var t = this.nextVal;\n            return this.nextVal = NaN, t;\n          }\n\n          for (var e, n, r = !1; !r;) {\n            var o = void 0,\n                i = void 0,\n                a = void 0;\n\n            do {\n              a = (o = 2 * this.random() - 1) * o + (i = 2 * this.random() - 1) * i;\n            } while (a >= 1 || 0 === a);\n\n            var s = Math.sqrt(-2 * Math.log(a) / a);\n            e = this.mean + this.stdDev * o * s, n = this.mean + this.stdDev * i * s, this.truncated && !this.isValidTruncated(e) || (r = !0);\n          }\n\n          return this.truncated && !this.isValidTruncated(n) || (this.nextVal = this.convertValue(n)), this.convertValue(e);\n        }, t.prototype.convertValue = function (t) {\n          return null == this.dtype || \"float32\" === this.dtype ? t : Math.round(t);\n        }, t.prototype.isValidTruncated = function (t) {\n          return t <= this.upper && t >= this.lower;\n        }, t;\n      }(),\n          zn = function () {\n        function t(t, e, n, r) {\n          this.alpha = t, this.beta = 1 / e, this.dtype = n;\n          var o = r || Math.random();\n          this.randu = Ln(o.toString()), this.randn = new Bn(0, 1, n, !1, this.randu()), this.d = t < 1 ? t + 2 / 3 : t - 1 / 3, this.c = 1 / Math.sqrt(9 * this.d);\n        }\n\n        return t.prototype.nextValue = function () {\n          for (var t, e, n, r, o, i;;) {\n            do {\n              r = this.randn.nextValue(), i = 1 + this.c * r;\n            } while (i <= 0);\n\n            if (i *= i * i, e = 1 - .331 * (t = r * r) * t, n = .5 * t + this.d * (1 - i + Math.log(i)), (o = this.randu()) < e || Math.log(o) < n) break;\n          }\n\n          return i = 1 / this.beta * this.d * i, this.alpha < 1 && (i *= Math.pow(this.randu(), 1 / this.alpha)), this.convertValue(i);\n        }, t.prototype.convertValue = function (t) {\n          return \"float32\" === this.dtype ? t : Math.round(t);\n        }, t;\n      }(),\n          qn = function () {\n        function t(t, e, n, r) {\n          var o = this;\n          if (void 0 === t && (t = 0), void 0 === e && (e = 1), this.canReturnFloat = function () {\n            return null == o.dtype || \"float32\" === o.dtype;\n          }, this.min = t, this.range = e - t, this.dtype = n, null == r && (r = Math.random()), \"number\" == typeof r && (r = r.toString()), !this.canReturnFloat() && this.range <= 1) throw new Error(\"The difference between \" + t + \" - \" + e + \" <= 1 and dtype is not float\");\n          this.random = Ln(r);\n        }\n\n        return t.prototype.convertValue = function (t) {\n          return this.canReturnFloat() ? t : Math.round(t);\n        }, t.prototype.nextValue = function () {\n          return this.convertValue(this.min + this.range * this.random());\n        }, t;\n      }();\n\n      function Vn(t, e, n) {\n        return void 0 === e && (e = \"float32\"), e = e || \"float32\", nt(t), new ft(t, e, n);\n      }\n\n      var Un = an({\n        batchToSpaceND_: function (t, e, n) {\n          var r = $e(t, \"x\", \"batchToSpaceND\"),\n              o = e.reduce(function (t, e) {\n            return t * e;\n          });\n          return S(r.rank >= 1 + e.length, function () {\n            return \"input rank is \" + r.rank + \" but should be > than blockShape.length \" + e.length;\n          }), S(n.length === e.length, function () {\n            return \"crops.length is \" + n.length + \" but should be equal to blockShape.length  \" + e.length;\n          }), S(r.shape[0] % o == 0, function () {\n            return \"input tensor batch is \" + r.shape[0] + \" but is not divisible by the product of the elements of blockShape \" + e.join(\" * \") + \" === \" + o;\n          }), Mt.runKernelFunc(function (t) {\n            return t.batchToSpaceND(r, e, n);\n          }, {\n            $x: r\n          }, function (t) {\n            return {\n              $x: function () {\n                return t.spaceToBatchND(e, n);\n              }\n            };\n          });\n        }\n      }),\n          jn = an({\n        cast_: function (t, e) {\n          var n = $e(t, \"x\", \"cast\");\n          if (!z(e)) throw new Error(\"Failed to cast to unknown dtype \" + e);\n          if (\"string\" === e && \"string\" !== n.dtype || \"string\" !== e && \"string\" === n.dtype) throw new Error(\"Only strings can be casted to strings\");\n          var r = {\n            dtype: e\n          };\n          return Mt.runKernelFunc(function (t) {\n            return t.cast(n, e);\n          }, {\n            x: n\n          }, function (t) {\n            return {\n              x: function () {\n                return t.clone();\n              }\n            };\n          }, \"Cast\", r);\n        }\n      }),\n          Wn = an({\n        clone_: function (t) {\n          var e = $e(t, \"x\", \"clone\", null);\n          return Mt.runKernelFunc(function () {\n            return Mt.makeTensorFromDataId(e.dataId, e.shape, e.dtype);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return t.toFloat();\n              }\n            };\n          });\n        }\n      }),\n          Gn = an({\n        cumsum_: function (t, e, n, r) {\n          void 0 === e && (e = 0), void 0 === n && (n = !1), void 0 === r && (r = !1);\n          var o = $e(t, \"x\", \"cumsum\"),\n              i = tn([e |= 0], o.rank),\n              a = o;\n          null != i && (a = o.transpose(i));\n          var s = nn(1, o.rank)[0],\n              u = Mt.runKernelFunc(function (t) {\n            return t.cumsum(a, s, n, r);\n          }, {\n            permutedX: a\n          }, function (t) {\n            return {\n              permutedX: function () {\n                return t.cumsum(e, n, !r);\n              }\n            };\n          });\n          return null != i && (u = u.transpose(i)), u;\n        }\n      }),\n          Hn = an({\n        depthToSpace_: function (t, e, n) {\n          void 0 === n && (n = \"NHWC\");\n          var r = $e(t, \"x\", \"depthToSpace\"),\n              o = \"NHWC\" === n ? r.shape[1] : r.shape[2],\n              i = \"NHWC\" === n ? r.shape[2] : r.shape[3],\n              a = \"NHWC\" === n ? r.shape[3] : r.shape[1];\n          return S(o * e >= 0, function () {\n            return \"Negative dimension size caused by overflow when multiplying\\n      \" + o + \" and \" + e + \"  for depthToSpace with input shape\\n      \" + r.shape;\n          }), S(i * e >= 0, function () {\n            return \"Negative dimension size caused by overflow when multiplying\\n      \" + i + \" and \" + e + \" for depthToSpace with input shape\\n          \" + r.shape;\n          }), S(a % (e * e) == 0, function () {\n            return \"Dimension size must be evenly divisible by \" + e * e + \" but is \" + a + \" for depthToSpace with input shape \" + r.shape;\n          }), Mt.runKernelFunc(function (t) {\n            return t.depthToSpace(r, e, n);\n          }, {\n            $x: r\n          });\n        }\n      }),\n          $n = an({\n        expandDims_: function (t, e) {\n          void 0 === e && (e = 0);\n          var n = $e(t, \"x\", \"expandDims\", null);\n          S(e <= n.rank, function () {\n            return \"Axis must be <= rank of the tensor\";\n          });\n          var r = n.shape.slice();\n          return e < 0 && (S(-(n.rank + 1) <= e, function () {\n            return \"Axis must be in the interval [\" + -(n.rank + 1) + \", \" + n.rank + \"]\";\n          }), e = n.rank + e + 1), r.splice(e, 0, 1), ar(n, r);\n        }\n      }),\n          Kn = an({\n        eye_: function (t, e, n, r) {\n          void 0 === r && (r = \"float32\"), null == e && (e = t);\n\n          for (var o = Vn([t, e], r), i = t <= e ? t : e, a = 0; a < i; ++a) o.set(1, a, a);\n\n          var s = o.toTensor().as2D(t, e);\n          if (null == n) return s;\n          if (1 === n.length) return lr($n(s, 0), [n[0], 1, 1]);\n          if (2 === n.length) return lr($n($n(s, 0), 0), [n[0], n[1], 1, 1]);\n          if (3 === n.length) return lr($n($n($n(s, 0), 0), 0), [n[0], n[1], n[2], 1, 1]);\n          throw new Error(\"eye() currently supports only 1D and 2D batchShapes, but received \" + n.length + \"D.\");\n        }\n      }),\n          Qn = an({\n        multinomial_: function (t, e, n, r) {\n          void 0 === r && (r = !1);\n          var o = $e(t, \"logits\", \"multinomial\"),\n              i = o.size,\n              a = o.rank;\n          if (i < 2) throw new Error(\"Error in multinomial: you need at least 2 outcomes, but got \" + i + \".\");\n          if (a > 2) throw new Error(\"Rank of probabilities must be 1 or 2, but is \" + a);\n          n = n || Math.random();\n          var s = 1 === a ? o.as2D(1, -1) : o,\n              u = Mt.runKernelFunc(function (t) {\n            return t.multinomial(s, r, e, n);\n          }, {\n            logits2D: s\n          });\n          return 1 === a ? u.as1D() : u;\n        }\n      }),\n          Xn = an({\n        oneHot_: function (t, e, n, r) {\n          if (void 0 === n && (n = 1), void 0 === r && (r = 0), e < 2) throw new Error(\"Error in oneHot: depth must be >=2, but it is \" + e);\n          var o = $e(t, \"indices\", \"oneHot\", \"int32\"),\n              i = o.shape.concat([e]);\n          return o = o.flatten(), Mt.runKernelFunc(function (t) {\n            return t.oneHot(o, e, n, r);\n          }, {\n            $indices: o\n          }, function (t) {\n            return {\n              $indices: function () {\n                return yn(o.shape, \"float32\");\n              }\n            };\n          }).reshape(i);\n        }\n      }),\n          Yn = an({\n        pad_: function (t, e, n) {\n          void 0 === n && (n = 0);\n          var r = $e(t, \"x\", \"pad\");\n          if (0 === r.rank) throw new Error(\"pad(scalar) is not defined. Pass non-scalar to pad\");\n          var o = e.map(function (t) {\n            return t[0];\n          });\n          return Mt.runKernelFunc(function (t) {\n            return t.pad(r, e, n);\n          }, {\n            $x: r\n          }, function (t) {\n            return {\n              $x: function () {\n                return t.slice(o, r.shape);\n              }\n            };\n          });\n        }\n      }),\n          Jn = an({\n        pad1d_: function (t, e, n) {\n          return void 0 === n && (n = 0), S(2 === e.length, function () {\n            return \"Invalid number of paddings. Must be length of 2.\";\n          }), Yn(t, [e], n);\n        }\n      }),\n          Zn = an({\n        pad2d_: function (t, e, n) {\n          return void 0 === n && (n = 0), S(2 === e.length && 2 === e[0].length && 2 === e[1].length, function () {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n          }), Yn(t, e, n);\n        }\n      }),\n          tr = an({\n        pad3d_: function (t, e, n) {\n          return void 0 === n && (n = 0), S(3 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length, function () {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n          }), Yn(t, e, n);\n        }\n      }),\n          er = an({\n        pad4d_: function (t, e, n) {\n          return void 0 === n && (n = 0), S(4 === e.length && 2 === e[0].length && 2 === e[1].length && 2 === e[2].length && 2 === e[3].length, function () {\n            return \"Invalid number of paddings. Must be length of 2 each.\";\n          }), Yn(t, e, n);\n        }\n      }),\n          nr = an({\n        rand_: function (t, e, n) {\n          var r = A(t),\n              o = null;\n          if (null == n || \"float32\" === n) o = new Float32Array(r);else if (\"int32\" === n) o = new Int32Array(r);else {\n            if (\"bool\" !== n) throw new Error(\"Unknown data type \" + n);\n            o = new Uint8Array(r);\n          }\n\n          for (var i = 0; i < r; i++) o[i] = e();\n\n          return Mt.makeTensor(o, t, n);\n        }\n      }),\n          rr = an({\n        randomNormal_: function (t, e, n, r, o) {\n          if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && \"bool\" === r) throw new Error(\"Unsupported data type \" + r);\n\n          for (var i = new Bn(e, n, r, !1, o), a = Vn(t, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue();\n\n          return a.toTensor();\n        }\n      }),\n          or = an({\n        randomGamma_: function (t, e, n, r, o) {\n          if (void 0 === n && (n = 1), void 0 === r && (r = \"float32\"), null == n && (n = 1), null == r && (r = \"float32\"), \"float32\" !== r && \"int32\" !== r) throw new Error(\"Unsupported data type \" + r);\n\n          for (var i = new zn(e, n, r, o), a = Vn(t, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue();\n\n          return a.toTensor();\n        }\n      }),\n          ir = an({\n        randomUniform_: function (t, e, n, r, o) {\n          void 0 === e && (e = 0), void 0 === n && (n = 1), void 0 === r && (r = \"float32\");\n\n          for (var i = Vn(t, r), a = new qn(e, n, null, o), s = 0; s < i.values.length; s++) i.values[s] = a.nextValue();\n\n          return i.toTensor();\n        }\n      }),\n          ar = an({\n        reshape_: function (t, e) {\n          var n = $e(t, \"x\", \"reshape\", null);\n          e = M(e, n.size), S(n.size === A(e), function () {\n            return \"new shape and old shape must have the same number of elements.\";\n          });\n          var r = {\n            shape: e\n          };\n          return Mt.runKernelFunc(function (t) {\n            return t.reshape(n, e);\n          }, {\n            x: n\n          }, function (t) {\n            return {\n              x: function () {\n                return t.reshape(n.shape);\n              }\n            };\n          }, \"Reshape\", r);\n        }\n      }),\n          sr = an({\n        spaceToBatchND_: function (t, e, n) {\n          var r = $e(t, \"x\", \"spaceToBatchND\");\n          return S(r.rank >= 1 + e.length, function () {\n            return \"input rank \" + r.rank + \" should be > than [blockShape] \" + e.length;\n          }), S(n.length === e.length, function () {\n            return \"paddings.shape[0] \" + n.length + \" must be equal to [blockShape] \" + e.length;\n          }), S(r.shape.reduce(function (t, r, o) {\n            return o > 0 && o <= e.length ? t && (r + n[o - 1][0] + n[o - 1][1]) % e[o - 1] == 0 : t;\n          }, !0), function () {\n            return \"input spatial dimensions \" + r.shape.slice(1) + \" with paddings \" + n.toString() + \" must be divisible by blockShapes \" + e.toString();\n          }), Mt.runKernelFunc(function (t) {\n            return t.spaceToBatchND(r, e, n);\n          }, {\n            $x: r\n          }, function (t) {\n            return {\n              $x: function () {\n                return t.batchToSpaceND(e, n);\n              }\n            };\n          });\n        }\n      }),\n          ur = an({\n        squeeze_: function (t, e) {\n          var n = $e(t, \"x\", \"squeeze\");\n          return ar(n, D(n.shape, e).newShape);\n        }\n      }),\n          cr = an({\n        stack_: function (t, e) {\n          void 0 === e && (e = 0);\n          var n = Ke(t, \"tensors\", \"stack\");\n          if (S(n.length >= 1, function () {\n            return \"Pass at least one tensor to tf.stack\";\n          }), 1 === n.length) return n[0].expandDims(e);\n          var r = n[0].rank,\n              o = n[0].shape,\n              i = n[0].dtype;\n          S(e <= r, function () {\n            return \"Axis must be <= rank of the tensor\";\n          }), n.forEach(function (t) {\n            E(o, t.shape, \"All tensors passed to stack must have matching shapes\");\n          }), n.forEach(function (t) {\n            S(i === t.dtype, function () {\n              return \"All tensors passed to stack must have matching dtypes\";\n            });\n          });\n          var a = n.map(function (t) {\n            return t.expandDims(e);\n          });\n          return En(a, e);\n        }\n      }),\n          lr = an({\n        tile_: function (t, e) {\n          var n = $e(t, \"x\", \"tile\", null);\n          return S(n.rank === e.length, function () {\n            return \"Error in transpose: rank of input \" + n.rank + \" must match length of reps \" + e + \".\";\n          }), Mt.runKernelFunc(function (t, r) {\n            var o = t.tile(n, e);\n            return r([n]), o;\n          }, {\n            $x: n\n          }, function (t, n) {\n            var r = n[0];\n            return {\n              $x: function () {\n                var n = Sn(r);\n                if (1 === r.rank) for (var o = 0; o < e[0]; ++o) n = n.add(t.slice([o * r.shape[0]], [r.shape[0]]));else if (2 === r.rank) for (o = 0; o < e[0]; ++o) for (var i = 0; i < e[1]; ++i) n = n.add(t.slice([o * r.shape[0], i * r.shape[1]], [r.shape[0], r.shape[1]]));else if (3 === r.rank) for (o = 0; o < e[0]; ++o) for (i = 0; i < e[1]; ++i) for (var a = 0; a < e[2]; ++a) n = n.add(t.slice([o * r.shape[0], i * r.shape[1], a * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));else {\n                  if (4 !== r.rank) throw new Error(\"Gradient for tile operation is not implemented for rank-\" + r.rank + \" tensors yet.\");\n\n                  for (o = 0; o < e[0]; ++o) for (i = 0; i < e[1]; ++i) for (a = 0; a < e[2]; ++a) for (var s = 0; s < e[3]; ++s) n = n.add(t.slice([o * r.shape[0], i * r.shape[1], a * r.shape[2], s * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]));\n                }\n                return n;\n              }\n            };\n          });\n        }\n      }),\n          hr = an({\n        truncatedNormal_: function (t, e, n, r, o) {\n          if (void 0 === e && (e = 0), void 0 === n && (n = 1), null != r && \"bool\" === r) throw new Error(\"Unsupported data type \" + r);\n\n          for (var i = new Bn(e, n, r, !0, o), a = Vn(t, r), s = 0; s < a.values.length; s++) a.values[s] = i.nextValue();\n\n          return a.toTensor();\n        }\n      }),\n          pr = an({\n        unstack_: function (t, e) {\n          void 0 === e && (e = 0), e = e || 0;\n          var n = $e(t, \"x\", \"unstack\");\n          return S(e >= -n.shape.length && e < n.shape.length, function () {\n            return \"Axis = \" + e + \" is not in [-\" + n.shape.length + \", \" + n.shape.length + \")\";\n          }), e < 0 && (e += n.shape.length), Mt.runKernelFunc(function (t) {\n            return t.unstack(n, e);\n          }, {\n            $x: n\n          }, function (t) {\n            return {\n              $x: function () {\n                return cr(t, e);\n              }\n            };\n          });\n        }\n      });\n\n      function fr(t, e, n, r) {\n        void 0 === r && (r = !0);\n        var o = [];\n        if (r) (o = o.concat(e.slice(0))).push(t[0] / n), o = o.concat(t.slice(1));else {\n          o = o.concat(t[0]);\n\n          for (var i = e.length, a = 0; a < i; ++a) o = o.concat([t[a + 1] / e[a], e[a]]);\n\n          o = o.concat(t.slice(i + 1));\n        }\n        return o;\n      }\n\n      function dr(t, e, n) {\n        void 0 === n && (n = !0);\n        var r = [];\n\n        if (n) {\n          r.push(e);\n\n          for (var o = e + 1; o < t; ++o) o <= 2 * e ? (r.push(o), r.push(o - (e + 1))) : r.push(o);\n        } else {\n          var i = [],\n              a = [];\n\n          for (o = 1; o < t; ++o) o >= 2 * e + 1 || o % 2 == 1 ? a.push(o) : i.push(o);\n\n          r.push.apply(r, i), r.push(0), r.push.apply(r, a);\n        }\n\n        return r;\n      }\n\n      function mr(t, e, n, r) {\n        void 0 === r && (r = !0);\n        var o = [];\n        r ? o.push(t[0] / n) : o.push(t[0] * n);\n\n        for (var i = 1; i < t.length; ++i) i <= e.length ? r ? o.push(e[i - 1] * t[i]) : o.push(t[i] / e[i - 1]) : o.push(t[i]);\n\n        return o;\n      }\n\n      function gr(t, e) {\n        for (var n = [0], r = 0; r < e; ++r) n.push(t[r][0]);\n\n        return n;\n      }\n\n      function vr(t, e, n) {\n        for (var r = t.slice(0, 1), o = 0; o < n; ++o) r.push(t[o + 1] - e[o][0] - e[o][1]);\n\n        return r;\n      }\n\n      function yr(t, e) {\n        if (t.rank < 1) throw new Error(\"tf.gatherND() expects the input to be rank 1 or higher, but the rank was \" + t.rank + \".\");\n        if (e.rank < 1) throw new Error(\"tf.gatherND() expects the indices to be rank 1 or higher, but the rank was \" + e.rank + \".\");\n        if (\"int32\" !== e.dtype) throw new Error(\"tf.gatherND() expects the indices to be int32 type, but the dtype was \" + e.dtype + \".\");\n        if (e.shape[e.rank - 1] > t.rank) throw new Error(\"index innermost dimension length must be <= tensor rank; saw: \" + e.shape[e.rank - 1] + \" vs. \" + t.rank);\n        if (0 === t.size) throw new Error(\"Requested more than 0 entries, but input is empty. Input shape: \" + t.shape + \".\");\n\n        for (var n = e.shape, r = n[n.length - 1], o = 1, i = 0; i < n.length - 1; ++i) o *= n[i];\n\n        var a = t.shape,\n            s = n.slice();\n        s.pop();\n        var u = 1;\n\n        for (i = r; i < t.rank; ++i) u *= a[i], s.push(a[i]);\n\n        var c = X(t.shape).map(function (t) {\n          return t / u;\n        }).concat([1]).slice(0, r);\n        return [s, o, u, c];\n      }\n\n      var br = 30;\n\n      function wr(t) {\n        return t <= br ? t : Q(t, Math.floor(Math.sqrt(t)));\n      }\n\n      function xr(t, e, n) {\n        for (var r = e.rank > 1 ? e.shape[e.rank - 1] : 1, o = n.length, i = 1, a = r; a < o; ++a) i *= n[a];\n\n        var s = r < 1 ? 1 : r;\n        return {\n          sliceRank: r,\n          numUpdates: e.size / s,\n          sliceSize: i,\n          strides: X(n.slice(0, r)).concat([1]),\n          outputSize: A(n)\n        };\n      }\n\n      function Sr(t, e, n) {\n        S(t.rank === e.length, function () {\n          return \"Error in slice\" + t.rank + \"D: Length of begin \" + e + \" must match the rank of the array (\" + t.rank + \").\";\n        }), S(t.rank === n.length, function () {\n          return \"Error in slice\" + t.rank + \"D: Length of size \" + n + \" must match the rank of the array (\" + t.rank + \").\";\n        });\n\n        for (var r = function (r) {\n          S(e[r] + n[r] <= t.shape[r], function () {\n            return \"Error in slice\" + t.rank + \"D: begin[\" + r + \"] + size[\" + r + \"] (\" + (e[r] + n[r]) + \") would overflow input.shape[\" + r + \"] (\" + t.shape[r] + \")\";\n          });\n        }, o = 0; o < t.rank; ++o) r(o);\n      }\n\n      function Er(t) {\n        for (var e = [], n = 0; t > 0;) 1 & t && e.push(n), t /= 2, n++;\n\n        return e;\n      }\n\n      function Cr(t, e, n) {\n        for (var r = [], o = 0; o < t.length; o++) r[o] = Math.ceil((e[o] - t[o]) / n[o]);\n\n        return r;\n      }\n\n      function Ir(t, e, n, r, o) {\n        var i = e[o],\n            a = n[o] || 1;\n        (t & 1 << o || null == i) && (i = a > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);\n        var s = r[o];\n        return i < 0 && (i += s), b(0, i, s - 1);\n      }\n\n      function Ar(t, e, n, r, o) {\n        var i = e[o],\n            a = n[o] || 1;\n        (t & 1 << o || null == i) && (i = a > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);\n        var s = r[o];\n        return i < 0 && (i += s), a > 0 ? b(0, i, s) : b(-1, i, s - 1);\n      }\n\n      function kr(t, e, n) {\n        for (var r = n.length, o = 0; o < n.length; o++) if (n[o] > 1) {\n          r = o;\n          break;\n        }\n\n        for (o = r + 1; o < n.length; o++) if (e[o] > 0 || n[o] !== t[o]) return !1;\n\n        return !0;\n      }\n\n      function Tr(t, e) {\n        for (var n = t.length > 0 ? t[t.length - 1] : 1, r = 0; r < t.length - 1; r++) n += t[r] * e[r];\n\n        return n;\n      }\n\n      Object.freeze({\n        assertParamsValid: Sr,\n        maskToAxes: Er,\n        computeOutShape: Cr,\n        startForAxis: Ir,\n        stopForAxis: Ar,\n        isSliceContinous: kr,\n        computeFlatOffset: Tr\n      });\n\n      function Nr(t) {\n        return Mt.customGrad(t);\n      }\n\n      var Pr = an({\n        softmax_: function (t, e) {\n          void 0 === e && (e = -1);\n          var n = $e(t, \"logits\", \"softmax\");\n          if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error(\"Softmax along a non-last dimension is not yet supported. Logits was rank \" + n.rank + \" and dim was \" + e);\n          return Nr(function (t, n) {\n            var r = t.logSumExp([e], !0),\n                o = t.toFloat().sub(r).exp();\n            return n([o]), {\n              value: o,\n              gradFunc: function (t, n) {\n                var r = n[0],\n                    o = t.mul(r);\n                return o.sub(o.sum([e], !0).mul(r));\n              }\n            };\n          })(n);\n        }\n      }),\n          Rr = an({\n        logSoftmax_: function (t, e) {\n          void 0 === e && (e = -1);\n          var n = $e(t, \"logits\", \"logSoftmax\");\n          if (-1 === e && (e = n.rank - 1), e !== n.rank - 1) throw Error(\"Log Softmax along a non-last dimension is not yet supported. Logits was rank \" + n.rank + \" and axis was \" + e);\n          return Nr(function (t, n) {\n            var r = t.max(e, !0),\n                o = t.sub(r),\n                i = o.toFloat().sub(o.exp().sum(e, !0).log());\n            return n([i]), {\n              value: i,\n              gradFunc: function (t, n) {\n                var r = n[0].exp();\n                return t.sub(t.sum(e, !0).mul(r));\n              }\n            };\n          })(n);\n        }\n      }),\n          _r = function () {\n        function t(t, e) {\n          this.backend = t, this.dataMover = e, this.data = new WeakMap(), this.dataIdsCount = 0;\n        }\n\n        return t.prototype.get = function (t) {\n          return this.data.has(t) || this.dataMover.moveData(this.backend, t), this.data.get(t);\n        }, t.prototype.set = function (t, e) {\n          this.dataIdsCount++, this.data.set(t, e);\n        }, t.prototype.has = function (t) {\n          return this.data.has(t);\n        }, t.prototype.delete = function (t) {\n          return this.dataIdsCount--, this.data.delete(t);\n        }, t.prototype.numDataIds = function () {\n          return this.dataIdsCount;\n        }, t;\n      }(),\n          Mr = function () {\n        function t() {}\n\n        return t.prototype.time = function (t) {\n          return Or();\n        }, t.prototype.read = function (t) {\n          return Or();\n        }, t.prototype.readSync = function (t) {\n          return Or();\n        }, t.prototype.numDataIds = function () {\n          return Or();\n        }, t.prototype.disposeData = function (t) {\n          return Or();\n        }, t.prototype.fromPixels = function (t, e) {\n          return Or();\n        }, t.prototype.write = function (t, e, n) {\n          return Or();\n        }, t.prototype.move = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.memory = function () {\n          return Or();\n        }, t.prototype.floatPrecision = function () {\n          return Or();\n        }, t.prototype.epsilon = function () {\n          return 32 === this.floatPrecision() ? 1e-7 : 1e-4;\n        }, t.prototype.batchMatMul = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.fusedBatchMatMul = function (t) {\n          return t.a, t.b, t.transposeA, t.transposeB, t.bias, t.activation, t.preluActivationWeights, Or();\n        }, t.prototype.slice = function (t, e, n) {\n          return Or();\n        }, t.prototype.stridedSlice = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.unstack = function (t, e) {\n          return Or();\n        }, t.prototype.reverse = function (t, e) {\n          return Or();\n        }, t.prototype.concat = function (t, e) {\n          return Or();\n        }, t.prototype.neg = function (t) {\n          return Or();\n        }, t.prototype.add = function (t, e) {\n          return Or();\n        }, t.prototype.addN = function (t) {\n          return Or();\n        }, t.prototype.subtract = function (t, e) {\n          return Or();\n        }, t.prototype.multiply = function (t, e) {\n          return Or();\n        }, t.prototype.realDivide = function (t, e) {\n          return Or();\n        }, t.prototype.floorDiv = function (t, e) {\n          return Or();\n        }, t.prototype.sum = function (t, e) {\n          return Or();\n        }, t.prototype.prod = function (t, e) {\n          return Or();\n        }, t.prototype.unsortedSegmentSum = function (t, e, n) {\n          return Or();\n        }, t.prototype.argMin = function (t, e) {\n          return Or();\n        }, t.prototype.argMax = function (t, e) {\n          return Or();\n        }, t.prototype.equal = function (t, e) {\n          return Or();\n        }, t.prototype.notEqual = function (t, e) {\n          return Or();\n        }, t.prototype.less = function (t, e) {\n          return Or();\n        }, t.prototype.lessEqual = function (t, e) {\n          return Or();\n        }, t.prototype.greater = function (t, e) {\n          return Or();\n        }, t.prototype.greaterEqual = function (t, e) {\n          return Or();\n        }, t.prototype.logicalNot = function (t) {\n          return Or();\n        }, t.prototype.logicalAnd = function (t, e) {\n          return Or();\n        }, t.prototype.logicalOr = function (t, e) {\n          return Or();\n        }, t.prototype.where = function (t) {\n          return Or();\n        }, t.prototype.select = function (t, e, n) {\n          return Or();\n        }, t.prototype.topk = function (t, e, n) {\n          return Or();\n        }, t.prototype.min = function (t, e) {\n          return Or();\n        }, t.prototype.minimum = function (t, e) {\n          return Or();\n        }, t.prototype.mod = function (t, e) {\n          return Or();\n        }, t.prototype.max = function (t, e) {\n          return Or();\n        }, t.prototype.maximum = function (t, e) {\n          return Or();\n        }, t.prototype.all = function (t, e) {\n          return Or();\n        }, t.prototype.any = function (t, e) {\n          return Or();\n        }, t.prototype.squaredDifference = function (t, e) {\n          return Or();\n        }, t.prototype.ceil = function (t) {\n          return Or();\n        }, t.prototype.floor = function (t) {\n          return Or();\n        }, t.prototype.round = function (t) {\n          return Or();\n        }, t.prototype.sign = function (t) {\n          return Or();\n        }, t.prototype.isNaN = function (t) {\n          return Or();\n        }, t.prototype.isInf = function (t) {\n          return Or();\n        }, t.prototype.isFinite = function (t) {\n          return Or();\n        }, t.prototype.pow = function (t, e) {\n          return Or();\n        }, t.prototype.exp = function (t) {\n          return Or();\n        }, t.prototype.expm1 = function (t) {\n          return Or();\n        }, t.prototype.log = function (t) {\n          return Or();\n        }, t.prototype.log1p = function (t) {\n          return Or();\n        }, t.prototype.sqrt = function (t) {\n          return Or();\n        }, t.prototype.rsqrt = function (t) {\n          return Or();\n        }, t.prototype.square = function (t) {\n          return Or();\n        }, t.prototype.reciprocal = function (t) {\n          return Or();\n        }, t.prototype.relu = function (t) {\n          return Or();\n        }, t.prototype.relu6 = function (t) {\n          return Or();\n        }, t.prototype.prelu = function (t, e) {\n          return Or();\n        }, t.prototype.elu = function (t) {\n          return Or();\n        }, t.prototype.eluDer = function (t, e) {\n          return Or();\n        }, t.prototype.selu = function (t) {\n          return Or();\n        }, t.prototype.int = function (t) {\n          return Or();\n        }, t.prototype.clip = function (t, e, n) {\n          return Or();\n        }, t.prototype.abs = function (t) {\n          return Or();\n        }, t.prototype.complexAbs = function (t) {\n          return Or();\n        }, t.prototype.sigmoid = function (t) {\n          return Or();\n        }, t.prototype.softplus = function (t) {\n          return Or();\n        }, t.prototype.sin = function (t) {\n          return Or();\n        }, t.prototype.cos = function (t) {\n          return Or();\n        }, t.prototype.tan = function (t) {\n          return Or();\n        }, t.prototype.asin = function (t) {\n          return Or();\n        }, t.prototype.acos = function (t) {\n          return Or();\n        }, t.prototype.atan = function (t) {\n          return Or();\n        }, t.prototype.atan2 = function (t, e) {\n          return Or();\n        }, t.prototype.sinh = function (t) {\n          return Or();\n        }, t.prototype.cosh = function (t) {\n          return Or();\n        }, t.prototype.tanh = function (t) {\n          return Or();\n        }, t.prototype.asinh = function (t) {\n          return Or();\n        }, t.prototype.acosh = function (t) {\n          return Or();\n        }, t.prototype.atanh = function (t) {\n          return Or();\n        }, t.prototype.erf = function (t) {\n          return Or();\n        }, t.prototype.step = function (t, e) {\n          return Or();\n        }, t.prototype.fusedConv2d = function (t) {\n          return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, Or();\n        }, t.prototype.conv2d = function (t, e, n) {\n          return Or();\n        }, t.prototype.conv2dDerInput = function (t, e, n) {\n          return Or();\n        }, t.prototype.conv2dDerFilter = function (t, e, n) {\n          return Or();\n        }, t.prototype.fusedDepthwiseConv2D = function (t) {\n          return t.input, t.filter, t.convInfo, t.bias, t.activation, t.preluActivationWeights, Or();\n        }, t.prototype.depthwiseConv2D = function (t, e, n) {\n          return Or();\n        }, t.prototype.depthwiseConv2DDerInput = function (t, e, n) {\n          return Or();\n        }, t.prototype.depthwiseConv2DDerFilter = function (t, e, n) {\n          return Or();\n        }, t.prototype.conv3d = function (t, e, n) {\n          return Or();\n        }, t.prototype.conv3dDerInput = function (t, e, n) {\n          return Or();\n        }, t.prototype.conv3dDerFilter = function (t, e, n) {\n          return Or();\n        }, t.prototype.maxPool = function (t, e) {\n          return Or();\n        }, t.prototype.maxPoolBackprop = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.avgPool = function (t, e) {\n          return Or();\n        }, t.prototype.avgPoolBackprop = function (t, e, n) {\n          return Or();\n        }, t.prototype.avgPool3d = function (t, e) {\n          return Or();\n        }, t.prototype.avgPool3dBackprop = function (t, e, n) {\n          return Or();\n        }, t.prototype.maxPool3d = function (t, e) {\n          return Or();\n        }, t.prototype.maxPool3dBackprop = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.reshape = function (t, e) {\n          return Or();\n        }, t.prototype.cast = function (t, e) {\n          return Or();\n        }, t.prototype.tile = function (t, e) {\n          return Or();\n        }, t.prototype.pad = function (t, e, n) {\n          return Or();\n        }, t.prototype.transpose = function (t, e) {\n          return Or();\n        }, t.prototype.gather = function (t, e, n) {\n          return Or();\n        }, t.prototype.gatherND = function (t, e) {\n          return Or();\n        }, t.prototype.scatterND = function (t, e, n) {\n          return Or();\n        }, t.prototype.batchToSpaceND = function (t, e, n) {\n          return Or();\n        }, t.prototype.spaceToBatchND = function (t, e, n) {\n          return Or();\n        }, t.prototype.resizeBilinear = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.resizeBilinearBackprop = function (t, e, n) {\n          return Or();\n        }, t.prototype.resizeNearestNeighbor = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.resizeNearestNeighborBackprop = function (t, e, n) {\n          return Or();\n        }, t.prototype.batchNormalization = function (t, e, n, r, o, i) {\n          return Or();\n        }, t.prototype.localResponseNormalization4D = function (t, e, n, r, o) {\n          return Or();\n        }, t.prototype.LRNGrad = function (t, e, n, r, o, i, a) {\n          return Or();\n        }, t.prototype.multinomial = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.oneHot = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.cumsum = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.nonMaxSuppression = function (t, e, n, r, o) {\n          return Or();\n        }, t.prototype.fft = function (t) {\n          return Or();\n        }, t.prototype.ifft = function (t) {\n          return Or();\n        }, t.prototype.complex = function (t, e) {\n          return Or();\n        }, t.prototype.real = function (t) {\n          return Or();\n        }, t.prototype.imag = function (t) {\n          return Or();\n        }, t.prototype.cropAndResize = function (t, e, n, r, o, i) {\n          return Or();\n        }, t.prototype.depthToSpace = function (t, e, n) {\n          return Or();\n        }, t.prototype.split = function (t, e, n) {\n          return Or();\n        }, t.prototype.sparseToDense = function (t, e, n, r) {\n          return Or();\n        }, t.prototype.diag = function (t) {\n          return Or();\n        }, t.prototype.fill = function (t, e, n) {\n          throw new Error(\"Not yet implemented.\");\n        }, t.prototype.onesLike = function (t) {\n          return Or();\n        }, t.prototype.zerosLike = function (t) {\n          return Or();\n        }, t.prototype.linspace = function (t, e, n) {\n          return Or();\n        }, t.prototype.dispose = function () {\n          return Or();\n        }, t;\n      }();\n\n      function Or() {\n        throw new Error(\"Not yet implemented or not found in the registry. Did you forget to import the kernel?\");\n      }\n\n      function Dr(t, e) {\n        for (var n = t.length, r = [], o = 0; o < n; o++) {\n          var i = n - 1 - o,\n              a = t[i] || 1;\n          (e[e.length - 1 - o] || 1) > 1 && 1 === a && r.unshift(i);\n        }\n\n        return r;\n      }\n\n      function Fr(t, e) {\n        for (var n = [], r = 0; r < e.length; r++) {\n          var o = t[t.length - r - 1],\n              i = e.length - r - 1,\n              a = e[i];\n          (null == o || 1 === o && a > 1) && n.unshift(i);\n        }\n\n        return n;\n      }\n\n      function Lr(t, e) {\n        for (var n = [], r = Math.max(t.length, e.length), o = 0; o < r; o++) {\n          var i = t[t.length - o - 1];\n          null == i && (i = 1);\n          var a = e[e.length - o - 1];\n          if (null == a && (a = 1), 1 === i) n.unshift(a);else if (1 === a) n.unshift(i);else {\n            if (i !== a) throw Error(\"Operands could not be broadcast together with shapes \" + t + \" and \" + e + \".\");\n            n.unshift(i);\n          }\n        }\n\n        return n;\n      }\n\n      function Br(t, e, n, r, o, i, a) {\n        void 0 === a && (a = \"channelsLast\");\n        var s,\n            u = jr(e),\n            c = u[0],\n            l = u[1];\n        if (\"channelsLast\" === a) s = [c, l, t[3], t[3]];else {\n          if (\"channelsFirst\" !== a) throw new Error(\"Unknown dataFormat \" + a);\n          s = [c, l, t[1], t[1]];\n        }\n        return qr(t, s, n, r, o, i, !1, a);\n      }\n\n      function zr(t, e, n, r, o, i, a) {\n        void 0 === a && (a = \"NDHWC\");\n        var s,\n            u,\n            c = Wr(e),\n            l = c[0],\n            h = c[1],\n            p = c[2];\n        if (\"NDHWC\" === a) u = \"channelsLast\", s = [l, h, p, t[4], t[4]];else {\n          if (\"NCDHW\" !== a) throw new Error(\"Unknown dataFormat \" + a);\n          u = \"channelsFirst\", s = [l, h, p, t[1], t[1]];\n        }\n        return Vr(t, s, n, r, o, !1, u, i);\n      }\n\n      function qr(t, e, n, r, o, i, a, s) {\n        void 0 === a && (a = !1), void 0 === s && (s = \"channelsLast\");\n        var u = [-1, -1, -1, -1],\n            c = u[0],\n            l = u[1],\n            h = u[2],\n            p = u[3];\n        if (\"channelsLast\" === s) c = t[0], l = t[1], h = t[2], p = t[3];else {\n          if (\"channelsFirst\" !== s) throw new Error(\"Unknown dataFormat \" + s);\n          c = t[0], p = t[1], l = t[2], h = t[3];\n        }\n\n        var f,\n            d = e[0],\n            m = e[1],\n            g = e[3],\n            v = jr(n),\n            y = v[0],\n            b = v[1],\n            w = jr(r),\n            x = w[0],\n            E = w[1],\n            C = Gr(d, x),\n            I = Gr(m, E),\n            A = function (t, e, n, r, o, i, a, s) {\n          var u, c, l;\n\n          if (\"number\" == typeof t) {\n            u = {\n              top: t,\n              bottom: t,\n              left: t,\n              right: t,\n              type: 0 === t ? \"VALID\" : \"NUMBER\"\n            };\n\n            var h = function (t, e, n, r, o) {\n              null == r && (r = Ur(t, e, n));\n              var i = t[1],\n                  a = Hr((t[0] - e + 2 * r) / n + 1, o);\n              S(T(a), function () {\n                return \"The output # of rows (\" + a + \") must be an integer. Change the stride and/or zero pad parameters\";\n              });\n              var s = Hr((i - e + 2 * r) / n + 1, o);\n              return S(T(s), function () {\n                return \"The output # of columns (\" + s + \") must be an integer. Change the stride and/or zero pad parameters\";\n              }), [a, s];\n            }([e, n], i, r, t, s);\n\n            c = h[0], l = h[1];\n          } else if (\"same\" === t) {\n            c = Math.ceil(e / r), l = Math.ceil(n / o);\n            var p = Math.max(0, (c - 1) * r + i - e),\n                f = Math.max(0, (l - 1) * o + a - n),\n                d = Math.floor(p / 2),\n                m = p - d,\n                g = Math.floor(f / 2);\n            u = {\n              top: d,\n              bottom: m,\n              left: g,\n              right: f - g,\n              type: \"SAME\"\n            };\n          } else {\n            if (\"valid\" !== t) throw Error(\"Unknown padding parameter: \" + t);\n            u = {\n              top: 0,\n              bottom: 0,\n              left: 0,\n              right: 0,\n              type: \"VALID\"\n            }, c = Math.ceil((e - i + 1) / r), l = Math.ceil((n - a + 1) / o);\n          }\n\n          return {\n            padInfo: u,\n            outHeight: c,\n            outWidth: l\n          };\n        }(o, l, h, y, b, C, I, i),\n            k = A.padInfo,\n            N = A.outHeight,\n            P = A.outWidth,\n            R = a ? g * p : g;\n\n        return \"channelsFirst\" === s ? f = [c, R, N, P] : \"channelsLast\" === s && (f = [c, N, P, R]), {\n          batchSize: c,\n          dataFormat: s,\n          inHeight: l,\n          inWidth: h,\n          inChannels: p,\n          outHeight: N,\n          outWidth: P,\n          outChannels: R,\n          padInfo: k,\n          strideHeight: y,\n          strideWidth: b,\n          filterHeight: d,\n          filterWidth: m,\n          effectiveFilterHeight: C,\n          effectiveFilterWidth: I,\n          dilationHeight: x,\n          dilationWidth: E,\n          inShape: t,\n          outShape: f,\n          filterShape: e\n        };\n      }\n\n      function Vr(t, e, n, r, o, i, a, s) {\n        void 0 === i && (i = !1), void 0 === a && (a = \"channelsLast\");\n        var u = [-1, -1, -1, -1, -1],\n            c = u[0],\n            l = u[1],\n            h = u[2],\n            p = u[3],\n            f = u[4];\n        if (\"channelsLast\" === a) c = t[0], l = t[1], h = t[2], p = t[3], f = t[4];else {\n          if (\"channelsFirst\" !== a) throw new Error(\"Unknown dataFormat \" + a);\n          c = t[0], f = t[1], l = t[2], h = t[3], p = t[4];\n        }\n\n        var d,\n            m = e[0],\n            g = e[1],\n            v = e[2],\n            y = e[4],\n            b = Wr(n),\n            w = b[0],\n            x = b[1],\n            E = b[2],\n            C = Wr(r),\n            I = C[0],\n            A = C[1],\n            k = C[2],\n            N = Gr(m, I),\n            P = Gr(g, A),\n            R = Gr(v, k),\n            _ = function (t, e, n, r, o, i, a, s, u, c, l) {\n          var h, p, f, d;\n\n          if (\"number\" == typeof t) {\n            h = {\n              top: t,\n              bottom: t,\n              left: t,\n              right: t,\n              front: t,\n              back: t,\n              type: 0 === t ? \"VALID\" : \"NUMBER\"\n            };\n\n            var m = function (t, e, n, r, o, i) {\n              null == o && (o = Ur(t, e, r));\n              var a = t[1],\n                  s = t[2],\n                  u = Hr((t[0] - e + 2 * o) / r + 1, i);\n              S(T(u), function () {\n                return \"The output # of depths (\" + u + \") must be an integer. Change the stride and/or zero pad parameters\";\n              });\n              var c = Hr((a - e + 2 * o) / r + 1, i);\n              S(T(c), function () {\n                return \"The output # of rows (\" + c + \") must be an integer. Change the stride and/or zero pad parameters\";\n              });\n              var l = Hr((s - e + 2 * o) / r + 1, i);\n              return S(T(l), function () {\n                return \"The output # of columns (\" + l + \") must be an integer. Change the stride and/or zero pad parameters\";\n              }), [u, c, l, 1];\n            }([e, n, r, 1], s, 0, o, t, l);\n\n            p = m[0], f = m[1], d = m[2];\n          } else if (\"same\" === t) {\n            var g = ((p = Math.ceil(e / o)) - 1) * o + s - e,\n                v = ((f = Math.ceil(n / i)) - 1) * i + u - n,\n                y = ((d = Math.ceil(r / a)) - 1) * a + c - r,\n                b = Math.floor(g / 2),\n                w = g - b,\n                x = Math.floor(v / 2),\n                E = v - x,\n                C = Math.floor(y / 2);\n            h = {\n              top: x,\n              bottom: E,\n              left: C,\n              right: y - C,\n              front: b,\n              back: w,\n              type: \"SAME\"\n            };\n          } else {\n            if (\"valid\" !== t) throw Error(\"Unknown padding parameter: \" + t);\n            h = {\n              top: 0,\n              bottom: 0,\n              left: 0,\n              right: 0,\n              front: 0,\n              back: 0,\n              type: \"VALID\"\n            }, p = Math.ceil((e - s + 1) / o), f = Math.ceil((n - u + 1) / i), d = Math.ceil((r - c + 1) / a);\n          }\n\n          return {\n            padInfo: h,\n            outDepth: p,\n            outHeight: f,\n            outWidth: d\n          };\n        }(o, l, h, p, w, x, E, N, P, R, s),\n            M = _.padInfo,\n            O = _.outDepth,\n            D = _.outHeight,\n            F = _.outWidth,\n            L = i ? y * f : y;\n\n        return \"channelsFirst\" === a ? d = [c, L, O, D, F] : \"channelsLast\" === a && (d = [c, O, D, F, L]), {\n          batchSize: c,\n          dataFormat: a,\n          inDepth: l,\n          inHeight: h,\n          inWidth: p,\n          inChannels: f,\n          outDepth: O,\n          outHeight: D,\n          outWidth: F,\n          outChannels: L,\n          padInfo: M,\n          strideDepth: w,\n          strideHeight: x,\n          strideWidth: E,\n          filterDepth: m,\n          filterHeight: g,\n          filterWidth: v,\n          effectiveFilterDepth: N,\n          effectiveFilterHeight: P,\n          effectiveFilterWidth: R,\n          dilationDepth: I,\n          dilationHeight: A,\n          dilationWidth: k,\n          inShape: t,\n          outShape: d,\n          filterShape: e\n        };\n      }\n\n      function Ur(t, e, n, r) {\n        void 0 === r && (r = 1);\n        var o = Gr(e, r);\n        return Math.floor((t[0] * (n - 1) - n + o) / 2);\n      }\n\n      function jr(t) {\n        return \"number\" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t;\n      }\n\n      function Wr(t) {\n        return \"number\" == typeof t ? [t, t, t] : t;\n      }\n\n      function Gr(t, e) {\n        return e <= 1 ? t : t + (t - 1) * (e - 1);\n      }\n\n      function Hr(t, e) {\n        if (!e) return t;\n\n        switch (e) {\n          case \"round\":\n            return Math.round(t);\n\n          case \"ceil\":\n            return Math.ceil(t);\n\n          case \"floor\":\n            return Math.floor(t);\n\n          default:\n            throw new Error(\"Unknown roundingMode \" + e);\n        }\n      }\n\n      function $r(t) {\n        var e = jr(t),\n            n = e[0],\n            r = e[1],\n            o = e[2];\n        return 1 === n && 1 === r && 1 === o;\n      }\n\n      function Kr(t, e) {\n        return $r(t) || $r(e);\n      }\n\n      function Qr(t) {\n        if (\"NHWC\" === t) return \"channelsLast\";\n        if (\"NCHW\" === t) return \"channelsFirst\";\n        throw new Error(\"Unknown dataFormat \" + t);\n      }\n\n      function Xr(t, e, n) {\n        if (\"complex64\" === e) {\n          if (\"complex64\" === t.dtype) return t.clone();\n          var r = yn(t.shape),\n              o = t.toFloat(),\n              i = n.complex(o, r);\n          return r.dispose(), o.dispose(), i;\n        }\n\n        if (!q(t.dtype, e)) return Mt.makeTensorFromDataId(t.dataId, t.shape, e);\n\n        if (\"complex64\" === t.dtype) {\n          var a = n.real(t);\n          return i = a.cast(e), a.dispose(), i;\n        }\n\n        if (\"int32\" === e) return n.int(t);\n\n        if (\"bool\" === e) {\n          var s = pn(0, t.dtype);\n          return i = n.notEqual(t, s), s.dispose(), i;\n        }\n\n        throw new Error(\"Error in Cast: failed to cast \" + t.dtype + \" to \" + e);\n      }\n\n      function Yr(t, e) {\n        return Mt.makeTensorFromDataId(t.dataId, e, t.dtype);\n      }\n\n      function Jr(t, e, n) {\n        var r = (e - t) / (n - 1),\n            o = tt(n, \"float32\");\n        o[0] = t;\n\n        for (var i = 1; i < o.length; i++) o[i] = o[i - 1] + r;\n\n        return fn(o, \"float32\");\n      }\n\n      Object.freeze({\n        castTensor: Xr,\n        reshapeTensor: Yr,\n        linspaceImpl: Jr,\n        upcastType: It,\n        axesAreInnerMostDims: Qe,\n        combineLocations: Xe,\n        computeOutAndReduceShapes: Ye,\n        expandShapeToKeepDim: Je,\n        assertAxesAreInnerMostDims: Ze,\n        getAxesPermutation: tn,\n        getUndoAxesPermutation: en,\n        getInnerMostAxes: nn,\n        getBroadcastDims: Dr,\n        getReductionAxes: Fr,\n        assertAndGetBroadcastShape: Lr,\n        assertParamsConsistent: rn,\n        computeOutShape: on,\n        computePool2DInfo: Br,\n        computePool3DInfo: zr,\n        computeConv2DInfo: qr,\n        computeConv3DInfo: Vr,\n        computeDefaultPad: Ur,\n        tupleValuesAreOne: $r,\n        eitherStridesOrDilationsAreOne: Kr,\n        convertConv2DDataFormat: Qr\n      });\n\n      function Zr(t, e) {\n        if (t.length !== e.length) throw new Error(\"Cannot merge real and imag arrays of different lengths. real:\" + t.length + \", imag: \" + e.length + \".\");\n\n        for (var n = new Float32Array(2 * t.length), r = 0; r < n.length; r += 2) n[r] = t[r / 2], n[r + 1] = e[r / 2];\n\n        return n;\n      }\n\n      function to(t, e) {\n        return {\n          real: t[2 * e],\n          imag: t[2 * e + 1]\n        };\n      }\n\n      function eo(t, e, n, r) {\n        t[2 * r] = e, t[2 * r + 1] = n;\n      }\n\n      function no(t, e, n) {\n        var r = (n ? 2 : -2) * Math.PI * (t / e);\n        return {\n          real: Math.cos(r),\n          imag: Math.sin(r)\n        };\n      }\n\n      function ro(t, e, n, r, o) {\n        for (var i = Array.from(e).map(function (t, e) {\n          return {\n            score: t,\n            boxIndex: e\n          };\n        }).filter(function (t) {\n          return t.score > o;\n        }).sort(function (t, e) {\n          return e.score - t.score;\n        }), a = [], s = 0; s < i.length; s++) {\n          var u = i[s],\n              c = u.score,\n              l = u.boxIndex;\n          if (c < o) break;\n\n          for (var h = !1, p = a.length - 1; p >= 0; --p) if (oo(t, l, a[p]) >= r) {\n            h = !0;\n            break;\n          }\n\n          if (!h && (a.push(l), a.length >= n)) break;\n        }\n\n        return fn(a, \"int32\");\n      }\n\n      function oo(t, e, n) {\n        var r = t.subarray(4 * e, 4 * e + 4),\n            o = t.subarray(4 * n, 4 * n + 4),\n            i = Math.min(r[0], r[2]),\n            a = Math.min(r[1], r[3]),\n            s = Math.max(r[0], r[2]),\n            u = Math.max(r[1], r[3]),\n            c = Math.min(o[0], o[2]),\n            l = Math.min(o[1], o[3]),\n            h = Math.max(o[0], o[2]),\n            p = Math.max(o[1], o[3]),\n            f = (s - i) * (u - a),\n            d = (h - c) * (p - l);\n        if (f <= 0 || d <= 0) return 0;\n        var m = Math.max(i, c),\n            g = Math.max(a, l),\n            v = Math.min(s, h),\n            y = Math.min(u, p),\n            b = Math.max(v - m, 0) * Math.max(y - g, 0);\n        return b / (f + d - b);\n      }\n\n      function io(t, e, n) {\n        var r = new Array(t.rank).fill(0),\n            o = t.shape.slice();\n        return e.map(function (e) {\n          o[n] = e;\n          var i = t.slice(r, o);\n          return r[n] += e, i;\n        });\n      }\n\n      function ao(t, e) {\n        for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[r] * e[r];\n\n        var o = Vn(n, t.dtype);\n\n        for (r = 0; r < o.values.length; ++r) {\n          for (var i = o.indexToLoc(r), a = new Array(t.rank), s = 0; s < a.length; s++) a[s] = i[s] % t.shape[s];\n\n          var u = t.locToIndex(a);\n          o.values[r] = t.values[u];\n        }\n\n        return o.toTensor();\n      }\n\n      function so(t, e, n, r, o) {\n        for (var i = e[e.length - 1], a = [t.length / i, i], s = a[0], u = a[1], c = F(n, s * r), l = F(\"int32\", s * r), h = 0; h < s; h++) {\n          for (var p = h * u, f = t.subarray(p, p + u), d = [], m = 0; m < f.length; m++) d.push({\n            value: f[m],\n            index: m\n          });\n\n          d.sort(function (t, e) {\n            return e.value - t.value;\n          });\n          var g = h * r,\n              v = c.subarray(g, g + r),\n              y = l.subarray(g, g + r);\n\n          for (m = 0; m < r; m++) v[m] = d[m].value, y[m] = d[m].index;\n        }\n\n        var b = e.slice();\n        return b[b.length - 1] = r, [ln(c, b, n), ln(l, b, \"int32\")];\n      }\n\n      function uo(t, e) {\n        for (var n = [], r = 0; r < e.length; r++) e[r] && n.push(r);\n\n        var o = Vn(t, \"int32\"),\n            i = Vn([n.length, t.length], \"int32\");\n\n        for (r = 0; r < n.length; r++) {\n          var a = o.indexToLoc(n[r]),\n              s = r * t.length;\n          i.values.set(a, s);\n        }\n\n        return i.toTensor();\n      }\n\n      var co = function (t, e) {\n        this.outputShape = [], this.outputShape = t, this.variableNames = e.map(function (t, e) {\n          return \"T\" + e;\n        });\n        var n = [];\n        this.variableNames.forEach(function (t) {\n          n.push(\"float v\" + t + \" = get\" + t + \"AtOutCoords();\");\n        });\n        var r = this.variableNames.map(function (t) {\n          return \"v\" + t;\n        }).join(\" + \");\n        this.userCode = \"\\n      void main() {\\n        \" + n.join(\"\\n        \") + \"\\n\\n        float result = \" + r + \";\\n        setOutput(result);\\n      }\\n    \";\n      },\n          lo = function (t, e) {\n        this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.variableNames = e.map(function (t, e) {\n          return \"T\" + e;\n        });\n        var n = [];\n        this.variableNames.forEach(function (t) {\n          n.push(\"vec4 v\" + t + \" = get\" + t + \"AtOutCoords();\");\n        });\n        var r = this.variableNames.map(function (t) {\n          return \"v\" + t;\n        }).join(\" + \");\n        this.userCode = \"\\n      void main() {\\n        \" + n.join(\"\\n        \") + \"\\n\\n        vec4 result = \" + r + \";\\n        setOutput(result);\\n      }\\n    \";\n      },\n          ho = function (t, e, n) {\n        this.variableNames = [\"A\"];\n        var r = t.windowSize,\n            o = t.batchSize,\n            i = t.inSize,\n            a = Math.ceil(i / r);\n        n || this.variableNames.push(\"bestIndicesA\"), this.outputShape = [o, a];\n        var s = \"max\" === e ? \">\" : \"<\",\n            u = n ? \"inOffset + i;\" : \"round(getBestIndicesA(batch, inOffset + i));\";\n        this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + r + \";\\n\\n        int bestIndex = inOffset;\\n        float bestValue = getA(batch, bestIndex);\\n\\n        for (int i = 0; i < \" + r + \"; i++) {\\n          int inIdx = \" + u + \";\\n          float candidate = getA(batch, inIdx);\\n          if (candidate \" + s + \" bestValue) {\\n            bestValue = candidate;\\n            bestIndex = inIdx;\\n          }\\n        }\\n        setOutput(float(bestIndex));\\n      }\\n    \";\n      };\n\n      function po(t, e) {\n        return [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"].slice(0, e).map(function (e) {\n          return t + \".\" + e;\n        });\n      }\n\n      function fo(t, e) {\n        return 1 === e ? [t] : po(t, e);\n      }\n\n      function mo() {\n        var t, e, n, r, o, i, a, s, u, c;\n        return 2 === h().getNumber(\"WEBGL_VERSION\") ? (t = \"#version 300 es\", e = \"in\", n = \"out\", r = \"in\", o = \"texture\", i = \"outputColor\", a = \"out vec4 outputColor;\", s = \"\\n      bool isnan_custom(float val) {\\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\\n      }\\n\\n      bvec4 isnan_custom(vec4 val) {\\n        return bvec4(isnan_custom(val.x),\\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\\n      }\\n\\n      #define isnan(value) isnan_custom(value)\\n    \", u = \"\", c = \"\\n      #define round(value) newRound(value)\\n      int newRound(float value) {\\n        return int(floor(value + 0.5));\\n      }\\n\\n      ivec4 newRound(vec4 value) {\\n        return ivec4(floor(value + vec4(0.5)));\\n      }\\n    \") : (t = \"\", e = \"attribute\", n = \"varying\", r = \"varying\", o = \"texture2D\", i = \"gl_FragColor\", a = \"\", s = \"\\n      #define isnan(value) isnan_custom(value)\\n      bool isnan_custom(float val) {\\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\\n      }\\n      bvec4 isnan_custom(vec4 val) {\\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\\n      }\\n    \", u = \"\\n      uniform float INFINITY;\\n\\n      bool isinf(float val) {\\n        return abs(val) == INFINITY;\\n      }\\n      bvec4 isinf(vec4 val) {\\n        return equal(abs(val), vec4(INFINITY));\\n      }\\n    \", c = \"\\n      int round(float value) {\\n        return int(floor(value + 0.5));\\n      }\\n\\n      ivec4 round(vec4 value) {\\n        return ivec4(floor(value + vec4(0.5)));\\n      }\\n    \"), {\n          version: t,\n          attribute: e,\n          varyingVs: n,\n          varyingFs: r,\n          texture2D: o,\n          output: i,\n          defineOutput: a,\n          defineSpecialNaN: s,\n          defineSpecialInf: u,\n          defineRound: c\n        };\n      }\n\n      function go(t, e, n) {\n        void 0 === n && (n = \"index\");\n        var r = X(e);\n        return r.map(function (e, o) {\n          return \"int \" + t[o] + \" = \" + n + \" / \" + e + \"; \" + (o === r.length - 1 ? \"int \" + t[o + 1] + \" = \" + n + \" - \" + t[o] + \" * \" + e : \"index -= \" + t[o] + \" * \" + e) + \";\";\n        }).join(\"\");\n      }\n\n      function vo(t) {\n        var e = X(t).map(function (t) {\n          return t.toString();\n        });\n        return \"\\n  int getFlatIndex(ivec3 coords) {\\n    return coords.x * \" + e[0] + \" + coords.y * \" + e[1] + \" + coords.z;\\n  }\\n\";\n      }\n\n      var yo = \"\\n  const float FLOAT_MAX = 1.70141184e38;\\n  const float FLOAT_MIN = 1.17549435e-38;\\n\\n  lowp vec4 encode_float(highp float v) {\\n    if (isnan(v)) {\\n      return vec4(255, 255, 255, 255);\\n    }\\n\\n    highp float av = abs(v);\\n\\n    if(av < FLOAT_MIN) {\\n      return vec4(0.0, 0.0, 0.0, 0.0);\\n    } else if(v > FLOAT_MAX) {\\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n    } else if(v < -FLOAT_MAX) {\\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n    }\\n\\n    highp vec4 c = vec4(0,0,0,0);\\n\\n    highp float e = floor(log2(av));\\n    highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n    c[2] = floor(128.0 * m);\\n    m -= c[2] / 128.0;\\n    c[1] = floor(32768.0 * m);\\n    m -= c[1] / 32768.0;\\n    c[0] = floor(8388608.0 * m);\\n\\n    highp float ebias = e + 127.0;\\n    c[3] = floor(ebias / 2.0);\\n    ebias -= c[3] * 2.0;\\n    c[2] += floor(ebias) * 128.0;\\n\\n    c[3] += 128.0 * step(0.0, -v);\\n\\n    return c / 255.0;\\n  }\\n\";\n\n      function bo(t, e, n, r) {\n        var o = [];\n        t.forEach(function (t) {\n          var e = A(t.shapeInfo.logicalShape);\n          t.shapeInfo.isUniform ? o.push(\"uniform float \" + t.name + (e > 1 ? \"[\" + e + \"]\" : \"\") + \";\") : (o.push(\"uniform sampler2D \" + t.name + \";\"), o.push(\"uniform int offset\" + t.name + \";\"));\n        });\n\n        var i,\n            a,\n            s = o.join(\"\\n\"),\n            u = t.map(function (t) {\n          return function (t, e, n) {\n            void 0 === n && (n = !1);\n            var r = \"\";\n            r += n ? function t(e) {\n              var n, r, o;\n\n              switch (e.shapeInfo.logicalShape.length) {\n                case 0:\n                  return n = e.name, r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1), o = mo(), \"\\n    vec4 \" + r + \"() {\\n      return \" + o.texture2D + \"(\" + n + \", halfCR);\\n    }\\n  \";\n\n                case 1:\n                  return function (t) {\n                    var e = t.name,\n                        n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1),\n                        r = t.shapeInfo.texShape,\n                        o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)],\n                        i = mo();\n                    return \"\\n    vec4 \" + n + \"(int index) {\\n      vec2 uv = packedUVfrom1D(\\n        \" + o[0] + \", \" + o[1] + \", index);\\n      return \" + i.texture2D + \"(\" + e + \", uv);\\n    }\\n  \";\n                  }(e);\n\n                case 2:\n                  return function (t) {\n                    var e = t.shapeInfo.logicalShape,\n                        n = t.name,\n                        r = \"get\" + n.charAt(0).toUpperCase() + n.slice(1),\n                        o = t.shapeInfo.texShape,\n                        i = o[0],\n                        a = o[1],\n                        s = mo();\n                    if (null != o && k(e, o)) return \"\\n      vec4 \" + r + \"(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + a + \".0, \" + i + \".0);\\n\\n        return \" + s.texture2D + \"(\" + n + \", uv);\\n      }\\n    \";\n                    var u = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];\n                    return \"\\n    vec4 \" + r + \"(int row, int col) {\\n      vec2 uv = packedUVfrom2D(\" + Math.ceil(e[1] / 2) + \", \" + u[0] + \", \" + u[1] + \", row, col);\\n      return \" + s.texture2D + \"(\" + n + \", uv);\\n    }\\n  \";\n                  }(e);\n\n                case 3:\n                  return function (e) {\n                    var n = e.shapeInfo.logicalShape,\n                        r = e.name,\n                        o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n                        i = e.shapeInfo.texShape,\n                        a = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)];\n\n                    if (1 === n[0]) {\n                      var s = ko(e, n.slice(1));\n                      return \"\\n        \" + t(s) + \"\\n        vec4 \" + o + \"(int b, int row, int col) {\\n          return \" + o + \"(\" + To([\"b\", \"row\", \"col\"], [1, 2]) + \");\\n        }\\n      \";\n                    }\n\n                    var u = a[0],\n                        c = a[1],\n                        l = Math.ceil(n[2] / 2);\n                    return \"\\n    vec4 \" + o + \"(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        \" + u + \", \" + c + \", \" + l * Math.ceil(n[1] / 2) + \", \" + l + \", b, row, col);\\n      return \" + mo().texture2D + \"(\" + r + \", uv);\\n    }\\n  \";\n                  }(e);\n\n                default:\n                  return function (t) {\n                    for (var e = t.shapeInfo.logicalShape, n = e.length, r = t.name, o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1), i = t.shapeInfo.texShape, a = [Math.ceil(i[0] / 2), Math.ceil(i[1] / 2)], s = a[0], u = a[1], c = Math.ceil(e[n - 1] / 2), l = c * Math.ceil(e[n - 2] / 2), h = \"int b, int row, int col\", p = \"b * \" + l + \" + (row / 2) * \" + c + \" + (col / 2)\", f = 2; f < n - 1; f++) h = \"int b\" + f + \", \" + h, p = \"b\" + f + \" * \" + (l *= e[n - f - 1]) + \" + \" + p;\n\n                    return \"\\n    vec4 \" + o + \"(\" + h + \") {\\n      int index = \" + p + \";\\n      int texR = index / \" + u + \";\\n      int texC = index - texR * \" + u + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + u + \", \" + s + \");\\n      return \" + mo().texture2D + \"(\" + r + \", uv);\\n    }\\n  \";\n                  }(e);\n              }\n            }(t) : function t(e) {\n              var n = e.shapeInfo.logicalShape;\n\n              switch (n.length) {\n                case 0:\n                  return function (t) {\n                    var e = t.name,\n                        n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1);\n                    if (t.shapeInfo.isUniform) return \"float \" + n + \"() {return \" + e + \";}\";\n                    var r = t.shapeInfo.texShape,\n                        o = r[0],\n                        i = r[1];\n                    if (1 === o && 1 === i) return \"\\n      float \" + n + \"() {\\n        return sampleTexture(\" + e + \", halfCR);\\n      }\\n    \";\n                    var a = t.shapeInfo.texShape;\n                    return \"\\n    float \" + n + \"() {\\n      vec2 uv = uvFromFlat(\" + a[0] + \", \" + a[1] + \", \" + Co(e) + \");\\n      return sampleTexture(\" + e + \", uv);\\n    }\\n  \";\n                  }(e);\n\n                case 1:\n                  return function (t) {\n                    var e = t.name,\n                        n = \"get\" + e.charAt(0).toUpperCase() + e.slice(1);\n                    if (t.shapeInfo.isUniform) return \"\\n      float \" + n + \"(int index) {\\n        \" + Io(t) + \"\\n      }\\n    \";\n                    var r = t.shapeInfo.texShape,\n                        o = r[0],\n                        i = r[1];\n                    if (1 === i && 1 === o) return \"\\n      float \" + n + \"(int index) {\\n        return sampleTexture(\" + e + \", halfCR);\\n      }\\n    \";\n                    var a = Co(e);\n                    return 1 === i ? \"\\n      float \" + n + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index + \" + a + \") + 0.5) / \" + o + \".0);\\n        return sampleTexture(\" + e + \", uv);\\n      }\\n    \" : 1 === o ? \"\\n      float \" + n + \"(int index) {\\n        vec2 uv = vec2((float(index + \" + a + \") + 0.5) / \" + i + \".0, 0.5);\\n        return sampleTexture(\" + e + \", uv);\\n      }\\n    \" : \"\\n    float \" + n + \"(int index) {\\n      vec2 uv = uvFromFlat(\" + o + \", \" + i + \", index + \" + a + \");\\n      return sampleTexture(\" + e + \", uv);\\n    }\\n  \";\n                  }(e);\n\n                case 2:\n                  return function (e) {\n                    var n = e.shapeInfo.logicalShape,\n                        r = e.name,\n                        o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n                        i = e.shapeInfo.texShape;\n\n                    if (null != i && k(n, i)) {\n                      var a = i[0];\n                      return \"\\n    float \" + o + \"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + i[1] + \".0, \" + a + \".0);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n                    }\n\n                    var s = D(n),\n                        u = s.newShape,\n                        c = s.keptDims,\n                        l = u;\n\n                    if (l.length < n.length) {\n                      var h = ko(e, l);\n                      return \"\\n      \" + t(h) + \"\\n      float \" + o + \"(int row, int col) {\\n        return \" + o + \"(\" + To([\"row\", \"col\"], c) + \");\\n      }\\n    \";\n                    }\n\n                    if (e.shapeInfo.isUniform) return \"\\n      float \" + o + \"(int row, int col) {\\n        int index = round(dot(vec2(row, col), vec2(\" + n[1] + \", 1)));\\n        \" + Io(e) + \"\\n      }\\n    \";\n                    var p = i[0],\n                        f = i[1],\n                        d = Co(r);\n                    return 1 === f ? \"\\n    float \" + o + \"(int row, int col) {\\n      float index = dot(vec3(row, col, \" + d + \"), vec3(\" + n[1] + \", 1, 1));\\n      vec2 uv = vec2(0.5, (index + 0.5) / \" + p + \".0);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \" : 1 === p ? \"\\n    float \" + o + \"(int row, int col) {\\n      float index = dot(vec3(row, col, \" + d + \"), vec3(\" + n[1] + \", 1, 1));\\n      vec2 uv = vec2((index + 0.5) / \" + f + \".0, 0.5);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \" : \"\\n  float \" + o + \"(int row, int col) {\\n    // Explicitly use integer operations as dot() only works on floats.\\n    int index = row * \" + n[1] + \" + col + \" + d + \";\\n    vec2 uv = uvFromFlat(\" + p + \", \" + f + \", index);\\n    return sampleTexture(\" + r + \", uv);\\n  }\\n\";\n                  }(e);\n\n                case 3:\n                  return function (e) {\n                    var n = e.shapeInfo.logicalShape,\n                        r = e.name,\n                        o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n                        i = n[1] * n[2],\n                        a = n[2],\n                        s = D(n),\n                        u = s.newShape,\n                        c = s.keptDims,\n                        l = u;\n\n                    if (l.length < n.length) {\n                      var h = ko(e, l);\n                      return \"\\n        \" + t(h) + \"\\n        float \" + o + \"(int row, int col, int depth) {\\n          return \" + o + \"(\" + To([\"row\", \"col\", \"depth\"], c) + \");\\n        }\\n      \";\n                    }\n\n                    if (e.shapeInfo.isUniform) return \"\\n      float \" + o + \"(int row, int col, int depth) {\\n        int index = round(dot(vec3(row, col, depth),\\n                          vec3(\" + i + \", \" + a + \", 1)));\\n        \" + Io(e) + \"\\n      }\\n    \";\n                    var p = e.shapeInfo.texShape,\n                        f = p[0],\n                        d = p[1],\n                        m = e.shapeInfo.flatOffset;\n                    return d === i && null == m ? \"\\n        float \" + o + \"(int row, int col, int depth) {\\n          float texR = float(row);\\n          float texC = dot(vec2(col, depth), vec2(\" + a + \", 1));\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\" + d + \".0, \" + f + \".0);\\n          return sampleTexture(\" + r + \", uv);\\n        }\\n      \" : d === a && null == m ? \"\\n    float \" + o + \"(int row, int col, int depth) {\\n      float texR = dot(vec2(row, col), vec2(\" + n[1] + \", 1));\\n      float texC = float(depth);\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + d + \".0, \" + f + \".0);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \" : \"\\n      float \" + o + \"(int row, int col, int depth) {\\n        // Explicitly use integer operations as dot() only works on floats.\\n        int index = row * \" + i + \" + col * \" + a + \" + depth + \" + Co(r) + \";\\n        vec2 uv = uvFromFlat(\" + f + \", \" + d + \", index);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n  \";\n                  }(e);\n\n                case 4:\n                  return function (e) {\n                    var n = e.shapeInfo.logicalShape,\n                        r = e.name,\n                        o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n                        i = n[3],\n                        a = n[2] * i,\n                        s = n[1] * a,\n                        u = D(n),\n                        c = u.newShape,\n                        l = u.keptDims;\n\n                    if (c.length < n.length) {\n                      var h = ko(e, c);\n                      return \"\\n      \" + t(h) + \"\\n      float \" + o + \"(int row, int col, int depth, int depth2) {\\n        return \" + o + \"(\" + To([\"row\", \"col\", \"depth\", \"depth2\"], l) + \");\\n      }\\n    \";\n                    }\n\n                    if (e.shapeInfo.isUniform) return \"\\n      float \" + o + \"(int row, int col, int depth, int depth2) {\\n        int index = round(dot(vec4(row, col, depth, depth2),\\n                          vec4(\" + s + \", \" + a + \", \" + i + \", 1)));\\n        \" + Io(e) + \"\\n      }\\n    \";\n                    var p = e.shapeInfo.flatOffset,\n                        f = e.shapeInfo.texShape,\n                        d = f[0],\n                        m = f[1];\n                    return m === s && null == p ? \"\\n      float \" + o + \"(int row, int col, int depth, int depth2) {\\n        float texR = float(row);\\n        float texC =\\n            dot(vec3(col, depth, depth2),\\n                vec3(\" + a + \", \" + i + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + m + \".0, \" + d + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : m === i && null == p ? \"\\n      float \" + o + \"(int row, int col, int depth, int depth2) {\\n        float texR = dot(vec3(row, col, depth),\\n                         vec3(\" + n[1] * n[2] + \", \" + n[2] + \", 1));\\n        float texC = float(depth2);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + m + \".0, \" + d + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : \"\\n    float \" + o + \"(int row, int col, int depth, int depth2) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + s + \" + col * \" + a + \" +\\n          depth * \" + i + \" + depth2;\\n      vec2 uv = uvFromFlat(\" + d + \", \" + m + \", index + \" + Co(r) + \");\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n                  }(e);\n\n                case 5:\n                  return function (e) {\n                    var n = e.shapeInfo.logicalShape,\n                        r = e.name,\n                        o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n                        i = n[4],\n                        a = n[3] * i,\n                        s = n[2] * a,\n                        u = n[1] * s,\n                        c = D(n),\n                        l = c.newShape,\n                        h = c.keptDims;\n\n                    if (l.length < n.length) {\n                      var p = ko(e, l);\n                      return \"\\n      \" + t(p) + \"\\n      float \" + o + \"(int row, int col, int depth, int depth2, int depth3) {\\n        return \" + o + \"(\" + To([\"row\", \"col\", \"depth\", \"depth2\", \"depth3\"], h) + \");\\n      }\\n    \";\n                    }\n\n                    if (e.shapeInfo.isUniform) return \"\\n      float \" + o + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + u + \", \" + s + \", \" + a + \", \" + i + \")) +\\n          depth3;\\n        \" + Io(e) + \"\\n      }\\n    \";\n                    var f = e.shapeInfo.flatOffset,\n                        d = e.shapeInfo.texShape,\n                        m = d[0],\n                        g = d[1];\n                    return g === u && null == f ? \"\\n      float \" + o + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n                         vec4(\" + s + \", \" + a + \", \" + i + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + g + \".0, \" + m + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : g === i && null == f ? \"\\n      float \" + o + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + n[1] * n[2] * n[3] + \",\\n               \" + n[2] * n[3] + \", \" + n[3] + \", 1));\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + g + \".0, \" + m + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : \"\\n    float \" + o + \"(int row, int col, int depth, int depth2, int depth3) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + u + \" + col * \" + s + \" + depth * \" + a + \" +\\n          depth2 * \" + i + \" + depth3 + \" + Co(r) + \";\\n      vec2 uv = uvFromFlat(\" + m + \", \" + g + \", index);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n                  }(e);\n\n                case 6:\n                  return function (e) {\n                    var n = e.shapeInfo.logicalShape,\n                        r = e.name,\n                        o = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n                        i = D(n),\n                        a = i.newShape,\n                        s = i.keptDims;\n\n                    if (a.length < n.length) {\n                      var u = ko(e, a);\n                      return \"\\n      \" + t(u) + \"\\n      float \" + o + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        return \" + o + \"(\" + To([\"row\", \"col\", \"depth\", \"depth2\", \"depth3\", \"depth4\"], s) + \");\\n      }\\n    \";\n                    }\n\n                    var c = n[5],\n                        l = n[4] * c,\n                        h = n[3] * l,\n                        p = n[2] * h,\n                        f = n[1] * p;\n                    if (e.shapeInfo.isUniform) return \"\\n      float \" + o + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n        int index = round(dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + f + \", \" + p + \", \" + h + \", \" + l + \")) +\\n          dot(\\n            vec2(depth3, depth4),\\n            vec2(\" + c + \", 1)));\\n        \" + Io(e) + \"\\n      }\\n    \";\n                    var d = e.shapeInfo.flatOffset,\n                        m = e.shapeInfo.texShape,\n                        g = m[0],\n                        v = m[1];\n                    return v === f && null == d ? \"\\n      float \" + o + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n          vec4(\" + p + \", \" + h + \", \" + l + \", \" + c + \")) +\\n               float(depth4);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + v + \".0, \" + g + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : v === c && null == d ? \"\\n      float \" + o + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        float texR = dot(vec4(row, col, depth, depth2),\\n          vec4(\" + n[1] * n[2] * n[3] * n[4] + \",\\n               \" + n[2] * n[3] * n[4] + \",\\n               \" + n[3] * n[4] + \",\\n               \" + n[4] + \")) + float(depth3);\\n        int texC = depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + v + \".0, \" + g + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : \"\\n    float \" + o + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * \" + f + \" + col * \" + p + \" + depth * \" + h + \" +\\n          depth2 * \" + l + \" + depth3 * \" + c + \" + depth4 + \" + Co(r) + \";\\n      vec2 uv = uvFromFlat(\" + g + \", \" + v + \", index);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n                  }(e);\n\n                default:\n                  throw new Error(n.length + \"-D input sampling is not yet supported\");\n              }\n            }(t);\n            var o = t.shapeInfo.logicalShape,\n                i = e.logicalShape;\n            return o.length <= i.length && (r += n ? function (t, e) {\n              var n,\n                  r = t.name,\n                  o = r.charAt(0).toUpperCase() + r.slice(1),\n                  i = \"get\" + o + \"AtOutCoords\",\n                  a = t.shapeInfo.logicalShape.length,\n                  s = e.logicalShape.length,\n                  u = Dr(t.shapeInfo.logicalShape, e.logicalShape),\n                  c = Ao(s),\n                  l = s - a,\n                  h = [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"];\n              n = 0 === a ? \"\" : s < 2 && u.length >= 1 ? \"coords = 0;\" : u.map(function (t) {\n                return \"coords.\" + h[t + l] + \" = 0;\";\n              }).join(\"\\n\");\n              var p;\n              p = s < 2 && a > 0 ? \"coords\" : t.shapeInfo.logicalShape.map(function (t, e) {\n                return \"coords.\" + h[e + l];\n              }).join(\", \");\n              var f = \"return outputValue;\",\n                  d = 1 === A(t.shapeInfo.logicalShape),\n                  m = 1 === A(e.logicalShape);\n\n              if (1 !== a || d || m) {\n                if (d && !m) f = 1 === s ? \"\\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\\n      \" : \"\\n        return vec4(outputValue.x);\\n      \";else if (u.length) {\n                  var g = a - 2,\n                      v = a - 1;\n                  u.indexOf(g) > -1 && u.indexOf(v) > -1 ? f = \"return vec4(outputValue.x);\" : u.indexOf(g) > -1 ? f = \"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\" : u.indexOf(v) > -1 && (f = \"return vec4(outputValue.xx, outputValue.zz);\");\n                }\n              } else f = \"\\n      return vec4(outputValue.xy, outputValue.xy);\\n    \";\n\n              return \"\\n    vec4 \" + i + \"() {\\n      \" + c + \" coords = getOutputCoords();\\n      \" + n + \"\\n      vec4 outputValue = get\" + o + \"(\" + p + \");\\n      \" + f + \"\\n    }\\n  \";\n            }(t, e) : function (t, e) {\n              var n = t.name,\n                  r = n.charAt(0).toUpperCase() + n.slice(1),\n                  o = \"get\" + r + \"AtOutCoords\",\n                  i = e.texShape,\n                  a = t.shapeInfo.texShape,\n                  s = t.shapeInfo.logicalShape.length,\n                  u = e.logicalShape.length;\n              if (!t.shapeInfo.isUniform && s === u && null == t.shapeInfo.flatOffset && k(a, i)) return \"\\n      float \" + o + \"() {\\n        return sampleTexture(\" + n + \", resultUV);\\n      }\\n    \";\n              var c = Ao(u),\n                  l = Dr(t.shapeInfo.logicalShape, e.logicalShape),\n                  h = u - s,\n                  p = [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"];\n              return \"\\n    float \" + o + \"() {\\n      \" + c + \" coords = getOutputCoords();\\n      \" + (0 === s ? \"\" : u < 2 && l.length >= 1 ? \"coords = 0;\" : l.map(function (t) {\n                return \"coords.\" + p[t + h] + \" = 0;\";\n              }).join(\"\\n\")) + \"\\n      return get\" + r + \"(\" + (u < 2 && s > 0 ? \"coords\" : t.shapeInfo.logicalShape.map(function (t, e) {\n                return \"coords.\" + p[e + h];\n              }).join(\", \")) + \");\\n    }\\n  \";\n            }(t, e)), r;\n          }(t, e, r);\n        }).join(\"\\n\"),\n            c = e.texShape,\n            l = mo(),\n            h = function (t) {\n          return \"\\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n      return \" + t.texture2D + \"(textureSampler, uv).r;\\n    }\\n  \";\n        }(l),\n            p = function (t) {\n          return t.version + \"\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    \" + t.varyingFs + \" vec2 resultUV;\\n    \" + t.defineOutput + \"\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    uniform float NAN;\\n    \" + t.defineSpecialNaN + \"\\n    \" + t.defineSpecialInf + \"\\n    \" + t.defineRound + \"\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    int idiv(int a, int b, float sign) {\\n      int res = a / b;\\n      int mod = imod(a, b);\\n      if (sign < 0. && mod != 0) {\\n        res -= 1;\\n      }\\n      return res;\\n    }\\n\\n    //Based on the work of Dave Hoskins\\n    //https://www.shadertoy.com/view/4djSRW\\n    #define HASHSCALE1 443.8975\\n    float random(float seed){\\n      vec2 p = resultUV * seed;\\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n      p3 += dot(p3, p3.yzx + 19.19);\\n      return fract((p3.x + p3.y) * p3.z);\\n    }\\n\\n    \" + wo + \"\\n    \" + xo + \"\\n    \" + So + \"\\n  \";\n        }(l);\n\n        return e.isPacked ? (i = function (t, e) {\n          switch (t.length) {\n            case 0:\n              return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n\n            case 1:\n              return function (t, e) {\n                var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];\n                return 1 === n[0] ? \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.x * \" + n[1] + \".0);\\n      }\\n    \" : 1 === n[1] ? \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.y * \" + n[0] + \".0);\\n      }\\n    \" : \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      return 2 * (resTexRC.x * \" + n[1] + \" + resTexRC.y);\\n    }\\n  \";\n              }(0, e);\n\n            case 2:\n              return function (t, e) {\n                var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)];\n                if (k(t, e)) return \"\\n      ivec2 getOutputCoords() {\\n        return 2 * ivec2(resultUV.yx * vec2(\" + n[0] + \", \" + n[1] + \"));\\n      }\\n    \";\n                var r = Math.ceil(t[1] / 2);\n                return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n      int r = 2 * (index / \" + r + \");\\n      int c = imod(index, \" + r + \") * 2;\\n\\n      return ivec2(r, c);\\n    }\\n  \";\n              }(t, e);\n\n            case 3:\n              return n = t, r = e, o = [Math.ceil(r[0] / 2), Math.ceil(r[1] / 2)], a = (i = Math.ceil(n[2] / 2)) * Math.ceil(n[1] / 2), \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + o[0] + \", \" + o[1] + \"));\\n      int index = resTexRC.x * \" + o[1] + \" + resTexRC.y;\\n\\n      int b = index / \" + a + \";\\n      index -= b * \" + a + \";\\n\\n      int r = 2 * (index / \" + i + \");\\n      int c = imod(index, \" + i + \") * 2;\\n\\n      return ivec3(b, r, c);\\n    }\\n  \";\n\n            default:\n              return function (t, e) {\n                for (var n = [Math.ceil(e[0] / 2), Math.ceil(e[1] / 2)], r = Math.ceil(t[t.length - 1] / 2), o = r * Math.ceil(t[t.length - 2] / 2), i = o, a = \"\", s = \"b, r, c\", u = 2; u < t.length - 1; u++) a = \"\\n      int b\" + u + \" = index / \" + (i *= t[t.length - u - 1]) + \";\\n      index -= b\" + u + \" * \" + i + \";\\n    \" + a, s = \"b\" + u + \", \" + s;\n\n                return \"\\n    ivec\" + t.length + \" getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n\\n      \" + a + \"\\n\\n      int b = index / \" + o + \";\\n      index -= b * \" + o + \";\\n\\n      int r = 2 * (index / \" + r + \");\\n      int c = imod(index, \" + r + \") * 2;\\n\\n      return ivec\" + t.length + \"(\" + s + \");\\n    }\\n  \";\n              }(t, e);\n          }\n\n          var n, r, o, i, a;\n        }(e.logicalShape, c), a = function (t) {\n          return \"\\n    void setOutput(vec4 val) {\\n      \" + t.output + \" = val;\\n    }\\n  \";\n        }(l)) : (i = function (t, e) {\n          switch (t.length) {\n            case 0:\n              return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n\n            case 1:\n              return function (t, e) {\n                return 1 === e[0] ? \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + e[1] + \".0);\\n      }\\n    \" : 1 === e[1] ? \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + e[0] + \".0);\\n      }\\n    \" : \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + e[0] + \", \" + e[1] + \"));\\n      return resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n    }\\n  \";\n              }(0, e);\n\n            case 2:\n              return function (t, e) {\n                return k(t, e) ? \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + e[0] + \", \" + e[1] + \"));\\n      }\\n    \" : 1 === t[1] ? \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \" : 1 === t[0] ? \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \" : \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n      int r = index / \" + t[1] + \";\\n      int c = index - r * \" + t[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\n              }(t, e);\n\n            case 3:\n              return n = e, r = go([\"r\", \"c\", \"d\"], t), \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + n[0] + \", \" + n[1] + \"));\\n      int index = resTexRC.x * \" + n[1] + \" + resTexRC.y;\\n      \" + r + \"\\n      return ivec3(r, c, d);\\n    }\\n  \";\n\n            case 4:\n              return function (t, e) {\n                var n = go([\"r\", \"c\", \"d\", \"d2\"], t);\n                return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n      \" + n + \"\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\n              }(t, e);\n\n            case 5:\n              return function (t, e) {\n                var n = go([\"r\", \"c\", \"d\", \"d2\", \"d3\"], t);\n                return \"\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(\" + e[0] + \",\\n                             \" + e[1] + \"));\\n\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n\\n      \" + n + \"\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  \";\n              }(t, e);\n\n            case 6:\n              return function (t, e) {\n                var n = go([\"r\", \"c\", \"d\", \"d2\", \"d3\", \"d4\"], t);\n                return \"\\n    ivec6 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + e[0] + \", \" + e[1] + \"));\\n      int index = resTexRC.x * \" + e[1] + \" + resTexRC.y;\\n\\n      \" + n + \"\\n\\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\\n      return result;\\n    }\\n  \";\n              }(t, e);\n\n            default:\n              throw new Error(t.length + \"-D output sampling is not yet supported\");\n          }\n\n          var n, r;\n        }(e.logicalShape, c), a = function (t) {\n          return \"\\n    void setOutput(float val) {\\n      \" + t.output + \" = vec4(val, 0, 0, 0);\\n    }\\n  \";\n        }(l)), r && (p += Eo), [p, h, a, s, i, u, n].join(\"\\n\");\n      }\n\n      var wo = \"\\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n  int texelIndex = index / 2;\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n          xo = \"\\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\\n  int texNumC, int row, int col) {\\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n          So = \"\\nvec2 packedUVfrom3D(int texNumR, int texNumC,\\n    int texelsInBatch, int texelsInLogicalRow, int b,\\n    int row, int col) {\\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n          Eo = \"\\n  float getChannel(vec4 frag, vec2 innerDims) {\\n    vec2 modCoord = mod(innerDims, 2.);\\n    return modCoord.x == 0. ?\\n      (modCoord.y == 0. ? frag.r : frag.g) :\\n      (modCoord.y == 0. ? frag.b : frag.a);\\n  }\\n  float getChannel(vec4 frag, int dim) {\\n    float modCoord = mod(float(dim), 2.);\\n    return modCoord == 0. ? frag.r : frag.g;\\n  }\\n\";\n\n      function Co(t) {\n        return \"offset\" + t;\n      }\n\n      function Io(t) {\n        var e = t.name,\n            n = A(t.shapeInfo.logicalShape);\n        return n < 2 ? \"return \" + e + \";\" : \"\\n    for (int i = 0; i < \" + n + \"; i++) {\\n      if (i == index) {\\n        return \" + e + \"[i];\\n      }\\n    }\\n  \";\n      }\n\n      function Ao(t) {\n        if (t <= 1) return \"int\";\n        if (2 === t) return \"ivec2\";\n        if (3 === t) return \"ivec3\";\n        if (4 === t) return \"ivec4\";\n        if (5 === t) return \"ivec5\";\n        if (6 === t) return \"ivec6\";\n        throw Error(\"GPU for rank \" + t + \" is not yet supported\");\n      }\n\n      function ko(t, e) {\n        var n = JSON.parse(JSON.stringify(t));\n        return n.shapeInfo.logicalShape = e, n;\n      }\n\n      function To(t, e) {\n        return e.map(function (e) {\n          return t[e];\n        }).join(\", \");\n      }\n\n      var No = function (t, e, n, r) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !0, S(t.length > 2, function () {\n          return \"Packed arg\" + (n.charAt(0).toUpperCase() + n.slice(1)) + \" supports only inputs with rank above 2.\";\n        });\n        var o = t[t.length - 1],\n            i = Math.ceil(o / e);\n        this.outputShape = t.slice(0, -1), i > 1 && this.outputShape.push(i), r || this.variableNames.push(\"bestIndicesA\");\n        var a,\n            s,\n            u = this.outputShape,\n            c = u.length,\n            l = Ao(c),\n            h = fo(\"coords\", c);\n\n        if (1 === i) {\n          var p = Ao(s = c + 1);\n          a = \"\\n        \" + p + \" sourceLocR = \" + p + \"(\" + h.join() + \", 0);\\n        ++\" + h[c - 1] + \";\\n        \" + p + \" sourceLocG = \" + p + \"(\" + h.join() + \", 0);\\n        ++\" + h[c - 2] + \";\\n        \" + p + \" sourceLocA = \" + p + \"(\" + h.join() + \", 0);\\n        --\" + h[c - 1] + \";\\n        \" + p + \" sourceLocB = \" + p + \"(\" + h.join() + \", 0);\\n        --\" + h[c - 2] + \";\";\n        } else s = c, a = \"\\n        \" + l + \" sourceLocR = coords;\\n        ++\" + h[c - 1] + \";\\n        \" + l + \" sourceLocG = coords;\\n        ++\" + h[c - 2] + \";\\n        \" + l + \" sourceLocA = coords;\\n        --\" + h[c - 1] + \";\\n        \" + l + \" sourceLocB = coords;\\n        --\" + h[c - 2] + \";\";\n\n        var f = [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"].slice(0, s),\n            d = \".\" + f[s - 1],\n            m = f.map(function (t) {\n          return \"int \" + t;\n        }),\n            g = fo(\"sourceLocR\", s - 1).concat(\"inIdx.r\"),\n            v = fo(\"sourceLocG\", s - 1).concat(\"inIdx.g\"),\n            y = fo(\"sourceLocB\", s - 1).concat(\"inIdx.b\"),\n            b = fo(\"sourceLocA\", s - 1).concat(\"inIdx.a\"),\n            w = \"max\" === n ? \"greaterThan\" : \"lessThan\",\n            x = r ? \"\" : \"\\n          inIdx = round(vec4(getBestIndicesAChannel(\" + g.join() + \"),\\n                             getBestIndicesAChannel(\" + v.join() + \"),\\n                             getBestIndicesAChannel(\" + y.join() + \"),\\n                             getBestIndicesAChannel(\" + b.join() + \")));\",\n            E = \"vec4(\\n            getAChannel(\" + g.join() + \"),\\n            hasNextCol ? getAChannel(\" + v.join() + \") : 0.,\\n            hasNextRow ? getAChannel(\" + y.join() + \") : 0.,\\n            hasNextRow && hasNextCol ? getAChannel(\" + b.join() + \") : 0.)\",\n            C = r ? \"\" : \"\\n      float getBestIndicesAChannel(\" + m.join() + \") {\\n        return getChannel(getBestIndicesA(\" + f.join() + \"),\\n                                          vec2(\" + f.slice(-2).join() + \"));\\n      }\";\n        this.userCode = \"\\n      float getAChannel(\" + m.join() + \") {\\n        return getChannel(getA(\" + f.join() + \"),\\n                               vec2(\" + f.slice(-2).join() + \"));\\n      }\\n      \" + C + \"\\n      void main() {\\n        \" + l + \" coords = getOutputCoords();\\n        bool hasNextCol = \" + h[c - 1] + \" < \" + (u[c - 1] - 1) + \";\\n        bool hasNextRow = \" + h[c - 2] + \" < \" + (u[c - 2] - 1) + \";\\n        \" + a + \"\\n        ivec4 srcIdx = ivec4(sourceLocR\" + d + \", sourceLocG\" + d + \",\\n          sourceLocB\" + d + \", sourceLocA\" + d + \") * \" + e + \";\\n        ivec4 inIdx = srcIdx;\\n        vec4 bestIndex = vec4(inIdx);\\n        vec4 bestValue = \" + E + \";\\n\\n        for (int i = 0; i < \" + e + \"; i++) {\\n          inIdx = srcIdx;\\n          \" + x + \"\\n          vec4 candidate = \" + E + \";\\n          bvec4 nan = isnan(candidate);\\n          bvec4 replace = bvec4(\\n            vec4(\" + w + \"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\\n\\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\\n                           replace.y  ? candidate.y : bestValue.y,\\n                           replace.z  ? candidate.z : bestValue.z,\\n                           replace.w  ? candidate.w : bestValue.w);\\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\\n          srcIdx++;\\n        }\\n        setOutput(bestIndex);\\n      }\\n    \";\n      },\n          Po = function (t) {\n        this.variableNames = [\"dy\"], this.outputShape = t.inShape;\n        var e = t.filterHeight,\n            n = t.filterWidth,\n            r = t.strideHeight,\n            o = t.strideWidth,\n            i = t.dilationHeight,\n            a = t.dilationWidth,\n            s = t.effectiveFilterHeight,\n            u = t.effectiveFilterWidth,\n            c = s - 1 - t.padInfo.top,\n            l = u - 1 - t.padInfo.left,\n            h = 1 / (e * n);\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + c + \", \" + l + \");\\n      const float avgMultiplier = float(\" + h + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + s + \";\\n            wR += \" + i + \") {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + u + \";\\n            wC+= \" + a + \") {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n\\n            dotProd += dyValue * avgMultiplier;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          Ro = function (t) {\n        this.variableNames = [\"dy\"], this.outputShape = t.inShape;\n        var e = t.filterDepth,\n            n = t.filterHeight,\n            r = t.filterWidth,\n            o = t.strideDepth,\n            i = t.strideHeight,\n            a = t.strideWidth,\n            s = t.dilationDepth,\n            u = t.dilationHeight,\n            c = t.dilationWidth,\n            l = t.effectiveFilterDepth,\n            h = t.effectiveFilterHeight,\n            p = t.effectiveFilterWidth,\n            f = l - 1 - t.padInfo.front,\n            d = h - 1 - t.padInfo.top,\n            m = p - 1 - t.padInfo.left,\n            g = 1 / (e * n * r);\n        this.userCode = \"\\n      const ivec3 pads = ivec3(\" + f + \", \" + d + \", \" + m + \");\\n      const float avgMultiplier = float(\" + g + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyDCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\\n        // dx(xD, xR, xC, ch).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int wD = 0; wD < \" + l + \";\\n            wD += \" + s + \") {\\n          float dyD = float(dyDCorner + wD) / \" + o + \".0;\\n\\n          if (dyD < 0.0 || dyD >= \" + t.outDepth + \".0 || fract(dyD) > 0.0) {\\n            continue;\\n          }\\n          int idyD = int(dyD);\\n\\n          for (int wR = 0; wR < \" + h + \";\\n              wR += \" + u + \") {\\n            float dyR = float(dyRCorner + wR) / \" + i + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n                fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            for (int wC = 0; wC < \" + p + \";\\n                wC += \" + c + \") {\\n              float dyC = float(dyCCorner + wC) / \" + a + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\\n\\n              dotProd += dyValue * avgMultiplier;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          _o = function (t, e, n, r, o, i) {\n        this.outputShape = [], this.variableNames = [\"x\", \"mean\", \"variance\"], Lr(t, e), Lr(t, n);\n        var a = \"0.0\";\n        null != r && (Lr(t, r), this.variableNames.push(\"offset\"), a = \"getOffsetAtOutCoords()\");\n        var s = \"1.0\";\n        null != o && (Lr(t, o), this.variableNames.push(\"scale\"), s = \"getScaleAtOutCoords()\"), this.outputShape = t, this.userCode = \"\\n      void main() {\\n        float x = getXAtOutCoords();\\n        float mean = getMeanAtOutCoords();\\n        float variance = getVarianceAtOutCoords();\\n        float offset = \" + a + \";\\n        float scale = \" + s + \";\\n        float inv = scale * inversesqrt(variance + float(\" + i + \"));\\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\\n      }\\n    \";\n      },\n          Mo = function (t, e, n, r, o, i) {\n        this.packedInputs = !0, this.packedOutput = !0, this.variableNames = [\"x\", \"mean\", \"variance\"], Lr(t, e), Lr(t, n);\n        var a = \"vec4(0.0)\";\n        null != r && (Lr(t, r), this.variableNames.push(\"offset\"), a = \"getOffsetAtOutCoords()\");\n        var s = \"vec4(1.0)\";\n        null != o && (Lr(t, o), this.variableNames.push(\"scale\"), s = \"getScaleAtOutCoords()\"), this.outputShape = t, this.userCode = \"\\n      void main() {\\n        vec4 offset = \" + a + \";\\n        vec4 scale = \" + s + \";\\n\\n        vec4 x = getXAtOutCoords();\\n        vec4 mean = getMeanAtOutCoords();\\n        vec4 variance = getVarianceAtOutCoords();\\n\\n        vec4 inv = scale * inversesqrt(variance + vec4(\" + i + \"));\\n\\n        setOutput((x - mean) * inv + offset);\\n      }\\n    \";\n      },\n          Oo = function (t, e, n) {\n        this.variableNames = [\"AReal\", \"AImag\", \"BReal\", \"BImag\"], this.outputShape = Lr(e, n), this.userCode = \"\\n      float binaryOpComplex(\\n          float areal, float aimag, float breal, float bimag) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        float areal = getARealAtOutCoords();\\n        float aimag = getAImagAtOutCoords();\\n        float breal = getBRealAtOutCoords();\\n        float bimag = getBImagAtOutCoords();\\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\\n      }\\n    \";\n      },\n          Do = \"return a + b;\",\n          Fo = \"return a - b;\",\n          Lo = \"return a * b;\",\n          Bo = \"return (a < 0.) ? b * a : a;\",\n          zo = function (t, e, n) {\n        this.variableNames = [\"A\", \"B\"], this.outputShape = Lr(e, n), this.userCode = \"\\n      float binaryOperation(float a, float b) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";\n      },\n          qo = \"\\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\\n\",\n          Vo = function (t, e, n, r) {\n        void 0 === r && (r = !1), this.variableNames = [\"A\", \"B\"], this.supportsBroadcasting = !0, this.packedInputs = !0, this.packedOutput = !0, this.outputShape = Lr(e, n);\n        var o = this.outputShape.length,\n            i = \"\";\n        if (r) if (0 === o || 1 === A(this.outputShape)) i = \"\\n          result.y = 0.;\\n          result.z = 0.;\\n          result.w = 0.;\\n        \";else if (i = \"\\n          \" + Ao(o) + \" coords = getOutputCoords();\\n        \", 1 === o) i += \"\\n            result.y = (coords + 1) >= \" + this.outputShape[0] + \" ? 0. : result.y;\\n            result.z = 0.;\\n            result.w = 0.;\\n          \";else {\n          var a = fo(\"coords\", o);\n          i += \"\\n            bool nextRowOutOfBounds =\\n              (\" + a[o - 2] + \" + 1) >= \" + this.outputShape[o - 2] + \";\\n            bool nextColOutOfBounds =\\n              (\" + a[o - 1] + \" + 1) >= \" + this.outputShape[o - 1] + \";\\n            result.y = nextColOutOfBounds ? 0. : result.y;\\n            result.z = nextRowOutOfBounds ? 0. : result.z;\\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\\n          \";\n        }\n        this.userCode = \"\\n      vec4 binaryOperation(vec4 a, vec4 b) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        vec4 a = getAAtOutCoords();\\n        vec4 b = getBAtOutCoords();\\n\\n        vec4 result = binaryOperation(a, b);\\n        \" + i + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n      },\n          Uo = function () {\n        function t(t) {\n          this.variableNames = [\"A\"], this.outputShape = t, this.userCode = \"\\n      uniform float minVal;\\n      uniform float maxVal;\\n\\n      void main() {\\n        float value = getAAtOutCoords();\\n        if (isnan(value)) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, minVal, maxVal));\\n      }\\n    \";\n        }\n\n        return t.prototype.getCustomSetupFunc = function (t, e) {\n          var n = this;\n          return function (r, o) {\n            null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, \"minVal\"), n.maxLoc = r.getUniformLocationNoThrow(o, \"maxVal\")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);\n          };\n        }, t;\n      }(),\n          jo = function () {\n        function t(t) {\n          this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = \"\\n      uniform float minVal;\\n      uniform float maxVal;\\n\\n      void main() {\\n        vec4 value = getAAtOutCoords();\\n\\n        if (any(isnan(value))) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\\n      }\\n    \";\n        }\n\n        return t.prototype.getCustomSetupFunc = function (t, e) {\n          var n = this;\n          return function (r, o) {\n            null == n.minLoc && (n.minLoc = r.getUniformLocationNoThrow(o, \"minVal\"), n.maxLoc = r.getUniformLocationNoThrow(o, \"maxVal\")), r.gl.uniform1f(n.minLoc, t), r.gl.uniform1f(n.maxLoc, e);\n          };\n        }, t;\n      }(),\n          Wo = function (t) {\n        this.variableNames = [\"real\", \"imag\"], this.outputShape = t, this.userCode = \"\\n      void main() {\\n        float re = abs(getRealAtOutCoords());\\n        float im = abs(getImagAtOutCoords());\\n        float mx = max(re, im);\\n\\n        // sadly the length function in glsl is not underflow-safe\\n        // (at least not on Intel GPUs). So the safe solution is\\n        // to ensure underflow-safety in all cases.\\n        setOutput(\\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\\n        );\\n      }\\n    \";\n      },\n          Go = function (t) {\n        this.outputShape = [], this.outputShape = on(t, 1), this.variableNames = t.map(function (t, e) {\n          return \"T\" + e;\n        });\n        var e = new Array(t.length - 1);\n        e[0] = t[0][1];\n\n        for (var n = 1; n < e.length; n++) e[n] = e[n - 1] + t[n][1];\n\n        var r = [\"if (yC < \" + e[0] + \") setOutput(getT0(yR, yC));\"];\n\n        for (n = 1; n < e.length; n++) {\n          var o = e[n - 1];\n          r.push(\"else if (yC < \" + e[n] + \") setOutput(getT\" + n + \"(yR, yC-\" + o + \"));\");\n        }\n\n        var i = e.length,\n            a = e[e.length - 1];\n        r.push(\"else setOutput(getT\" + i + \"(yR, yC-\" + a + \"));\"), this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int yR = coords.x;\\n        int yC = coords.y;\\n\\n        \" + r.join(\"\\n        \") + \"\\n      }\\n    \";\n      },\n          Ho = function (t, e) {\n        this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [], this.outputShape = on(t, e);\n        var n = this.outputShape,\n            r = n.length,\n            o = Ao(r),\n            i = fo(\"coords\", r),\n            a = [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"].slice(0, r);\n        this.variableNames = t.map(function (t, e) {\n          return \"T\" + e;\n        });\n        var s = new Array(t.length - 1);\n        s[0] = t[0][e];\n\n        for (var u = 1; u < s.length; u++) s[u] = s[u - 1] + t[u][e];\n\n        var c = a[e],\n            l = a.slice(-2),\n            h = a.join(),\n            p = \"if (\" + c + \" < \" + s[0] + \") {\\n        return getChannel(\\n            getT0(\" + h + \"), vec2(\" + l.join() + \"));\\n        }\";\n\n        for (u = 1; u < s.length; u++) {\n          var f = s[u - 1];\n          p += \"\\n        if (\" + c + \" < \" + s[u] + \"  && \" + c + \" >= \" + s[u - 1] + \") {\\n          return getChannel(\\n            getT\" + u + \"(\" + $o(a, c, f) + \"),\\n            vec2(\" + $o(l, c, f) + \"));\\n        }\";\n        }\n\n        var d = s.length,\n            m = s[s.length - 1];\n        p += \"\\n        return getChannel(\\n          getT\" + d + \"(\" + $o(a, c, m) + \"),\\n          vec2(\" + $o(l, c, m) + \"));\", this.userCode = \"\\n      float getValue(\" + a.map(function (t) {\n          return \"int \" + t;\n        }) + \") {\\n        \" + p + \"\\n      }\\n\\n      void main() {\\n        \" + o + \" coords = getOutputCoords();\\n        vec4 result = vec4(getValue(\" + i + \"), 0., 0., 0.);\\n\\n        \" + i[r - 1] + \" = \" + i[r - 1] + \" + 1;\\n        if (\" + i[r - 1] + \" < \" + n[r - 1] + \") {\\n          result.g = getValue(\" + i + \");\\n        }\\n\\n        \" + i[r - 2] + \" = \" + i[r - 2] + \" + 1;\\n        if (\" + i[r - 2] + \" < \" + n[r - 2] + \") {\\n          result.a = getValue(\" + i + \");\\n        }\\n\\n        \" + i[r - 1] + \" = \" + i[r - 1] + \" - 1;\\n        if (\" + i[r - 2] + \" < \" + n[r - 2] + \" &&\\n            \" + i[r - 1] + \" < \" + n[r - 1] + \") {\\n          result.b = getValue(\" + i + \");\\n        }\\n        setOutput(result);\\n      }\\n    \";\n      };\n\n      function $o(t, e, n) {\n        var r = t.indexOf(e);\n        return t.map(function (t, e) {\n          return e === r ? t + \" - \" + n : t;\n        }).join();\n      }\n\n      var Ko = function (t) {\n        this.variableNames = [\"x\", \"dy\"], this.outputShape = t.filterShape;\n        var e = t.strideHeight,\n            n = t.strideWidth,\n            r = t.padInfo.top,\n            o = t.padInfo.left,\n            i = \"channelsLast\" === t.dataFormat;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + e + \" - \" + r + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + n + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              if (\" + i + \") {\\n                float dyValue = getDy(b, yR, yC, d2);\\n                float xValue = getX(b, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              } else {\\n                float dyValue = getDy(b, d2, yR, yC);\\n                float xValue = getX(b, d1, xR, xC);\\n                dotProd += (xValue * dyValue);\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          Qo = function (t) {\n        this.variableNames = [\"dy\", \"W\"], this.outputShape = t.inShape;\n        var e = t.filterHeight,\n            n = t.filterWidth,\n            r = t.strideHeight,\n            o = t.strideWidth,\n            i = \"channelsLast\" === t.dataFormat,\n            a = e - 1 - t.padInfo.top,\n            s = n - 1 - t.padInfo.left,\n            u = i ? 1 : 2,\n            c = i ? 2 : 3,\n            l = i ? 3 : 1;\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[\" + l + \"];\\n\\n        ivec2 dyCorner = ivec2(coords[\" + u + \"], coords[\" + c + \"]) - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + e + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + e + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + n + \" - 1 - wC;\\n\\n            for (int d2 = 0; d2 < \" + t.outChannels + \"; d2++) {\\n\\n              if (\" + i + \") {\\n                float xValue = getDy(batch, idyR, idyC, d2);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              } else {\\n                float xValue = getDy(batch, d2, idyR, idyC);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          Xo = function (t) {\n        this.variableNames = [\"x\", \"dy\"], this.outputShape = t.filterShape;\n        var e = t.strideDepth,\n            n = t.strideHeight,\n            r = t.strideWidth,\n            o = t.padInfo.front,\n            i = t.padInfo.top,\n            a = t.padInfo.left;\n        this.userCode = \"\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int wF = coords.x;\\n        int wR = coords.y;\\n        int wC = coords.z;\\n        int d1 = coords.w;\\n        int d2 = coords.u;\\n\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yF = 0; yF < \" + t.outDepth + \"; yF++) {\\n            int xF = wF + yF * \" + e + \" - \" + o + \";\\n\\n            if (xF < 0 || xF >= \" + t.inDepth + \") {\\n              continue;\\n            }\\n\\n            for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n              int xR = wR + yR * \" + n + \" - \" + i + \";\\n\\n              if (xR < 0 || xR >= \" + t.inHeight + \") {\\n                continue;\\n              }\\n\\n              for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n                int xC = wC + yC * \" + r + \" - \" + a + \";\\n\\n                if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                  continue;\\n                }\\n\\n                float dyValue = getDy(b, yF, yR, yC, d2);\\n                float xValue = getX(b, xF, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          Yo = function (t) {\n        this.variableNames = [\"dy\", \"W\"], this.outputShape = t.inShape;\n        var e = t.filterDepth,\n            n = t.filterHeight,\n            r = t.filterWidth,\n            o = t.strideDepth,\n            i = t.strideHeight,\n            a = t.strideWidth,\n            s = e - 1 - t.padInfo.front,\n            u = n - 1 - t.padInfo.top,\n            c = r - 1 - t.padInfo.left;\n        this.userCode = \"\\n      const ivec3 pads = ivec3(\" + s + \", \" + u + \", \" + c + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d1 = coords.u;\\n\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyFCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \" + e + \"; wF++) {\\n          float dyF = float(dyFCorner + wF) / \" + o + \".0;\\n\\n          if (dyF < 0.0 || dyF >= \" + t.outDepth + \".0 || fract(dyF) > 0.0) {\\n            continue;\\n          }\\n          int idyF = int(dyF);\\n\\n          int wFPerm = \" + e + \" - 1 - wF;\\n\\n          for (int wR = 0; wR < \" + n + \"; wR++) {\\n            float dyR = float(dyRCorner + wR) / \" + i + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n              fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            int wRPerm = \" + n + \" - 1 - wR;\\n\\n            for (int wC = 0; wC < \" + r + \"; wC++) {\\n              float dyC = float(dyCCorner + wC) / \" + a + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              int wCPerm = \" + r + \" - 1 - wC;\\n\\n              for (int d2 = 0; d2 < \" + t.outChannels + \"; d2++) {\\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          Jo = function (t) {\n        this.variableNames = [\"x\", \"dy\"], this.outputShape = t.filterShape;\n        var e = t.strideHeight,\n            n = t.strideWidth,\n            r = t.padInfo.top,\n            o = t.padInfo.left,\n            i = t.outChannels / t.inChannels;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int dm = coords.w;\\n        int d2 = d1 * \" + i + \" + dm;\\n\\n        float dotProd = 0.0;\\n\\n        // TO DO: Vec4 over the batch size\\n        for (int b = 0; b < \" + t.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + t.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + e + \" - \" + r + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + t.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + n + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          Zo = function (t) {\n        this.variableNames = [\"dy\", \"W\"], this.outputShape = t.inShape;\n        var e = t.filterHeight,\n            n = t.filterWidth,\n            r = t.strideHeight,\n            o = t.strideWidth,\n            i = e - 1 - t.padInfo.top,\n            a = n - 1 - t.padInfo.left,\n            s = t.outChannels / t.inChannels;\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + i + \", \" + a + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        float dotProd = 0.0;\\n\\n        for (int wR = 0; wR < \" + e + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + r + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + e + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + n + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + n + \" - 1 - wC;\\n\\n            // TO DO: Vec4 over the channelMul\\n            for (int dm = 0; dm < \" + s + \"; dm++) {\\n              int d2 = d1 * \" + s + \" + dm;\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          ti = function (t, e, n, r) {\n        void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\"x\", \"W\"], this.outputShape = t.outShape;\n        var o = t.padInfo.top,\n            i = t.padInfo.left,\n            a = t.strideHeight,\n            s = t.strideWidth,\n            u = t.dilationHeight,\n            c = t.dilationWidth,\n            l = t.filterHeight,\n            h = t.filterWidth,\n            p = 4 * Math.floor(t.inChannels / 4),\n            f = t.inChannels % 4,\n            d = \"channelsLast\" === t.dataFormat,\n            m = d ? 1 : 2,\n            g = d ? 2 : 3,\n            v = d ? 3 : 1,\n            y = \"\",\n            b = \"\";\n        n && (y = r ? \"float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"\\n          float activation(float x) {\\n            \" + n + \"\\n          }\\n        \", b = \"result = activation(result);\");\n        var w = e ? \"result += getBiasAtOutCoords();\" : \"\";\n        e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + y + \"\\n\\n      const ivec2 strides = ivec2(\" + a + \", \" + s + \");\\n      const ivec2 pads = ivec2(\" + o + \", \" + i + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d2 = coords[\" + v + \"];\\n\\n        ivec2 xRCCorner =\\n            ivec2(coords[\" + m + \"], coords[\" + g + \"]) * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + l + \"; wR++) {\\n          int xR = xRCorner + wR * \" + u + \";\\n\\n          if (xR < 0 || xR >= \" + t.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + h + \"; wC++) {\\n            int xC = xCCorner + wC * \" + c + \";\\n\\n            if (xC < 0 || xC >= \" + t.inWidth + \") {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < \" + p + \"; d1 += 4) {\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              if (\" + d + \") {\\n                vec4 xValues = vec4(\\n                  getX(batch, xR, xC, d1),\\n                  getX(batch, xR, xC, d1 + 1),\\n                  getX(batch, xR, xC, d1 + 2),\\n                  getX(batch, xR, xC, d1 + 3)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec4 xValues = vec4(\\n                  getX(batch, d1, xR, xC),\\n                  getX(batch, d1 + 1, xR, xC),\\n                  getX(batch, d1 + 2, xR, xC),\\n                  getX(batch, d1 + 3, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n\\n            if (\" + (1 === f) + \") {\\n\\n              if (\" + d + \") {\\n                dotProd +=\\n                    getX(batch, xR, xC, \" + p + \") *\\n                    getW(wR, wC, \" + p + \", d2);\\n              } else {\\n                dotProd +=\\n                    getX(batch, \" + p + \", xR, xC) *\\n                    getW(wR, wC, \" + p + \", d2);\\n              }\\n\\n            } else if (\" + (2 === f) + \") {\\n              vec2 wValues = vec2(\\n                getW(wR, wC, \" + p + \", d2),\\n                getW(wR, wC, \" + p + \" + 1, d2)\\n              );\\n\\n              if (\" + d + \") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xR, xC, \" + p + \"),\\n                  getX(batch, xR, xC, \" + p + \" + 1)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec2 xValues = vec2(\\n                  getX(batch, \" + p + \", xR, xC),\\n                  getX(batch, \" + p + \" + 1, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            } else if (\" + (3 === f) + \") {\\n              vec3 wValues = vec3(\\n                getW(wR, wC, \" + p + \", d2),\\n                getW(wR, wC, \" + p + \" + 1, d2),\\n                getW(wR, wC, \" + p + \" + 2, d2)\\n              );\\n\\n              if (\" + d + \") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xR, xC, \" + p + \"),\\n                  getX(batch, xR, xC, \" + p + \" + 1),\\n                  getX(batch, xR, xC, \" + p + \" + 2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec3 xValues = vec3(\\n                  getX(batch, \" + p + \", xR, xC),\\n                  getX(batch, \" + p + \" + 1, xR, xC),\\n                  getX(batch, \" + p + \" + 2, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            }\\n          }\\n        }\\n\\n        float result = dotProd;\\n        \" + w + \"\\n        \" + b + \"\\n        setOutput(result);\\n      }\\n    \";\n      },\n          ei = function (t) {\n        this.variableNames = [\"x\", \"W\"], this.outputShape = t.outShape;\n        var e = t.padInfo.front,\n            n = t.padInfo.top,\n            r = t.padInfo.left,\n            o = t.strideDepth,\n            i = t.strideHeight,\n            a = t.strideWidth,\n            s = t.dilationDepth,\n            u = t.dilationHeight,\n            c = t.dilationWidth,\n            l = t.filterDepth,\n            h = t.filterHeight,\n            p = t.filterWidth,\n            f = 4 * Math.floor(t.inChannels / 4),\n            d = t.inChannels % 4;\n        this.userCode = \"\\n      const ivec3 strides = ivec3(\" + o + \", \" + i + \", \" + a + \");\\n      const ivec3 pads = ivec3(\" + e + \", \" + n + \", \" + r + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d2 = coords.u;\\n\\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xFCorner = xFRCCorner.x;\\n        int xRCorner = xFRCCorner.y;\\n        int xCCorner = xFRCCorner.z;\\n\\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\\n        // values in that axis.\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < \" + l + \"; wF++) {\\n          int xF = xFCorner + wF * \" + s + \";\\n\\n          if (xF < 0 || xF >= \" + t.inDepth + \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \" + h + \"; wR++) {\\n            int xR = xRCorner + wR * \" + u + \";\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + p + \"; wC++) {\\n              int xC = xCCorner + wC * \" + c + \";\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              for (int d1 = 0; d1 < \" + f + \"; d1 += 4) {\\n                vec4 xValues = vec4(\\n                  getX(batch, xF, xR, xC, d1),\\n                  getX(batch, xF, xR, xC, d1 + 1),\\n                  getX(batch, xF, xR, xC, d1 + 2),\\n                  getX(batch, xF, xR, xC, d1 + 3)\\n                );\\n                vec4 wValues = vec4(\\n                  getW(wF, wR, wC, d1, d2),\\n                  getW(wF, wR, wC, d1 + 1, d2),\\n                  getW(wF, wR, wC, d1 + 2, d2),\\n                  getW(wF, wR, wC, d1 + 3, d2)\\n                );\\n\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n              if (\" + (1 === d) + \") {\\n                dotProd +=\\n                  getX(batch, xF, xR, xC, \" + f + \") *\\n                  getW(wF, wR, wC, \" + f + \", d2);\\n              } else if (\" + (2 === d) + \") {\\n                vec2 xValues = vec2(\\n                  getX(batch, xF, xR, xC, \" + f + \"),\\n                  getX(batch, xF, xR, xC, \" + f + \" + 1)\\n                );\\n                vec2 wValues = vec2(\\n                  getW(wF, wR, wC, \" + f + \", d2),\\n                  getW(wF, wR, wC, \" + f + \" + 1, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else if (\" + (3 === d) + \") {\\n                vec3 xValues = vec3(\\n                  getX(batch, xF, xR, xC, \" + f + \"),\\n                  getX(batch, xF, xR, xC, \" + f + \" + 1),\\n                  getX(batch, xF, xR, xC, \" + f + \" + 2)\\n                );\\n                vec3 wValues = vec3(\\n                  getW(wF, wR, wC, \" + f + \", d2),\\n                  getW(wF, wR, wC, \" + f + \" + 1, d2),\\n                  getW(wF, wR, wC, \" + f + \" + 2, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          ni = function (t, e, n, r) {\n        void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\"x\", \"W\"], this.outputShape = t.outShape;\n        var o = t.inHeight,\n            i = t.inWidth,\n            a = t.padInfo.top,\n            s = t.padInfo.left,\n            u = t.strideHeight,\n            c = t.strideWidth,\n            l = t.dilationHeight,\n            h = t.dilationWidth,\n            p = t.filterHeight,\n            f = t.filterWidth,\n            d = t.outChannels / t.inChannels,\n            m = \"\",\n            g = \"\";\n        n && (m = r ? \"float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"\\n          float activation(float x) {\\n            \" + n + \"\\n          }\\n        \", g = \"result = activation(result);\");\n        var v = e ? \"result += getBiasAtOutCoords();\" : \"\";\n        e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + m + \"\\n\\n      const ivec2 strides = ivec2(\" + u + \", \" + c + \");\\n      const ivec2 pads = ivec2(\" + a + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2 / \" + d + \";\\n        int q = d2 - d1 * \" + d + \";\\n\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\\n        for (int wR = 0; wR < \" + p + \"; wR++) {\\n          int xR = xRCorner + wR * \" + l + \";\\n\\n          if (xR < 0 || xR >= \" + o + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + f + \"; wC++) {\\n            int xC = xCCorner + wC * \" + h + \";\\n\\n            if (xC < 0 || xC >= \" + i + \") {\\n              continue;\\n            }\\n\\n            float xVal = getX(batch, xR, xC, d1);\\n            float wVal = getW(wR, wC, d1, q);\\n            dotProd += xVal * wVal;\\n          }\\n        }\\n\\n        float result = dotProd;\\n        \" + v + \"\\n        \" + g + \"\\n        setOutput(result);\\n      }\\n    \";\n      },\n          ri = function (t, e, n, r) {\n        void 0 === e && (e = !1), void 0 === n && (n = null), void 0 === r && (r = !1), this.variableNames = [\"x\", \"W\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t.outShape;\n\n        for (var o = t.inHeight, i = t.inWidth, a = t.padInfo.top, s = t.padInfo.left, u = t.strideHeight, c = t.strideWidth, l = t.dilationHeight, h = t.dilationWidth, p = t.filterHeight, f = t.filterWidth, d = f, m = \"int xR; int xC; int xCOffset;\", g = 0; g < p; g++) for (var v = 0; v < f; v++) m += \"\\n          vec4 xTexelR\" + g + \"C\" + 2 * v + \" = vec4(0.);\\n          vec4 wR\" + g + \"C\" + v + \" = vec4(0.);\\n          vec4 xR\" + g + \"C\" + v + \" = vec4(0.);\";\n\n        for (g = 0; g < p; g++) for (var y = 0; y < d; y++) {\n          if (m += \"\\n          xR = xRCorner + \" + g * l + \";\\n          xC = xCCorner + \" + (v = 2 * y) * h + \";\\n        \", 1 === c) {\n            if (v < f && (m += s % 2 == 1 ? \"\\n                xCOffset = xC + 1;\\n                if(xR >= 0 && xR < \" + o + \" && xCOffset >= 0 && xCOffset < \" + i + \") {\\n                  xTexelR\" + g + \"C\" + v + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + v + \" = vec4(0.);\\n                }\\n\\n                xCOffset = xC + 1 - 2;\\n                if(xR >= 0 && xR < \" + o + \" && xCOffset >= 0 && xCOffset < \" + i + \") {\\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\\n                  xR\" + g + \"C\" + v + \" = vec4(previous.zw, xTexelR\" + g + \"C\" + v + \".xy);\\n                } else {\\n                  xR\" + g + \"C\" + v + \" = vec4(0, 0, xTexelR\" + g + \"C\" + v + \".xy);\\n                }\\n              \" : \"\\n                if(xR >= 0 && xR < \" + o + \" && xC >= 0 && xC < \" + i + \") {\\n                  xTexelR\" + g + \"C\" + v + \" = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + v + \" = vec4(0.);\\n                }\\n\\n                xR\" + g + \"C\" + v + \" = xTexelR\" + g + \"C\" + v + \";\\n              \", v + 1 < f)) {\n              var b = s % 2 == 0 ? w(h) : h;\n              h % 2 == 0 && s % 2 == 1 || h % 2 != 0 && s % 2 != 1 ? (m += \"\\n                  xCOffset = xC + \" + s % 2 + \" + \" + b + \";\\n\\n                  if(xR >= 0 && xR < \" + o + \" &&\\n                    xCOffset >= 0 && xCOffset < \" + i + \") {\\n                    xTexelR\" + g + \"C\" + (v + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                  }\\n                \", h > 1 && (m += \"\\n                    xCOffset -= 2;\\n                    if(xR >= 0 && xR < \" + o + \" &&\\n                      xCOffset >= 0 && xCOffset < \" + i + \") {\\n                      xTexelR\" + g + \"C\" + v + \" = getX(batch, xR, xCOffset, d1);\\n                    } else {\\n                      xTexelR\" + g + \"C\" + v + \" = vec4(0.);\\n                    }\\n                  \"), m += \"\\n                  xR\" + g + \"C\" + (v + 1) + \" = vec4(\\n                    xTexelR\" + g + \"C\" + v + \".zw, xTexelR\" + g + \"C\" + (v + 2) + \".xy);\\n                \") : m += \"\\n                  xCOffset = xC + \" + b + \";\\n\\n                  if(xR >= 0 && xR < \" + o + \" &&\\n                    xCOffset >= 0 && xCOffset < \" + i + \") {\\n                    xTexelR\" + g + \"C\" + (v + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                  }\\n\\n                  xR\" + g + \"C\" + (v + 1) + \" = xTexelR\" + g + \"C\" + (v + 2) + \";\\n                \";\n            }\n          } else v < f && (m += \"\\n              if(xR >= 0 && xR < \" + o + \") {\\n            \", s % 2 == 1 ? (m += \"\\n                xCOffset = xC + 1 - \" + c + \";\\n                if(xCOffset >= 0 && xCOffset < \" + i + \") {\\n                  xTexelR\" + g + \"C\" + v + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + v + \" = vec4(0.);\\n                }\\n\\n                if(xC + 1 >= 0 && xC + 1 < \" + i + \") {\\n                  xTexelR\" + g + \"C\" + (v + 2) + \" = getX(batch, xR, xC + 1, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + (v + 2) + \" = vec4(0.);\\n                }\\n\\n                xR\" + g + \"C\" + v + \" = vec4(\\n                  xTexelR\" + g + \"C\" + v + \".zw, xTexelR\" + g + \"C\" + (v + 2) + \".zw);\\n              \", v + 1 < f && (m += \"\\n                  vec4 final = vec4(0.);\\n                  xCOffset = xC + 1 + \" + c + \";\\n                  if(xCOffset >= 0 && xCOffset < \" + i + \") {\\n                    final = getX(batch, xR, xCOffset, d1);\\n                  }\\n                  xR\" + g + \"C\" + (v + 1) + \" = vec4(xTexelR\" + g + \"C\" + (v + 2) + \".xy, final.xy);\\n                \")) : (m += \"\\n                if(xC >= 0 && xC < \" + i + \") {\\n                  xTexelR\" + g + \"C\" + v + \" = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + v + \" = vec4(0.);\\n                }\\n\\n                xCOffset = xC + \" + c + \";\\n                if(xCOffset >= 0 && xCOffset < \" + i + \") {\\n                  xTexelR\" + g + \"C\" + (v + 2) + \" = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR\" + g + \"C\" + (v + 2) + \" = vec4(0.);\\n                }\\n\\n                xR\" + g + \"C\" + v + \" = vec4(\\n                  xTexelR\" + g + \"C\" + v + \".xy, xTexelR\" + g + \"C\" + (v + 2) + \".xy);\\n              \", v + 1 < f && (m += \"\\n                  xR\" + g + \"C\" + (v + 1) + \" = vec4(\\n                    xTexelR\" + g + \"C\" + v + \".zw, xTexelR\" + g + \"C\" + (v + 2) + \".zw);\\n                \")), m += \"}\");\n\n          v < f && (m += \"\\n            vec4 wTexelR\" + g + \"C\" + v + \" = getW(\" + g + \", \" + v + \", d1, q);\\n            wR\" + g + \"C\" + v + \" = vec4(wTexelR\" + g + \"C\" + v + \".xz, wTexelR\" + g + \"C\" + v + \".xz);\\n          \", v + 1 < f && (m += \"\\n              vec4 wTexelR\" + g + \"C\" + (v + 1) + \" = getW(\" + g + \", \" + (v + 1) + \", d1, q);\\n              wR\" + g + \"C\" + (v + 1) + \" =\\n                vec4(wTexelR\" + g + \"C\" + (v + 1) + \".xz, wTexelR\" + g + \"C\" + (v + 1) + \".xz);\"));\n        }\n\n        for (g = 0; g < p; g++) for (v = 0; v < f; v++) m += \"dotProd += xR\" + g + \"C\" + v + \" * wR\" + g + \"C\" + v + \";\";\n\n        var x = \"\",\n            S = \"\";\n        n && (x = r ? \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + n + \"\\n        }\" : \"vec4 activation(vec4 x) {\\n          \" + n + \"\\n        }\", S = \"result = activation(result);\");\n        var E = e ? \"result += getBiasAtOutCoords();\" : \"\";\n        e && this.variableNames.push(\"bias\"), r && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + x + \"\\n\\n      const ivec2 strides = ivec2(\" + u + \", \" + c + \");\\n      const ivec2 pads = ivec2(\" + a + \", \" + s + \");\\n\\n      void main() {\\n\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2;\\n        int q = 0;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        vec4 dotProd = vec4(0.);\\n\\n        \" + m + \"\\n\\n        vec4 result = dotProd;\\n        \" + E + \"\\n        \" + S + \"\\n        setOutput(result);\\n      }\\n    \";\n      },\n          oi = function (t, e, n, r, o) {\n        this.variableNames = [\"Image\", \"Boxes\", \"BoxInd\"], this.outputShape = [];\n        var i = t[0],\n            a = t[1],\n            s = t[2],\n            u = t[3],\n            c = e[0],\n            l = n[0],\n            h = n[1];\n        this.outputShape = [c, l, h, u];\n        var p = \"bilinear\" === r ? 1 : 0,\n            f = [a - 1 + \".0\", s - 1 + \".0\"],\n            d = f[0],\n            m = f[1],\n            g = l > 1 ? [\"\" + (a - 1) / (l - 1), \"(y2-y1) * height_ratio\", \"y1*\" + d + \" + float(y)*(height_scale)\"] : [\"0.0\", \"0.0\", \"0.5 * (y1+y2) * \" + d],\n            v = g[0],\n            y = g[1],\n            b = g[2],\n            w = h > 1 ? [\"\" + (s - 1) / (h - 1), \"(x2-x1) * width_ratio\", \"x1*\" + m + \" + float(x)*(width_scale)\"] : [\"0.0\", \"0.0\", \"0.5 * (x1+x2) * \" + m],\n            x = w[0],\n            S = w[1],\n            E = w[2];\n        this.userCode = \"\\n      const float height_ratio = float(\" + v + \");\\n      const float width_ratio = float(\" + x + \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \" + i + \") {\\n          return;\\n        }\\n\\n        float height_scale = \" + y + \";\\n        float width_scale = \" + S + \";\\n\\n        float in_y = \" + b + \";\\n        if( in_y < 0.0 || in_y > \" + d + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n        float in_x = \" + E + \";\\n        if( in_x < 0.0 || in_x > \" + m + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\\n        if(\" + p + \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\\n\\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\\n\\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\\n\\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\\n          float newValue = top + (bottom - top) * fracCR.y;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestCR = ivec2(floor(\\n            sourceFracIndexCR + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";\n      },\n          ii = function (t, e, n) {\n        this.variableNames = [\"x\"], this.outputShape = t;\n        var r = t.length,\n            o = t[t.length - 1],\n            i = n ? \"<\" : \">\";\n\n        this.userCode = \"\\n      int getIndex(int i) {\\n        \" + (n ? \"return \" + o + \" -i - 1;\" : \"return i;\") + \"\\n      }\\n\\n      void main() {\\n        \" + Ao(r) + \" coords = getOutputCoords();\\n        int end = \" + ai(r, \"coords\") + \";\\n        float val = 0.0;\\n        for (int i = \" + o + \" - 1; i >= 0; i -= 1) {\\n          int idx = getIndex(i);\\n          if (idx \" + i + \" end) {\\n            continue;\\n          }\\n          if (idx == end && \" + e + \") {\\n            continue;\\n          }\\n          \" + ai(r, \"coords\") + \" = idx;\\n          val += getX(\" + function (t, e) {\n          if (1 === t) return \"\" + e;\n          if (2 === t) return e + \".x, \" + e + \".y\";\n          if (3 === t) return e + \".x, \" + e + \".y, \" + e + \".z\";\n          if (4 === t) return e + \".x, \" + e + \".y, \" + e + \".z, \" + e + \".w\";\n          throw Error(\"Cumulative sum for rank \" + t + \" is not yet supported\");\n        }(r, \"coords\") + \");\\n        }\\n        setOutput(val);\\n      }\\n    \";\n      };\n\n      function ai(t, e) {\n        if (1 === t) return \"\" + e;\n        if (2 === t) return e + \".y\";\n        if (3 === t) return e + \".z\";\n        if (4 === t) return e + \".w\";\n        throw Error(\"Cumulative sum for rank \" + t + \" is not yet supported\");\n      }\n\n      var si = function (t) {\n        this.variableNames = [\"A\"], this.packedInputs = !1, this.packedOutput = !0, this.outPackingScheme = Ft.DENSE;\n        var e = Gt(t),\n            n = mo();\n        this.outputShape = t, this.userCode = \"\\n      ivec3 outCoordsFromFlatIndex(int index) {\\n        \" + go([\"r\", \"c\", \"d\"], t) + \"\\n        return ivec3(r, c, d);\\n      }\\n\\n      void main() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n          vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = 4 * (resTexRC.x * \" + e[1] + \" + resTexRC.y);\\n\\n        vec4 result = vec4(0.);\\n\\n        for (int i=0; i<4; i++) {\\n          int flatIndex = index + i;\\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\\n          result[i] = getA(rc.x, rc.y, rc.z);\\n        }\\n\\n        \" + n.output + \" = result;\\n      }\\n    \";\n      },\n          ui = function (t) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !0, this.outPackingScheme = Ft.DENSE;\n        var e = Gt(t),\n            n = mo();\n        this.outputShape = t, this.userCode = \"\\n      ivec3 outCoordsFromFlatIndex(int index) {\\n        \" + go([\"r\", \"c\", \"d\"], t) + \"\\n        return ivec3(r, c, d);\\n      }\\n\\n      void main() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n          vec2(\" + e[0] + \", \" + e[1] + \"));\\n        int index = 4 * (resTexRC.x * \" + e[1] + \" + resTexRC.y);\\n\\n        vec4 result = vec4(0.);\\n\\n        for (int i=0; i<4; i++) {\\n          int flatIndex = index + i;\\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\\n        }\\n\\n        \" + n.output + \" = result;\\n      }\\n    \";\n      },\n          ci = function () {\n        function t(t, e, n) {\n          this.variableNames = [\"x\"], this.outputShape = [], this.outputShape = t, this.blockSize = e, this.dataFormat = n, this.userCode = \"\\n    void main() {\\n      ivec4 coords = getOutputCoords();\\n      int b = coords[0];\\n      int h = \" + this.getHeightCoordString() + \";\\n      int w = \" + this.getWidthCoordString() + \";\\n      int d = \" + this.getDepthCoordString() + \";\\n\\n      int in_h = h / \" + e + \";\\n      int offset_h = imod(h, \" + e + \");\\n      int in_w = w / \" + e + \";\\n      int offset_w = imod(w, \" + e + \");\\n      int offset_d = (offset_h * \" + e + \" + offset_w) *\\n        \" + this.getOutputDepthSize() + \";\\n      int in_d = d + offset_d;\\n\\n      float result = \" + this.getInputSamplingString() + \";\\n      setOutput(result);\\n    }\\n  \";\n        }\n\n        return t.prototype.getHeightCoordString = function () {\n          return \"NHWC\" === this.dataFormat ? \"coords[1]\" : \"coords[2]\";\n        }, t.prototype.getWidthCoordString = function () {\n          return \"NHWC\" === this.dataFormat ? \"coords[2]\" : \"coords[3]\";\n        }, t.prototype.getDepthCoordString = function () {\n          return \"NHWC\" === this.dataFormat ? \"coords[3]\" : \"coords[1]\";\n        }, t.prototype.getOutputDepthSize = function () {\n          return \"NHWC\" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];\n        }, t.prototype.getInputSamplingString = function () {\n          return \"NHWC\" === this.dataFormat ? \"getX(b, in_h, in_w, in_d)\" : \"getX(b, in_d, in_h, in_w)\";\n        }, t;\n      }(),\n          li = function (t) {\n        this.variableNames = [\"X\"], this.outputShape = [t, t], this.userCode = \"\\n      void main() {\\n          ivec2 coords = getOutputCoords();\\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\\n          setOutput(val);\\n      }\\n    \";\n      },\n          hi = function (t) {\n        this.variableNames = [\"A\"], this.outTexUsage = Lt.DOWNLOAD;\n        var e = mo();\n        this.outputShape = t, this.userCode = \"\\n      \" + yo + \"\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        \" + e.output + \" = encode_float(x);\\n      }\\n    \";\n      },\n          pi = function (t) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !1, this.outTexUsage = Lt.DOWNLOAD;\n        var e = mo();\n        this.outputShape = t, this.userCode = \"\\n      \" + yo + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\\n        \" + e.output + \" = encode_float(x);\\n      }\\n    \";\n      },\n          fi = function (t, e, n) {\n        void 0 === n && (n = !1), this.variableNames = [\"A\"];\n        var r = mo(),\n            o = e[0],\n            i = e[1];\n        this.outputShape = t;\n        var a = \"result\";\n        n && (a = \"floor(result * 255. + 0.5)\"), this.userCode = \"\\n      \" + vo(t) + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        int flatIndex = getFlatIndex(coords);\\n        int offset = imod(flatIndex, 4);\\n\\n        flatIndex = idiv(flatIndex, 4, 1.);\\n        \\n        int r = flatIndex / \" + i + \";\\n        int c = imod(flatIndex, \" + i + \");\\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(\" + i + \".0, \" + o + \".0);\\n        vec4 values = \" + r.texture2D + \"(A, uv);\\n\\n        float result;\\n\\n        if(offset == 0) {\\n          result = values[0];\\n        } else if(offset == 1) {\\n          result = values[1];\\n        } else if(offset == 2) {\\n          result = values[2];\\n        } else {\\n          result = values[3];\\n        }\\n\\n        \" + r.output + \" = vec4(\" + a + \", 0., 0., 0.);\\n      }\\n    \";\n      },\n          di = function (t, e, n) {\n        void 0 === n && (n = !1), this.variableNames = [\"A\"], this.packedInputs = !1, this.packedOutput = !0;\n        var r = mo(),\n            o = e[0],\n            i = e[1];\n        this.outputShape = t;\n        var a = \"\",\n            s = \"result\";\n        n && (s = \"floor(result * 255. + 0.5)\");\n\n        for (var u = 0; u <= 1; u++) for (var c = 0; c <= 1; c++) {\n          var l = 2 * u + c;\n          a += \"\\n          localCoords = coords;\\n          if(localCoords[2] + \" + c + \" < \" + t[2] + \") {\\n            localCoords[2] += \" + c + \";\\n            if(localCoords[1] + \" + u + \" < \" + t[1] + \") {\\n              localCoords[1] += \" + u + \";\\n\\n              flatIndex = getFlatIndex(localCoords);\\n              offset = imod(flatIndex, 4);\\n\\n              flatIndex = idiv(flatIndex, 4, 1.);\\n\\n              r = flatIndex / \" + i + \";\\n              c = imod(flatIndex, \" + i + \");\\n              uv = (vec2(c, r) + halfCR) / vec2(\" + i + \".0, \" + o + \".0);\\n              values = \" + r.texture2D + \"(A, uv);\\n\\n              if(offset == 0) {\\n                result[\" + l + \"] = values[0];\\n              } else if(offset == 1) {\\n                result[\" + l + \"] = values[1];\\n              } else if(offset == 2) {\\n                result[\" + l + \"] = values[2];\\n              } else {\\n                result[\" + l + \"] = values[3];\\n              }\\n            }\\n          }\\n        \";\n        }\n\n        this.userCode = \"\\n      \" + vo(t) + \"\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n        int flatIndex, r, c, offset;\\n        ivec3 localCoords;\\n        vec2 uv;\\n        vec4 values;\\n\\n        \" + a + \"\\n\\n        \" + r.output + \" = \" + s + \";\\n      }\\n    \";\n      },\n          mi = function (t, e, n) {\n        this.variableNames = [\"real\", \"imag\"];\n        var r = e[1];\n        this.outputShape = e;\n        var o = n ? \"2.0 * \" + Math.PI : \"-2.0 * \" + Math.PI,\n            i = n ? r + \".0\" : \"1.0\";\n        this.userCode = \"\\n      const float exponentMultiplier = \" + o + \";\\n\\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\\n        \" + t + \"\\n      }\\n\\n      float mulMatDFT(int batch, int index) {\\n        float indexRatio = float(index) / float(\" + r + \");\\n        float exponentMultiplierTimesIndexRatio =\\n            exponentMultiplier * indexRatio;\\n\\n        float result = 0.0;\\n\\n        for (int i = 0; i < \" + r + \"; i++) {\\n          // x = (-2|2 * PI / N) * index * i;\\n          float x = exponentMultiplierTimesIndexRatio * float(i);\\n          float expR = cos(x);\\n          float expI = sin(x);\\n          float real = getReal(batch, i);\\n          float imag = getImag(batch, i);\\n\\n          result +=\\n              unaryOpComplex(real, expR, imag, expI) / \" + i + \";\\n        }\\n\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        setOutput(mulMatDFT(coords[0], coords[1]));\\n      }\\n    \";\n      },\n          gi = function () {\n        function t(t, e) {\n          this.outputShape = [], this.variableNames = [\"x\"], this.outputShape = t, this.userCode = \"\\n      uniform float value;\\n      void main() {\\n        // Input can be obtained from uniform value.\\n        setOutput(value);\\n      }\\n    \";\n        }\n\n        return t.prototype.getCustomSetupFunc = function (t) {\n          var e = this;\n          return function (n, r) {\n            null == e.valueLoc && (e.valueLoc = n.getUniformLocationNoThrow(r, \"value\")), n.gl.uniform1f(e.valueLoc, t);\n          };\n        }, t;\n      }(),\n          vi = function (t) {\n        this.variableNames = [\"A\"];\n        var e = mo(),\n            n = t[0],\n            r = t[1];\n        this.outputShape = t, this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + r + \".0, \" + n + \".0);\\n\\n        vec4 values = \" + e.texture2D + \"(A, uv);\\n        float value;\\n        if (depth == 0) {\\n          value = values.r;\\n        } else if (depth == 1) {\\n          value = values.g;\\n        } else if (depth == 2) {\\n          value = values.b;\\n        } else if (depth == 3) {\\n          value = values.a;\\n        }\\n\\n        setOutput(floor(value * 255.0 + 0.5));\\n      }\\n    \";\n      },\n          yi = function (t) {\n        this.variableNames = [\"A\"], this.packedInputs = !1, this.packedOutput = !0;\n        var e = mo(),\n            n = t[0],\n            r = t[1];\n        this.outputShape = t, this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n\\n        vec4 result = vec4(0.);\\n\\n        for(int row=0; row<=1; row++) {\\n          for(int col=0; col<=1; col++) {\\n            texC = coords[1] + row;\\n            depth = coords[2] + col;\\n\\n            vec2 uv = (vec2(texC, texR) + halfCR) /\\n                       vec2(\" + r + \".0, \" + n + \".0);\\n            vec4 values = \" + e.texture2D + \"(A, uv);\\n            float value;\\n            if (depth == 0) {\\n              value = values.r;\\n            } else if (depth == 1) {\\n              value = values.g;\\n            } else if (depth == 2) {\\n              value = values.b;\\n            } else if (depth == 3) {\\n              value = values.a;\\n            }\\n\\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\\n          }\\n        }\\n\\n        \" + e.output + \" = result;\\n      }\\n    \";\n      },\n          bi = function (t, e, n) {\n        this.variableNames = [\"A\", \"indices\"];\n        var r = t.slice();\n        r[n] = e, this.outputShape = r, this.rank = r.length;\n\n        var o = Ao(this.rank),\n            i = function (t, e) {\n          var n = t.length;\n          if (n > 4) throw Error(\"Gather for rank \" + n + \" is not yet supported\");\n          if (1 === n) return \"int(getIndices(resRC))\";\n\n          for (var r = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\"], o = [], i = 0; i < t.length; i++) i === e ? o.push(\"int(getIndices(\" + r[i] + \"))\") : o.push(\"\" + r[i]);\n\n          return o.join();\n        }(t, n);\n\n        this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + i + \"));\\n      }\\n    \";\n      },\n          wi = function (t, e, n) {\n        this.sliceDim = t, this.strides = e, this.variableNames = [\"x\", \"indices\"], this.outputShape = n;\n        var r = Ao(e.length),\n            o = Ao(n.length),\n            i = this.sliceDim > 1 ? \"strides[j]\" : \"strides\";\n        this.userCode = \"\\n        \" + r + \" strides = \" + r + \"(\" + this.strides + \");\\n         void main() {\\n          \" + o + \" coords = getOutputCoords();\\n          int flattenIndex = 0;\\n          for (int j = 0; j < \" + this.sliceDim + \"; j++) {\\n            int index = round(getIndices(coords[0], j));\\n            flattenIndex += index * \" + i + \";\\n          }\\n          setOutput(getX(flattenIndex, coords[1]));\\n        }\\n      \";\n      };\n\n      function xi(t, e) {\n        var n = mo();\n        return te(t, e, n.version + \"\\n    precision highp float;\\n    \" + n.attribute + \" vec3 clipSpacePos;\\n    \" + n.attribute + \" vec2 uv;\\n    \" + n.varyingVs + \" vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\");\n      }\n\n      function Si(t, e) {\n        return ue(t, e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));\n      }\n\n      function Ei(t, e) {\n        return ce(t, e, new Uint16Array([0, 1, 2, 2, 1, 3]));\n      }\n\n      function Ci(t, e, n, r, o, i, a) {\n        he(n, r);\n        var s = le(t, e),\n            u = t.TEXTURE_2D;\n        return Kt(t, e, function () {\n          return t.bindTexture(u, s);\n        }), Kt(t, e, function () {\n          return t.texParameteri(u, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE);\n        }), Kt(t, e, function () {\n          return t.texParameteri(u, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);\n        }), Kt(t, e, function () {\n          return t.texParameteri(u, t.TEXTURE_MIN_FILTER, t.NEAREST);\n        }), Kt(t, e, function () {\n          return t.texParameteri(u, t.TEXTURE_MAG_FILTER, t.NEAREST);\n        }), Kt(t, e, function () {\n          return t.texImage2D(u, 0, o, n, r, 0, i, a, null);\n        }), Kt(t, e, function () {\n          return t.bindTexture(t.TEXTURE_2D, null);\n        }), s;\n      }\n\n      function Ii(t, e, n, r, o) {\n        var i = Wt(n, r);\n        return Ci(t, e, i[0], i[1], o.internalFormatFloat, o.textureFormatFloat, t.FLOAT);\n      }\n\n      function Ai(t, e, n, r, o) {\n        var i = Wt(n, r);\n        return Ci(t, e, i[0], i[1], o.internalFormatHalfFloat, o.textureFormatFloat, o.textureTypeHalfFloat);\n      }\n\n      function ki(t, e, n, r, o) {\n        var i = Wt(n, r);\n        return Ci(t, e, i[0], i[1], t.RGBA, t.RGBA, t.UNSIGNED_BYTE);\n      }\n\n      function Ti(t, e, n, r, o) {\n        var i = Ht(n, r);\n        return Ci(t, e, i[0], i[1], o.internalFormatPackedFloat, t.RGBA, t.FLOAT);\n      }\n\n      function Ni(t, e, n, r, o) {\n        var i = Ht(n, r);\n        return Ci(t, e, i[0], i[1], o.internalFormatPackedHalfFloat, t.RGBA, o.textureTypeHalfFloat);\n      }\n\n      function Pi(t, e, n, r) {\n        return Kt(t, e, function () {\n          return t.bindBuffer(t.ARRAY_BUFFER, r);\n        }), fe(t, e, n, \"clipSpacePos\", r, 3, 20, 0) && fe(t, e, n, \"uv\", r, 2, 20, 12);\n      }\n\n      function Ri(t, e, n, r, o, i, a) {\n        var s, u, c;\n        Kt(t, e, function () {\n          return t.bindTexture(t.TEXTURE_2D, n);\n        }), i instanceof Uint8Array ? (s = new Uint8Array(r * o * 4), u = t.UNSIGNED_BYTE, c = t.RGBA) : (s = new Float32Array(r * o * 4), u = t.FLOAT, c = a.internalFormatPackedFloat), s.set(i), Kt(t, e, function () {\n          return t.texImage2D(t.TEXTURE_2D, 0, c, r, o, 0, t.RGBA, u, s);\n        }), Kt(t, e, function () {\n          return t.bindTexture(t.TEXTURE_2D, null);\n        });\n      }\n\n      function _i(t, e, n, r) {\n        Kt(t, e, function () {\n          return t.bindTexture(t.TEXTURE_2D, n);\n        }), r.data instanceof Uint8Array ? Kt(t, e, function () {\n          return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, r.width, r.height, 0, t.RGBA, t.UNSIGNED_BYTE, r.data);\n        }) : Kt(t, e, function () {\n          return t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r);\n        }), Kt(t, e, function () {\n          return t.bindTexture(t.TEXTURE_2D, null);\n        });\n      }\n\n      function Mi(t, e, n, r, o) {\n        var i = t.createBuffer();\n        Kt(t, e, function () {\n          return t.bindBuffer(t.PIXEL_PACK_BUFFER, i);\n        });\n        var a = 16 * n * r;\n        return Kt(t, e, function () {\n          return t.bufferData(t.PIXEL_PACK_BUFFER, a, t.STREAM_READ);\n        }), Kt(t, e, function () {\n          return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, 0);\n        }), Kt(t, e, function () {\n          return t.bindBuffer(t.PIXEL_PACK_BUFFER, null);\n        }), i;\n      }\n\n      function Oi(t, e, n) {\n        var r = t,\n            o = new Float32Array(n);\n        return r.bindBuffer(r.PIXEL_PACK_BUFFER, e), r.getBufferSubData(r.PIXEL_PACK_BUFFER, 0, o), r.bindBuffer(r.PIXEL_PACK_BUFFER, null), o;\n      }\n\n      function Di(t, e, n, r, o) {\n        var i = Wt(n, r),\n            a = i[0],\n            s = i[1],\n            u = new Uint8Array(n * r * 4);\n        return Kt(t, e, function () {\n          return t.readPixels(0, 0, a, s, o.downloadTextureFormat, t.UNSIGNED_BYTE, u);\n        }), new Float32Array(u.buffer);\n      }\n\n      function Fi(t, e, n, r, o, i, a, s) {\n        var u = t,\n            c = new Float32Array(function (t, e) {\n          var n = Ht(t, e);\n          return n[0] * n[1] * 4;\n        }(i, a));\n        return u.bindBuffer(u.PIXEL_PACK_BUFFER, e), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c), u.bindBuffer(u.PIXEL_PACK_BUFFER, null), c;\n      }\n\n      function Li(t, e, n, r) {\n        var o = new Float32Array(n * r * 4);\n        return Kt(t, e, function () {\n          return t.readPixels(0, 0, r, n, t.RGBA, t.FLOAT, o);\n        }), o;\n      }\n\n      var Bi = Object.freeze({\n        createVertexShader: xi,\n        createVertexBuffer: Si,\n        createIndexBuffer: Ei,\n        createFloat32MatrixTexture: Ii,\n        createFloat16MatrixTexture: Ai,\n        createUnsignedBytesMatrixTexture: ki,\n        createPackedMatrixTexture: Ti,\n        createFloat16PackedMatrixTexture: Ni,\n        bindVertexProgramAttributeStreams: Pi,\n        uploadDenseMatrixToTexture: Ri,\n        uploadPixelDataToTexture: _i,\n        createBufferFromOutputTexture: Mi,\n        downloadFloat32MatrixFromBuffer: Oi,\n        downloadByteEncodedFloatMatrixFromOutputTexture: Di,\n        downloadPackedMatrixFromBuffer: Fi,\n        downloadMatrixFromPackedOutputTexture: Li\n      }),\n          zi = function () {\n        function t(t) {\n          this.outputTexture = null, this.program = null, this.disposed = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [];\n          var e = h().getNumber(\"WEBGL_VERSION\");\n          if (null != t ? (this.gl = t, Vt(e, t)) : this.gl = Ut(e), 1 === h().getNumber(\"WEBGL_VERSION\")) this.textureFloatExtension = Zt(this.gl, this.debug, \"OES_texture_float\"), this.colorBufferFloatExtension = this.gl.getExtension(\"WEBGL_color_buffer_float\"), this.textureHalfFloatExtension = Zt(this.gl, this.debug, \"OES_texture_half_float\"), this.colorBufferHalfFloatExtension = this.gl.getExtension(\"EXT_color_buffer_half_float\");else if (Me(this.gl, \"EXT_color_buffer_float\")) this.colorBufferFloatExtension = this.gl.getExtension(\"EXT_color_buffer_float\");else {\n            if (!Me(this.gl, \"EXT_color_buffer_half_float\")) throw new Error(\"GL context does not support color renderable floats\");\n            this.colorBufferHalfFloatExtension = this.gl.getExtension(\"EXT_color_buffer_half_float\");\n          }\n          this.vertexBuffer = Si(this.gl, this.debug), this.indexBuffer = Ei(this.gl, this.debug), this.framebuffer = pe(this.gl, this.debug), this.textureConfig = $t(this.gl, this.textureHalfFloatExtension);\n        }\n\n        return Object.defineProperty(t.prototype, \"debug\", {\n          get: function () {\n            return h().getBool(\"DEBUG\");\n          },\n          enumerable: !0,\n          configurable: !0\n        }), t.prototype.dispose = function () {\n          var t = this;\n\n          if (!this.disposed) {\n            null != this.program && console.warn(\"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.\"), null != this.outputTexture && console.warn(\"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.\");\n            var e = this.gl;\n            Kt(e, this.debug, function () {\n              return e.finish();\n            }), Kt(e, this.debug, function () {\n              return e.bindFramebuffer(e.FRAMEBUFFER, null);\n            }), Kt(e, this.debug, function () {\n              return e.deleteFramebuffer(t.framebuffer);\n            }), Kt(e, this.debug, function () {\n              return e.bindBuffer(e.ARRAY_BUFFER, null);\n            }), Kt(e, this.debug, function () {\n              return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null);\n            }), Kt(e, this.debug, function () {\n              return e.deleteBuffer(t.indexBuffer);\n            }), this.disposed = !0;\n          }\n        }, t.prototype.createFloat32MatrixTexture = function (t, e) {\n          return this.throwIfDisposed(), Ii(this.gl, this.debug, t, e, this.textureConfig);\n        }, t.prototype.createFloat16MatrixTexture = function (t, e) {\n          return this.throwIfDisposed(), Ai(this.gl, this.debug, t, e, this.textureConfig);\n        }, t.prototype.createUnsignedBytesMatrixTexture = function (t, e) {\n          return this.throwIfDisposed(), ki(this.gl, this.debug, t, e, this.textureConfig);\n        }, t.prototype.uploadPixelDataToTexture = function (t, e) {\n          this.throwIfDisposed(), _i(this.gl, this.debug, t, e);\n        }, t.prototype.uploadDenseMatrixToTexture = function (t, e, n, r) {\n          this.throwIfDisposed(), Ri(this.gl, this.debug, t, e, n, r, this.textureConfig);\n        }, t.prototype.createFloat16PackedMatrixTexture = function (t, e) {\n          return this.throwIfDisposed(), Ni(this.gl, this.debug, t, e, this.textureConfig);\n        }, t.prototype.createPackedMatrixTexture = function (t, e) {\n          return this.throwIfDisposed(), Ti(this.gl, this.debug, t, e, this.textureConfig);\n        }, t.prototype.deleteMatrixTexture = function (t) {\n          var e = this;\n          this.throwIfDisposed(), this.outputTexture === t && (be(this.gl, this.debug, this.framebuffer), this.outputTexture = null), Kt(this.gl, this.debug, function () {\n            return e.gl.deleteTexture(t);\n          });\n        }, t.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (t, e, n) {\n          var r = this;\n          return this.downloadMatrixDriver(t, function () {\n            return Di(r.gl, r.debug, e, n, r.textureConfig);\n          });\n        }, t.prototype.downloadPackedMatrixFromBuffer = function (t, e, n, r, o, i) {\n          return Fi(this.gl, t, 0, 0, 0, o, i, this.textureConfig);\n        }, t.prototype.downloadFloat32MatrixFromBuffer = function (t, e) {\n          return Oi(this.gl, t, e);\n        }, t.prototype.createBufferFromTexture = function (t, e, n) {\n          this.bindTextureToFrameBuffer(t);\n          var r = Mi(this.gl, this.debug, e, n, this.textureConfig);\n          return this.unbindTextureToFrameBuffer(), r;\n        }, t.prototype.createAndWaitForFence = function () {\n          var t = this.createFence(this.gl);\n          return this.pollFence(t);\n        }, t.prototype.createFence = function (t) {\n          var e,\n              n,\n              r = this;\n\n          if (h().getBool(\"WEBGL_FENCE_API_ENABLED\")) {\n            var o = t,\n                i = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            t.flush(), n = function () {\n              var t = o.clientWaitSync(i, 0, 0);\n              return t === o.ALREADY_SIGNALED || t === o.CONDITION_SATISFIED;\n            }, e = i;\n          } else h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? (e = this.beginQuery(), this.endQuery(), n = function () {\n            return r.isQueryAvailable(e, h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n          }) : n = function () {\n            return !0;\n          };\n\n          return {\n            query: e,\n            isFencePassed: n\n          };\n        }, t.prototype.downloadMatrixFromPackedTexture = function (t, e, n) {\n          var r = this;\n          return this.downloadMatrixDriver(t, function () {\n            return Li(r.gl, r.debug, e, n);\n          });\n        }, t.prototype.createProgram = function (t) {\n          this.throwIfDisposed();\n          var e = this.gl,\n              n = ee(e, this.debug, t),\n              r = xi(e, this.debug),\n              o = ie(e, this.debug);\n          return Kt(e, this.debug, function () {\n            return e.attachShader(o, r);\n          }), Kt(e, this.debug, function () {\n            return e.attachShader(o, n);\n          }), ae(e, this.debug, o), this.debug && se(e, this.debug, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = Pi(e, this.debug, this.program, this.vertexBuffer)), o;\n        }, t.prototype.deleteProgram = function (t) {\n          var e = this;\n          this.throwIfDisposed(), t === this.program && (this.program = null), null != t && Kt(this.gl, this.debug, function () {\n            return e.gl.deleteProgram(t);\n          });\n        }, t.prototype.setProgram = function (t) {\n          var e = this;\n          this.throwIfDisposed(), this.program = t, null != this.program && this.debug && se(this.gl, this.debug, this.program), Kt(this.gl, this.debug, function () {\n            return e.gl.useProgram(t);\n          });\n        }, t.prototype.getUniformLocation = function (t, e, n) {\n          return void 0 === n && (n = !0), this.throwIfDisposed(), n ? me(this.gl, this.debug, t, e) : ge(this.gl, t, e);\n        }, t.prototype.getAttributeLocation = function (t, e) {\n          var n = this;\n          return this.throwIfDisposed(), Kt(this.gl, this.debug, function () {\n            return n.gl.getAttribLocation(t, e);\n          });\n        }, t.prototype.getUniformLocationNoThrow = function (t, e) {\n          return this.throwIfDisposed(), this.gl.getUniformLocation(t, e);\n        }, t.prototype.setInputMatrixTexture = function (t, e, n) {\n          this.throwIfDisposed(), this.throwIfNoProgram(), ve(this.gl, this.debug, this.program, t, e, n);\n        }, t.prototype.setOutputMatrixTexture = function (t, e, n) {\n          this.setOutputMatrixTextureDriver(t, n, e);\n        }, t.prototype.setOutputPackedMatrixTexture = function (t, e, n) {\n          this.throwIfDisposed();\n          var r = Ht(e, n),\n              o = r[0],\n              i = r[1];\n          this.setOutputMatrixTextureDriver(t, o, i);\n        }, t.prototype.setOutputMatrixWriteRegion = function (t, e, n, r) {\n          this.setOutputMatrixWriteRegionDriver(n, t, r, e);\n        }, t.prototype.setOutputPackedMatrixWriteRegion = function (t, e, n, r) {\n          throw new Error(\"setOutputPackedMatrixWriteRegion not implemented.\");\n        }, t.prototype.debugValidate = function () {\n          null != this.program && se(this.gl, this.debug, this.program), we(this.gl);\n        }, t.prototype.executeProgram = function () {\n          this.throwIfDisposed(), this.throwIfNoProgram();\n          var t = this.gl;\n          this.debug && this.debugValidate(), Kt(t, this.debug, function () {\n            return t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0);\n          });\n        }, t.prototype.blockUntilAllProgramsCompleted = function () {\n          var t = this;\n          this.throwIfDisposed(), Kt(this.gl, this.debug, function () {\n            return t.gl.finish();\n          });\n        }, t.prototype.getQueryTimerExtension = function () {\n          return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = Zt(this.gl, this.debug, 2 === h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") ? \"EXT_disjoint_timer_query_webgl2\" : \"EXT_disjoint_timer_query\")), this.disjointQueryTimerExtension;\n        }, t.prototype.getQueryTimerExtensionWebGL2 = function () {\n          return this.getQueryTimerExtension();\n        }, t.prototype.getQueryTimerExtensionWebGL1 = function () {\n          return this.getQueryTimerExtension();\n        }, t.prototype.beginQuery = function () {\n          if (2 === h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n            var t = this.gl,\n                e = this.getQueryTimerExtensionWebGL2(),\n                n = t.createQuery();\n            return t.beginQuery(e.TIME_ELAPSED_EXT, n), n;\n          }\n\n          var r = this.getQueryTimerExtensionWebGL1(),\n              o = r.createQueryEXT();\n          return r.beginQueryEXT(r.TIME_ELAPSED_EXT, o), o;\n        }, t.prototype.endQuery = function () {\n          if (2 !== h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n            var t = this.getQueryTimerExtensionWebGL1();\n            t.endQueryEXT(t.TIME_ELAPSED_EXT);\n          } else {\n            var e = this.gl,\n                n = this.getQueryTimerExtensionWebGL2();\n            e.endQuery(n.TIME_ELAPSED_EXT);\n          }\n        }, t.prototype.waitForQueryAndGetTime = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e = this;\n            return c(this, function (n) {\n              switch (n.label) {\n                case 0:\n                  return [4, _(function () {\n                    return e.disposed || e.isQueryAvailable(t, h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n                  })];\n\n                case 1:\n                  return n.sent(), [2, this.getQueryTime(t, h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))];\n              }\n            });\n          });\n        }, t.prototype.getQueryTime = function (t, e) {\n          if (0 === e) return null;\n\n          if (2 === e) {\n            var n = this.gl;\n            return n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;\n          }\n\n          var r = this.getQueryTimerExtensionWebGL1();\n          return r.getQueryObjectEXT(t, r.QUERY_RESULT_EXT) / 1e6;\n        }, t.prototype.isQueryAvailable = function (t, e) {\n          if (0 === e) return !0;\n\n          if (2 === e) {\n            var n = this.gl,\n                r = this.getQueryTimerExtensionWebGL2(),\n                o = n.getQueryParameter(t, n.QUERY_RESULT_AVAILABLE);\n            return null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;\n          }\n\n          return o = (r = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t, r.QUERY_RESULT_AVAILABLE_EXT), null == this.disjoint && (this.disjoint = this.gl.getParameter(r.GPU_DISJOINT_EXT)), o && !this.disjoint;\n        }, t.prototype.pollFence = function (t) {\n          var e = this;\n          return new Promise(function (n) {\n            e.addItemToPoll(function () {\n              return t.isFencePassed();\n            }, function () {\n              return n();\n            });\n          });\n        }, t.prototype.pollItems = function () {\n          for (var t = function (t) {\n            for (var e = 0; e < t.length; ++e) {\n              if (!t[e]()) break;\n            }\n\n            return e - 1;\n          }(this.itemsToPoll.map(function (t) {\n            return t.isDoneFn;\n          })), e = 0; e <= t; ++e) (0, this.itemsToPoll[e].resolveFn)();\n\n          this.itemsToPoll = this.itemsToPoll.slice(t + 1);\n        }, t.prototype.addItemToPoll = function (t, e) {\n          var n = this;\n          this.itemsToPoll.push({\n            isDoneFn: t,\n            resolveFn: e\n          }), this.itemsToPoll.length > 1 || _(function () {\n            return n.pollItems(), 0 === n.itemsToPoll.length;\n          });\n        }, t.prototype.bindTextureToFrameBuffer = function (t) {\n          this.throwIfDisposed(), ye(this.gl, this.debug, t, this.framebuffer), this.debug && we(this.gl);\n        }, t.prototype.unbindTextureToFrameBuffer = function () {\n          null != this.outputTexture ? (ye(this.gl, this.debug, this.outputTexture, this.framebuffer), this.debug && we(this.gl)) : be(this.gl, this.debug, this.framebuffer);\n        }, t.prototype.downloadMatrixDriver = function (t, e) {\n          this.bindTextureToFrameBuffer(t);\n          var n = e();\n          return this.unbindTextureToFrameBuffer(), n;\n        }, t.prototype.setOutputMatrixTextureDriver = function (t, e, n) {\n          this.throwIfDisposed();\n          var r = this.gl;\n          ye(r, this.debug, t, this.framebuffer), this.debug && we(r), this.outputTexture = t, Kt(r, this.debug, function () {\n            return r.viewport(0, 0, e, n);\n          }), Kt(r, this.debug, function () {\n            return r.scissor(0, 0, e, n);\n          });\n        }, t.prototype.setOutputMatrixWriteRegionDriver = function (t, e, n, r) {\n          var o = this;\n          this.throwIfDisposed(), Kt(this.gl, this.debug, function () {\n            return o.gl.scissor(t, e, n, r);\n          });\n        }, t.prototype.throwIfDisposed = function () {\n          if (this.disposed) throw new Error(\"Attempted to use disposed GPGPUContext.\");\n        }, t.prototype.throwIfNoProgram = function () {\n          if (null == this.program) throw new Error(\"No GPU program is currently set.\");\n        }, t;\n      }();\n\n      function qi(t, e) {\n        if (t.length !== e.length) throw Error(\"Binary was compiled with \" + t.length + \" inputs, but was executed with \" + e.length + \" inputs\");\n        t.forEach(function (t, n) {\n          var r = t.logicalShape,\n              o = e[n],\n              i = o.shape;\n          if (!k(r, i)) throw Error(\"Binary was compiled with different shapes than the current args. Shapes \" + r + \" and \" + i + \" must match\");\n\n          if (!t.isUniform || !o.isUniform) {\n            var a = t.texShape,\n                s = o.isUniform ? null : o.texData.texShape;\n            if (!k(a, s)) throw Error(\"Binary was compiled with different texture shapes than the current args. Shape \" + a + \" and \" + s + \" must match\");\n          }\n        });\n      }\n\n      var Vi = function (t, e, n) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;\n\n        for (var r = n.filterWidth, o = n.inChannels, i = n.strideWidth, a = n.strideHeight, s = n.padInfo, u = n.outWidth, c = n.dilationWidth, l = n.dilationHeight, h = n.dataFormat, p = s.left, f = s.top, d = o * r, m = mo(), g = \"channelsLast\" === h, v = g ? 0 : 1, y = g ? 1 : 2, b = \"\", w = 0; w <= 1; w++) for (var x = 0; x <= 1; x++) b += \"\\n          blockIndex = rc.y + \" + x + \";\\n          pos = rc.x + \" + w + \";\\n\\n          if(blockIndex < \" + t[1] + \" && pos < \" + t[0] + \") {\\n            offsetY = int(blockIndex / (\" + u + \")) * \" + a + \" - \" + f + \";\\n            d0 = offsetY + \" + l + \" * (pos / \" + d + \");\\n\\n            if(d0 < \" + e[v] + \" && d0 >= 0) {\\n\\n              offsetX = int(mod(float(blockIndex), \" + u + \".) * \" + i + \". - \" + p + \".);\\n              d1 = offsetX + \" + c + \" * (int(mod(float(pos), \" + d + \".) / \" + o + \".));\\n\\n              if(d1 < \" + e[y] + \" && d1 >= 0) {\\n\\n                ch = int(mod(float(pos), \" + o + \".));\\n\\n                if (\" + g + \") {\\n                  innerDims = vec2(d1, ch);\\n                  result[\" + (2 * w + x) + \"] = getChannel(\\n                    getA(d0, int(innerDims.x),\\n                    int(innerDims.y)), innerDims);\\n                } else {\\n                  innerDims = vec2(d0, d1);\\n                  result[\" + (2 * w + x) + \"] = getChannel(\\n                    getA(ch, int(innerDims.x),\\n                    int(innerDims.y)), innerDims);\\n                }\\n              }\\n            }\\n          }\\n        \";\n\n        this.userCode = \"\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0);\\n\\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\\n        vec2 innerDims;\\n\\n        \" + b + \"\\n\\n        \" + m.output + \" = result;\\n      }\\n    \";\n      },\n          Ui = function (t, e, n, r, o) {\n        this.variableNames = [\"x\"], this.outputShape = [];\n        var i,\n            a = e,\n            s = t[3] - 1;\n        this.outputShape = t;\n        var u = \"float(\" + n + \") + float(\" + r + \") * sum\";\n        i = .5 === o ? \"inversesqrt(\" + u + \")\" : 1 === o ? \"1.0/(\" + u + \")\" : \"exp(log(\" + u + \") * float(-\" + o + \"));\", this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n        int d = coords[3];\\n        float x = getX(b, r, c, d);\\n        float sum = 0.0;\\n        for (int j = -\" + a + \"; j <= \" + a + \"; j++) {\\n          int idx = d + j;\\n          if (idx >= 0 && idx <=  \" + s + \") {\\n            float z = getX(b, r, c, idx);\\n            sum += z * z;\\n          }\\n        }\\n        float val = x * \" + i + \";\\n        setOutput(val);\\n      }\\n    \";\n      },\n          ji = function (t, e, n, r, o) {\n        this.variableNames = [\"inputImage\", \"outputImage\", \"dy\"], this.outputShape = [], this.outputShape = t, this.depth = t[3], this.depthRadius = e, this.bias = n, this.alpha = r, this.beta = o, this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float result = 0.0;\\n        for (int d = 0; d < \" + this.depth + \"; ++d) {\\n          int depthBegin = int(max(0.0, float(d - \" + e + \")));\\n          int depthEnd = int(min(float(\" + this.depth + \"),\\n              float(d + \" + e + \" + 1)));\\n\\n          const int MIN_DEPTH_BEGIN = 0;\\n          const int MAX_DEPTH_END = \" + this.depth + \";\\n\\n          float norm = 0.0;\\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd) {\\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n\\n          norm = float(\" + r + \") * norm + float(\" + n + \");\\n\\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd){\\n              float dyi = -2.0 * float(\" + r + \")\\n                * float(\" + o + \")\\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\\n                / norm;\\n              if (k == d) {\\n                dyi += pow(norm, -1.0 * \" + o + \");\\n              }\\n              if (k == coords[3]) {\\n                dyi *= getDy(b, r, c, d);\\n                result += dyi;\\n              }\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n      }\\n      setOutput(result);\\n      }\\n    \";\n      },\n          Wi = function (t, e, n, r, o) {\n        this.variableNames = [\"x\"], this.outputShape = [], this.packedInputs = !0, this.packedOutput = !0;\n        var i,\n            a = e,\n            s = t[3] - 1;\n        this.outputShape = t;\n        var u = \"float(\" + n + \") + float(\" + r + \") * sum\";\n        i = .5 === o ? \"inversesqrt(\" + u + \")\" : 1 === o ? \"1.0/(\" + u + \")\" : \"exp(log(\" + u + \") * float(-\" + o + \"));\", this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords.x;\\n        int r = coords.y;\\n        int c = coords.z;\\n        int d = coords.w;\\n\\n        bool hasNextCol = d < \" + this.outputShape[3] + \";\\n        bool hasNextRow = c < \" + this.outputShape[2] + \";\\n\\n        vec4 sum = vec4(0.);\\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\\n\\n        vec4 xAtOutputCoords = vec4(\\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\\n          hasNextCol ?\\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\\n          hasNextRow ?\\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\\n        );\\n\\n        int firstChannel = d - \" + a + \";\\n        vec2 cache = vec2(0.);\\n        if(firstChannel >= 0){\\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\\n            if(hasNextRow){\\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\\n            }\\n        }\\n\\n        ivec2 depth = ivec2(d, d + 1);\\n        for (int j = - \" + a + \"; j <= \" + a + \"; j++) {\\n          ivec2 idx = depth + j;\\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(\" + s + \"));\\n\\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\\n\\n          if(depthInRange || depthPlusOneInRange){\\n            vec4 z = vec4(0.);\\n            vec4 xFragAtCurrentDepth;\\n            z.xz = cache.xy;\\n            if(depthPlusOneInRange && hasNextCol){\\n              xFragAtCurrentDepth = idx.y != d ?\\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\\n              if(hasNextRow){\\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\\n              }\\n            }\\n            cache.xy = z.yw;\\n            sum += z * z;\\n          }\\n        }\\n        vec4 result = xAtOutputCoords * \" + i + \";\\n        setOutput(result);\\n      }\\n    \";\n      },\n          Gi = function (t) {\n        this.variableNames = [\"dy\", \"maxPos\"], this.outputShape = t.inShape;\n        var e = t.strideHeight,\n            n = t.strideWidth,\n            r = t.dilationHeight,\n            o = t.effectiveFilterHeight,\n            i = t.effectiveFilterWidth,\n            a = o - 1 - t.padInfo.top,\n            s = i - 1 - t.padInfo.left,\n            u = o * i - 1;\n        this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + o + \";\\n          wR += \" + r + \") {\\n          float dyR = float(dyRCorner + wR) / \" + e + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + i + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + n + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n            int maxPosValue = \" + u + \" - int(getMaxPos(b, idyR, idyC, d));\\n\\n            // Get the current value, check it against the value from the\\n            // position matrix.\\n            int curPosValue = wR * \" + i + \" + wC;\\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n            dotProd += dyValue * mask;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          Hi = function (t) {\n        this.variableNames = [\"dy\", \"maxPos\"], this.outputShape = t.inShape;\n        var e = t.strideDepth,\n            n = t.strideHeight,\n            r = t.strideWidth,\n            o = t.dilationDepth,\n            i = t.dilationHeight,\n            a = t.dilationWidth,\n            s = t.effectiveFilterDepth,\n            u = t.effectiveFilterHeight,\n            c = t.effectiveFilterWidth,\n            l = s - 1 - t.padInfo.front,\n            h = u - 1 - t.padInfo.top,\n            p = c - 1 - t.padInfo.left,\n            f = s * u * c - 1;\n        this.userCode = \"\\n      const ivec3 pads = ivec3(\" + l + \", \" + h + \", \" + p + \");\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyDCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\\n        // dx(xD, xR, xC, ch).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int wD = 0; wD < \" + s + \";\\n           wD += \" + o + \") {\\n          float dyD = float(dyDCorner + wD) / \" + e + \".0;\\n\\n          if (dyD < 0.0 || dyD >= \" + t.outDepth + \".0 || fract(dyD) > 0.0) {\\n            continue;\\n          }\\n          int idyD = int(dyD);\\n\\n          for (int wR = 0; wR < \" + u + \";\\n              wR += \" + i + \") {\\n            float dyR = float(dyRCorner + wR) / \" + n + \".0;\\n\\n            if (dyR < 0.0 || dyR >= \" + t.outHeight + \".0 ||\\n                fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            for (int wC = 0; wC < \" + c + \";\\n                wC += \" + a + \") {\\n              float dyC = float(dyCCorner + wC) / \" + r + \".0;\\n\\n              if (dyC < 0.0 || dyC >= \" + t.outWidth + \".0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\\n              int maxPosValue = \" + f + \" -\\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\\n\\n              // Get the current value, check it against the value from the\\n              // position matrix.\\n              int curPosValue =\\n                  wD * \" + u + \" * \" + c + \" +\\n                  wR * \" + c + \" + wC;\\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n              dotProd += dyValue * mask;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n      },\n          $i = function (t, e, n, r, o, i, a) {\n        void 0 === n && (n = !1), void 0 === r && (r = !1), void 0 === o && (o = !1), void 0 === i && (i = null), void 0 === a && (a = !1), this.variableNames = [\"matrixA\", \"matrixB\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e;\n        var s = n ? t[1] : t[2],\n            u = Math.ceil(s / 2),\n            c = n ? \"i * 2, rc.y\" : \"rc.y, i * 2\",\n            l = r ? \"rc.z, i * 2\" : \"i * 2, rc.z\",\n            h = n ? [\"a.xxyy\", \"a.zzww\"] : [\"a.xxzz\", \"a.yyww\"],\n            p = r ? [\"b.xzxz\", \"b.ywyw\"] : [\"b.xyxy\", \"b.zwzw\"],\n            f = \"\",\n            d = \"\";\n        i && (f = a ? \"vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          \" + i + \"\\n        }\" : \"vec4 activation(vec4 x) {\\n          \" + i + \"\\n        }\", d = \"result = activation(result);\");\n        var m = o ? \"result += getBiasAtOutCoords();\" : \"\";\n        o && this.variableNames.push(\"bias\"), a && this.variableNames.push(\"preluActivationWeights\"), this.userCode = \"\\n      \" + f + \"\\n\\n      const float sharedDimension = \" + u + \".0;\\n\\n      vec4 dot2x2ARowBCol(ivec3 rc) {\\n        vec4 result = vec4(0);\\n        for (int i = 0; i < \" + u + \"; i++) {\\n          vec4 a = getMatrixA(rc.x, \" + c + \");\\n          vec4 b = getMatrixB(rc.x, \" + l + \");\\n\\n          // These swizzled products need to be separately added.\\n          // See: https://github.com/tensorflow/tfjs/issues/1735\\n          result += (\" + h[0] + \" * \" + p[0] + \");\\n          result += (\" + h[1] + \" * \" + p[1] + \");\\n        }\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n        vec4 result = dot2x2ARowBCol(rc);\\n\\n        \" + m + \"\\n\\n        \" + d + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n      },\n          Ki = function () {\n        function t(t, e, n) {\n          this.variableNames = [\"probs\"], this.outputShape = [t, n], this.userCode = \"\\n      uniform float seed;\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n\\n        float r = random(seed);\\n        float cdf = 0.0;\\n\\n        for (int i = 0; i < \" + (e - 1) + \"; i++) {\\n          cdf += getProbs(batch, i);\\n\\n          if (r < cdf) {\\n            setOutput(float(i));\\n            return;\\n          }\\n        }\\n\\n        // If no other event happened, last event happened.\\n        setOutput(float(\" + (e - 1) + \"));\\n      }\\n    \";\n        }\n\n        return t.prototype.getCustomSetupFunc = function (t) {\n          var e = this;\n          return function (n, r) {\n            null == e.seedLoc && (e.seedLoc = n.getUniformLocation(r, \"seed\")), n.gl.uniform1f(e.seedLoc, t);\n          };\n        }, t;\n      }(),\n          Qi = function (t, e, n, r) {\n        this.variableNames = [\"indices\"], this.outputShape = [t, e], this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int index = round(getIndices(coords.x));\\n        setOutput(mix(float(\" + r + \"), float(\" + n + \"),\\n                      float(index == coords.y)));\\n      }\\n    \";\n      },\n          Xi = function (t) {\n        this.variableNames = [\"A\"], this.packedInputs = !1, this.packedOutput = !0, this.outputShape = t;\n        var e = t.length;\n        if (0 === e) this.userCode = \"\\n        void main() {\\n          setOutput(vec4(getA(), 0., 0., 0.));\\n        }\\n      \";else {\n          var n = fo(\"rc\", e),\n              r = Ao(e),\n              o = function (t, e, n) {\n            if (1 === t) return \"rc > \" + e[0];\n\n            for (var r = \"\", o = t - 2; o < t; o++) r += n[o] + \" >= \" + e[o], o < t - 1 && (r += \"||\");\n\n            return r;\n          }(e, t, n),\n              i = function (t, e, n, r) {\n            if (1 === t) return \"\";\n            var o = r.slice(-2);\n            return \"\\n    int r = \" + o[0] + \";\\n    int c = \" + o[1] + \";\\n    int rp1 = r + 1;\\n    int cp1 = c + 1;\\n\\n    bool cEdge = cp1 >= \" + e + \";\\n    bool rEdge = rp1 >= \" + n + \";\\n  \";\n          }(e, t[t.length - 1], t[t.length - 2], n),\n              a = function (t, e) {\n            var n = t.length,\n                r = function (t, e) {\n              for (var n = [], r = 0; r <= 1; r++) for (var o = 0; o <= 1; o++) {\n                for (var i = (0 === r ? \"r\" : \"rp1\") + \", \" + (0 === o ? \"c\" : \"cp1\"), a = 2; a < t; a++) i = e[e.length - 1 - a] + \",\" + i;\n\n                n.push(i);\n              }\n\n              return n;\n            }(n, e);\n\n            return 1 === n ? \"getA(rc),\\n            rc + 1 >= \" + t[0] + \" ? 0. : getA(rc + 1),\\n            0, 0\" : \"getA(\" + r[0] + \"),\\n          cEdge ? 0. : getA(\" + r[1] + \"),\\n          rEdge ? 0. : getA(\" + r[2] + \"),\\n          rEdge || cEdge ? 0. : getA(\" + r[3] + \")\";\n          }(t, n);\n\n          this.userCode = \"\\n        void main() {\\n          \" + r + \" rc = getOutputCoords();\\n\\n          if(\" + o + \") {\\n            setOutput(vec4(0));\\n          } else {\\n            \" + i + \"\\n\\n            setOutput(vec4(\" + a + \"));\\n          }\\n        }\\n      \";\n        }\n      },\n          Yi = function (t, e, n) {\n        this.variableNames = [\"x\"], this.outputShape = e.map(function (e, n) {\n          return e[0] + t[n] + e[1];\n        });\n        var r = t.length,\n            o = Ao(r),\n            i = e.map(function (t) {\n          return t[0];\n        }).join(\",\"),\n            a = e.map(function (e, n) {\n          return e[0] + t[n];\n        }).join(\",\"),\n            s = [\"coords[0]\", \"coords[1]\", \"coords[2]\", \"coords[3]\"].slice(0, r);\n        this.userCode = 1 !== r ? \"\\n      \" + o + \" start = \" + o + \"(\" + i + \");\\n      \" + o + \" end = \" + o + \"(\" + a + \");\\n\\n      void main() {\\n        \" + o + \" outC = getOutputCoords();\\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\\n          setOutput(float(\" + n + \"));\\n        } else {\\n          \" + o + \" coords = outC - start;\\n          setOutput(getX(\" + s + \"));\\n        }\\n      }\\n    \" : \"\\n        int start = \" + i + \";\\n        int end = \" + a + \";\\n\\n        void main() {\\n          int outC = getOutputCoords();\\n          if (outC < start || outC >= end) {\\n            setOutput(float(\" + n + \"));\\n          } else {\\n            setOutput(getX(outC - start));\\n          }\\n        }\\n      \";\n      },\n          Ji = function (t, e, n) {\n        this.variableNames = [\"x\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = e.map(function (e, n) {\n          return e[0] + t[n] + e[1];\n        });\n\n        for (var r = t.length, o = Ao(r), i = e.map(function (t) {\n          return t[0];\n        }).join(\",\"), a = e.map(function (e, n) {\n          return e[0] + t[n];\n        }).join(\",\"), s = fo(\"rc\", r), u = fo(\"source\", r), c = s[r - 1] + \" < \" + this.outputShape[r - 1], l = 1 === r ? \"source\" : \"vec2(\" + u.slice(-2).join() + \")\", h = [o + \" rc = outputLoc;\", s[r - 1] + \" += 1;\\n       if(\" + c + \") {\\n      \", 1 === r ? \"\" : \"}\\n       rc = outputLoc;\\n       \" + s[r - 2] + \" += 1;\\n       if(\" + s[r - 2] + \" < \" + this.outputShape[r - 2] + \") {\", 1 === r ? \"\" : \"  \" + s[r - 1] + \" += 1;\\n         if(\" + c + \") {\"], p = 1 === r ? \"rc < start || rc >= end\" : \"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))\", f = \"\", d = 0, m = 1 === r ? 2 : 4; d < m; d++) f += \"\\n        \" + h[d] + \"\\n        if (\" + p + \") {\\n          result[\" + d + \"] = float(\" + n + \");\\n        } else {\\n          \" + o + \" source = rc - start;\\n          result[\" + d + \"] = getChannel(getX(\" + u.join() + \"), \" + l + \");\\n        }\\n      \";\n\n        f += 1 === r ? \"} \" : \"}}\", this.userCode = \"\\n      const \" + o + \" start = \" + o + \"(\" + i + \");\\n      const \" + o + \" end = \" + o + \"(\" + a + \");\\n\\n      void main() {\\n        \" + o + \" outputLoc = getOutputCoords();\\n        vec4 result = vec4(0.);\\n        \" + f + \"\\n        setOutput(result);\\n      }\\n    \";\n      },\n          Zi = function (t, e, n) {\n        if (this.variableNames = [\"x\"], \"avg\" === e && n) throw new Error(\"Cannot compute positions for average pool.\");\n        var r = t.filterWidth,\n            o = t.strideHeight,\n            i = t.strideWidth,\n            a = t.dilationHeight,\n            s = t.dilationWidth,\n            u = t.effectiveFilterHeight,\n            c = t.effectiveFilterWidth,\n            l = t.padInfo.top,\n            h = t.padInfo.left;\n        this.outputShape = t.outShape;\n        var p = \"avg\" === e,\n            f = \"0.0\";\n        if (p || (f = \"-1.0 / 1e-20\"), n) this.userCode = \"\\n        const ivec2 strides = ivec2(\" + o + \", \" + i + \");\\n        const ivec2 pads = ivec2(\" + l + \", \" + h + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + u + \";\\n              wR += \" + a + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + c + \";\\n                wC += \" + s + \") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value >= currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \" + c + \" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";else {\n          var d = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n          \"avg\" === e && (d = \"avgValue / count\");\n          var m = 4 * Math.floor(r / 4),\n              g = r % 4,\n              v = \"\\n      if (\" + p + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";\n          this.userCode = \"\\n      const ivec2 strides = ivec2(\" + o + \", \" + i + \");\\n      const ivec2 pads = ivec2(\" + l + \", \" + h + \");\\n      const float initializationValue = \" + f + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + t.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + f + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \" + u + \";\\n            wR += \" + a + \") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + t.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + m + \"; wC += 4) {\\n            int xC = xCCorner + wC * \" + s + \";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              getValue(batch, xR, xC + 2 * \" + s + \", d),\\n              getValue(batch, xR, xC + 3 * \" + s + \", d)\\n            );\\n\\n            \" + v + \"\\n          }\\n\\n          int xC = xCCorner + \" + m + \";\\n          if (\" + (1 === g) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + v + \"\\n          } else if (\" + (2 === g) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + v + \"\\n          } else if (\" + (3 === g) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              getValue(batch, xR, xC + 2 * \" + s + \", d),\\n              initializationValue\\n            );\\n\\n            \" + v + \"\\n          }\\n        }\\n        setOutput(\" + d + \");\\n      }\\n    \";\n        }\n      },\n          ta = function (t, e, n) {\n        if (this.variableNames = [\"x\"], \"avg\" === e && n) throw new Error(\"Cannot compute positions for average pool.\");\n        var r = t.filterWidth,\n            o = t.strideDepth,\n            i = t.strideHeight,\n            a = t.strideWidth,\n            s = t.dilationDepth,\n            u = t.dilationHeight,\n            c = t.dilationWidth,\n            l = t.effectiveFilterDepth,\n            h = t.effectiveFilterHeight,\n            p = t.effectiveFilterWidth,\n            f = t.padInfo.front,\n            d = t.padInfo.top,\n            m = t.padInfo.left;\n        this.outputShape = t.outShape;\n        var g = \"avg\" === e,\n            v = \"0.0\";\n        if (g || (v = \"-1.0 / 1e-20\"), n) this.userCode = \"\\n        const ivec3 strides =\\n            ivec3(\" + o + \", \" + i + \", \" + a + \");\\n        const ivec3 pads = ivec3(\" + f + \", \" + d + \", \" + m + \");\\n\\n        void main() {\\n          ivec5 coords = getOutputCoords();\\n          int batch = coords.x;\\n          int ch = coords.u;\\n\\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n          int xDCorner = xCorner.x;\\n          int xRCorner = xCorner.y;\\n          int xCCorner = xCorner.z;\\n\\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n\\n          for (int wD = 0; wD < \" + l + \";\\n              wD += \" + s + \") {\\n            int xD = xDCorner + wD;\\n\\n            if (xD < 0 || xD >= \" + t.inDepth + \") {\\n              continue;\\n            }\\n\\n            for (int wR = 0; wR < \" + h + \";\\n                wR += \" + u + \") {\\n              int xR = xRCorner + wR;\\n\\n              if (xR < 0 || xR >= \" + t.inHeight + \") {\\n                continue;\\n              }\\n\\n              for (int wC = 0; wC < \" + p + \";\\n                  wC += \" + c + \") {\\n                int xC = xCCorner + wC;\\n\\n                if (xC < 0 || xC >= \" + t.inWidth + \") {\\n                  continue;\\n                }\\n\\n                float value = getX(batch, xD, xR, xC, ch);\\n\\n                // If a min / max value has already been found, use it. If not,\\n                // use the current value.\\n                float currMinMaxValue = mix(\\n                    value, minMaxValue, minMaxValueFound);\\n                if (value >= currMinMaxValue) {\\n                  minMaxValue = value;\\n                  minMaxValueFound = 1.0;\\n                  minMaxPosition =\\n                      wD * \" + h + \" * \" + p + \" +\\n                      wR * \" + p + \" + wC;;\\n                }\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";else {\n          var y = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n          \"avg\" === e && (y = \"avgValue / count\");\n          var b = 4 * Math.floor(r / 4),\n              w = r % 4,\n              x = \"\\n      if (\" + g + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";\n          this.userCode = \"\\n      const ivec3 strides =\\n        ivec3(\" + o + \", \" + i + \", \" + a + \");\\n      const ivec3 pads = ivec3(\" + f + \", \" + d + \", \" + m + \");\\n      const float initializationValue = \" + v + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\\n        if (xC < 0 || xC >= \" + t.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xD, xR, xC, ch);\\n      }\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xDCorner = xCorner.x;\\n        int xRCorner = xCorner.y;\\n        int xCCorner = xCorner.z;\\n\\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + v + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wD = 0; wD < \" + l + \";\\n            wD += \" + s + \") {\\n          int xD = xDCorner + wD;\\n\\n          if (xD < 0 || xD >= \" + t.inDepth + \") {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < \" + h + \";\\n            wR += \" + u + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + t.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + b + \"; wC += 4) {\\n              int xC = xCCorner + wC * \" + c + \";\\n\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + c + \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \" + c + \", ch),\\n                getValue(batch, xD, xR, xC + 3 * \" + c + \", ch)\\n              );\\n\\n              \" + x + \"\\n            }\\n\\n            int xC = xCCorner + \" + b + \";\\n            if (\" + (1 === w) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                initializationValue,\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \" + x + \"\\n            } else if (\" + (2 === w) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + c + \", ch),\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              \" + x + \"\\n            } else if (\" + (3 === w) + \") {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + \" + c + \", ch),\\n                getValue(batch, xD, xR, xC + 2 * \" + c + \", ch),\\n                initializationValue\\n              );\\n\\n              \" + x + \"\\n            }\\n          }\\n          setOutput(\" + y + \");\\n        }\\n      }\\n    \";\n        }\n      },\n          ea = function (t, e) {\n        this.variableNames = [\"x\"];\n        var n = t.windowSize,\n            r = t.batchSize,\n            o = t.inSize,\n            i = Math.ceil(o / n);\n        this.outputShape = [r, i];\n        var a = \"0.0\",\n            s = \"\";\n        \"prod\" === e ? a = \"1.0\" : \"min\" === e ? (a = \"1.0 / 1e-20\", s = \"min\") : \"max\" === e && (a = \"-1.0 / 1e-20\", s = \"max\");\n        var u = e + \"(\" + e + \"(\" + e + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n        \"sum\" === e ? u = \"sumValue\" : \"prod\" === e ? u = \"prodValue\" : \"all\" === e ? u = \"allValue\" : \"any\" === e && (u = \"anyValue\");\n        var c = 4 * Math.floor(n / 4),\n            l = n % 4,\n            h = \"\\n      if (\" + (\"sum\" === e) + \") {\\n        sumValue += dot(values, ones);\\n      } else if (\" + (\"prod\" === e) + \") {\\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\\n        prodValue *= tmp[0] * tmp[1];\\n      } else {\\n        minMaxValue = \" + s + \"(values, minMaxValue);\\n      }\\n    \",\n            p = \"vec4\";\n        \"all\" === e ? (a = \"1.0\", h = \"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \", p = \"bvec4\") : \"any\" === e && (a = \"0.0\", h = \"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \", p = \"bvec4\");\n        var f = \"\";\n        o % n > 0 && (f = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = \" + a + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + f + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + n + \";\\n\\n        vec4 minMaxValue = vec4(\" + a + \");\\n        float prodValue = 1.0;\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < \" + c + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          \" + p + \" values = \" + p + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \" + h + \"\\n        }\\n\\n        int inIdx = inOffset + \" + c + \";\\n        if (\" + (1 === l) + \") {\\n          \" + p + \" values = \" + p + \"(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        } else if (\" + (2 === l) + \") {\\n          \" + p + \" values = \" + p + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        } else if (\" + (3 === l) + \") {\\n          \" + p + \" values = \" + p + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          \" + h + \"\\n        }\\n        setOutput(\" + u + \");\\n      }\\n    \";\n      },\n          na = function (t, e) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t;\n\n        for (var n = \"\", r = 0; r < 4; r++) {\n          var o = \"thisRC = rc;\";\n          r % 2 == 1 && (o += \"thisRC.z += 1;\"), r > 1 && (o += \"thisRC.y += 1;\"), n += \"\\n        \" + o + \"\\n        \" + (r > 0 ? \"if(thisRC.y < rows && thisRC.z < cols){\" : \"\") + \"\\n          int flatIndex = getFlatIndex(thisRC);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[\" + r + \"] =\\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\\n        \" + (r > 0 ? \"}\" : \"\") + \"\\n      \";\n        }\n\n        this.userCode = \"\\n      \\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      \" + go([\"r\", \"c\", \"d\"], e) + \"\\n      return ivec3(r, c, d);\\n    }\\n  \\n      \" + vo(t) + \"\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n\\n        ivec3 thisRC;\\n        int rows = \" + t[1] + \";\\n        int cols = \" + t[2] + \";\\n\\n        \" + n + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n      },\n          ra = function (t, e, n) {\n        this.variableNames = [\"dy\"], this.outputShape = [], this.outputShape = e.shape;\n        var r = e.shape,\n            o = r[1],\n            i = r[2],\n            a = t.shape,\n            s = a[1],\n            u = a[2],\n            c = [n && s > 1 ? o - 1 : o, n && u > 1 ? i - 1 : i],\n            l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],\n            h = c[0] / l[0],\n            p = c[1] / l[1],\n            f = 1 / h,\n            d = 1 / p,\n            m = 2 * Math.ceil(f) + 2,\n            g = 2 * Math.ceil(d) + 2;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + h + \");\\n        const float widthScale = float(\" + p + \");\\n\\n        const float invHeightScale = float(\" + f + \");\\n        const float invWidthScale = float(\" + d + \");\\n\\n        const int winHeight = int(\" + m + \");\\n        const int winWidth = int(\" + g + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(startRLerp - float(winHeight / 2));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(startCLerp - float(winWidth / 2));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float dxR = float(dyR) * heightScale;\\n            int topDxRIndex = int(floor(dxR));\\n            int bottomDxRIndex = int(min(ceil(dxR), \" + (o - 1) + \".0));\\n            float dxRLerp = dxR - float(topDxRIndex);\\n            float inverseDxRLerp = 1.0 - dxRLerp;\\n\\n            float dxC = float(dyC) * widthScale;\\n            int leftDxCIndex = int(floor(dxC));\\n            int rightDxCIndex = int(min(ceil(dxC), \" + (i - 1) + \".0));\\n            float dxCLerp = dxC - float(leftDxCIndex);\\n            float inverseDxCLerp = 1.0 - dxCLerp;\\n\\n            if (r == topDxRIndex && c == leftDxCIndex) {\\n              // topLeft\\n              accumulator +=\\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == topDxRIndex && c == rightDxCIndex) {\\n              // topRight\\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\\n              // bottomLeft\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\\n              // bottomRight\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n      },\n          oa = function (t, e, n, r) {\n        this.variableNames = [\"A\"], this.outputShape = [];\n        var o = t[0],\n            i = t[1],\n            a = t[2],\n            s = t[3];\n        this.outputShape = [o, e, n, s];\n        var u = [r && e > 1 ? i - 1 : i, r && n > 1 ? a - 1 : a],\n            c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];\n        this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + i + \".0, \" + a + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";\n      },\n          ia = function (t, e, n, r) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = [];\n        var o = t[0],\n            i = t[1],\n            a = t[2],\n            s = t[3];\n        this.outputShape = [o, e, n, s];\n        var u = [r && e > 1 ? i - 1 : i, r && n > 1 ? a - 1 : a],\n            c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n];\n        this.userCode = \"\\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec3 inputShapeRC = vec3(\" + i + \".0, \" + a + \".0,\\n                                     \" + a + \".0);\\n\\n      float getAValue(int b, int r, int c, int d) {\\n        return getChannel(getA(b, r, c, d), vec2(c, d));\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        // Calculate values for next column in yRC.z.\\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\\n\\n        // Fractional source index.\\n        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);\\n        ivec3 sourceCeilRC = ivec3(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        // Should we calculate next column and row elements in 2x2 packed cell.\\n        bool hasNextCol = d < \" + (s - 1) + \";\\n        bool hasNextRow = coords.z < \" + (n - 1) + \";\\n\\n        // In parallel, construct four corners for all four components in\\n        // packed 2x2 cell.\\n        vec4 topLeft = vec4(\\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\\n\\n        vec4 bottomLeft = vec4(\\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\\n\\n        vec4 topRight = vec4(\\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\\n\\n        vec4 bottomRight = vec4(\\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\\n                     : 0.0,\\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\\n                     : 0.0,\\n          (hasNextRow && hasNextCol) ?\\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\\n\\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\\n\\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\\n        vec4 newValue = mix(top, bottom, fracRC.x);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n      },\n          aa = function (t, e, n) {\n        this.variableNames = [\"dy\"], this.outputShape = [], this.outputShape = e.shape;\n        var r = e.shape,\n            o = r[1],\n            i = r[2],\n            a = t.shape,\n            s = a[1],\n            u = a[2],\n            c = [n && s > 1 ? o - 1 : o, n && u > 1 ? i - 1 : i],\n            l = [n && s > 1 ? s - 1 : s, n && u > 1 ? u - 1 : u],\n            h = c[0] / l[0],\n            p = c[1] / l[1],\n            f = 1 / h,\n            d = 1 / p,\n            m = 2 * Math.ceil(f) + 2,\n            g = 2 * Math.ceil(d) + 2;\n        this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + h + \");\\n        const float widthScale = float(\" + p + \");\\n\\n        const float invHeightScale = float(\" + f + \");\\n        const float invWidthScale = float(\" + d + \");\\n\\n        const int winHeight = int(\" + m + \");\\n        const int winWidth = int(\" + g + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float sourceFracRow =\\n              float(\" + c[0] + \") *\\n                (float(dyR) / float(\" + l[0] + \"));\\n\\n            float sourceFracCol =\\n                float(\" + c[1] + \") *\\n                  (float(dyC) / float(\" + l[1] + \"));\\n\\n            int sourceNearestRow = int(min(\\n                float(int(\" + o + \") - 1),\\n                \" + n + \" ? float(round(sourceFracRow)) :\\n                                  float(floor(sourceFracRow))));\\n\\n            int sourceNearestCol = int(min(\\n                float(int(\" + i + \") - 1),\\n                \" + n + \" ? float(round(sourceFracCol)) :\\n                                  float(floor(sourceFracCol))));\\n\\n            if (r == sourceNearestRow && c == sourceNearestCol) {\\n              accumulator += getDy(b, dyR, dyC, d);\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n      },\n          sa = function (t, e, n, r) {\n        this.variableNames = [\"A\"], this.outputShape = [];\n        var o = t[0],\n            i = t[1],\n            a = t[2],\n            s = t[3];\n        this.outputShape = [o, e, n, s];\n        var u = [r && e > 1 ? i - 1 : i, r && n > 1 ? a - 1 : a],\n            c = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n],\n            l = r ? \"0.5\" : \"0.0\";\n        this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / c[0] + \",\\n          \" + u[1] / c[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + i + \".0, \" + a + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the coordinators of nearest neighbor point.\\n        ivec2 sourceNearestRC = ivec2(\\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + \" + l + \")));\\n\\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n      },\n          ua = function (t, e) {\n        this.variableNames = [\"x\"];\n        var n = t.length;\n        if (n > 4) throw new Error(\"WebGL backend: Reverse of rank-\" + n + \" tensor is not yet supported\");\n\n        if (this.outputShape = t, 1 !== n) {\n          var r = t.map(function (n, r) {\n            return function (n) {\n              return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + \" - coords[\" + n + \"] - 1\" : \"coords[\" + n + \"]\";\n            }(r);\n          }).join(\",\"),\n              o = Ao(n);\n          this.userCode = \"\\n      void main() {\\n        \" + o + \" coords = getOutputCoords();\\n        setOutput(getX(\" + r + \"));\\n      }\\n    \";\n        } else this.userCode = \"\\n        void main() {\\n          int coord = getOutputCoords();\\n          setOutput(getX(\" + t[0] + \" - coord - 1));\\n        }\\n      \";\n      },\n          ca = function (t, e) {\n        this.variableNames = [\"x\"], this.packedInputs = !0, this.packedOutput = !0;\n        var n = t.length;\n        if (n > 4) throw new Error(\"WebGL backend: Reverse of rank-\" + n + \" tensor is not yet supported\");\n        this.outputShape = t;\n        var r = fo(\"rc\", n),\n            o = r[n - 1] + \" + 1 < \" + this.outputShape[n - 1],\n            i = r[n - 2] + \" + 1 < \" + this.outputShape[n - 2],\n            a = Ao(n);\n\n        function s(n) {\n          var r = t.map(function (r, o) {\n            return function (n, r) {\n              return -1 !== e.indexOf(n) && 1 !== t[n] ? t[n] + \" - \" + r[n] + \" - 1\" : \"\" + r[n];\n            }(o, n);\n          });\n          return \"getChannel(getX(\" + r.join(\",\") + \"), vec2(\" + r.slice(-2).join(\",\") + \"))\";\n        }\n\n        this.userCode = 1 === n ? \"\\n        void main(){\\n          int rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = getChannel(getX(\" + t[0] + \" - rc - 1),\\n            \" + t[0] + \" - rc - 1);\\n          if(\" + o + \"){\\n              result.g = getChannel(getX(\" + t[0] + \" - (rc  + 1) - 1),\\n                \" + t[0] + \" - (rc  + 1) - 1);\\n          }\\n          setOutput(result);\\n        }\\n      \" : \"\\n        void main() {\\n          \" + a + \" rc = getOutputCoords();\\n          vec4 result = vec4(0.);\\n          result.r = \" + function (t) {\n          return s(t);\n        }(r.slice()) + \";\\n          if(\" + o + \"){\\n            result.g = \" + function (t) {\n          return t[n - 1] = \"(\" + t[n - 1] + \" + 1)\", s(t);\n        }(r.slice()) + \";\\n          }\\n          if(\" + i + \") {\\n            result.b = \" + function (t) {\n          return t[n - 2] = \"(\" + t[n - 2] + \" + 1)\", s(t);\n        }(r.slice()) + \";\\n            if(\" + o + \") {\\n              result.a = \" + function (t) {\n          return t[n - 1] = \"(\" + t[n - 1] + \" + 1)\", t[n - 2] = \"(\" + t[n - 2] + \" + 1)\", s(t);\n        }(r.slice()) + \";\\n            }\\n          }\\n          setOutput(result);\\n        }\\n    \";\n      },\n          la = function (t, e, n, r, o, i, a) {\n        void 0 === a && (a = !0), this.variableNames = [\"updates\", \"indices\", \"defaultValue\"], this.outputShape = i;\n        var s = Ao(o.length),\n            u = Ao(i.length),\n            c = \"\";\n        1 === n ? c = \"i\" : 2 === n && (c = \"i, j\");\n        var l = \"getIndices(\" + c + \")\",\n            h = \"\";\n        1 === r ? h = \"i\" : 2 === r && (h = \"i, coords[1]\");\n        var p = \"getUpdates(\" + h + \")\",\n            f = e > 1 ? \"strides[j]\" : \"strides\";\n        this.userCode = \"\\n        \" + s + \" strides = \" + s + \"(\" + o + \");\\n\\n        void main() {\\n          \" + u + \" coords = getOutputCoords();\\n          float sum = 0.0;\\n          bool found = false;\\n          for (int i = 0; i < \" + t + \"; i++) {\\n            int flattenedIndex = 0;\\n            for (int j = 0; j < \" + e + \"; j++) {\\n              int index = round(\" + l + \");\\n              flattenedIndex += index * \" + f + \";\\n            }\\n            if (flattenedIndex == coords[0]) {\\n              sum += \" + p + \";\\n              found = true;\\n            }\\n          }\\n          setOutput(mix(getDefaultValue(), sum, float(found)));\\n        }\\n      \";\n      },\n          ha = function (t, e) {\n        this.variableNames = [\"x\", \"segmentIds\"];\n        var n = t.windowSize,\n            r = t.batchSize,\n            o = t.inSize,\n            i = t.numSegments,\n            a = i * Math.ceil(o / n);\n        this.outputShape = [r, a];\n        var s = 4 * Math.floor(n / 4),\n            u = n % 4,\n            c = \"\\n        sumValue += dot(values, segFilter);\\n    \",\n            l = \"\";\n        o % n > 0 && (l = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \");\n        var h = \"\";\n        o % n > 0 && (h = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return -1.0;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = 0.0;\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + l + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \" + h + \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \" + i + \")) * float(\" + n + \"));\\n        int currentSeg = int(mod(float(outIdx), float(\" + i + \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + s + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \" + c + \"\\n        }\\n\\n        int inIdx = inOffset + \" + s + \";\\n        if (\" + (1 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \" + c + \"\\n        } else if (\" + (2 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \" + c + \"\\n        } else if (\" + (3 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 segFilter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \" + c + \"\\n        }\\n        setOutput(sumValue);\\n      }\\n    \";\n      },\n          pa = function (t, e, n) {\n        var r, o;\n        if (this.variableNames = [\"c\", \"a\", \"b\"], this.outputShape = e, n > 4) throw Error(\"Where for rank \" + n + \" is not yet supported\");\n        if (1 === n) o = \"resRC\", r = \"resRC\";else {\n          for (var i = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\"], a = [], s = [], u = 0; u < e.length; u++) s.push(\"\" + i[u]), u < t && a.push(\"\" + i[u]);\n\n          r = a.join(), o = s.join();\n        }\n        var c = Ao(n);\n        this.userCode = \"\\n      void main() {\\n        \" + c + \" resRC = getOutputCoords();\\n        float cVal = getC(\" + r + \");\\n        if (cVal >= 1.0) {\\n          setOutput(getA(\" + o + \"));\\n        } else {\\n          setOutput(getB(\" + o + \"));\\n        }\\n      }\\n    \";\n      },\n          fa = function () {\n        function t(t) {\n          this.variableNames = [\"source\"], this.outputShape = t, this.rank = t.length;\n\n          var e,\n              n = Ao(this.rank),\n              r = \"uniform int start[\" + this.rank + \"];\",\n              o = function (t) {\n            if (1 === t) return \"sourceLoc\";\n            if (t <= 6) return da.slice(0, t).map(function (t) {\n              return \"sourceLoc.\" + t;\n            }).join(\",\");\n            throw Error(\"Slicing for rank \" + t + \" is not yet supported\");\n          }(this.rank);\n\n          e = \"\\n        \" + n + \" sourceLoc;\\n        \" + n + \" coords = getOutputCoords();\\n        \" + t.map(function (t, e) {\n            return \"sourceLoc.\" + da[e] + \" = start[\" + e + \"] + coords.\" + da[e] + \";\";\n          }).join(\"\\n\") + \"\\n      \", this.userCode = \"\\n      \" + r + \"\\n      void main() {\\n        \" + e + \"\\n        setOutput(getSource(\" + o + \"));\\n      }\\n    \";\n        }\n\n        return t.prototype.getCustomSetupFunc = function (t) {\n          var e = this;\n          if (t.length !== this.rank) throw Error(\"The rank (\" + this.rank + \") of the program must match the length of start (\" + t.length + \")\");\n          return function (n, r) {\n            null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, \"start\"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);\n          };\n        }, t;\n      }(),\n          da = [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"],\n          ma = function () {\n        function t(t) {\n          this.variableNames = [\"source\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.rank = t.length;\n          var e = Ao(this.rank),\n              n = fo(\"coords\", this.rank),\n              r = fo(\"sourceLoc\", this.rank),\n              o = 1 === this.rank ? \"sourceLoc\" : \"vec2(\" + r.slice(-2).join() + \")\",\n              i = \"getChannel(getSource(\" + r.join() + \"), \" + o + \")\",\n              a = \"\\n      result.x = \" + i + \";\\n      if (++\" + n[this.rank - 1] + \" < \" + t[this.rank - 1] + \") {\\n        ++\" + r[this.rank - 1] + \";\\n        result.y = \" + i + \";\\n        --\" + r[this.rank - 1] + \";\\n      }\\n    \",\n              s = 1 === this.rank ? \"\" : \"\\n      --\" + n[this.rank - 1] + \";\\n      if (++\" + n[this.rank - 2] + \" < \" + t[this.rank - 2] + \") {\\n        ++\" + r[this.rank - 2] + \";\\n        result.z = \" + i + \";\\n        if (++\" + n[this.rank - 1] + \" < \" + t[this.rank - 1] + \") {\\n          ++\" + r[this.rank - 1] + \";\\n          result.w = \" + i + \";\\n        }\\n      }\\n    \",\n              u = this.rank <= 4 ? \"sourceLoc = coords +\\n            \" + e + \"(\" + t.map(function (t, e) {\n            return \"start[\" + e + \"]\";\n          }).join() + \");\" : t.map(function (t, e) {\n            return r[e] + \" = \" + n[e] + \" + start[\" + e + \"];\";\n          }).join(\"\\n\");\n          this.userCode = \"\\n      uniform int start[\" + this.rank + \"];\\n      void main() {\\n        \" + e + \" coords = getOutputCoords();\\n        \" + e + \" sourceLoc;\\n        \" + u + \"\\n        vec4 result = vec4(0.);\\n        \" + a + \"\\n        \" + s + \"\\n        setOutput(result);\\n      }\\n    \";\n        }\n\n        return t.prototype.getCustomSetupFunc = function (t) {\n          var e = this;\n          if (t.length !== this.rank) throw Error(\"The rank (\" + this.rank + \") of the program must match the length of start (\" + t.length + \")\");\n          return function (n, r) {\n            null == e.startLoc && (e.startLoc = n.getUniformLocationNoThrow(r, \"start\"), null == e.startLoc) || n.gl.uniform1iv(e.startLoc, t);\n          };\n        }, t;\n      }(),\n          ga = function (t, e, n) {\n        this.variableNames = [\"x\"], this.outputShape = n;\n        var r = n.length,\n            o = Ao(n.length),\n            i = Ao(n.length),\n            a = \"\";\n        if (1 === r) a = \"coords * strides + begin\";else {\n          var s = 0;\n          a = n.map(function (t, e) {\n            return s++, 1 === n.length ? \"coords * strides[\" + e + \"] + begin[\" + e + \"]\" : \"coords[\" + (s - 1) + \"] * strides[\" + e + \"] + begin[\" + e + \"]\";\n          }).join(\",\");\n        }\n        this.userCode = \"\\n      \" + o + \" begin = \" + o + \"(\" + t + \");\\n      \" + o + \" strides = \" + o + \"(\" + e + \");\\n\\n      void main() {\\n        \" + i + \" coords = getOutputCoords();\\n        setOutput(getX(\" + a + \"));\\n      }\\n    \";\n      },\n          va = function () {\n        function t(t) {\n          this.gpgpu = t, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};\n        }\n\n        return t.prototype.acquireTexture = function (t, e, n) {\n          var r,\n              o = ya(e, n),\n              i = ba(t, o, n);\n\n          if (i in this.freeTextures || (this.freeTextures[i] = []), i in this.usedTextures || (this.usedTextures[i] = []), this.freeTextures[i].length > 0) {\n            this.numFreeTextures--, this.numUsedTextures++, this.log();\n            var a = this.freeTextures[i].shift();\n            return this.usedTextures[i].push(a), a;\n          }\n\n          return this.numUsedTextures++, this.log(), o === Bt.PACKED_2X2_FLOAT32 ? r = this.gpgpu.createPackedMatrixTexture(t[0], t[1]) : o === Bt.PACKED_2X2_FLOAT16 ? r = this.gpgpu.createFloat16PackedMatrixTexture(t[0], t[1]) : o === Bt.UNPACKED_FLOAT32 ? r = this.gpgpu.createFloat32MatrixTexture(t[0], t[1]) : o === Bt.UNPACKED_FLOAT16 ? r = this.gpgpu.createFloat16MatrixTexture(t[0], t[1]) : o === Bt.PACKED_4X1_UNSIGNED_BYTE && (r = this.gpgpu.createUnsignedBytesMatrixTexture(t[0], t[1])), this.usedTextures[i].push(r), r;\n        }, t.prototype.releaseTexture = function (t, e, n, r) {\n          if (null != this.freeTextures) {\n            var o = ba(e, ya(n, r), r);\n            o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(t), this.numFreeTextures++, this.numUsedTextures--;\n            var i = this.usedTextures[o],\n                a = i.indexOf(t);\n            if (a < 0) throw new Error(\"Cannot release a texture that was never provided by this texture manager\");\n            i.splice(a, 1), this.log();\n          }\n        }, t.prototype.log = function () {\n          if (this.logEnabled) {\n            var t = this.numFreeTextures + this.numUsedTextures;\n            console.log(\"Free/Used\", this.numFreeTextures + \" / \" + this.numUsedTextures, \"(\" + t + \")\");\n          }\n        }, t.prototype.getNumUsedTextures = function () {\n          return this.numUsedTextures;\n        }, t.prototype.getNumFreeTextures = function () {\n          return this.numFreeTextures;\n        }, t.prototype.dispose = function () {\n          var t = this;\n\n          if (null != this.freeTextures) {\n            for (var e in this.freeTextures) this.freeTextures[e].forEach(function (e) {\n              t.gpgpu.deleteMatrixTexture(e);\n            });\n\n            for (var e in this.usedTextures) this.usedTextures[e].forEach(function (e) {\n              t.gpgpu.deleteMatrixTexture(e);\n            });\n\n            this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;\n          }\n        }, t;\n      }();\n\n      function ya(t, e) {\n        if (t === Lt.UPLOAD) return Bt.PACKED_2X2_FLOAT32;\n        if (t === Lt.RENDER || null == t) return function (t) {\n          return h().getBool(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? t ? Bt.PACKED_2X2_FLOAT32 : Bt.UNPACKED_FLOAT32 : t ? Bt.PACKED_2X2_FLOAT16 : Bt.UNPACKED_FLOAT16;\n        }(e);\n        if (t === Lt.DOWNLOAD || t === Lt.PIXELS) return Bt.PACKED_4X1_UNSIGNED_BYTE;\n        throw new Error(\"Unknown logical texture type \" + t);\n      }\n\n      function ba(t, e, n) {\n        return t[0] + \"_\" + t[1] + \"_\" + e + \"_\" + n;\n      }\n\n      var wa = function (t, e) {\n        this.variableNames = [\"A\"];\n\n        for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[r] * e[r];\n\n        this.outputShape = n, this.rank = n.length;\n\n        var o = Ao(this.rank),\n            i = function (t) {\n          var e = t.length;\n          if (e > 5) throw Error(\"Tile for rank \" + e + \" is not yet supported\");\n          if (1 === e) return \"imod(resRC, \" + t[0] + \")\";\n\n          for (var n = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\", \"resRC.u\"], r = [], o = 0; o < t.length; o++) r.push(\"imod(\" + n[o] + \", \" + t[o] + \")\");\n\n          return r.join();\n        }(t);\n\n        this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + i + \"));\\n      }\\n    \";\n      },\n          xa = function (t, e) {\n        this.variableNames = [\"A\"];\n\n        for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];\n\n        this.outputShape = n, this.rank = n.length;\n\n        var o = Ao(this.rank),\n            i = function (t) {\n          var e = t.length;\n          if (e > 6) throw Error(\"Transpose for rank \" + e + \" is not yet supported\");\n\n          for (var n = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\", \"resRC.u\", \"resRC.v\"], r = new Array(e), o = 0; o < t.length; o++) r[t[o]] = n[o];\n\n          return r.join();\n        }(e);\n\n        this.userCode = \"\\n    void main() {\\n      \" + o + \" resRC = getOutputCoords();\\n      setOutput(getA(\" + i + \"));\\n    }\\n    \";\n      },\n          Sa = function (t, e) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !0;\n\n        for (var n = new Array(t.length), r = 0; r < n.length; r++) n[r] = t[e[r]];\n\n        if (this.outputShape = n, this.rank = n.length, this.rank > 6) throw Error(\"Packed transpose for rank \" + this.rank + \" is not yet supported.\");\n        var o = Ao(this.rank),\n            i = po(\"rc\", this.rank),\n            a = new Array(this.rank);\n\n        for (r = 0; r < e.length; r++) a[e[r]] = i[r];\n\n        var s = \"vec2(\" + a.slice(-2).join() + \")\",\n            u = \"++\" + i[this.rank - 1] + \" < \" + n[this.rank - 1],\n            c = \"getChannel(getA(\" + a.join() + \"), \" + s + \")\";\n        this.userCode = \"\\n    void main() {\\n      \" + o + \" rc = getOutputCoords();\\n      vec4 result = vec4(0.);\\n      result[0] = \" + c + \";\\n      if(\" + u + \") {\\n        result[1] = \" + c + \";\\n      }\\n      --\" + i[this.rank - 1] + \";\\n      if(++\" + i[this.rank - 2] + \" < \" + n[this.rank - 2] + \") {\\n        result[2] = \" + c + \";\\n        if(\" + u + \") {\\n          result[3] = \" + c + \";\\n        }\\n      }\\n      setOutput(result);\\n    }\\n    \";\n      },\n          Ea = 1.7580993408473768,\n          Ca = 1.0507009873554805,\n          Ia = function (t, e) {\n        this.variableNames = [\"A\"], this.outputShape = t, this.userCode = \"\\n      float unaryOperation(float x) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n      },\n          Aa = \"if (isnan(x)) return x;\",\n          ka = \"return x;\",\n          Ta = \"return abs(x);\",\n          Na = Aa + \"\\n  return (x < 0.0) ? 0.0 : x;\\n\",\n          Pa = Aa + \"\\n  return (x < 0.0) ? 0.0 : min(6.0, x);\\n\",\n          Ra = \"return (x >= 0.0) ? x : (exp(x) - 1.0);\",\n          _a = \"return -x;\",\n          Ma = \"return ceil(x);\",\n          Oa = \"return floor(x);\",\n          Da = \"return exp(x);\",\n          Fa = \"return exp(x) - 1.0;\",\n          La = \"return x;\",\n          Ba = \"return x;\",\n          za = \"\\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\",\n          qa = \"\\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\\n  bvec4 isNaN = isnan(x);\\n\\n  result.r = isNaN.r ? x.r : result.r;\\n  result.g = isNaN.g ? x.g : result.g;\\n  result.b = isNaN.b ? x.b : result.b;\\n  result.a = isNaN.a ? x.a : result.a;\\n\\n  return result;\\n\",\n          Va = \"\\n  vec4 result;\\n\\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\\n\\n  return result;\\n\",\n          Ua = function (t, e) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !0, this.outputShape = t, this.userCode = \"\\n      vec4 unaryOperation(vec4 x) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        vec4 x = getAAtOutCoords();\\n        vec4 y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n      },\n          ja = function (t) {\n        this.variableNames = [\"A\"], this.packedInputs = !0, this.packedOutput = !1, this.outputShape = t;\n\n        var e = t.length,\n            n = fo(\"rc\", e),\n            r = Ao(e),\n            o = function (t, e) {\n          if (1 === t) return \"rc\";\n\n          for (var n = \"\", r = 0; r < t; r++) n += e[r], r < t - 1 && (n += \",\");\n\n          return n;\n        }(e, n),\n            i = n.slice(-2),\n            a = e <= 1 ? \"rc\" : \"vec2(\" + i.join(\",\") + \")\";\n\n        this.userCode = \"\\n      void main() {\\n        \" + r + \" rc = getOutputCoords();\\n        vec4 packedInput = getA(\" + o + \");\\n\\n        setOutput(getChannel(packedInput, \" + a + \"));\\n      }\\n    \";\n      },\n          Wa = {};\n\n      function Ga(t, e) {\n        if (void 0 === e && (e = !1), \"linear\" === t) return e ? Ba : ka;\n        if (\"relu\" === t) return e ? za : Na;\n        if (\"elu\" === t) return e ? Va : Ra;\n        if (\"relu6\" === t) return e ? qa : Pa;\n        if (\"prelu\" === t) return e ? qo : Bo;\n        throw new Error(\"Activation \" + t + \" has not been implemented for the WebGL backend.\");\n      }\n\n      var Ha = 600,\n          $a = function (t) {\n        function e(e) {\n          var n,\n              r = t.call(this) || this;\n          if (r.gpgpu = e, r.pendingRead = new WeakMap(), r.pendingDisposal = new WeakSet(), r.dataRefCount = new WeakMap(), r.numBytesInGPU = 0, r.uploadWaitMs = 0, r.downloadWaitMs = 0, r.warnedAboutMemory = !1, r.pendingDeletes = 0, r.disposed = !1, !h().getBool(\"HAS_WEBGL\")) throw new Error(\"WebGL is not supported on this device\");\n\n          if (null == e) {\n            var o = Ut(h().getNumber(\"WEBGL_VERSION\"));\n            r.binaryCache = (n = h().getNumber(\"WEBGL_VERSION\")) in Wa ? Wa[n] : (Wa[n] = {}, Wa[n]), r.gpgpu = new zi(o), r.canvas = o.canvas, r.gpgpuCreatedLocally = !0;\n          } else r.binaryCache = {}, r.gpgpuCreatedLocally = !1, r.canvas = e.gl.canvas;\n\n          return r.textureManager = new va(r.gpgpu), r.numMBBeforeWarning = null == h().global.screen ? 1024 : h().global.screen.height * h().global.screen.width * window.devicePixelRatio * Ha / 1024 / 1024, r.texData = new _r(r, Mt), r;\n        }\n\n        return s(e, t), e.prototype.numDataIds = function () {\n          return this.texData.numDataIds() + (this.cpuBackend ? this.cpuBackend.numDataIds() : 0) - this.pendingDeletes;\n        }, e.prototype.fromPixels = function (t, e) {\n          if (null == t) throw new Error(\"pixels passed to tf.browser.fromPixels() can not be null\");\n          var n = \"undefined\" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || \"undefined\" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement,\n              r = t.data instanceof Uint8Array,\n              o = \"undefined\" != typeof ImageData && t instanceof ImageData,\n              i = \"undefined\" != typeof HTMLVideoElement && t instanceof HTMLVideoElement,\n              a = \"undefined\" != typeof HTMLImageElement && t instanceof HTMLImageElement,\n              s = i ? [t.videoWidth, t.videoHeight] : [t.width, t.height],\n              u = s[0],\n              c = s[1],\n              l = [c, u],\n              p = [c, u, e];\n          if (!(n || r || o || i || a)) throw new Error(\"pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was \" + t.constructor.name);\n          (a || i) && (null == this.fromPixels2DContext && (this.fromPixels2DContext = jt(h().getNumber(\"WEBGL_VERSION\")).getContext(\"2d\")), this.fromPixels2DContext.canvas.width = u, this.fromPixels2DContext.canvas.height = c, this.fromPixels2DContext.drawImage(t, 0, 0, u, c), t = this.fromPixels2DContext.canvas);\n          var f,\n              d,\n              m = this.makeTensorInfo(l, \"int32\");\n          return this.texData.get(m.dataId).usage = Lt.PIXELS, this.gpgpu.uploadPixelDataToTexture(this.getTexture(m.dataId), t), h().getBool(\"WEBGL_PACK\") ? (f = new yi(p), d = this.compileAndRun(f, [m])) : (f = new vi(p), d = this.compileAndRun(f, [m])), this.disposeData(m.dataId), d;\n        }, e.prototype.write = function (t, e, n) {\n          if (h().getBool(\"DEBUG\") && this.checkNumericalProblems(t), \"complex64\" === n && null != t) throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");\n          var r = {};\n          return this.texData.set(r, {\n            shape: e,\n            dtype: n,\n            values: t,\n            usage: Lt.UPLOAD\n          }), r;\n        }, e.prototype.move = function (t, e, n, r) {\n          if (h().getBool(\"DEBUG\") && this.checkNumericalProblems(e), \"complex64\" === r) throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");\n          this.texData.set(t, {\n            shape: n,\n            dtype: r,\n            values: e,\n            usage: Lt.UPLOAD\n          });\n        }, e.prototype.readSync = function (t) {\n          var e = this.texData.get(t),\n              n = e.values,\n              r = e.dtype,\n              o = e.complexTensors,\n              i = e.slice,\n              a = e.shape,\n              s = e.isPacked;\n\n          if (null != i) {\n            var u;\n            u = s ? new Ua(a, La) : new Ia(a, La);\n            var c = this.runWebGLProgram(u, [{\n              dataId: t,\n              shape: a,\n              dtype: r\n            }], r),\n                l = this.readSync(c.dataId);\n            return this.disposeData(c.dataId), l;\n          }\n\n          if (null != n) return this.convertAndCacheOnCPU(t);\n          if (\"string\" === r) return n;\n          var h,\n              p,\n              f = null != this.activeTimers;\n          return f && (h = et()), p = \"complex64\" === r ? Zr(o.real.dataSync(), o.imag.dataSync()) : this.getValuesFromTexture(t), f && (this.downloadWaitMs += et() - h), this.convertAndCacheOnCPU(t, p);\n        }, e.prototype.read = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n, r, o, i, a, s, u, l, p, f, d, m, g, v, y, b, w, x, S, E, C;\n            return c(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  if (this.pendingRead.has(t)) return e = this.pendingRead.get(t), [2, new Promise(function (t) {\n                    return e.push(t);\n                  })];\n                  if (n = this.texData.get(t), r = n.values, o = n.shape, i = n.slice, a = n.dtype, s = n.complexTensors, u = n.isPacked, null != i) return void 0, l = u ? new Ua(o, La) : new Ia(o, La), p = this.runWebGLProgram(l, [{\n                    dataId: t,\n                    shape: o,\n                    dtype: a\n                  }], a), f = this.read(p.dataId), this.disposeData(p.dataId), [2, f];\n                  if (null != r) return [2, this.convertAndCacheOnCPU(t)];\n                  if (!h().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\") && 2 === h().getNumber(\"WEBGL_VERSION\")) throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.\");\n                  return d = null, \"complex64\" !== a && h().get(\"WEBGL_BUFFER_SUPPORTED\") && (m = this.decode(t), g = this.texData.get(m.dataId), d = (C = this.gpgpu).createBufferFromTexture.apply(C, [g.texture].concat(Gt(o)))), this.pendingRead.set(t, []), \"complex64\" === a ? [3, 2] : [4, this.gpgpu.createAndWaitForFence()];\n\n                case 1:\n                  c.sent(), c.label = 2;\n\n                case 2:\n                  return \"complex64\" !== a ? [3, 4] : [4, Promise.all([s.real.data(), s.imag.data()])];\n\n                case 3:\n                  return y = c.sent(), b = y[0], w = y[1], v = Zr(b, w), [3, 5];\n\n                case 4:\n                  null == d ? v = this.getValuesFromTexture(t) : (x = A(o), v = this.gpgpu.downloadFloat32MatrixFromBuffer(d, x)), c.label = 5;\n\n                case 5:\n                  return null != m && this.disposeData(m.dataId), S = this.convertAndCacheOnCPU(t, v), E = this.pendingRead.get(t), this.pendingRead.delete(t), E.forEach(function (t) {\n                    return t(S);\n                  }), this.pendingDisposal.has(t) && (this.pendingDisposal.delete(t), this.disposeData(t), this.pendingDeletes--), [2, S];\n              }\n            });\n          });\n        }, e.prototype.checkNumericalProblems = function (t) {\n          if (null != t) for (var e = 0; e < t.length; e++) {\n            var n = t[e];\n\n            if (!Yt(n)) {\n              if (h().getBool(\"WEBGL_RENDER_FLOAT32_CAPABLE\")) throw Error(\"The value \" + n + \" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'\");\n              throw Error(\"The value \" + n + \" cannot be represented on this device.\");\n            }\n          }\n        }, e.prototype.getValuesFromTexture = function (t) {\n          var e,\n              n = this.texData.get(t),\n              r = n.shape,\n              o = n.dtype,\n              i = n.isPacked,\n              a = A(r);\n\n          if (h().getBool(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")) {\n            var s = this.decode(t),\n                u = this.texData.get(s.dataId),\n                c = (e = this.gpgpu).downloadMatrixFromPackedTexture.apply(e, [u.texture].concat(Gt(r))).subarray(0, a);\n            return this.disposeData(s.dataId), c;\n          }\n\n          var l = h().getBool(\"WEBGL_PACK\") && !0 === i,\n              p = l ? Ae(r) : r,\n              f = l ? new pi(p) : new hi(p),\n              d = this.runWebGLProgram(f, [{\n            shape: p,\n            dtype: o,\n            dataId: t\n          }], \"float32\"),\n              m = this.texData.get(d.dataId),\n              g = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(m.texture, m.texShape[0], m.texShape[1]).subarray(0, a);\n          return this.disposeData(d.dataId), g;\n        }, e.prototype.time = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n, r, o, i, a, s;\n            return c(this, function (u) {\n              switch (u.label) {\n                case 0:\n                  return e = this.activeTimers, n = [], r = !1, null == this.programTimersStack ? (this.programTimersStack = n, r = !0) : this.activeTimers.push(n), this.activeTimers = n, t(), o = I(this.activeTimers.map(function (t) {\n                    return t.query;\n                  })).filter(function (t) {\n                    return null != t;\n                  }), i = I(this.activeTimers.map(function (t) {\n                    return t.name;\n                  })).filter(function (t) {\n                    return null != t;\n                  }), this.activeTimers = e, r && (this.programTimersStack = null), [4, Promise.all(o)];\n\n                case 1:\n                  return a = u.sent(), s = {\n                    uploadWaitMs: this.uploadWaitMs,\n                    downloadWaitMs: this.downloadWaitMs,\n                    kernelMs: x(a),\n                    getExtraProfileInfo: function () {\n                      return a.map(function (t, e) {\n                        return {\n                          name: i[e],\n                          ms: t\n                        };\n                      }).map(function (t) {\n                        return t.name + \": \" + t.ms;\n                      }).join(\", \");\n                    },\n                    wallMs: null\n                  }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s];\n              }\n            });\n          });\n        }, e.prototype.memory = function () {\n          return {\n            unreliable: !1,\n            numBytesInGPU: this.numBytesInGPU\n          };\n        }, e.prototype.startTimer = function () {\n          return h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? this.gpgpu.beginQuery() : {\n            startMs: et(),\n            endMs: null\n          };\n        }, e.prototype.endTimer = function (t) {\n          return h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? (this.gpgpu.endQuery(), t) : (t.endMs = et(), t);\n        }, e.prototype.getQueryTime = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e;\n            return c(this, function (n) {\n              return h().getNumber(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(t)] : [2, (e = t).endMs - e.startMs];\n            });\n          });\n        }, e.prototype.disposeData = function (t) {\n          if (!this.pendingDisposal.has(t)) {\n            if (this.pendingRead.has(t)) return this.pendingDisposal.add(t), void this.pendingDeletes++;\n\n            if (this.texData.has(t)) {\n              this.releaseGPUData(t);\n              var e = this.texData.get(t).complexTensors;\n              null != e && (e.real.dispose(), e.imag.dispose()), this.texData.delete(t);\n            }\n          }\n        }, e.prototype.releaseGPUData = function (t) {\n          var e = this.texData.get(t),\n              n = e.texture,\n              r = e.dtype,\n              o = e.texShape,\n              i = e.usage,\n              a = e.isPacked,\n              s = e.slice,\n              u = s && s.origDataId || t,\n              c = this.dataRefCount.get(u);\n          c > 1 ? this.dataRefCount.set(u, c - 1) : (this.dataRefCount.delete(u), null != n && (this.numBytesInGPU -= this.computeBytes(o, r), this.textureManager.releaseTexture(n, o, i, a)));\n          var l = this.texData.get(t);\n          l.texture = null, l.texShape = null, l.isPacked = !1, l.slice = null;\n        }, e.prototype.getTexture = function (t) {\n          return this.uploadToGPU(t), this.texData.get(t).texture;\n        }, e.prototype.getDataInfo = function (t) {\n          return this.texData.get(t);\n        }, e.prototype.getCPUBackend = function () {\n          return h().getBool(\"WEBGL_CPU_FORWARD\") ? (null == this.cpuBackend && (this.cpuBackend = Mt.findBackend(\"cpu\")), this.cpuBackend) : null;\n        }, e.prototype.shouldExecuteOnCPU = function (t, e) {\n          var n = this;\n          return void 0 === e && (e = 128), null != this.getCPUBackend() && t.every(function (t) {\n            return null == n.texData.get(t.dataId).texture && t.size < e;\n          });\n        }, e.prototype.getGPGPUContext = function () {\n          return this.gpgpu;\n        }, e.prototype.complex = function (t, e) {\n          var n = this.makeOutput(t.shape, \"complex64\");\n          return this.texData.get(n.dataId).complexTensors = {\n            real: Mt.keep(t.clone()),\n            imag: Mt.keep(e.clone())\n          }, n;\n        }, e.prototype.real = function (t) {\n          return this.texData.get(t.dataId).complexTensors.real.clone();\n        }, e.prototype.imag = function (t) {\n          return this.texData.get(t.dataId).complexTensors.imag.clone();\n        }, e.prototype.slice = function (t, e, n) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.slice(t, e, n);\n          if (0 === A(n)) return ln([], n, t.dtype);\n          var r = this.texData.get(t.dataId).isPacked,\n              o = kr(t.shape, e, n);\n\n          if (r || !o) {\n            var i = h().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new ma(n) : new fa(n),\n                a = i.getCustomSetupFunc(e);\n            return this.compileAndRun(i, [t], null, a);\n          }\n\n          return this.uploadToGPU(t.dataId), this.shallowSlice(t, e, n);\n        }, e.prototype.shallowSlice = function (t, e, n) {\n          var r = this.texData.get(t.dataId),\n              o = this.makeOutput(n, t.dtype),\n              i = this.texData.get(o.dataId);\n          Object.assign(i, r), i.shape = n, i.dtype = t.dtype;\n          var a = Tr(e, t.strides);\n          r.slice && (a += r.slice.flatOffset), i.slice = {\n            flatOffset: a,\n            origDataId: r.slice && r.slice.origDataId || t.dataId\n          };\n          var s = this.dataRefCount.get(i.slice.origDataId) || 1;\n          return this.dataRefCount.set(i.slice.origDataId, s + 1), o;\n        }, e.prototype.stridedSlice = function (t, e, n, r) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.stridedSlice(t, e, n, r);\n          var o = Cr(e, n, r);\n          if (o.some(function (t) {\n            return 0 === t;\n          })) return ln([], o);\n          var i = new ga(e, r, o);\n          return this.compileAndRun(i, [t]);\n        }, e.prototype.reverse = function (t, e) {\n          var n = h().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new ca(t.shape, e) : new ua(t.shape, e);\n          return this.compileAndRun(n, [t]);\n        }, e.prototype.concat = function (t, e) {\n          if (\"complex64\" === t[0].dtype) {\n            var n = t.map(function (t) {\n              return un(t);\n            }),\n                r = t.map(function (t) {\n              return cn(t);\n            });\n            return sn(this.concat(n, e), this.concat(r, e));\n          }\n\n          if (this.shouldExecuteOnCPU(t)) return this.cpuBackend.concat(t, e);\n          if (1 === t.length) return t[0];\n\n          if (t.length > h().getNumber(\"WEBGL_MAX_TEXTURES_IN_SHADER\")) {\n            var o = Math.floor(t.length / 2),\n                i = this.concat(t.slice(0, o), e),\n                a = this.concat(t.slice(o), e);\n            return this.concat([i, a], e);\n          }\n\n          if (h().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") && t[0].rank > 1) {\n            var s = new Ho(t.map(function (t) {\n              return t.shape;\n            }), e);\n            return this.compileAndRun(s, t);\n          }\n\n          var u = on(t.map(function (t) {\n            return t.shape;\n          }), e),\n              c = t.map(function (t) {\n            return t.as2D(-1, A(t.shape.slice(e)));\n          }),\n              l = new Go(c.map(function (t) {\n            return t.shape;\n          }));\n          return this.compileAndRun(l, c).reshape(u);\n        }, e.prototype.neg = function (t) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.neg(t);\n          if (h().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, _a, t.dtype);\n          var e = new Ia(t.shape, _a);\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.batchMatMul = function (t, e, n, r) {\n          var o = n ? t.shape[2] : t.shape[1],\n              i = r ? e.shape[1] : e.shape[2],\n              a = n ? t.shape[1] : t.shape[2],\n              s = t.shape[0];\n\n          if ((1 === o || 1 === i) && a > 1e3) {\n            n && (t = t.transpose([0, 2, 1])), r && (e = e.transpose([0, 2, 1]));\n            var u = 1 === i ? t : t.as3D(s, a, 1),\n                c = 1 === i ? 2 : 1,\n                l = 1 === i ? e.as3D(s, 1, a) : e;\n            return this.multiply(u, l).sum(c, !0);\n          }\n\n          var h = It(t.dtype, e.dtype),\n              p = new $i(t.shape, [s, o, i], n, r);\n          return this.compileAndRun(p, [t, e], h);\n        }, e.prototype.fusedBatchMatMul = function (t) {\n          var e = t.a,\n              n = t.b,\n              r = t.transposeA,\n              o = t.transposeB,\n              i = t.bias,\n              a = t.activation,\n              s = t.preluActivationWeights,\n              u = r ? e.shape[2] : e.shape[1],\n              c = o ? n.shape[1] : n.shape[2],\n              l = e.shape[0],\n              h = It(e.dtype, n.dtype),\n              p = null != i,\n              f = null != s,\n              d = a ? Ga(a, !0) : null,\n              m = new $i(e.shape, [l, u, c], r, o, p, d, f),\n              g = [e, n];\n          return i && g.push(i), s && g.push(s), this.compileAndRun(m, g, h);\n        }, e.prototype.multiply = function (t, e) {\n          if (\"complex64\" === t.dtype) {\n            var n = this.texData.get(t.dataId),\n                r = this.texData.get(e.dataId),\n                o = new Oo(\"return areal * breal - aimag * bimag;\", t.shape, e.shape),\n                i = new Oo(\"return areal * bimag + aimag * breal;\", t.shape, e.shape),\n                a = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag), this.makeComplexComponentTensorInfo(e, r.complexTensors.real), this.makeComplexComponentTensorInfo(e, r.complexTensors.imag)],\n                s = this.compileAndRun(o, a),\n                u = this.compileAndRun(i, a),\n                c = this.complex(s, u);\n            return s.dispose(), u.dispose(), c;\n          }\n\n          if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.multiply(t, e);\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, Lo, t.dtype);\n          var l = new zo(Lo, t.shape, e.shape);\n          return this.compileAndRun(l, [t, e], t.dtype);\n        }, e.prototype.batchNormalization = function (t, e, n, r, o, i) {\n          var a = [t, e, n],\n              s = null;\n          null != i && (s = i.shape, a.push(i));\n          var u = null;\n\n          if (null != o && (u = o.shape, a.push(o)), h().getBool(\"WEBGL_PACK_NORMALIZATION\")) {\n            var c = new Mo(t.shape, e.shape, n.shape, s, u, r);\n            return this.compileAndRun(c, a);\n          }\n\n          var l = new _o(t.shape, e.shape, n.shape, s, u, r);\n          return this.compileAndRun(l, a);\n        }, e.prototype.localResponseNormalization4D = function (t, e, n, r, o) {\n          var i = h().getBool(\"WEBGL_PACK_NORMALIZATION\") ? new Wi(t.shape, e, n, r, o) : new Ui(t.shape, e, n, r, o);\n          return this.compileAndRun(i, [t]);\n        }, e.prototype.LRNGrad = function (t, e, n, r, o, i, a) {\n          var s = new ji(e.shape, r, o, i, a);\n          return this.compileAndRun(s, [e, n, t]);\n        }, e.prototype.tile = function (t, e) {\n          if (\"string\" === t.dtype) {\n            var n = this.readSync(t.dataId).map(function (t) {\n              return ot(t);\n            });\n            return ao(Vn(t.shape, t.dtype, n), e);\n          }\n\n          var r = new wa(t.shape, e);\n          return this.compileAndRun(r, [t]);\n        }, e.prototype.pad = function (t, e, n) {\n          var r = h().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new Ji(t.shape, e, n) : new Yi(t.shape, e, n);\n          return this.compileAndRun(r, [t]);\n        }, e.prototype.transpose = function (t, e) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.transpose(t, e);\n          var n = h().getBool(\"WEBGL_PACK_ARRAY_OPERATIONS\") ? new Sa(t.shape, e) : new xa(t.shape, e);\n          return this.compileAndRun(n, [t]);\n        }, e.prototype.gather = function (t, e, n) {\n          if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.gather(t, e, n);\n          var r = new bi(t.shape, e.size, n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.batchToSpaceND = function (t, e, n) {\n          S(t.rank <= 4, function () {\n            return \"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet\";\n          });\n          var r = e.reduce(function (t, e) {\n            return t * e;\n          }),\n              o = fr(t.shape, e, r),\n              i = dr(o.length, e.length),\n              a = mr(t.shape, e, r),\n              s = gr(n, e.length),\n              u = vr(a, n, e.length);\n          return t.reshape(o).transpose(i).reshape(a).slice(s, u);\n        }, e.prototype.spaceToBatchND = function (t, e, n) {\n          S(t.rank <= 4, function () {\n            return \"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet\";\n          });\n          var r = e.reduce(function (t, e) {\n            return t * e;\n          }),\n              o = [[0, 0]];\n          o.push.apply(o, n);\n\n          for (var i = 1 + e.length; i < t.shape.length; ++i) o.push([0, 0]);\n\n          var a = t.pad(o),\n              s = fr(a.shape, e, r, !1),\n              u = dr(s.length, e.length, !1),\n              c = mr(a.shape, e, r, !1);\n          return a.reshape(s).transpose(u).reshape(c);\n        }, e.prototype.reduce = function (t, e, n) {\n          var r = t.shape[0],\n              o = t.shape[1],\n              i = wr(o),\n              a = new ea({\n            windowSize: i,\n            inSize: o,\n            batchSize: r\n          }, e),\n              s = this.compileAndRun(a, [t], n);\n          return 1 === s.shape[1] ? s : this.reduce(s, e, n);\n        }, e.prototype.argReduce = function (t, e, n) {\n          void 0 === n && (n = null);\n          var r = t.shape[0],\n              o = t.shape[1];\n          null != n && (r = n.shape[0], o = n.shape[1]);\n          var i = wr(o),\n              a = new ho({\n            windowSize: i,\n            inSize: o,\n            batchSize: r\n          }, e, null == n),\n              s = [t];\n          null != n && s.push(n);\n          var u = this.compileAndRun(a, s, \"int32\");\n          return 1 === u.shape[1] ? u : this.argReduce(t, e, u);\n        }, e.prototype.argReducePacked = function (t, e, n) {\n          void 0 === n && (n = null);\n          var r = null != n ? n.shape : t.shape,\n              o = wr(r[r.length - 1]),\n              i = new No(r, o, e, null == n),\n              a = null == n ? [t] : [t, n],\n              s = this.compileAndRun(i, a, \"int32\");\n          return s.rank === t.rank ? this.argReducePacked(t, e, s) : s;\n        }, e.prototype.sum = function (t, e) {\n          Ze(\"sum\", e, t.rank);\n          var n = Ye(t.shape, e),\n              r = n[0],\n              o = A(n[1]),\n              i = t.as2D(-1, o),\n              a = At(t.dtype);\n          return this.reduce(i, \"sum\", a).reshape(r);\n        }, e.prototype.prod = function (t, e) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.prod(t, e);\n          var n = Ye(t.shape, e),\n              r = n[0],\n              o = A(n[1]),\n              i = t.as2D(-1, o),\n              a = At(t.dtype);\n          return this.reduce(i, \"prod\", a).reshape(r);\n        }, e.prototype.unsortedSegmentSum = function (t, e, n) {\n          var r = 0,\n              o = tn([r], t.rank),\n              i = t;\n          null != o && (i = t.transpose(o), r = nn(1, t.rank)[0]);\n\n          var a = function (t, e, n) {\n            for (var r = [], o = t.length, i = 0; i < o; i++) i !== e ? r.push(t[i]) : r.push(n);\n\n            return r;\n          }(i.shape, r, n),\n              s = A([i.shape[r]]),\n              u = i.as2D(-1, s),\n              c = At(t.dtype),\n              l = this.segOpCompute(u, \"unsortedSegmentSum\", e, c, n).reshape(a);\n\n          return null != o && (l = l.transpose(en(o))), l;\n        }, e.prototype.segOpCompute = function (t, e, n, r, o) {\n          var i = t.shape[0],\n              a = t.shape[1],\n              s = function (t, e) {\n            var n,\n                r = !1;\n\n            for (t <= br ? (n = t, r = !0) : n = Q(t, Math.floor(Math.sqrt(t))); !r;) n > e || n === t ? r = !0 : n = Q(t, n + 1);\n\n            return n;\n          }(a, o),\n              u = new ha({\n            windowSize: s,\n            inSize: a,\n            batchSize: i,\n            numSegments: o\n          }, e),\n              c = this.compileAndRun(u, [t, n], r);\n\n          return c.shape[1] === o ? c : (n = wn(0, o).tile([a / s]), this.segOpCompute(c, e, n, r, o));\n        }, e.prototype.argMinMaxReduce = function (t, e, n) {\n          var r = [e];\n\n          if (Ze(\"arg\" + n.charAt(0).toUpperCase() + n.slice(1), r, t.rank), !h().getBool(\"WEBGL_PACK_REDUCE\") || t.rank <= 2) {\n            var o = Ye(t.shape, r),\n                i = o[0],\n                a = A(o[1]),\n                s = t.as2D(-1, a);\n            return this.argReduce(s, n).reshape(i);\n          }\n\n          return this.argReducePacked(t, n);\n        }, e.prototype.argMin = function (t, e) {\n          return this.argMinMaxReduce(t, e, \"min\");\n        }, e.prototype.argMax = function (t, e) {\n          return this.argMinMaxReduce(t, e, \"max\");\n        }, e.prototype.cumsum = function (t, e, n, r) {\n          if (e !== t.rank - 1) throw new Error(\"WebGL cumsum shader expects an inner-most axis=\" + (t.rank - 1) + \" but got axis=\" + e);\n          var o = new ii(t.shape, n, r);\n          return this.compileAndRun(o, [t]);\n        }, e.prototype.equal = function (t, e) {\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(equal(a, b));\\n\", \"bool\");\n          var n = new zo(\"return float(a == b);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"bool\");\n        }, e.prototype.notEqual = function (t, e) {\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(notEqual(a, b));\\n\", \"bool\");\n          var n = new zo(\"return float(a != b);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"bool\");\n        }, e.prototype.less = function (t, e) {\n          if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.less(t, e);\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(lessThan(a, b));\\n\", \"bool\");\n          var n = new zo(\"return float(a < b);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"bool\");\n        }, e.prototype.lessEqual = function (t, e) {\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(lessThanEqual(a, b));\\n\", \"bool\");\n          var n = new zo(\"return float(a <= b);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"bool\");\n        }, e.prototype.greater = function (t, e) {\n          if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.greater(t, e);\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(greaterThan(a, b));\\n\", \"bool\");\n          var n = new zo(\"return float(a > b);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"bool\");\n        }, e.prototype.greaterEqual = function (t, e) {\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(greaterThanEqual(a, b));\\n\", \"bool\");\n          var n = new zo(\"return float(a >= b);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"bool\");\n        }, e.prototype.logicalNot = function (t) {\n          var e = new Ia(t.shape, \"return float(!(x >= 1.0));\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.logicalAnd = function (t, e) {\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return vec4(\\n    vec4(greaterThanEqual(a, vec4(1.0))) *\\n    vec4(greaterThanEqual(b, vec4(1.0))));\\n\", \"bool\");\n          var n = new zo(\"return float(a >= 1.0 && b >= 1.0);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"bool\");\n        }, e.prototype.logicalOr = function (t, e) {\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  return min(\\n    vec4(greaterThanEqual(a, vec4(1.0))) +\\n    vec4(greaterThanEqual(b, vec4(1.0))),\\n    vec4(1.0));\\n\", \"bool\");\n          var n = new zo(\"return float(a >= 1.0 || b >= 1.0);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"bool\");\n        }, e.prototype.select = function (t, e, n) {\n          var r = new pa(t.rank, e.shape, e.rank);\n          return this.compileAndRun(r, [t, e, n], It(e.dtype, n.dtype));\n        }, e.prototype.where = function (t) {\n          We(\"tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead\");\n          var e = t.dataSync();\n          return uo(t.shape, e);\n        }, e.prototype.topk = function (t, e, n) {\n          return so(t.dataSync(), t.shape, t.dtype, e);\n        }, e.prototype.min = function (t, e) {\n          Ze(\"min\", e, t.rank);\n          var n = Ye(t.shape, e),\n              r = n[0],\n              o = A(n[1]),\n              i = t.as2D(-1, o);\n          return this.reduce(i, \"min\", i.dtype).reshape(r);\n        }, e.prototype.minimum = function (t, e) {\n          if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.minimum(t, e);\n          var n = h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Vo(\"\\n  vec4 result = vec4(min(a, b));\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new zo(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return min(a, b);\\n\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e]);\n        }, e.prototype.mod = function (t, e) {\n          var n = h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Vo(\"\\n  vec4 result = mod(a, b);\\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new zo(\"if (b == 0.0) return NAN;\\n  return mod(a, b);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e]);\n        }, e.prototype.max = function (t, e) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.max(t, e);\n          Ze(\"max\", e, t.rank);\n          var n = Ye(t.shape, e),\n              r = n[0],\n              o = A(n[1]),\n              i = t.as2D(-1, o);\n          return this.reduce(i, \"max\", i.dtype).reshape(r);\n        }, e.prototype.maximum = function (t, e) {\n          if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.maximum(t, e);\n          var n = h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Vo(\"\\n  vec4 result = vec4(max(a, b));\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new zo(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return max(a, b);\\n\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e]);\n        }, e.prototype.all = function (t, e) {\n          Ze(\"all\", e, t.rank);\n          var n = Ye(t.shape, e),\n              r = n[0],\n              o = A(n[1]),\n              i = t.as2D(-1, o);\n          return this.reduce(i, \"all\", i.dtype).reshape(r);\n        }, e.prototype.any = function (t, e) {\n          Ze(\"any\", e, t.rank);\n          var n = Ye(t.shape, e),\n              r = n[0],\n              o = A(n[1]),\n              i = t.as2D(-1, o);\n          return this.reduce(i, \"any\", i.dtype).reshape(r);\n        }, e.prototype.squaredDifference = function (t, e) {\n          var n = h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Vo(\"return (a - b) * (a - b);\", t.shape, e.shape) : new zo(\"return (a - b) * (a - b);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e]);\n        }, e.prototype.realDivide = function (t, e) {\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  // vec4 one = vec4(equal(a, b));\\n  // return one + (vec4(1.0) - one) * a / b;\\n  vec4 result = a / b;\\n  if(a.x == b.x) {\\n    result.x = 1.;\\n  }\\n  if(a.y == b.y) {\\n    result.y = 1.;\\n  }\\n  if(a.z == b.z) {\\n    result.z = 1.;\\n  }\\n  if(a.w == b.w) {\\n    result.w = 1.;\\n  }\\n\\n  return result;\\n\", \"float32\", !0);\n          var n = new zo(\"\\nif (a == b) {\\n  return 1.0;\\n};\\nreturn a / b;\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"float32\");\n        }, e.prototype.floorDiv = function (t, e) {\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, \"\\n  ivec4 ia = round(a);\\n  ivec4 ib = round(b);\\n  bvec4 cond = notEqual(ib, ivec4(0));\\n  ivec4 result = ivec4(0);\\n  vec4 s = sign(a) * sign(b);\\n\\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n  if (cond[0]) {\\n    result[0] = idiv(ia[0], ib[0], s[0]);\\n  }\\n  if (cond[1]) {\\n    result[1] = idiv(ia[1], ib[1], s[1]);\\n  }\\n  if (cond[2]) {\\n    result[2] = idiv(ia[2], ib[2], s[2]);\\n  }\\n  if (cond[3]) {\\n    result[3] = idiv(ia[3], ib[3], s[3]);\\n  }\\n  return vec4(result);\\n\", \"int32\");\n          var n = new zo(\"\\n  float s = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  if (ib != 0) {\\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\\n    return float(idiv(ia, ib, s));\\n  } else {\\n    return NAN;\\n  }\\n\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e], \"int32\");\n        }, e.prototype.add = function (t, e) {\n          if (\"complex64\" === t.dtype && \"complex64\" === e.dtype) return this.complexSeparableBinaryOp(t, e, Do);\n          if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.add(t, e);\n          var n = It(t.dtype, e.dtype);\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, Do, n);\n          var r = new zo(Do, t.shape, e.shape);\n          return this.compileAndRun(r, [t, e], n);\n        }, e.prototype.packedUnaryOp = function (t, e, n) {\n          var r = new Ua(t.shape, e);\n          return this.compileAndRun(r, [t], n);\n        }, e.prototype.packedBinaryOp = function (t, e, n, r, o) {\n          void 0 === o && (o = !1);\n          var i = new Vo(n, t.shape, e.shape, o);\n          return this.compileAndRun(i, [t, e], r);\n        }, e.prototype.complexSeparableBinaryOp = function (t, e, n) {\n          var r = this,\n              o = this.texData.get(t.dataId),\n              i = this.texData.get(e.dataId),\n              a = [[o.complexTensors.real, i.complexTensors.real], [o.complexTensors.imag, i.complexTensors.imag]].map(function (o) {\n            var i = o[0],\n                a = o[1],\n                s = r.makeComplexComponentTensorInfo(t, i),\n                u = r.makeComplexComponentTensorInfo(e, a),\n                c = new zo(n, t.shape, e.shape);\n            return r.compileAndRun(c, [s, u], It(i.dtype, a.dtype));\n          }),\n              s = a[0],\n              u = a[1],\n              c = this.complex(s, u);\n          return s.dispose(), u.dispose(), c;\n        }, e.prototype.makeComplexComponentTensorInfo = function (t, e) {\n          return {\n            dataId: e.dataId,\n            dtype: e.dtype,\n            shape: t.shape\n          };\n        }, e.prototype.addN = function (t) {\n          if (1 === t.length) return t[0];\n\n          if (t.length > h().get(\"WEBGL_MAX_TEXTURES_IN_SHADER\")) {\n            var e = Math.floor(t.length / 2),\n                n = this.addN(t.slice(0, e)),\n                r = this.addN(t.slice(e));\n            return this.addN([n, r]);\n          }\n\n          var o = t.map(function (t) {\n            return t.dtype;\n          }).reduce(function (t, e) {\n            return It(t, e);\n          }),\n              i = t.map(function (t) {\n            return t.shape;\n          }),\n              a = h().getBool(\"WEBGL_PACK\") ? new lo(t[0].shape, i) : new co(t[0].shape, i);\n          return this.compileAndRun(a, t, o);\n        }, e.prototype.subtract = function (t, e) {\n          if (\"complex64\" === t.dtype && \"complex64\" === e.dtype) return this.complexSeparableBinaryOp(t, e, Fo);\n          if (this.shouldExecuteOnCPU([t, e])) return this.cpuBackend.subtract(t, e);\n          var n = It(t.dtype, e.dtype);\n          if (h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\")) return this.packedBinaryOp(t, e, Fo, t.dtype);\n          var r = new zo(Fo, t.shape, e.shape);\n          return this.compileAndRun(r, [t, e], n);\n        }, e.prototype.pow = function (t, e) {\n          var n = h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Vo(\"\\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\\n  vec4 result = multiplier * pow(abs(a), b);\\n\\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\\n  bvec4 isExpZero = equal(b, vec4(0.0));\\n  result.r = isExpZero.r ? 1.0 : result.r;\\n  result.g = isExpZero.g ? 1.0 : result.g;\\n  result.b = isExpZero.b ? 1.0 : result.b;\\n  result.a = isExpZero.a ? 1.0 : result.a;\\n\\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new zo(\"\\nif(a < 0.0 && floor(b) < b){\\n  return NAN;\\n}\\nif (b == 0.0) {\\n  return 1.0;\\n}\\nreturn (round(mod(b, 2.0)) != 1) ?\\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\", t.shape, e.shape),\n              r = It(t.dtype, e.dtype);\n          return this.compileAndRun(n, [t, e], r);\n        }, e.prototype.ceil = function (t) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.ceil(t);\n          if (h().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Ma, t.dtype);\n          var e = new Ia(t.shape, Ma);\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.floor = function (t) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.floor(t);\n          if (h().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Oa, t.dtype);\n          var e = new Ia(t.shape, Oa);\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.sign = function (t) {\n          var e = new Ia(t.shape, \"\\n  if (isnan(x)) { return 0.0; }\\n  return sign(x);\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.isNaN = function (t) {\n          var e = new Ia(t.shape, \"return float(isnan(x));\");\n          return this.compileAndRun(e, [t], \"bool\");\n        }, e.prototype.isInf = function (t) {\n          var e = new Ia(t.shape, \"return float(isinf(x));\");\n          return this.compileAndRun(e, [t], \"bool\");\n        }, e.prototype.isFinite = function (t) {\n          var e = new Ia(t.shape, \"return float(!isnan(x) && !isinf(x));\");\n          return this.compileAndRun(e, [t], \"bool\");\n        }, e.prototype.round = function (t) {\n          var e = new Ia(t.shape, \"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.exp = function (t) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.exp(t);\n          if (h().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Da, t.dtype);\n          var e = new Ia(t.shape, Da);\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.expm1 = function (t) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.expm1(t);\n          if (h().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Fa, t.dtype);\n          var e = new Ia(t.shape, Fa);\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.log = function (t) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.log(t);\n          if (h().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, \"\\n  vec4 result = log(x);\\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\\n\\n  return result;\\n\", t.dtype);\n          var e = new Ia(t.shape, \"if (x < 0.0) return NAN;\\n  return log(x);\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.log1p = function (t) {\n          var e = new Ia(t.shape, \"return log(1.0 + x);\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.sqrt = function (t) {\n          var e = new Ia(t.shape, \"return sqrt(x);\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.rsqrt = function (t) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.rsqrt(t);\n          var e = new Ia(t.shape, \"return inversesqrt(x);\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.reciprocal = function (t) {\n          var e = new Ia(t.shape, \"return 1.0 / x;\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.relu = function (t) {\n          var e;\n          return e = h().getBool(\"WEBGL_PACK\") ? new Ua(t.shape, za) : new Ia(t.shape, Na), this.compileAndRun(e, [t]);\n        }, e.prototype.relu6 = function (t) {\n          var e;\n          return e = h().getBool(\"WEBGL_PACK\") ? new Ua(t.shape, qa) : new Ia(t.shape, Pa), this.compileAndRun(e, [t]);\n        }, e.prototype.prelu = function (t, e) {\n          var n = h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Vo(qo, t.shape, e.shape) : new zo(Bo, t.shape, e.shape);\n          return this.compileAndRun(n, [t, e]);\n        }, e.prototype.elu = function (t) {\n          if (h().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Va, t.dtype);\n          var e = new Ia(t.shape, Ra);\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.eluDer = function (t, e) {\n          var n = h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Vo(\"\\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\\n\", t.shape, e.shape) : new zo(\"return (b >= 1.0) ? a : a * (b + 1.0);\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e]);\n        }, e.prototype.selu = function (t) {\n          var e = new Ia(t.shape, \"\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = 1.7580993408473768;\\n  float scale = 1.0507009873554805;\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.int = function (t) {\n          var e = new Ia(t.shape, \"return float(int(x));\");\n          return this.compileAndRun(e, [t], \"int32\");\n        }, e.prototype.clip = function (t, e, n) {\n          var r,\n              o = (r = h().getBool(\"WEBGL_PACK_CLIP\") ? new jo(t.shape) : new Uo(t.shape)).getCustomSetupFunc(e, n);\n          return this.compileAndRun(r, [t], null, o);\n        }, e.prototype.abs = function (t) {\n          if (this.shouldExecuteOnCPU([t])) return this.cpuBackend.abs(t);\n          if (h().getBool(\"WEBGL_PACK_UNARY_OPERATIONS\")) return this.packedUnaryOp(t, Ta, t.dtype);\n          var e = new Ia(t.shape, Ta);\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.complexAbs = function (t) {\n          var e = this.texData.get(t.dataId),\n              n = new Wo(t.shape),\n              r = [this.makeComplexComponentTensorInfo(t, e.complexTensors.real), this.makeComplexComponentTensorInfo(t, e.complexTensors.imag)];\n          return this.compileAndRun(n, r);\n        }, e.prototype.sigmoid = function (t) {\n          var e = new Ia(t.shape, \"return 1.0 / (1.0 + exp(-1.0 * x));\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.softplus = function (t) {\n          var e = new Ia(t.shape, \"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.sin = function (t) {\n          var e = new Ia(t.shape, \"if (isnan(x)) return x;\\n  return sin(x);\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.cos = function (t) {\n          var e = new Ia(t.shape, \"if (isnan(x)) return x;\\n  return cos(x);\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.tan = function (t) {\n          var e = new Ia(t.shape, \"return tan(x);\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.asin = function (t) {\n          var e = new Ia(t.shape, \"if (isnan(x)) return x;\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return asin(x);\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.acos = function (t) {\n          var e = new Ia(t.shape, \"if (isnan(x)) return x;\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return acos(x);\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.atan = function (t) {\n          var e = new Ia(t.shape, \"if (isnan(x)) return x;\\n  return atan(x);\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.atan2 = function (t, e) {\n          var n = h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") ? new Vo(\"\\n  vec4 result = atan(a, b);\\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\\n  \\n  result.r = isNaN.r > 0. ? NAN : result.r;\\n  result.g = isNaN.g > 0. ? NAN : result.g;\\n  result.b = isNaN.b > 0. ? NAN : result.b;\\n  result.a = isNaN.a > 0. ? NAN : result.a;\\n\\n  return result;\\n\", t.shape, e.shape) : new zo(\"\\n  if (isnan(a)) return a;\\n  if (isnan(b)) return b;\\n\\n  return atan(a, b);\\n\", t.shape, e.shape);\n          return this.compileAndRun(n, [t, e]);\n        }, e.prototype.sinh = function (t) {\n          var e = new Ia(t.shape, \"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.cosh = function (t) {\n          var e = new Ia(t.shape, \"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.tanh = function (t) {\n          var e = new Ia(t.shape, \"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.asinh = function (t) {\n          var e = new Ia(t.shape, \"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.acosh = function (t) {\n          var e = new Ia(t.shape, \"if (isnan(x)) return x;\\n  if (x < 1.0) return NAN;\\n  return log(x + sqrt(x * x - 1.0));\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.atanh = function (t) {\n          var e = new Ia(t.shape, \"if (isnan(x)) return x;\\n  if ((x < -1.0) || (x > 1.0)) return NAN;\\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;\");\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.erf = function (t) {\n          var e = new Ia(t.shape, '\\n  // Error function is calculated approximately with elementary function.\\n  // See \"Handbook of Mathematical Functions with Formulas,\\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\\n  float p = 0.3275911;\\n  float a1 = 0.254829592;\\n  float a2 = -0.284496736;\\n  float a3 = 1.421413741;\\n  float a4 = -1.453152027;\\n  float a5 = 1.061405429;\\n\\n  float sign = sign(x);\\n  x = abs(x);\\n  float t = 1.0 / (1.0 + p * x);\\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\\n');\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.step = function (t, e) {\n          var n = new Ia(t.shape, function (t) {\n            return void 0 === t && (t = 0), Aa + \"\\n    return x > 0.0 ? 1.0 : float(\" + t + \");\\n  \";\n          }(e));\n          return this.compileAndRun(n, [t]);\n        }, e.prototype.conv2dByMatMul = function (t, e, n, r, o, i) {\n          var a = t.shape,\n              s = this.texData.get(t.dataId),\n              u = n.inChannels,\n              c = a[0] * a[1] * a[2],\n              l = n.outChannels,\n              p = \"channelsLast\" === n.dataFormat,\n              f = (1 === c || 1 === l) && u > 1e3,\n              d = a[2] % 2 != 0 && !!s.isPacked;\n\n          if (f || !h().getBool(\"WEBGL_LAZILY_UNPACK\") || !h().getBool(\"WEBGL_PACK_BINARY_OPERATIONS\") || !d) {\n            var m = p ? a[0] * a[1] * a[2] : a[0] * a[2] * a[3],\n                g = this.reshape(t, [1, m, n.inChannels]),\n                v = this.reshape(e, [1, n.inChannels, n.outChannels]);\n            return this.reshape(this.fusedBatchMatMul({\n              a: g,\n              b: v,\n              transposeA: !1,\n              transposeB: !1,\n              bias: r,\n              activation: o,\n              preluActivationWeights: i\n            }), n.outShape);\n          }\n\n          var y = p ? a[0] * a[1] * (a[2] + 1) : a[0] * a[2] * (a[3] + 1),\n              b = {\n            dataId: t.dataId,\n            shape: [1, y, n.inChannels],\n            dtype: t.dtype\n          },\n              w = s.shape;\n          s.shape = s.shape.slice(), s.shape[s.shape.length - 2]++, S(Ne(s.shape, b.shape), function () {\n            return \"packed reshape \" + s.shape + \" to \" + b.shape + \" isn't free\";\n          });\n          var x = this.reshape(e, [1, n.inChannels, n.outChannels]),\n              E = this.fusedBatchMatMul({\n            a: b,\n            b: x,\n            transposeA: !1,\n            transposeB: !1,\n            bias: r,\n            activation: o,\n            preluActivationWeights: i\n          }),\n              C = this.texData.get(E.dataId);\n          return S(C.isPacked, function () {\n            return \"batchMatMul result is expected to be packed\";\n          }), s.shape = w, C.shape = n.outShape, Mt.makeTensorFromDataId(E.dataId, n.outShape, E.dtype);\n        }, e.prototype.conv2dWithIm2Row = function (t, e, n, r, o, i) {\n          var a = n.filterWidth,\n              s = n.filterHeight,\n              u = n.inChannels,\n              c = n.outWidth,\n              l = n.outHeight,\n              h = \"channelsLast\" === n.dataFormat,\n              p = a * s * u,\n              f = l * c,\n              d = [p, f],\n              m = t.squeeze([0]),\n              g = e.reshape([1, p, -1]),\n              v = new Vi(d, m.shape, n),\n              y = this.compileAndRun(v, [m]).reshape([1, d[0], d[1]]),\n              b = null != r,\n              w = null != i,\n              x = o ? Ga(o, !0) : null,\n              S = new $i(y.shape, [1, f, n.outChannels], !0, !1, b, x, w),\n              E = [y, g];\n          r && E.push(r), w && E.push(i);\n          var C = this.compileAndRun(S, E);\n          return h ? C.reshape([1, l, c, n.outChannels]) : C.reshape([1, n.outChannels, l, c]);\n        }, e.prototype.fusedConv2d = function (t) {\n          var e = t.input,\n              n = t.filter,\n              r = t.convInfo,\n              o = t.bias,\n              i = t.activation,\n              a = t.preluActivationWeights;\n          if (1 === r.filterHeight && 1 === r.filterWidth && 1 === r.dilationHeight && 1 === r.dilationWidth && 1 === r.strideHeight && 1 === r.strideWidth && (\"SAME\" === r.padInfo.type || \"VALID\" === r.padInfo.type)) return this.conv2dByMatMul(e, n, r, o, i, a);\n          if (h().getBool(\"WEBGL_CONV_IM2COL\") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, n, r, o, i, a);\n          var s = null != o,\n              u = null != a,\n              c = i ? Ga(i, !1) : null,\n              l = new ti(r, s, c, u),\n              p = [e, n];\n          return o && p.push(o), a && p.push(a), this.compileAndRun(l, p);\n        }, e.prototype.conv2d = function (t, e, n) {\n          if (1 === n.filterHeight && 1 === n.filterWidth && 1 === n.dilationHeight && 1 === n.dilationWidth && 1 === n.strideHeight && 1 === n.strideWidth && (\"SAME\" === n.padInfo.type || \"VALID\" === n.padInfo.type)) return this.conv2dByMatMul(t, e, n);\n          if (h().getBool(\"WEBGL_CONV_IM2COL\") && 1 === t.shape[0]) return this.conv2dWithIm2Row(t, e, n);\n          var r = new ti(n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.conv2dDerInput = function (t, e, n) {\n          var r = new Qo(n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.conv2dDerFilter = function (t, e, n) {\n          var r = new Ko(n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.fusedDepthwiseConv2D = function (t) {\n          var e,\n              n = t.input,\n              r = t.filter,\n              o = t.convInfo,\n              i = t.bias,\n              a = t.activation,\n              s = t.preluActivationWeights,\n              u = h().getBool(\"WEBGL_PACK_DEPTHWISECONV\") && o.strideWidth <= 2 && o.outChannels / o.inChannels == 1,\n              c = a ? Ga(a, u) : null,\n              l = [n, r],\n              p = null != i,\n              f = null != s;\n          return p && l.push(i), f && l.push(s), u ? (e = new ri(o, p, c, f), this.compileAndRun(e, l)) : (e = new ni(o, p, c, f), this.compileAndRun(e, l));\n        }, e.prototype.depthwiseConv2D = function (t, e, n) {\n          var r;\n          return h().getBool(\"WEBGL_PACK_DEPTHWISECONV\") && n.strideWidth <= 2 && n.outChannels / n.inChannels == 1 ? (r = new ri(n), this.compileAndRun(r, [t, e])) : (r = new ni(n), this.compileAndRun(r, [t, e]));\n        }, e.prototype.depthwiseConv2DDerInput = function (t, e, n) {\n          var r = new Zo(n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.depthwiseConv2DDerFilter = function (t, e, n) {\n          var r = new Jo(n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.conv3d = function (t, e, n) {\n          var r = new ei(n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.conv3dDerInput = function (t, e, n) {\n          var r = new Yo(n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.conv3dDerFilter = function (t, e, n) {\n          var r = new Xo(n);\n          return this.compileAndRun(r, [t, e]);\n        }, e.prototype.maxPool = function (t, e) {\n          var n = new Zi(e, \"max\", !1);\n          return this.compileAndRun(n, [t]);\n        }, e.prototype.avgPool = function (t, e) {\n          var n = new Zi(e, \"avg\", !1);\n          return this.compileAndRun(n, [t], \"float32\");\n        }, e.prototype.maxPoolBackprop = function (t, e, n, r) {\n          var o = new Zi(r, \"max\", !0),\n              i = this.compileAndRun(o, [e]),\n              a = new Gi(r),\n              s = this.compileAndRun(a, [t, i], e.dtype);\n          return i.dispose(), s;\n        }, e.prototype.avgPoolBackprop = function (t, e, n) {\n          var r = new Po(n);\n          return this.compileAndRun(r, [t], e.dtype);\n        }, e.prototype.cast = function (t, e) {\n          return Xr(t, e, this);\n        }, e.prototype.unstack = function (t, e) {\n          for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, i = 0; i < t.rank; i++) i !== e && (r[o++] = t.shape[i]);\n\n          var a = new Array(t.rank).fill(0),\n              s = t.shape.slice();\n          s[e] = 1;\n          var u = new Array(n);\n\n          for (i = 0; i < u.length; i++) a[e] = i, u[i] = this.slice(t, a, s).reshape(r);\n\n          return u;\n        }, e.prototype.avgPool3d = function (t, e) {\n          var n = new ta(e, \"avg\", !1);\n          return this.compileAndRun(n, [t], \"float32\");\n        }, e.prototype.avgPool3dBackprop = function (t, e, n) {\n          var r = new Ro(n);\n          return this.compileAndRun(r, [t], e.dtype);\n        }, e.prototype.maxPool3d = function (t, e) {\n          var n = new ta(e, \"max\", !1);\n          return this.compileAndRun(n, [t], \"float32\");\n        }, e.prototype.maxPool3dBackprop = function (t, e, n, r) {\n          var o = new ta(r, \"max\", !0),\n              i = this.compileAndRun(o, [e]),\n              a = new Hi(r),\n              s = this.compileAndRun(a, [t, i], e.dtype);\n          return i.dispose(), s;\n        }, e.prototype.reshape = function (t, e) {\n          var n = this.texData.get(t.dataId);\n\n          if (n.isPacked && !Ne(t.shape, e) && (null === n.texture || !Ne(n.shape, e))) {\n            var r = this.packedReshape(t, e);\n            return Mt.makeTensorFromDataId(r.dataId, r.shape, r.dtype);\n          }\n\n          return Yr(t, e);\n        }, e.prototype.resizeBilinear = function (t, e, n, r) {\n          var o = h().getBool(\"WEBGL_PACK_IMAGE_OPERATIONS\") ? new ia(t.shape, e, n, r) : new oa(t.shape, e, n, r);\n          return this.compileAndRun(o, [t]);\n        }, e.prototype.resizeBilinearBackprop = function (t, e, n) {\n          var r = new ra(t, e, n);\n          return this.compileAndRun(r, [t]);\n        }, e.prototype.resizeNearestNeighbor = function (t, e, n, r) {\n          var o = new sa(t.shape, e, n, r);\n          return this.compileAndRun(o, [t]);\n        }, e.prototype.resizeNearestNeighborBackprop = function (t, e, n) {\n          var r = new aa(t, e, n);\n          return this.compileAndRun(r, [t]);\n        }, e.prototype.multinomial = function (t, e, n, r) {\n          var o = e ? t : Pr(t),\n              i = o.shape[0],\n              a = o.shape[1],\n              s = new Ki(i, a, n),\n              u = s.getCustomSetupFunc(r);\n          return this.compileAndRun(s, [o], \"int32\", u);\n        }, e.prototype.oneHot = function (t, e, n, r) {\n          var o = new Qi(t.size, e, n, r);\n          return this.compileAndRun(o, [t]);\n        }, e.prototype.diag = function (t) {\n          var e = new li(t.size);\n          return this.compileAndRun(e, [t]);\n        }, e.prototype.nonMaxSuppression = function (t, e, n, r, o) {\n          return We(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\"), ro(t.dataSync(), e.dataSync(), n, r, o);\n        }, e.prototype.cropAndResize = function (t, e, n, r, o, i) {\n          var a = new oi(t.shape, e.shape, r, o, i);\n          return this.compileAndRun(a, [t, e, n]);\n        }, e.prototype.depthToSpace = function (t, e, n) {\n          S(e > 1, function () {\n            return \"blockSize should be > 1 for depthToSpace, but was: \" + e;\n          });\n          var r = t.shape[0],\n              o = \"NHWC\" === n ? t.shape[1] : t.shape[2],\n              i = \"NHWC\" === n ? t.shape[2] : t.shape[3],\n              a = \"NHWC\" === n ? t.shape[3] : t.shape[1],\n              s = o * e,\n              u = i * e,\n              c = a / (e * e),\n              l = new ci(\"NHWC\" === n ? [r, s, u, c] : [r, c, s, u], e, n);\n          return this.compileAndRun(l, [t]);\n        }, e.prototype.split = function (t, e, n) {\n          return io(t, e, n);\n        }, e.prototype.scatterND = function (t, e, n) {\n          var r = xr(0, t, n),\n              o = r.sliceRank,\n              i = r.numUpdates,\n              a = r.sliceSize,\n              s = r.strides,\n              u = r.outputSize,\n              c = [u / a, a],\n              l = t.reshape([i, o]),\n              h = e.reshape([i, a]);\n          if (0 === u) return Yr(ln([]), n);\n          var p = pn(0),\n              f = new la(i, o, l.rank, h.rank, s, c);\n          return this.compileAndRun(f, [h, l, p]).reshape(n);\n        }, e.prototype.sparseToDense = function (t, e, n, r) {\n          var o = xr(0, t, n),\n              i = o.sliceRank,\n              a = o.numUpdates,\n              s = o.strides,\n              u = o.outputSize,\n              c = new la(a, i, t.rank, e.rank, s, [u, 1], !1);\n          return this.compileAndRun(c, [e, t, r]).reshape(n);\n        }, e.prototype.fft = function (t) {\n          return this.fftImpl(t, !1);\n        }, e.prototype.ifft = function (t) {\n          return this.fftImpl(t, !0);\n        }, e.prototype.fftImpl = function (t, e) {\n          var n = this.texData.get(t.dataId),\n              r = new mi(\"return real * expR - imag * expI;\", t.shape, e),\n              o = new mi(\"return real * expI + imag * expR;\", t.shape, e),\n              i = [this.makeComplexComponentTensorInfo(t, n.complexTensors.real), this.makeComplexComponentTensorInfo(t, n.complexTensors.imag)],\n              a = this.compileAndRun(r, i),\n              s = this.compileAndRun(o, i),\n              u = this.complex(a, s).as2D(t.shape[0], t.shape[1]);\n          return a.dispose(), s.dispose(), u;\n        }, e.prototype.gatherND = function (t, e) {\n          var n = e.shape,\n              r = n[n.length - 1],\n              o = yr(t, e),\n              i = o[0],\n              a = o[1],\n              s = o[2],\n              u = o[3],\n              c = e.reshape([a, r]),\n              l = t.reshape([t.size / s, s]),\n              h = new wi(r, u, [a, s]);\n          return this.compileAndRun(h, [l, c]).reshape(i);\n        }, e.prototype.fill = function (t, e, n) {\n          if (\"string\" === (n = n || $(e))) {\n            var r = L(n, A(t));\n            return r.fill(e), Mt.makeTensor(r, t, n, this);\n          }\n\n          var o = new gi(t, e),\n              i = o.getCustomSetupFunc(e);\n          return this.compileAndRun(o, [], n, i);\n        }, e.prototype.onesLike = function (t) {\n          if (\"string\" === t.dtype) throw new Error(\"onesLike is not supported under string dtype\");\n          return this.fill(t.shape, 1, t.dtype);\n        }, e.prototype.zerosLike = function (t) {\n          return this.fill(t.shape, \"string\" === t.dtype ? \"\" : 0, t.dtype);\n        }, e.prototype.linspace = function (t, e, n) {\n          return Jr(t, e, n);\n        }, e.prototype.makeTensorInfo = function (t, e) {\n          var n = this.write(null, t, e);\n          return this.texData.get(n).usage = null, {\n            dataId: n,\n            shape: t,\n            dtype: e\n          };\n        }, e.prototype.makeOutput = function (t, e) {\n          var n = this.makeTensorInfo(t, e).dataId;\n          return Mt.makeTensorFromDataId(n, t, e, this);\n        }, e.prototype.unpackTensor = function (t) {\n          var e = new ja(t.shape);\n          return this.runWebGLProgram(e, [t], t.dtype);\n        }, e.prototype.packTensor = function (t) {\n          var e = new Xi(t.shape);\n          return this.runWebGLProgram(e, [t], t.dtype, null, !0);\n        }, e.prototype.packedReshape = function (t, e) {\n          var n = [Ce(t.shape)].concat(Ie(t.shape)),\n              r = {\n            dtype: t.dtype,\n            shape: n,\n            dataId: t.dataId\n          },\n              o = [Ce(e)].concat(Ie(e)),\n              i = new na(o, n),\n              a = this.runWebGLProgram(i, [r], t.dtype, null, !0);\n          return {\n            dataId: a.dataId,\n            shape: e,\n            dtype: a.dtype\n          };\n        }, e.prototype.decode = function (t) {\n          var e,\n              n = this.texData.get(t),\n              r = n.isPacked,\n              o = n.shape,\n              i = n.dtype,\n              a = Ae(o);\n          return e = r ? new ui(a) : new si(a), {\n            dtype: i,\n            shape: o,\n            dataId: this.runWebGLProgram(e, [{\n              shape: a,\n              dtype: i,\n              dataId: t\n            }], i, null, !0).dataId\n          };\n        }, e.prototype.runWebGLProgram = function (t, e, n, r, o) {\n          var i = this;\n          void 0 === o && (o = !1);\n          var a = this.makeTensorInfo(t.outputShape, n),\n              s = this.texData.get(a.dataId);\n\n          if (t.packedOutput && (s.isPacked = !0), t.outPackingScheme === Ft.DENSE) {\n            var u = Gt(t.outputShape);\n            s.texShape = u.map(function (t) {\n              return 2 * t;\n            });\n          }\n\n          if (null != t.outTexUsage && (s.usage = t.outTexUsage), 0 === A(a.shape)) return s.values = F(a.dtype, 0), a;\n          var c = [],\n              l = e.map(function (e) {\n            if (\"complex64\" === e.dtype) throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.\");\n            var n = i.texData.get(e.dataId);\n\n            if (null == n.texture) {\n              if (!t.packedInputs && A(e.shape) <= h().getNumber(\"WEBGL_SIZE_UPLOAD_UNIFORM\")) return {\n                shape: e.shape,\n                texData: null,\n                isUniform: !0,\n                uniformValues: n.values\n              };\n              t.packedInputs && (n.isPacked = !0, n.shape = e.shape);\n            } else if (!!n.isPacked != !!t.packedInputs) e = n.isPacked ? i.unpackTensor(e) : i.packTensor(e), c.push(e), n = i.texData.get(e.dataId);else if (n.isPacked && !Ne(n.shape, e.shape)) {\n              var r = e,\n                  o = e.shape;\n              e.shape = n.shape, e = i.packedReshape(e, o), c.push(e), n = i.texData.get(e.dataId), r.shape = o;\n            }\n\n            return i.uploadToGPU(e.dataId), {\n              shape: e.shape,\n              texData: n,\n              isUniform: !1\n            };\n          });\n          this.uploadToGPU(a.dataId);\n\n          var p,\n              f = {\n            shape: a.shape,\n            texData: s,\n            isUniform: !1\n          },\n              d = function (t, e, n) {\n            var r = \"\";\n            e.concat(n).forEach(function (t) {\n              var e = null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0,\n                  n = t.isUniform ? \"uniform\" : t.texData.texShape;\n              r += t.shape + \"_\" + n + \"_\" + e;\n            });\n            var o = t.userCode;\n            return t.constructor.name + \"_\" + r + \"_\" + o;\n          }(t, l, f),\n              m = this.getAndSaveBinary(d, function () {\n            return function (t, e, n, r) {\n              var o = e.userCode,\n                  i = n.map(function (t, n) {\n                var r = {\n                  logicalShape: t.shape,\n                  texShape: t.isUniform ? null : t.texData.texShape,\n                  isUniform: t.isUniform,\n                  isPacked: !t.isUniform && t.texData.isPacked,\n                  flatOffset: null\n                };\n                return null != t.texData && null != t.texData.slice && t.texData.slice.flatOffset > 0 && (r.flatOffset = t.texData.slice.flatOffset), {\n                  name: e.variableNames[n],\n                  shapeInfo: r\n                };\n              }),\n                  a = i.map(function (t) {\n                return t.shapeInfo;\n              }),\n                  s = {\n                logicalShape: r.shape,\n                texShape: r.texData.texShape,\n                isUniform: !1,\n                isPacked: r.texData.isPacked,\n                flatOffset: null\n              },\n                  u = bo(i, s, o, e.packedInputs),\n                  c = t.createProgram(u),\n                  l = null,\n                  p = t.getUniformLocation(c, \"NAN\", !1);\n              1 === h().getNumber(\"WEBGL_VERSION\") && (l = t.getUniformLocation(c, \"INFINITY\", !1));\n\n              for (var f = {}, d = 0; d < e.variableNames.length; d++) {\n                var m = e.variableNames[d];\n                f[m] = t.getUniformLocation(c, m, !1), f[\"offset\" + m] = t.getUniformLocation(c, \"offset\" + m, !1);\n              }\n\n              return {\n                program: e,\n                source: u,\n                webGLProgram: c,\n                uniformLocations: f,\n                inShapeInfos: a,\n                outShapeInfo: s,\n                infLoc: l,\n                nanLoc: p\n              };\n            }(i.gpgpu, t, l, f);\n          }),\n              g = null != this.activeTimers;\n\n          if (g && (p = this.startTimer()), function (t, e, n, r, o) {\n            qi(e.inShapeInfos, n), qi([e.outShapeInfo], [r]);\n            var i = r.texData.texture,\n                a = r.texData.texShape;\n            r.texData.isPacked ? t.setOutputPackedMatrixTexture(i, a[0], a[1]) : t.setOutputMatrixTexture(i, a[0], a[1]), t.setProgram(e.webGLProgram), 1 === h().getNumber(\"WEBGL_VERSION\") && null !== e.infLoc && t.gl.uniform1f(e.infLoc, 1 / 0), null !== e.nanLoc && t.gl.uniform1f(e.nanLoc, NaN), n.forEach(function (n, r) {\n              var o = e.program.variableNames[r],\n                  i = e.uniformLocations[o],\n                  a = e.uniformLocations[\"offset\" + o];\n              if (null != i) if (n.isUniform) {\n                if (A(n.shape) < 2) t.gl.uniform1f(i, n.uniformValues[0]);else {\n                  var s = n.uniformValues;\n                  s instanceof Float32Array || (s = new Float32Array(s)), t.gl.uniform1fv(i, s);\n                }\n              } else null != n.texData.slice && null != a && t.gl.uniform1i(a, n.texData.slice.flatOffset), t.setInputMatrixTexture(n.texData.texture, i, r);\n            }), null != o && o(t, e.webGLProgram), t.executeProgram();\n          }(this.gpgpu, m, l, f, r), c.forEach(function (t) {\n            return i.disposeData(t.dataId);\n          }), g && (p = this.endTimer(p), this.activeTimers.push({\n            name: t.constructor.name,\n            query: this.getQueryTime(p)\n          })), !h().getBool(\"WEBGL_LAZILY_UNPACK\") && s.isPacked && !1 === o) {\n            var v = this.unpackTensor(a);\n            return this.disposeData(a.dataId), v;\n          }\n\n          return a;\n        }, e.prototype.compileAndRun = function (t, e, n, r, o) {\n          void 0 === o && (o = !1), n = n || e[0].dtype;\n          var i = this.runWebGLProgram(t, e, n, r, o);\n          return Mt.makeTensorFromDataId(i.dataId, i.shape, i.dtype);\n        }, e.prototype.getAndSaveBinary = function (t, e) {\n          return t in this.binaryCache || (this.binaryCache[t] = e()), this.binaryCache[t];\n        }, e.prototype.getTextureManager = function () {\n          return this.textureManager;\n        }, e.prototype.dispose = function () {\n          this.disposed || (this.textureManager.dispose(), null != this.canvas && \"undefined\" != typeof HTMLCanvasElement && this.canvas instanceof HTMLCanvasElement ? this.canvas.remove() : this.canvas = null, null != this.fromPixels2DContext && this.fromPixels2DContext.canvas.remove && this.fromPixels2DContext.canvas.remove(), this.gpgpuCreatedLocally && (this.gpgpu.program = null, this.gpgpu.dispose()), this.disposed = !0);\n        }, e.prototype.floatPrecision = function () {\n          var t = this;\n          return null == this.floatPrecisionValue && (this.floatPrecisionValue = Ue(function () {\n            if (!h().get(\"WEBGL_RENDER_FLOAT32_ENABLED\")) {\n              var e = h().getBool(\"DEBUG\");\n              h().set(\"DEBUG\", !1);\n              var n = t.abs(pn(1e-8)).dataSync()[0];\n              if (h().set(\"DEBUG\", e), n > 0) return 32;\n            }\n\n            return 16;\n          })), this.floatPrecisionValue;\n        }, e.prototype.epsilon = function () {\n          return 32 === this.floatPrecision() ? 1e-7 : 1e-4;\n        }, e.prototype.uploadToGPU = function (t) {\n          var e,\n              n = this.texData.get(t),\n              r = n.shape,\n              o = n.dtype,\n              i = n.values,\n              a = n.texture,\n              s = n.usage,\n              u = n.isPacked;\n\n          if (null == a) {\n            var c,\n                l = null != this.activeTimers;\n            l && (c = et());\n            var h = n.texShape;\n\n            if (null == h && (h = ke(r, u), n.texShape = h), null != i) {\n              var p = Ae(r),\n                  f = void 0,\n                  d = h[1],\n                  m = h[0],\n                  g = i instanceof Uint8Array;\n              u ? (d = (e = Ht(h[0], h[1]))[0], m = e[1], f = new di(p, [m, d], g)) : f = new fi(p, [m, d], g);\n              var v = this.makeTensorInfo([m, d], o);\n              this.texData.get(v.dataId).usage = g ? Lt.PIXELS : Lt.UPLOAD, this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(v.dataId), d, m, i);\n              var y = this.runWebGLProgram(f, [v], o, null, !0),\n                  b = this.texData.get(y.dataId);\n              n.texture = b.texture, n.texShape = b.texShape, n.isPacked = b.isPacked, n.usage = b.usage, this.disposeData(v.dataId), this.texData.delete(y.dataId), n.values = null, l && (this.uploadWaitMs += et() - c);\n            } else {\n              var w = this.acquireTexture(h, s, o, u);\n              n.texture = w;\n            }\n          }\n        }, e.prototype.convertAndCacheOnCPU = function (t, e) {\n          var n = this.texData.get(t),\n              r = n.dtype;\n          return this.releaseGPUData(t), null != e && (n.values = function (t, e) {\n            if (\"float32\" === e || \"complex64\" === e) return t;\n\n            if (\"int32\" === e || \"bool\" === e) {\n              for (var n = \"int32\" === e ? new Int32Array(t.length) : new Uint8Array(t.length), r = 0; r < n.length; ++r) n[r] = Math.round(t[r]);\n\n              return n;\n            }\n\n            throw new Error(\"Unknown dtype \" + e);\n          }(e, r)), n.values;\n        }, e.prototype.acquireTexture = function (t, e, n, r) {\n          if (this.numBytesInGPU += this.computeBytes(t, n), !this.warnedAboutMemory && this.numBytesInGPU > 1024 * this.numMBBeforeWarning * 1024) {\n            var o = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n            this.warnedAboutMemory = !0, console.warn(\"High memory usage in GPU: \" + o + \" MB, most likely due to a memory leak\");\n          }\n\n          return this.textureManager.acquireTexture(t, e, r);\n        }, e.prototype.computeBytes = function (t, e) {\n          return t[0] * t[1] * U(e);\n        }, e;\n      }(Mr);\n\n      Ot() && Mt.registerBackend(\"webgl\", function () {\n        return new $a();\n      }, 2);\n      var Ka = an({\n        square_: function (t) {\n          var e = $e(t, \"x\", \"square\"),\n              n = [e];\n          return Mt.runKernelFunc(function (t, n) {\n            return n([e]), t.square(e);\n          }, {\n            x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              x: function () {\n                return t.mul(n.toFloat().mul(2));\n              }\n            };\n          }, \"Square\", {}, n, []);\n        }\n      }),\n          Qa = an({\n        abs_: function (t) {\n          var e = $e(t, \"x\", \"abs\");\n          return \"complex64\" === e.dtype ? Mt.runKernelFunc(function (t) {\n            return t.complexAbs(e);\n          }, {\n            $x: e\n          }) : Mt.runKernelFunc(function (t, n) {\n            var r = t.abs(e);\n            return n([e]), r;\n          }, {\n            x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              x: function () {\n                return t.mul(n.toFloat().step(-1));\n              }\n            };\n          }, \"Abs\");\n        }\n      }),\n          Xa = an({\n        acos_: function (t) {\n          var e = $e(t, \"x\", \"acos\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.acos(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.divStrict(pn(1).sub(n.toFloat().square()).sqrt()).neg();\n              }\n            };\n          });\n        }\n      }),\n          Ya = an({\n        acosh_: function (t) {\n          var e = $e(t, \"x\", \"acosh\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.acosh(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.divStrict(n.toFloat().square().sub(1).sqrt());\n              }\n            };\n          });\n        }\n      }),\n          Ja = an({\n        asin_: function (t) {\n          var e = $e(t, \"x\", \"asin\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.asin(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.divStrict(pn(1).sub(n.toFloat().square()).sqrt());\n              }\n            };\n          });\n        }\n      }),\n          Za = an({\n        asinh_: function (t) {\n          var e = $e(t, \"x\", \"asinh\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.asinh(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.divStrict(pn(1).add(n.toFloat().square()).sqrt());\n              }\n            };\n          });\n        }\n      }),\n          ts = an({\n        atan_: function (t) {\n          var e = $e(t, \"x\", \"atan\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.atan(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.div(n.toFloat().square().add(1));\n              }\n            };\n          });\n        }\n      }),\n          es = an({\n        atanh_: function (t) {\n          var e = $e(t, \"x\", \"atanh\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.atanh(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.div(pn(1).sub(n.toFloat().square()));\n              }\n            };\n          });\n        }\n      }),\n          ns = an({\n        ceil_: function (t) {\n          var e = $e(t, \"x\", \"ceil\");\n          return Mt.runKernelFunc(function (t) {\n            return t.ceil(e);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          rs = an({\n        clipByValue_: function (t, e, n) {\n          var r = $e(t, \"x\", \"clipByValue\");\n          return S(e <= n, function () {\n            return \"Error in clip: min (\" + e + \") must be less than or equal to max (\" + n + \").\";\n          }), Mt.runKernelFunc(function (t, o) {\n            var i = t.clip(r, e, n);\n            return o([r]), i;\n          }, {\n            $x: r\n          }, function (t, r) {\n            var o = r[0];\n            return {\n              $x: function () {\n                return t.where(o.greaterEqual(e).logicalAnd(o.lessEqual(n)), Sn(t));\n              }\n            };\n          });\n        }\n      }),\n          os = an({\n        cos_: function (t) {\n          var e = $e(t, \"x\", \"cos\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.cos(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return n.toFloat().sin().neg().mul(t);\n              }\n            };\n          });\n        }\n      }),\n          is = an({\n        cosh_: function (t) {\n          var e = $e(t, \"x\", \"cosh\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.cosh(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return n.toFloat().sinh().mulStrict(t);\n              }\n            };\n          });\n        }\n      }),\n          as = an({\n        erf_: function (t) {\n          var e = $e(t, \"x\", \"erf\");\n          return S(\"int32\" === e.dtype || \"float32\" === e.dtype, function () {\n            return \"Input dtype must be `int32` or `float32`.\";\n          }), \"int32\" === e.dtype && (e = e.toFloat()), Mt.runKernelFunc(function (t, n) {\n            var r = t.erf(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.mul(n.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));\n              }\n            };\n          });\n        }\n      }),\n          ss = an({\n        exp_: function (t) {\n          var e = $e(t, \"x\", \"exp\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.exp(e);\n            return n([r]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            return {\n              $x: function () {\n                return t.mulStrict(e[0]);\n              }\n            };\n          });\n        }\n      }),\n          us = an({\n        expm1_: function (t) {\n          var e = $e(t, \"x\", \"expm1\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.expm1(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.mul(n.exp());\n              }\n            };\n          });\n        }\n      }),\n          cs = an({\n        floor_: function (t) {\n          var e = $e(t, \"x\", \"floor\");\n          return Mt.runKernelFunc(function (t) {\n            return t.floor(e);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          ls = an({\n        log_: function (t) {\n          var e = $e(t, \"x\", \"log\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.log(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.div(n.toFloat());\n              }\n            };\n          });\n        }\n      }),\n          hs = an({\n        log1p_: function (t) {\n          var e = $e(t, \"x\", \"log1p\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.log1p(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.div(n.add(1));\n              }\n            };\n          });\n        }\n      }),\n          ps = an({\n        logSigmoid_: function (t) {\n          var e = $e(t, \"x\", \"logSigmoid\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.softplus(e.neg()).neg();\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.mul(n.neg().sigmoid());\n              }\n            };\n          });\n        }\n      }),\n          fs = an({\n        neg_: function (t) {\n          var e = $e(t, \"x\", \"neg\");\n          return Mt.runKernelFunc(function (t) {\n            return t.neg(e);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return t.neg();\n              }\n            };\n          });\n        }\n      }),\n          ds = an({\n        reciprocal_: function (t) {\n          var e = $e(t, \"x\", \"reciprocal\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.reciprocal(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.div(n.square().neg());\n              }\n            };\n          });\n        }\n      }),\n          ms = an({\n        round_: function (t) {\n          var e = $e(t, \"x\", \"round\");\n          return Mt.runKernelFunc(function (t) {\n            return t.round(e);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          gs = an({\n        rsqrt_: function (t) {\n          var e = $e(t, \"x\", \"rsqrt\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.rsqrt(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.div(n.pow(1.5).mul(2)).neg();\n              }\n            };\n          });\n        }\n      }),\n          vs = an({\n        sigmoid_: function (t) {\n          var e = $e(t, \"x\", \"sigmoid\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.sigmoid(e);\n            return n([r]), r;\n          }, {\n            x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              x: function () {\n                return t.mul(n.mul(pn(1).sub(n)));\n              }\n            };\n          }, \"Sigmoid\");\n        }\n      }),\n          ys = an({\n        sign_: function (t) {\n          var e = $e(t, \"x\", \"sign\");\n          return Mt.runKernelFunc(function (t) {\n            return t.sign(e);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          bs = an({\n        isNaN_: function (t) {\n          var e = $e(t, \"x\", \"isNaN\");\n          return Mt.runKernelFunc(function (t) {\n            return t.isNaN(e);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          ws = an({\n        isInf_: function (t) {\n          var e = $e(t, \"x\", \"isInf\");\n          return Mt.runKernelFunc(function (t) {\n            return t.isInf(e);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          xs = an({\n        isFinite_: function (t) {\n          var e = $e(t, \"x\", \"isFinite\");\n          return Mt.runKernelFunc(function (t) {\n            return t.isFinite(e);\n          }, {\n            $x: e\n          }, function (t) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          Ss = an({\n        sin_: function (t) {\n          var e = $e(t, \"x\", \"sin\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.sin(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return n.toFloat().cos().mul(t);\n              }\n            };\n          });\n        }\n      }),\n          Es = an({\n        sinh_: function (t) {\n          var e = $e(t, \"x\", \"sinh\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.sinh(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return n.toFloat().cosh().mulStrict(t);\n              }\n            };\n          });\n        }\n      }),\n          Cs = an({\n        softplus_: function (t) {\n          var e = $e(t, \"x\", \"softplus\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.softplus(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.mul(n.sigmoid());\n              }\n            };\n          });\n        }\n      }),\n          Is = an({\n        sqrt_: function (t) {\n          var e = $e(t, \"x\", \"sqrt\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.sqrt(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.div(n.toFloat().sqrt().mul(2));\n              }\n            };\n          });\n        }\n      }),\n          As = an({\n        step_: function (t, e) {\n          void 0 === e && (e = 0);\n          var n = $e(t, \"x\", \"step\");\n          return Mt.runKernelFunc(function (t) {\n            return t.step(n, e);\n          }, {\n            $x: n\n          }, function (t) {\n            return {\n              $x: function () {\n                return Sn(t);\n              }\n            };\n          });\n        }\n      }),\n          ks = an({\n        tan_: function (t) {\n          var e = $e(t, \"x\", \"tan\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.tan(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.div(n.cos().square());\n              }\n            };\n          });\n        }\n      }),\n          Ts = an({\n        tanh_: function (t) {\n          var e = $e(t, \"x\", \"tanh\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.tanh(e);\n            return n([r]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return pn(1).sub(n.square()).mulStrict(t);\n              }\n            };\n          });\n        }\n      });\n\n      function Ns(t, e, n, r, o, i) {\n        var a,\n            s,\n            u = $e(t, \"x\", \"batchNorm\"),\n            c = $e(e, \"mean\", \"batchNorm\"),\n            l = $e(n, \"variance\", \"batchNorm\");\n        return null != o && (a = $e(o, \"scale\", \"batchNorm\")), null != r && (s = $e(r, \"offset\", \"batchNorm\")), S(2 === u.rank, function () {\n          return \"Error in batchNorm3D: x must be rank 3 but got rank \" + u.rank + \".\";\n        }), S(2 === c.rank || 1 === c.rank, function () {\n          return \"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank \" + c.rank + \".\";\n        }), S(2 === l.rank || 1 === l.rank, function () {\n          return \"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank \" + l.rank + \".\";\n        }), null != a && S(2 === a.rank || 1 === a.rank, function () {\n          return \"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank \" + a.rank + \".\";\n        }), null != s && S(2 === s.rank || 1 === s.rank, function () {\n          return \"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank \" + s.rank + \".\";\n        }), _s(u, c, l, s, a, i);\n      }\n\n      function Ps(t, e, n, r, o, i) {\n        var a,\n            s,\n            u = $e(t, \"x\", \"batchNorm\"),\n            c = $e(e, \"mean\", \"batchNorm\"),\n            l = $e(n, \"variance\", \"batchNorm\");\n        return null != o && (a = $e(o, \"scale\", \"batchNorm\")), null != r && (s = $e(r, \"offset\", \"batchNorm\")), S(3 === u.rank, function () {\n          return \"Error in batchNorm3D: x must be rank 3 but got rank \" + u.rank + \".\";\n        }), S(3 === c.rank || 1 === c.rank, function () {\n          return \"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank \" + c.rank + \".\";\n        }), S(3 === l.rank || 1 === l.rank, function () {\n          return \"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank \" + l.rank + \".\";\n        }), null != a && S(3 === a.rank || 1 === a.rank, function () {\n          return \"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank \" + a.rank + \".\";\n        }), null != s && S(3 === s.rank || 1 === s.rank, function () {\n          return \"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank \" + s.rank + \".\";\n        }), _s(u, c, l, s, a, i);\n      }\n\n      function Rs(t, e, n, r, o, i) {\n        var a,\n            s,\n            u = $e(t, \"x\", \"batchNorm\"),\n            c = $e(e, \"mean\", \"batchNorm\"),\n            l = $e(n, \"variance\", \"batchNorm\");\n        return null != o && (a = $e(o, \"scale\", \"batchNorm\")), null != r && (s = $e(r, \"offset\", \"batchNorm\")), S(4 === u.rank, function () {\n          return \"Error in batchNorm4D: x must be rank 4 but got rank \" + u.rank + \".\";\n        }), S(4 === c.rank || 1 === c.rank, function () {\n          return \"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank \" + c.rank + \".\";\n        }), S(4 === l.rank || 1 === l.rank, function () {\n          return \"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank \" + l.rank + \".\";\n        }), null != a && S(4 === a.rank || 1 === a.rank, function () {\n          return \"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank \" + a.rank + \".\";\n        }), null != s && S(4 === s.rank || 1 === s.rank, function () {\n          return \"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank \" + s.rank + \".\";\n        }), _s(u, c, l, s, a, i);\n      }\n\n      function _s(t, e, n, r, o, i) {\n        null == i && (i = .001);\n        var a,\n            s,\n            u,\n            c = $e(t, \"x\", \"batchNorm\"),\n            l = $e(e, \"mean\", \"batchNorm\"),\n            h = $e(n, \"variance\", \"batchNorm\");\n        null != o && (a = $e(o, \"scale\", \"batchNorm\")), null != r && (s = $e(r, \"offset\", \"batchNorm\")), S(l.rank === h.rank, function () {\n          return \"Batch normalization gradient requires mean and variance to have equal ranks.\";\n        }), S(null == s || l.rank === s.rank, function () {\n          return \"Batch normalization gradient requires mean and offset to have equal ranks.\";\n        }), S(null == a || l.rank === a.rank, function () {\n          return \"Batch normalization gradient requires mean and scale to have equal ranks.\";\n        }), u = 0 === c.rank || 1 === c.rank ? c.as4D(1, 1, 1, c.size) : 2 === c.rank ? c.as4D(1, 1, c.shape[0], c.shape[1]) : 3 === c.rank ? c.as4D(1, c.shape[0], c.shape[1], c.shape[2]) : c;\n        var p = [c, l, h, a];\n        return Mt.runKernelFunc(function (t, e) {\n          var n = t.batchNormalization(u, Ms(l), Ms(h), i, Ms(a), Ms(s));\n          return e([c, l, h, a]), n;\n        }, {\n          x: c,\n          mean: l,\n          variance: h,\n          scale: a,\n          offset: s\n        }, function (t, e) {\n          var n = e,\n              r = n[0],\n              o = n[1],\n              a = n[2],\n              s = n[3],\n              c = null == s ? pn(1) : s,\n              l = Fr(o.shape, u.shape),\n              h = [];\n\n          if (1 === o.rank) {\n            for (var p = 0; p < u.shape.length - 1; ++p) h.push(u.shape[p]);\n\n            h.push(1);\n          }\n\n          var f = r.sub(o),\n              d = t.mul(c),\n              m = gs(a.add(pn(i))),\n              g = m.mul(m).mul(m).mul(pn(-.5));\n          return {\n            x: function () {\n              return 1 === o.rank ? t.mul(lr(m.as4D(1, 1, 1, o.shape[0]), h)).mul(c).reshape(r.shape) : t.mul(m).mul(c).reshape(r.shape);\n            },\n            mean: function () {\n              var t = m.mul(pn(-1)).mul(d);\n              return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);\n            },\n            variance: function () {\n              var t = g.mul(f).mul(d);\n              return 1 === o.rank && (t = t.sum(l)), t.reshape(o.shape);\n            },\n            scale: function () {\n              var e = f.mul(m),\n                  n = t.mul(e);\n              return 1 === o.rank && (n = n.sum(l)), n.reshape(o.shape);\n            },\n            offset: function () {\n              var e = t;\n              return 1 === o.rank && (e = e.sum(l)), e.reshape(o.shape);\n            }\n          };\n        }, \"BatchNormalization\", {\n          varianceEpsilon: i\n        }, p).reshape(c.shape);\n      }\n\n      function Ms(t) {\n        return null == t ? null : 0 === t.rank ? t.as1D() : 1 === t.rank ? t : 2 === t.rank ? t.as4D(1, 1, t.shape[0], t.shape[1]) : 3 === t.rank ? t.as4D(1, t.shape[0], t.shape[1], t.shape[2]) : t;\n      }\n\n      function Os() {\n        Ve(\"tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon\");\n      }\n\n      var Ds = an({\n        batchNormalization2d_: function (t, e, n, r, o, i) {\n          return void 0 === r && (r = .001), Os(), Ns(t, e, n, i, o, r);\n        }\n      }),\n          Fs = an({\n        batchNormalization3d_: function (t, e, n, r, o, i) {\n          return void 0 === r && (r = .001), Os(), Ps(t, e, n, i, o, r);\n        }\n      }),\n          Ls = an({\n        batchNormalization4d_: function (t, e, n, r, o, i) {\n          return void 0 === r && (r = .001), Os(), Rs(t, e, n, i, o, r);\n        }\n      }),\n          Bs = an({\n        batchNormalization_: function (t, e, n, r, o, i) {\n          return void 0 === r && (r = .001), Os(), _s(t, e, n, i, o, r);\n        }\n      }),\n          zs = an({\n        batchNorm_: _s\n      }),\n          qs = an({\n        batchNorm2d_: Ns\n      }),\n          Vs = an({\n        batchNorm3d_: Ps\n      }),\n          Us = an({\n        batchNorm4d_: Rs\n      }),\n          js = an({\n        logicalAnd_: function (t, e) {\n          var n = $e(t, \"a\", \"logicalAnd\", \"bool\"),\n              r = $e(e, \"b\", \"logicalAnd\", \"bool\");\n          return Lr(n.shape, r.shape), Mt.runKernelFunc(function (t) {\n            return t.logicalAnd(n, r);\n          }, {\n            $a: n,\n            $b: r\n          });\n        }\n      }),\n          Ws = an({\n        logicalNot_: function (t) {\n          var e = $e(t, \"x\", \"logicalNot\", \"bool\");\n          return Mt.runKernelFunc(function (t) {\n            return t.logicalNot(e);\n          }, {\n            $x: e\n          });\n        }\n      }),\n          Gs = an({\n        logicalOr_: function (t, e) {\n          var n = $e(t, \"a\", \"logicalOr\", \"bool\"),\n              r = $e(e, \"b\", \"logicalOr\", \"bool\");\n          return Lr(n.shape, r.shape), Mt.runKernelFunc(function (t) {\n            return t.logicalOr(n, r);\n          }, {\n            $a: n,\n            $b: r\n          });\n        }\n      }),\n          Hs = an({\n        logicalXor_: function (t, e) {\n          var n = $e(t, \"a\", \"logicalXor\", \"bool\"),\n              r = $e(e, \"b\", \"logicalXor\", \"bool\");\n          return Lr(n.shape, r.shape), Gs(t, e).logicalAnd(js(t, e).logicalNot());\n        }\n      }),\n          $s = an({\n        where_: function (t, e, n) {\n          var r = $e(e, \"a\", \"where\"),\n              o = $e(n, \"b\", \"where\"),\n              i = $e(t, \"condition\", \"where\", \"bool\");\n          return E(r.shape, o.shape, \"Error in where: \"), 1 === i.rank ? S(i.shape[0] === r.shape[0], function () {\n            return \"The first dimension of `a` must match the size of `condition`.\";\n          }) : E(i.shape, o.shape, \"Error in where: \"), Mt.runKernelFunc(function (t, e) {\n            var n = t.select(i, r, o);\n            return e([i]), n;\n          }, {\n            $condition: i,\n            $a: r,\n            $b: o\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $condition: function () {\n                return Sn(n).toFloat();\n              },\n              $a: function () {\n                return t.mul(n.cast(t.dtype));\n              },\n              $b: function () {\n                return t.mul(n.logicalNot().cast(t.dtype));\n              }\n            };\n          });\n        }\n      }),\n          Ks = function (t) {\n        return u(this, void 0, void 0, function () {\n          var e, n, r;\n          return c(this, function (o) {\n            switch (o.label) {\n              case 0:\n                return [4, (e = $e(t, \"condition\", \"whereAsync\", \"bool\")).data()];\n\n              case 1:\n                return n = o.sent(), r = uo(e.shape, n), t !== e && e.dispose(), [2, r];\n            }\n          });\n        });\n      },\n          Qs = an({\n        add_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"add\"),\n              o = $e(e, \"b\", \"add\");\n          n = kt(r, o), r = n[0], o = n[1];\n          var i = Lr(r.shape, o.shape);\n          return Mt.runKernelFunc(function (t) {\n            return t.add(r, o);\n          }, {\n            a: r,\n            b: o\n          }, function (t) {\n            return {\n              a: function () {\n                var e = t,\n                    n = Fr(r.shape, i);\n                return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);\n              },\n              b: function () {\n                var e = t,\n                    n = Fr(o.shape, i);\n                return n.length > 0 && (e = e.sum(n)), e.reshape(o.shape);\n              }\n            };\n          }, \"Add\");\n        }\n      }),\n          Xs = an({\n        addN_: function (t) {\n          S(Array.isArray(t), function () {\n            return \"The argument passed to tf.addN() must be a list of tensors\";\n          }), S(t.length >= 1, function () {\n            return \"Must pass at least one tensor to tf.addN(), but got \" + t.length;\n          });\n          var e = t.map(function (t, e) {\n            return $e(t, \"tensors\" + e, \"addN\");\n          }),\n              n = e[0];\n          e.forEach(function (t) {\n            if (t.dtype !== n.dtype) throw new Error(\"All tensors passed to tf.addN() must have the same dtype\");\n          }), e.forEach(function (t) {\n            if (!k(t.shape, n.shape)) throw new Error(\"All tensors passed to tf.addN() must have the same shape\");\n          });\n          var r = e;\n          return Mt.runKernelFunc(function (t) {\n            return t.addN(e);\n          }, r, function (t) {\n            var n = {};\n            return e.forEach(function (e, r) {\n              n[r] = function () {\n                return t.clone();\n              };\n            }), n;\n          });\n        }\n      }),\n          Ys = an({\n        addStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"addStrict\"),\n              r = $e(e, \"b\", \"addStrict\");\n          return E(n.shape, r.shape, \"Error in addStrict: \"), n.add(r);\n        }\n      }),\n          Js = an({\n        atan2_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"atan2\"),\n              o = $e(e, \"b\", \"atan2\");\n          n = kt(r, o), r = n[0], o = n[1];\n          var i = Lr(r.shape, o.shape);\n          return Mt.runKernelFunc(function (t, e) {\n            var n = t.atan2(r, o);\n            return e([r, o]), n;\n          }, {\n            $a: r,\n            $b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1];\n            return {\n              $a: function () {\n                var e = Qs(n.square(), r.square()),\n                    o = t.mul(r.div(e)),\n                    a = Fr(n.shape, i);\n                return a.length > 0 && (o = o.sum(a)), o.reshape(n.shape);\n              },\n              $b: function () {\n                var e = Qs(n.square(), r.square()),\n                    o = fs(t.mul(n.div(e))),\n                    a = Fr(r.shape, i);\n                return a.length > 0 && (o = o.sum(a)), o.reshape(r.shape);\n              }\n            };\n          });\n        }\n      }),\n          Zs = an({\n        div_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"div\"),\n              o = $e(e, \"b\", \"div\");\n          if (n = kt(r, o), r = n[0], o = n[1], \"int32\" === r.dtype && \"int32\" === o.dtype) return eu(r, o);\n          var i = Lr(r.shape, o.shape);\n          return Mt.runKernelFunc(function (t, e) {\n            var n = t.realDivide(r, o);\n            return e([r, o]), n;\n          }, {\n            a: r,\n            b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1];\n            return {\n              a: function () {\n                var e = t.div(r.toFloat()),\n                    o = Fr(n.shape, i);\n                return o.length > 0 ? e.sum(o).reshape(n.shape) : e;\n              },\n              b: function () {\n                var e = t.mul(n.toFloat()),\n                    o = Fr(r.shape, i);\n                o.length > 0 && (e = e.sum(o).reshape(r.shape));\n                var a = r.square();\n                return e.div(a.toFloat()).neg();\n              }\n            };\n          }, \"Div\");\n        }\n      }),\n          tu = an({\n        divStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"div\"),\n              r = $e(e, \"b\", \"div\");\n          return E(n.shape, r.shape, \"Error in divideStrict: \"), n.div(r);\n        }\n      }),\n          eu = an({\n        floorDiv_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"floorDiv\"),\n              o = $e(e, \"b\", \"floorDiv\");\n          n = kt(r, o), r = n[0], o = n[1];\n          var i = Lr(r.shape, o.shape);\n          return Mt.runKernelFunc(function (t, e) {\n            var n = t.floorDiv(r, o);\n            return e([r, o]), n;\n          }, {\n            $a: r,\n            $b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1];\n            return {\n              $a: function () {\n                var e = t.div(r.toFloat()),\n                    o = Fr(n.shape, i);\n                return o.length > 0 ? e.sum(o).reshape(n.shape) : e;\n              },\n              $b: function () {\n                var e = t.mul(n.toFloat()),\n                    o = Fr(r.shape, i);\n                o.length > 0 && (e = e.sum(o).reshape(r.shape));\n                var a = r.square();\n                return e.div(a.toFloat()).neg();\n              }\n            };\n          });\n        }\n      }),\n          nu = an({\n        maximum_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"maximum\"),\n              o = $e(e, \"b\", \"maximum\");\n          return n = kt(r, o), r = n[0], o = n[1], \"bool\" === r.dtype && (r = r.toInt(), o = o.toInt()), Lr(r.shape, o.shape), Mt.runKernelFunc(function (t, e) {\n            var n = t.maximum(r, o);\n            return e([r, o]), n;\n          }, {\n            $a: r,\n            $b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1];\n            return {\n              $a: function () {\n                return t.mul(n.greaterEqual(r).toFloat());\n              },\n              $b: function () {\n                return t.mul(n.less(r).toFloat());\n              }\n            };\n          });\n        }\n      }),\n          ru = an({\n        maximumStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"maximumStrict\"),\n              r = $e(e, \"b\", \"maximumStrict\");\n          return E(n.shape, r.shape, \"Error in maximumStrict: \"), n.maximum(r);\n        }\n      }),\n          ou = an({\n        minimum_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"minimum\"),\n              o = $e(e, \"b\", \"minimum\");\n          return n = kt(r, o), r = n[0], o = n[1], \"bool\" === r.dtype && (r = r.toInt(), o = o.toInt()), Lr(r.shape, o.shape), Mt.runKernelFunc(function (t, e) {\n            var n = t.minimum(r, o);\n            return e([r, o]), n;\n          }, {\n            $a: r,\n            $b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1];\n            return {\n              $a: function () {\n                return t.mul(n.lessEqual(r).toFloat());\n              },\n              $b: function () {\n                return t.mul(n.greater(r).toFloat());\n              }\n            };\n          });\n        }\n      }),\n          iu = an({\n        minimumStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"minimumStrict\"),\n              r = $e(e, \"b\", \"minimumStrict\");\n          return E(n.shape, r.shape, \"Error in minimumStrict: \"), n.minimum(r);\n        }\n      }),\n          au = an({\n        mod_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"mod\"),\n              o = $e(e, \"b\", \"mod\");\n          n = kt(r, o), r = n[0], o = n[1];\n          var i = Lr(r.shape, o.shape);\n          return Mt.runKernelFunc(function (t, e) {\n            var n = t.mod(r, o);\n            return e([r, o]), n;\n          }, {\n            $a: r,\n            $b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1];\n            return {\n              $a: function () {\n                var e = Fr(n.shape, i);\n                return e.length > 0 ? t.sum(e).reshape(n.shape) : t;\n              },\n              $b: function () {\n                var e = t.mul(n.div(r).floor().neg()),\n                    o = Fr(r.shape, i);\n                return o.length > 0 ? e.sum(o).reshape(r.shape) : e;\n              }\n            };\n          });\n        }\n      }),\n          su = an({\n        modStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"modStrict\"),\n              r = $e(e, \"b\", \"modStrict\");\n          return E(n.shape, r.shape, \"Error in modStrict: \"), n.mod(r);\n        }\n      }),\n          uu = an({\n        mul_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"mul\"),\n              o = $e(e, \"b\", \"mul\");\n          n = kt(r, o), r = n[0], o = n[1];\n          var i = Lr(r.shape, o.shape);\n          return Mt.runKernelFunc(function (t, e) {\n            var n = t.multiply(r, o);\n            return e([r, o]), n;\n          }, {\n            a: r,\n            b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1];\n            return {\n              a: function () {\n                var e = t.mul(r.toFloat()),\n                    o = Fr(n.shape, i);\n                return o.length > 0 ? e.sum(o).reshape(n.shape) : e;\n              },\n              b: function () {\n                var e = t.mul(n.toFloat()),\n                    o = Fr(r.shape, i);\n                return o.length > 0 ? e.sum(o).reshape(r.shape) : e;\n              }\n            };\n          }, \"Mul\");\n        }\n      }),\n          cu = an({\n        mulStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"mul\"),\n              r = $e(e, \"b\", \"mul\");\n          return E(n.shape, r.shape, \"Error in multiplyStrict: \"), n.mul(r);\n        }\n      }),\n          lu = an({\n        pow_: function (t, e) {\n          var n = $e(t, \"base\", \"pow\"),\n              r = $e(e, \"exp\", \"pow\"),\n              o = Lr(n.shape, r.shape);\n          return t = n.cast(It(n.dtype, r.dtype)), e = r.cast(It(n.dtype, r.dtype)), Mt.runKernelFunc(function (t, e) {\n            var o = t.pow(n, r);\n            return e([n, r, o]), o;\n          }, {\n            $base: n,\n            $exp: r\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1],\n                i = e[2];\n            return {\n              $base: function () {\n                var e = r.toFloat(),\n                    i = t.mul(e.mul(n.pow(e.sub(pn(1))))),\n                    a = Fr(n.shape, o);\n                return a.length > 0 && (i = i.sum(a)), i.reshape(n.shape);\n              },\n              $exp: function () {\n                var e = n.greater(0),\n                    a = n.log().where(e, Sn(n)),\n                    s = t.mul(i.mul(a)),\n                    u = Fr(r.shape, o);\n                return u.length > 0 && (s = s.sum(u)), s.reshape(r.shape);\n              }\n            };\n          });\n        }\n      }),\n          hu = an({\n        powStrict_: function (t, e) {\n          return E(t.shape, e.shape, \"Error in powStrict: \"), t.pow(e);\n        }\n      }),\n          pu = an({\n        squaredDifference_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"squaredDifference\"),\n              o = $e(e, \"b\", \"squaredDifference\");\n          return n = kt(r, o), r = n[0], o = n[1], Lr(r.shape, o.shape), Mt.runKernelFunc(function (t, e) {\n            var n = t.squaredDifference(r, o);\n            return e([r, o]), n;\n          }, {\n            $a: r,\n            $b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1],\n                o = pn(2);\n            return {\n              $a: function () {\n                return t.mul(n.sub(r).mul(o));\n              },\n              $b: function () {\n                return t.mul(r.sub(n).mul(o));\n              }\n            };\n          });\n        }\n      }),\n          fu = an({\n        squaredDifferenceStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"squaredDifferenceStrict\"),\n              r = $e(e, \"b\", \"squaredDifferenceStrict\");\n          return E(n.shape, r.shape, \"Error in squaredDifferenceStrict: \"), n.squaredDifference(r);\n        }\n      }),\n          du = an({\n        sub_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"sub\"),\n              o = $e(e, \"b\", \"sub\");\n          n = kt(r, o), r = n[0], o = n[1];\n          var i = Lr(r.shape, o.shape);\n          return Mt.runKernelFunc(function (t) {\n            return t.subtract(r, o);\n          }, {\n            a: r,\n            b: o\n          }, function (t) {\n            return {\n              a: function () {\n                var e = t,\n                    n = Fr(r.shape, i);\n                return n.length > 0 && (e = e.sum(n)), e.reshape(r.shape);\n              },\n              b: function () {\n                var e = t,\n                    n = Fr(o.shape, i);\n                return n.length > 0 && (e = e.sum(n)), e.neg().reshape(o.shape);\n              }\n            };\n          }, \"Sub\");\n        }\n      }),\n          mu = an({\n        subStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"subStrict\"),\n              r = $e(e, \"b\", \"subStrict\");\n          return E(n.shape, r.shape, \"Error in subStrict: \"), n.sub(r);\n        }\n      }),\n          gu = an({\n        equal_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"equal\"),\n              o = $e(e, \"b\", \"equal\");\n          return n = kt(r, o), r = n[0], o = n[1], Lr(r.shape, o.shape), Mt.runKernelFunc(function (t) {\n            return t.equal(r, o);\n          }, {\n            $a: r,\n            $b: o\n          });\n        }\n      }),\n          vu = an({\n        equalStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"equalStrict\"),\n              r = $e(e, \"b\", \"equalStrict\");\n          return E(n.shape, r.shape, \"Error in equalStrict: \"), n.equal(r);\n        }\n      }),\n          yu = an({\n        greater_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"greater\"),\n              o = $e(e, \"b\", \"greater\");\n          return n = kt(r, o), r = n[0], o = n[1], Lr(r.shape, o.shape), Mt.runKernelFunc(function (t) {\n            return t.greater(r, o);\n          }, {\n            $a: r,\n            $b: o\n          });\n        }\n      }),\n          bu = an({\n        greaterEqual_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"greaterEqual\"),\n              o = $e(e, \"b\", \"greaterEqual\");\n          return n = kt(r, o), r = n[0], o = n[1], Lr(r.shape, o.shape), Mt.runKernelFunc(function (t, e) {\n            var n = t.greaterEqual(r, o);\n            return e([r, o]), n;\n          }, {\n            $a: r,\n            $b: o\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1];\n            return {\n              $a: function () {\n                return Sn(n);\n              },\n              $b: function () {\n                return Sn(r);\n              }\n            };\n          });\n        }\n      }),\n          wu = an({\n        greaterEqualStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"greaterEqualStrict\"),\n              r = $e(e, \"b\", \"greaterEqualStrict\");\n          return E(n.shape, r.shape, \"Error in greaterEqualStrict: \"), n.greaterEqual(r);\n        }\n      }),\n          xu = an({\n        greaterStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"greaterStrict\"),\n              r = $e(e, \"b\", \"greaterStrict\");\n          return E(n.shape, r.shape, \"Error in greaterStrict: \"), n.greater(r);\n        }\n      }),\n          Su = an({\n        less_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"less\"),\n              o = $e(e, \"b\", \"less\");\n          return n = kt(r, o), r = n[0], o = n[1], Lr(r.shape, o.shape), Mt.runKernelFunc(function (t) {\n            return t.less(r, o);\n          }, {\n            $a: r,\n            $b: o\n          });\n        }\n      }),\n          Eu = an({\n        lessEqual_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"lessEqual\"),\n              o = $e(e, \"b\", \"lessEqual\");\n          return n = kt(r, o), r = n[0], o = n[1], Lr(r.shape, o.shape), Mt.runKernelFunc(function (t) {\n            return t.lessEqual(r, o);\n          }, {\n            $a: r,\n            $b: o\n          });\n        }\n      }),\n          Cu = an({\n        lessEqualStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"lessEqualStrict\"),\n              r = $e(e, \"b\", \"lessEqualStrict\");\n          return E(n.shape, r.shape, \"Error in lessEqualStrict: \"), n.lessEqual(r);\n        }\n      }),\n          Iu = an({\n        lessStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"lessStrict\"),\n              r = $e(e, \"b\", \"lessStrict\");\n          return E(n.shape, r.shape, \"Error in lessStrict: \"), n.less(r);\n        }\n      }),\n          Au = an({\n        notEqual_: function (t, e) {\n          var n,\n              r = $e(t, \"a\", \"notEqual\"),\n              o = $e(e, \"b\", \"notEqual\");\n          return n = kt(r, o), r = n[0], o = n[1], Lr(r.shape, o.shape), Mt.runKernelFunc(function (t) {\n            return t.notEqual(r, o);\n          }, {\n            $a: r,\n            $b: o\n          });\n        }\n      }),\n          ku = an({\n        notEqualStrict_: function (t, e) {\n          var n = $e(t, \"a\", \"notEqualStrict\"),\n              r = $e(e, \"b\", \"notEqualStrict\");\n          return E(n.shape, r.shape, \"Error in notEqualStrict: \"), n.notEqual(r);\n        }\n      });\n\n      function Tu(t, e) {\n        for (var n = [], r = t; r < e; ++r) n.push(r);\n\n        return n;\n      }\n\n      function Nu(t) {\n        for (var e = [], n = 0; n < t.length; ++n) for (var r = 0; r < t[n].length; ++r) e.push(t[n][r]);\n\n        return e;\n      }\n\n      var Pu = an({\n        gather_: function (t, e, n) {\n          void 0 === n && (n = 0);\n          var r = $e(t, \"x\", \"gather\"),\n              o = $e(e, \"indices\", \"gather\", \"int32\");\n          n = O(n, r.shape)[0];\n\n          var i = function (t, e, n) {\n            for (var r = t.shape[n], o = [], i = 1, a = 1, s = 0; s < n; s++) o.push(t.shape[s]), i *= t.shape[s];\n\n            for (s = 0; s < e.rank; s++) o.push(e.shape[s]);\n\n            for (s = n + 1; s < t.rank; s++) o.push(t.shape[s]), a *= t.shape[s];\n\n            return {\n              batchSize: i,\n              sliceSize: a,\n              dimSize: r,\n              outputShape: o\n            };\n          }(r, o, n);\n\n          return Mt.runKernelFunc(function (t, e) {\n            var i = t.gather(r, o.flatten(), n);\n            return e([o]), i;\n          }, {\n            $x: r\n          }, function (t, e) {\n            var o = e[0];\n            return {\n              $x: function () {\n                var e = r.shape,\n                    i = o.size,\n                    a = e.slice(0, n),\n                    s = a.length,\n                    u = e.slice(n, e.length).slice(1),\n                    c = u.length,\n                    l = Tu(0, s),\n                    h = Tu(s + 1, s + 1 + c),\n                    p = Nu([a, [i], u]),\n                    f = t.reshape(p),\n                    d = o.reshape([i]),\n                    m = Nu([[s], l, h]),\n                    g = f.transpose(m),\n                    v = Ru(g, d, r.shape[n]),\n                    y = en(m);\n                return v.transpose(y);\n              }\n            };\n          }).reshape(i.outputShape);\n        }\n      }),\n          Ru = an({\n        unsortedSegmentSum_: function (t, e, n) {\n          var r = $e(t, \"x\", \"unsortedSegmentSum\"),\n              o = $e(e, \"segmentIds\", \"unsortedSegmentSum\", \"int32\");\n          return S(T(n), function () {\n            return \"numSegments must be of dtype int\";\n          }), Mt.runKernelFunc(function (t, e) {\n            var i = t.unsortedSegmentSum(r, o, n);\n            return e([o]), i;\n          }, {\n            $x: r\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return function (t, e) {\n                  for (var n = nu(e, Sn(e)), r = Pu(t, n), o = bu(e, pn(0, \"int32\")), i = r.rank - o.rank, a = 0; a < i; ++a) o = $n(o, a + 1);\n\n                  o = js(o, vn(r.shape, \"bool\"));\n                  var s = Sn(r);\n                  return $s(o, r, s);\n                }(t, n);\n              }\n            };\n          });\n        }\n      });\n\n      function _u(t, e, n, r, o, i, a) {\n        void 0 === i && (i = \"NHWC\"), S(t.length === e.rank, function () {\n          return \"Length of inShape (\" + t.length + \") and rank of dy (\" + e.rank + \") must match\";\n        });\n        var s = t,\n            u = e,\n            c = !1;\n        3 === e.rank && (c = !0, u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]), s = [1, t[0], t[1], t[2]]), S(4 === s.length, function () {\n          return \"Error in conv2dDerInput: inShape must be length 4, but got length \" + s.length + \".\";\n        }), S(4 === u.rank, function () {\n          return \"Error in conv2dDerInput: dy must be rank 4, but got rank \" + u.rank;\n        }), S(4 === n.rank, function () {\n          return \"Error in conv2dDerInput: filter must be rank 4, but got rank \" + n.rank;\n        });\n        var l = \"NHWC\" === i ? s[3] : s[1],\n            h = \"NHWC\" === i ? u.shape[3] : u.shape[1];\n        S(l === n.shape[2], function () {\n          return \"Error in conv2dDerInput: depth of input (\" + l + \") must match input depth for filter \" + n.shape[2] + \".\";\n        }), S(h === n.shape[3], function () {\n          return \"Error in conv2dDerInput: depth of output (\" + h + \") must match output depth for filter \" + n.shape[3] + \".\";\n        }), null != a && S(T(o), function () {\n          return \"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\";\n        });\n        var p = Qr(i),\n            f = qr(s, n.shape, r, 1, o, a, !1, p),\n            d = Mt.runKernelFunc(function (t, e) {\n          var r = t.conv2dDerInput(u, n, f);\n          return e([n, u]), r;\n        }, {\n          dy4D: u,\n          filter: n\n        }, function (t, e) {\n          var n = e[0],\n              s = e[1];\n          return {\n            dy4D: function () {\n              return Fu(t, n, r, o, i, 1, a);\n            },\n            filter: function () {\n              return Bu(t, s, n.shape, r, o, i, a);\n            }\n          };\n        });\n        return c ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n      }\n\n      function Mu(t) {\n        var e = function (t) {\n          return \"number\" == typeof t ? [t, t, t] : 2 === t.length ? [t[0], t[1], 1] : t;\n        }(t),\n            n = e[0],\n            r = e[1],\n            o = e[2];\n\n        return 1 === n && 1 === r && 1 === o;\n      }\n\n      function Ou(t, e, n, r, o) {\n        S(t.length === e.rank, function () {\n          return \"Length of inShape (\" + t.length + \") and rank of dy (\" + e.rank + \") must match\";\n        });\n        var i = t,\n            a = e,\n            s = !1;\n        4 === e.rank && (s = !0, a = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3]), i = [1, t[0], t[1], t[2], t[3]]);\n        var u = i[4],\n            c = a.shape[4];\n        S(5 === i.length, function () {\n          return \"Error in conv3dDerInput: inShape must be length 5, but got length \" + i.length + \".\";\n        }), S(5 === a.rank, function () {\n          return \"Error in conv3dDerInput: dy must be rank 5, but got rank \" + a.rank;\n        }), S(5 === n.rank, function () {\n          return \"Error in conv3dDerInput: filter must be rank 5, but got rank \" + n.rank;\n        }), S(u === n.shape[3], function () {\n          return \"Error in conv3dDerInput: depth of input (\" + u + \") must match input depth for filter \" + n.shape[3] + \".\";\n        }), S(c === n.shape[4], function () {\n          return \"Error in conv3dDerInput: depth of output (\" + c + \") must match output depth for filter \" + n.shape[4] + \".\";\n        });\n        var l = Vr(i, n.shape, r, 1, o),\n            h = Mt.runKernelFunc(function (t) {\n          return t.conv3dDerInput(a, n, l);\n        }, {\n          dy5D: a\n        });\n        return s ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n      }\n\n      var Du = an({\n        conv1d_: function (t, e, n, r, o, i, a) {\n          void 0 === o && (o = \"NWC\"), void 0 === i && (i = 1);\n          var s = $e(t, \"x\", \"conv1d\"),\n              u = $e(e, \"filter\", \"conv1d\"),\n              c = s,\n              l = !1;\n          2 === s.rank && (l = !0, c = s.as3D(1, s.shape[0], s.shape[1])), S(3 === c.rank, function () {\n            return \"Error in conv1d: input must be rank 3, but got rank \" + c.rank + \".\";\n          }), S(3 === u.rank, function () {\n            return \"Error in conv1d: filter must be rank 3, but got rank \" + u.rank + \".\";\n          }), null != a && S(T(r), function () {\n            return \"Error in conv1d: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + r + \".\";\n          }), S(c.shape[2] === u.shape[1], function () {\n            return \"Error in conv1d: depth of input (\" + c.shape[2] + \") must match input depth for filter \" + u.shape[1] + \".\";\n          }), S(Kr(n, i), function () {\n            return \"Error in conv1D: Either stride or dilation must be 1. Got stride \" + n + \" and dilation '\" + i + \"'\";\n          }), S(\"NWC\" === o, function () {\n            return \"Error in conv1d: got dataFormat of \" + o + \" but only NWC is currently supported.\";\n          });\n          var h = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),\n              p = c.as4D(c.shape[0], 1, c.shape[1], c.shape[2]),\n              f = Fu(p, h, [1, n], r, \"NHWC\", [1, i], a);\n          return l ? f.as2D(f.shape[2], f.shape[3]) : f.as3D(f.shape[0], f.shape[2], f.shape[3]);\n        }\n      }),\n          Fu = an({\n        conv2d_: function (t, e, n, r, o, i, a) {\n          void 0 === o && (o = \"NHWC\"), void 0 === i && (i = [1, 1]);\n          var s = $e(t, \"x\", \"conv2d\"),\n              u = $e(e, \"filter\", \"conv2d\"),\n              c = s,\n              l = !1;\n          3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), S(4 === c.rank, function () {\n            return \"Error in conv2d: input must be rank 4, but got rank \" + c.rank + \".\";\n          }), S(4 === u.rank, function () {\n            return \"Error in conv2d: filter must be rank 4, but got rank \" + u.rank + \".\";\n          }), null != a && S(T(r), function () {\n            return \"Error in conv2d: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + r + \".\";\n          });\n          var h = \"NHWC\" === o ? c.shape[3] : c.shape[1];\n          S(h === u.shape[2], function () {\n            return \"Error in conv2d: depth of input (\" + h + \") must match input depth for filter \" + u.shape[2] + \".\";\n          }), S(Kr(n, i), function () {\n            return \"Error in conv2D: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + i + \"'\";\n          });\n          var p = Qr(o),\n              f = qr(c.shape, u.shape, n, i, r, a, !1, p),\n              d = Mt.runKernelFunc(function (t, e) {\n            var n = t.conv2d(c, u, f);\n            return e([u, c]), n;\n          }, {\n            x: c,\n            $filter: u\n          }, function (t, e) {\n            var a = e,\n                s = a[0],\n                u = a[1];\n            return S($r(i), function () {\n              return \"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + i + \"'\";\n            }), {\n              x: function () {\n                return zu(u.shape, t, s, n, r, o);\n              },\n              $filter: function () {\n                return Bu(u, t, s.shape, n, r, o);\n              }\n            };\n          });\n          return l ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n        }\n      }),\n          Lu = an({\n        conv3d_: function (t, e, n, r, o, i) {\n          void 0 === o && (o = \"NDHWC\"), void 0 === i && (i = [1, 1, 1]);\n          var a = $e(t, \"x\", \"conv3d\"),\n              s = $e(e, \"filter\", \"conv3d\"),\n              u = a,\n              c = !1;\n          4 === a.rank && (c = !0, u = a.as5D(1, a.shape[0], a.shape[1], a.shape[2], a.shape[3])), S(5 === u.rank, function () {\n            return \"Error in conv3d: input must be rank 5, but got rank \" + u.rank + \".\";\n          }), S(5 === s.rank, function () {\n            return \"Error in conv3d: filter must be rank 5, but got rank \" + s.rank + \".\";\n          }), S(u.shape[4] === s.shape[3], function () {\n            return \"Error in conv3d: depth of input (\" + u.shape[4] + \") must match input depth for filter \" + s.shape[3] + \".\";\n          }), S(function (t, e) {\n            return Mu(t) || Mu(e);\n          }(n, i), function () {\n            return \"Error in conv3D: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + i + \"'\";\n          }), S(\"NDHWC\" === o, function () {\n            return \"Error in conv3d: got dataFormat of \" + o + \" but only NDHWC is currently supported.\";\n          });\n          var l = Vr(u.shape, s.shape, n, i, r),\n              h = Mt.runKernelFunc(function (t, e) {\n            var n = t.conv3d(u, s, l);\n            return e([u, s]), n;\n          }, {\n            x: u,\n            $filter: s\n          }, function (t, e) {\n            S(Mu(i), function () {\n              return \"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + i + \"'\";\n            });\n            var o = e[0],\n                a = e[1];\n            return {\n              x: function () {\n                return Ou(o.shape, t, a, n, r);\n              },\n              $filter: function () {\n                return function (t, e, n, r, o) {\n                  var i = t;\n                  4 === t.rank && (i = t.as5D(1, t.shape[0], t.shape[1], t.shape[2], t.shape[3]));\n                  var a = e;\n                  4 === a.rank && (a = e.as5D(1, e.shape[0], e.shape[1], e.shape[2], e.shape[3])), S(5 === i.rank, function () {\n                    return \"Error in conv3dDerFilter: input must be rank 5, but got shape \" + i.shape + \".\";\n                  }), S(5 === a.rank, function () {\n                    return \"Error in conv3dDerFilter: dy must be rank 5, but got shape \" + a.shape + \".\";\n                  }), S(5 === n.length, function () {\n                    return \"Error in conv3dDerFilter: filterShape must be length 5, but got \" + n + \".\";\n                  }), S(i.shape[4] === n[3], function () {\n                    return \"Error in conv3dDerFilter: depth of input \" + i.shape[4] + \") must match input depth in filter (\" + n[3] + \".\";\n                  }), S(a.shape[4] === n[4], function () {\n                    return \"Error in conv3dDerFilter: depth of dy (\" + a.shape[4] + \") must match output depth for filter (\" + n[4] + \").\";\n                  });\n                  var s = Vr(i.shape, n, r, 1, o);\n                  return Mt.runKernelFunc(function (t) {\n                    return t.conv3dDerFilter(i, a, s);\n                  }, {\n                    x5D: i,\n                    dy5D: a\n                  });\n                }(o, t, a.shape, n, r);\n              }\n            };\n          });\n          return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n        }\n      }),\n          Bu = an({\n        conv2dDerFilter_: function (t, e, n, r, o, i, a) {\n          void 0 === i && (i = \"NHWC\");\n          var s = t;\n          3 === t.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));\n          var u = e;\n          3 === u.rank && (u = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), S(4 === s.rank, function () {\n            return \"Error in conv2dDerFilter: input must be rank 4, but got shape \" + s.shape + \".\";\n          }), S(4 === u.rank, function () {\n            return \"Error in conv2dDerFilter: dy must be rank 4, but got shape \" + u.shape + \".\";\n          }), S(4 === n.length, function () {\n            return \"Error in conv2dDerFilter: filterShape must be length 4, but got \" + n + \".\";\n          });\n          var c = \"NHWC\" === i ? s.shape[3] : s.shape[1],\n              l = \"NHWC\" === i ? u.shape[3] : u.shape[1];\n          S(c === n[2], function () {\n            return \"Error in conv2dDerFilter: depth of input \" + c + \") must match input depth in filter (\" + n[2] + \".\";\n          }), S(l === n[3], function () {\n            return \"Error in conv2dDerFilter: depth of dy (\" + l + \") must match output depth for filter (\" + n[3] + \").\";\n          }), null != a && S(T(o), function () {\n            return \"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\";\n          });\n          var h = Qr(i),\n              p = qr(s.shape, n, r, 1, o, a, !1, h);\n          return Mt.runKernelFunc(function (t) {\n            return t.conv2dDerFilter(s, u, p);\n          }, {\n            x4D: s,\n            dy4D: u\n          });\n        }\n      }),\n          zu = an({\n        conv2dDerInput_: _u\n      }),\n          qu = an({\n        depthwiseConv2d_: function (t, e, n, r, o, i, a) {\n          void 0 === o && (o = \"NHWC\"), void 0 === i && (i = [1, 1]);\n          var s = $e(t, \"x\", \"depthwiseConv2d\"),\n              u = $e(e, \"filter\", \"depthwiseConv2d\"),\n              c = s,\n              l = !1;\n          3 === s.rank && (l = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), S(4 === c.rank, function () {\n            return \"Error in depthwiseConv2d: input must be rank 4, but got rank \" + c.rank + \".\";\n          }), S(4 === u.rank, function () {\n            return \"Error in depthwiseConv2d: filter must be rank 4, but got rank \" + u.rank + \".\";\n          }), S(c.shape[3] === u.shape[2], function () {\n            return \"Error in depthwiseConv2d: number of input channels (\" + c.shape[3] + \") must match the inChannels dimension in filter \" + u.shape[2] + \".\";\n          }), null == i && (i = [1, 1]), S(Kr(n, i), function () {\n            return \"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + i + \"'\";\n          }), null != a && S(T(r), function () {\n            return \"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + r + \".\";\n          });\n          var h = qr(c.shape, u.shape, n, i, r, a, !0),\n              p = Mt.runKernelFunc(function (t, e) {\n            var n = t.depthwiseConv2D(c, u, h);\n            return e([c, u]), n;\n          }, {\n            x: c,\n            $filter: u\n          }, function (t, e) {\n            S($r(i), function () {\n              return \"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\" + i + \"'\";\n            });\n            var n = e[0],\n                r = e[1];\n            return {\n              x: function () {\n                return Vu(n.shape, t, r, h);\n              },\n              $filter: function () {\n                return Uu(n, t, r.shape, h);\n              }\n            };\n          });\n          return l ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;\n        }\n      }),\n          Vu = an({\n        depthwiseConv2dDerInput_: function (t, e, n, r) {\n          var o = e,\n              i = !1;\n          3 === e.rank && (i = !0, o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));\n          var a = Mt.runKernelFunc(function (t) {\n            return t.depthwiseConv2DDerInput(o, n, r);\n          }, {\n            dy4D: o\n          });\n          return i ? a.as3D(a.shape[1], a.shape[2], a.shape[3]) : a;\n        }\n      }),\n          Uu = an({\n        depthwiseConv2dDerFilter_: function (t, e, n, r) {\n          var o = t;\n          3 === t.rank && (o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));\n          var i = e;\n          return 3 === i.rank && (i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2])), Mt.runKernelFunc(function (t) {\n            return t.depthwiseConv2DDerFilter(o, i, r);\n          }, {\n            x4D: o,\n            dy4D: i\n          });\n        }\n      }),\n          ju = an({\n        separableConv2d_: function (t, e, n, r, o, i, a) {\n          void 0 === i && (i = [1, 1]), void 0 === a && (a = \"NHWC\");\n          var s = $e(t, \"x\", \"separableConv2d\"),\n              u = $e(e, \"depthwiseFilter\", \"separableConv2d\"),\n              c = $e(n, \"pointwiseFilter\", \"separableConv2d\"),\n              l = s,\n              h = !1;\n          if (3 === s.rank && (h = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), \"NCHW\" === a) throw new Error(\"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported\");\n          S(4 === l.rank, function () {\n            return \"Error in separableConv2d: input must be rank 4, but got rank \" + l.rank + \".\";\n          }), S(4 === u.rank, function () {\n            return \"Error in separableConv2d: depthwise filter must be rank 4, but got rank \" + u.rank + \".\";\n          }), S(4 === c.rank, function () {\n            return \"Error in separableConv2d: pointwise filter must be rank 4, but got rank \" + u.rank + \".\";\n          }), S(1 === c.shape[0], function () {\n            return \"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got \" + c.shape[0] + \".\";\n          }), S(1 === c.shape[1], function () {\n            return \"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got \" + c.shape[1] + \".\";\n          });\n          var p = u.shape[2],\n              f = u.shape[3];\n          S(c.shape[2] === p * f, function () {\n            return \"Error in separableConv2d: the third dimension of pointwise filter must be \" + p * f + \", but got \" + c.shape[2] + \".\";\n          });\n          var d = qu(l, u, r, o, a, i),\n              m = Fu(d, c, 1, \"valid\", a);\n          return h ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m;\n        }\n      }),\n          Wu = an({\n        conv2dTranspose_: function (t, e, n, r, o, i) {\n          return _u(n, $e(t, \"x\", \"conv2dTranspose\"), $e(e, \"filter\", \"conv2dTranspose\"), r, o, \"NHWC\", i);\n        }\n      }),\n          Gu = an({\n        conv3dTranspose_: function (t, e, n, r, o) {\n          return Ou(n, $e(t, \"x\", \"conv3dTranspose\"), $e(e, \"filter\", \"conv3dTranspose\"), r, o);\n        }\n      }),\n          Hu = an({\n        matMul_: function (t, e, n, r) {\n          var o;\n          void 0 === n && (n = !1), void 0 === r && (r = !1);\n          var i = $e(t, \"a\", \"matMul\"),\n              a = $e(e, \"b\", \"matMul\");\n          o = kt(i, a), i = o[0], a = o[1];\n          var s = n ? i.shape[i.rank - 2] : i.shape[i.rank - 1],\n              u = r ? a.shape[a.rank - 1] : a.shape[a.rank - 2],\n              c = n ? i.shape[i.rank - 1] : i.shape[i.rank - 2],\n              l = r ? a.shape[a.rank - 2] : a.shape[a.rank - 1],\n              h = i.shape.slice(0, -2),\n              p = a.shape.slice(0, -2),\n              f = A(h),\n              d = A(p);\n          S(i.rank >= 2 && a.rank >= 2 && i.rank === a.rank, function () {\n            return \"Error in matMul: inputs must have the same rank of at least 2, got ranks \" + i.rank + \" and \" + a.rank + \".\";\n          }), S(k(h, p), function () {\n            return \"Error in matMul: outer dimensions (\" + h + \") and (\" + p + \") of Tensors with shapes \" + i.shape + \" and \" + a.shape + \" must match.\";\n          }), S(s === u, function () {\n            return \"Error in matMul: inner shapes (\" + s + \") and (\" + u + \") of Tensors with shapes \" + i.shape + \" and \" + a.shape + \" and transposeA=\" + n + \" and transposeB=\" + r + \" must match.\";\n          });\n          var m = i.shape.slice(0, -2).concat([c, l]),\n              g = n ? i.as3D(f, s, c) : i.as3D(f, c, s),\n              v = r ? a.as3D(d, l, u) : a.as3D(d, u, l),\n              y = {\n            transposeA: n,\n            transposeB: r\n          };\n          return Mt.runKernelFunc(function (t, e) {\n            var o = t.batchMatMul(g, v, n, r);\n            return e([g, v]), o;\n          }, {\n            a: g,\n            b: v\n          }, function (t, e) {\n            var o = e,\n                i = o[0],\n                a = o[1];\n            return n || r ? !n && r ? {\n              a: function () {\n                return t.matMul(a, !1, !1);\n              },\n              b: function () {\n                return t.matMul(i, !0, !1);\n              }\n            } : n && !r ? {\n              a: function () {\n                return a.matMul(t, !1, !0);\n              },\n              b: function () {\n                return i.matMul(t, !1, !1);\n              }\n            } : {\n              a: function () {\n                return a.matMul(t, !0, !0);\n              },\n              b: function () {\n                return t.matMul(i, !0, !0);\n              }\n            } : {\n              a: function () {\n                return t.matMul(a, !1, !0);\n              },\n              b: function () {\n                return i.matMul(t, !0, !1);\n              }\n            };\n          }, \"BatchMatMul\", y).reshape(m);\n        }\n      }),\n          $u = an({\n        dot_: function (t, e) {\n          var n = $e(t, \"t1\", \"dot\"),\n              r = $e(e, \"t2\", \"dot\");\n          S(!(1 !== n.rank && 2 !== n.rank || 1 !== r.rank && 2 !== r.rank), function () {\n            return \"Error in dot: inputs must all be rank 1 or 2, but got ranks \" + n.rank + \" and \" + r.rank + \".\";\n          });\n          var o = 1 === n.rank ? n.size : n.shape[1],\n              i = 1 === r.rank ? r.size : r.shape[0];\n          return S(o === i, function () {\n            return \"Error in dot: inner dimensions of inputs must match, but got \" + o + \" and \" + i + \".\";\n          }), 1 === n.rank && 1 === r.rank ? n.as2D(1, -1).matMul(r.as2D(-1, 1)).asScalar() : 1 === n.rank && 2 === r.rank ? n.as2D(1, -1).matMul(r.as2D(r.shape[0], r.shape[1])).as1D() : 2 === n.rank && 1 === r.rank ? n.matMul(r.as2D(-1, 1)).as1D() : n.matMul(r.as2D(r.shape[0], r.shape[1]));\n        }\n      }),\n          Ku = an({\n        outerProduct_: function (t, e) {\n          var n = $e(t, \"v1\", \"outerProduct\"),\n              r = $e(e, \"v2\", \"outerProduct\");\n          return S(1 === n.rank && 1 === r.rank, function () {\n            return \"Error in outerProduct: inputs must be rank 1, but got ranks \" + n.rank + \" and \" + r.rank + \".\";\n          }), n.as2D(-1, 1).matMul(r.as2D(1, -1));\n        }\n      }),\n          Qu = an({\n        reverse_: function (t, e) {\n          var n = $e(t, \"x\", \"reverse\");\n          if (0 === n.rank) return n.clone();\n          var r = O(e, n.shape);\n          return Mt.runKernelFunc(function (t) {\n            return t.reverse(n, r);\n          }, {\n            $x: n\n          }, function (t) {\n            return {\n              $x: function () {\n                return t.reverse(r);\n              }\n            };\n          }).reshapeAs(n);\n        }\n      }),\n          Xu = an({\n        reverse1d_: function (t) {\n          var e = $e(t, \"x\", \"reverse\");\n          return S(1 === e.rank, function () {\n            return \"Error in reverse1D: x must be rank 1 but got rank \" + e.rank + \".\";\n          }), Qu(e, 0);\n        }\n      }),\n          Yu = an({\n        reverse2d_: function (t, e) {\n          var n = $e(t, \"x\", \"reverse\");\n          return S(2 === n.rank, function () {\n            return \"Error in reverse2D: x must be rank 2 but got rank \" + n.rank + \".\";\n          }), Qu(n, e);\n        }\n      }),\n          Ju = an({\n        reverse3d_: function (t, e) {\n          var n = $e(t, \"x\", \"reverse\");\n          return S(3 === n.rank, function () {\n            return \"Error in reverse3D: x must be rank 3 but got rank \" + n.rank + \".\";\n          }), Qu(n, e);\n        }\n      }),\n          Zu = an({\n        reverse4d_: function (t, e) {\n          var n = $e(t, \"x\", \"reverse\");\n          return S(4 === n.rank, function () {\n            return \"Error in reverse4D: x must be rank 4 but got rank \" + n.rank + \".\";\n          }), Qu(n, e);\n        }\n      });\n\n      function tc(t, e, n, r, o, i) {\n        var a = $e(t, \"x\", \"maxPool\"),\n            s = a,\n            u = !1;\n        3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), null == r && (r = [1, 1]), S(4 === s.rank, function () {\n          return \"Error in maxPool: input must be rank 4 but got rank \" + s.rank + \".\";\n        }), S(Kr(n, r), function () {\n          return \"Error in maxPool: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + r + \"'\";\n        }), null != i && S(T(o), function () {\n          return \"Error in maxPool: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + o + \".\";\n        });\n        var c = Br(s.shape, e, n, r, o, i),\n            l = Mt.runKernelFunc(function (t, e) {\n          var n = t.maxPool(s, c);\n          return e([s, n]), n;\n        }, {\n          x: s\n        }, function (t, i) {\n          var a = i[0],\n              s = i[1];\n          return {\n            x: function () {\n              return function (t, e, n, r, o, i, a, s) {\n                var u = $e(t, \"dy\", \"maxPoolBackprop\"),\n                    c = $e(e, \"input\", \"maxPoolBackprop\"),\n                    l = $e(n, \"output\", \"maxPoolBackprop\");\n                S(c.rank === u.rank, function () {\n                  return \"Rank of input (\" + c.rank + \") does not match rank of dy (\" + u.rank + \")\";\n                }), null == i && (i = [1, 1]), S(Kr(o, i), function () {\n                  return \"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides \" + o + \" and dilations '\" + i + \"'\";\n                }), S(4 === u.rank, function () {\n                  return \"Error in maxPoolBackprop: dy must be rank 4 but got rank \" + u.rank + \".\";\n                }), S(4 === c.rank, function () {\n                  return \"Error in maxPoolBackprop: input must be rank 4 but got rank \" + c.rank + \".\";\n                });\n                var h = Br(c.shape, r, o, i, a, s);\n                return Mt.runKernelFunc(function (t) {\n                  return t.maxPoolBackprop(u, c, l, h);\n                }, {\n                  $dy: u,\n                  $input: c\n                });\n              }(t, a, s, e, n, r, o);\n            }\n          };\n        });\n        return u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;\n      }\n\n      function ec(t, e, n, r, o, i) {\n        var a = $e(t, \"x\", \"avgPool\", \"float32\");\n        null == r && (r = [1, 1]), S(Kr(n, r), function () {\n          return \"Error in avgPool: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + r + \"'\";\n        });\n        var s = a,\n            u = !1;\n        3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), S(4 === s.rank, function () {\n          return \"Error in avgPool: x must be rank 4 but got rank \" + s.rank + \".\";\n        }), null != i && S(T(o), function () {\n          return \"Error in avgPool: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + o + \".\";\n        });\n        var c = Br(s.shape, e, n, r, o, i),\n            l = Mt.runKernelFunc(function (t) {\n          return t.avgPool(s, c);\n        }, {\n          x: s\n        }, function (t) {\n          return {\n            x: function () {\n              return function (t, e, n, r, o, i) {\n                var a = $e(t, \"dy\", \"avgPoolBackprop\"),\n                    s = $e(e, \"input\", \"avgPoolBackprop\");\n                S(s.rank === a.rank, function () {\n                  return \"Rank of input (\" + s.rank + \") does not match rank of dy (\" + a.rank + \")\";\n                }), null == o && (o = [1, 1]), S(Kr(r, o), function () {\n                  return \"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + o + \"'\";\n                });\n                var u = s,\n                    c = a,\n                    l = !1;\n                3 === s.rank && (l = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), c = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), S(4 === c.rank, function () {\n                  return \"Error in avgPoolBackprop: dy must be rank 4 but got rank \" + c.rank + \".\";\n                }), S(4 === u.rank, function () {\n                  return \"Error in avgPoolBackprop: input must be rank 4 but got rank \" + u.rank + \".\";\n                });\n                var h = Br(u.shape, n, r, o, i),\n                    p = Mt.runKernelFunc(function (t) {\n                  return t.avgPoolBackprop(c, u, h);\n                }, {\n                  dy4D: c,\n                  input4D: u\n                });\n                return l ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;\n              }(t, s, e, n, r, o);\n            }\n          };\n        });\n        return l = l.cast(a.dtype), u ? l.as3D(l.shape[1], l.shape[2], l.shape[3]) : l;\n      }\n\n      var nc = an({\n        maxPool_: function (t, e, n, r, o) {\n          return tc(t, e, n, 1, r, o);\n        }\n      }),\n          rc = an({\n        avgPool_: function (t, e, n, r, o) {\n          return ec(t, e, n, 1, r, o);\n        }\n      }),\n          oc = an({\n        pool_: function (t, e, n, r, o, i) {\n          null == o && (o = [1, 1]), null == i && (i = 1), 0 === r && (r = \"valid\");\n          var a = $e(t, \"x\", \"maxPool\"),\n              s = a,\n              u = !1;\n          3 === a.rank && (u = !0, s = a.as4D(1, a.shape[0], a.shape[1], a.shape[2])), S(Kr(i, o), function () {\n            return \"Error in pool: Either strides or dilations must be 1. Got strides \" + i + \" and dilations '\" + o + \"'\";\n          });\n          var c,\n              l = Br(s.shape, e, i, o, r),\n              h = [l.dilationHeight, l.dilationWidth];\n          c = \"same\" === r ? function (t, e) {\n            var n = t.map(function (t, n) {\n              return t + (t - 1) * (e[n] - 1);\n            }).map(function (t) {\n              return t - 1;\n            }),\n                r = n.map(function (t) {\n              return Math.floor(t / 2);\n            }),\n                o = n.map(function (t, e) {\n              return t - r[e];\n            });\n            return n.map(function (t, e) {\n              return [r[e], o[e]];\n            });\n          }([l.filterHeight, l.filterWidth], h) : [[0, 0], [0, 0]];\n\n          var p = 1 === h[0] && 1 === h[1],\n              f = function (t, e, n) {\n            var r = n.map(function (t) {\n              return t[0];\n            }),\n                o = n.map(function (t) {\n              return t[1];\n            }),\n                i = t.concat(r, o),\n                a = e.map(function (t, e) {\n              return (t - i[e] % t) % t;\n            }),\n                s = o.map(function (t, e) {\n              return t + a[e];\n            });\n            return [e.map(function (t, e) {\n              return [r[e], s[e]];\n            }), e.map(function (t, e) {\n              return [0, a[e]];\n            })];\n          }([l.inHeight, l.inWidth], h, c),\n              d = f[0],\n              m = f[1],\n              g = p ? r : \"valid\",\n              v = p ? s : sr(s, h, d),\n              y = (\"avg\" === n ? function () {\n            return ec(v, e, i, 1, g);\n          } : function () {\n            return tc(v, e, i, 1, g);\n          })(),\n              b = p ? y : Un(y, h, m);\n\n          return u ? b.as3D(b.shape[1], b.shape[2], b.shape[3]) : b;\n        }\n      }),\n          ic = an({\n        maxPool3d_: function (t, e, n, r, o, i, a) {\n          void 0 === i && (i = \"NDHWC\");\n          var s = $e(t, \"x\", \"maxPool3d\"),\n              u = s,\n              c = !1;\n          4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == a && (a = [1, 1, 1]), S(5 === u.rank, function () {\n            return \"Error in maxPool3d: x must be rank 5 but got rank \" + u.rank + \".\";\n          }), S(\"NDHWC\" === i, function () {\n            return \"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of \" + i;\n          }), S(Kr(n, a), function () {\n            return \"Error in maxPool3d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\";\n          }), null != o && S(T(r), function () {\n            return \"Error in maxPool3d: pad must be an integer when using, dimRoundingMode \" + o + \" but got pad \" + r + \".\";\n          });\n          var l = zr(u.shape, e, n, a, r, o, i),\n              h = Mt.runKernelFunc(function (t, e) {\n            var n = t.maxPool3d(u, l);\n            return e([u, n]), n;\n          }, {\n            x: u\n          }, function (t, i) {\n            var s = i[0],\n                u = i[1];\n            return {\n              x: function () {\n                return function (t, e, n, r, o, i, a, s) {\n                  var u = $e(t, \"dy\", \"maxPool3dBackprop\"),\n                      c = $e(e, \"input\", \"maxPool3dBackprop\"),\n                      l = $e(n, \"output\", \"maxPool3dBackprop\"),\n                      h = u,\n                      p = c,\n                      f = l,\n                      d = !1;\n                  4 === c.rank && (d = !0, h = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3]), p = c.as5D(1, c.shape[0], c.shape[1], c.shape[2], c.shape[3]), f = l.as5D(1, l.shape[0], l.shape[1], l.shape[2], l.shape[3])), S(5 === h.rank, function () {\n                    return \"Error in maxPool3dBackprop: dy must be rank 5 but got rank \" + h.rank + \".\";\n                  }), S(5 === p.rank, function () {\n                    return \"Error in maxPool3dBackprop: input must be rank 5 but got rank \" + p.rank + \".\";\n                  }), S(5 === f.rank, function () {\n                    return \"Error in maxPool3dBackprop: output must be rank 5 but got rank \" + f.rank + \".\";\n                  }), null == i && (i = [1, 1, 1]), S(Kr(o, i), function () {\n                    return \"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides \" + o + \" and dilations '\" + i + \"'\";\n                  }), null != s && S(T(a), function () {\n                    return \"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode \" + s + \" but got pad \" + a + \".\";\n                  });\n                  var m = zr(p.shape, r, o, i, a, s),\n                      g = Mt.runKernelFunc(function (t) {\n                    return t.maxPool3dBackprop(h, p, f, m);\n                  }, {\n                    dy5D: h,\n                    input5D: p\n                  });\n                  return d ? g.as4D(g.shape[1], g.shape[2], g.shape[3], g.shape[4]) : g;\n                }(t, s, u, e, n, a, r, o);\n              }\n            };\n          });\n          return c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n        }\n      }),\n          ac = an({\n        avgPool3d_: function (t, e, n, r, o, i, a) {\n          void 0 === i && (i = \"NDHWC\");\n          var s = $e(t, \"x\", \"avgPool3d\", \"float32\"),\n              u = s,\n              c = !1;\n          4 === s.rank && (c = !0, u = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3])), null == a && (a = [1, 1, 1]), S(5 === u.rank, function () {\n            return \"Error in avgPool3d: x must be rank 5 but got rank \" + u.rank + \".\";\n          }), S(\"NDHWC\" === i, function () {\n            return \"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of \" + i;\n          }), S(Kr(n, a), function () {\n            return \"Error in avgPool3d: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + a + \"'\";\n          }), null != o && S(T(r), function () {\n            return \"Error in avgPool3d: pad must be an integer when using, dimRoundingMode \" + o + \" but got pad \" + r + \".\";\n          });\n          var l = zr(u.shape, e, n, a, r, o, i),\n              h = Mt.runKernelFunc(function (t) {\n            return t.avgPool3d(u, l);\n          }, {\n            x: u\n          }, function (t) {\n            return {\n              x: function () {\n                return function (t, e, n, r, o, i, a) {\n                  var s = $e(t, \"dy\", \"avgPool3dBackprop\"),\n                      u = $e(e, \"input\", \"avgPool3dBackprop\"),\n                      c = s,\n                      l = u,\n                      h = !1;\n                  4 === u.rank && (h = !0, c = s.as5D(1, s.shape[0], s.shape[1], s.shape[2], s.shape[3]), l = u.as5D(1, u.shape[0], u.shape[1], u.shape[2], u.shape[3])), S(5 === c.rank, function () {\n                    return \"Error in avgPool3dBackprop: dy must be rank 5 but got rank \" + c.rank + \".\";\n                  }), S(5 === l.rank, function () {\n                    return \"Error in avgPool3dBackprop: input must be rank 5 but got rank \" + l.rank + \".\";\n                  }), null == o && (o = [1, 1, 1]), S(Kr(r, o), function () {\n                    return \"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + o + \"'\";\n                  }), null != a && S(T(i), function () {\n                    return \"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + i + \".\";\n                  });\n                  var p = zr(l.shape, n, r, o, i, a),\n                      f = Mt.runKernelFunc(function (t) {\n                    return t.avgPool3dBackprop(c, l, p);\n                  }, {\n                    dy5D: c,\n                    input5D: l\n                  });\n                  return h ? f.as4D(f.shape[1], f.shape[2], f.shape[3], f.shape[4]) : f;\n                }(t, u, e, n, a, r, o);\n              }\n            };\n          });\n          return h = h.cast(u.dtype), c ? h.as4D(h.shape[1], h.shape[2], h.shape[3], h.shape[4]) : h;\n        }\n      }),\n          sc = an({\n        slice_: function (t, e, n) {\n          var r,\n              o,\n              i = $e(t, \"x\", \"slice\");\n          if (0 === i.rank) throw new Error(\"Slicing scalar is not possible\");\n          (r = \"number\" == typeof e ? [e].concat(new Array(i.rank - 1).fill(0)) : e.length < i.rank ? e.concat(new Array(i.rank - e.length).fill(0)) : e.slice()).forEach(function (t) {\n            S(-1 !== t, function () {\n              return \"slice() does not support negative begin indexing.\";\n            });\n          }), o = (o = null == n ? new Array(i.rank).fill(-1) : \"number\" == typeof n ? [n].concat(new Array(i.rank - 1).fill(-1)) : n.length < i.rank ? n.concat(new Array(i.rank - n.length).fill(-1)) : n).map(function (t, e) {\n            return t >= 0 ? t : (S(-1 === t, function () {\n              return \"Negative size values should be exactly -1 but got \" + t + \" for the slice() size at index \" + e + \".\";\n            }), i.shape[e] - r[e]);\n          }), Sr(i, r, o);\n          var a = i.shape,\n              s = {\n            begin: r,\n            size: o\n          };\n          return Mt.runKernelFunc(function (t) {\n            return t.slice(i, r, o);\n          }, {\n            x: i\n          }, function (t) {\n            for (var e = [], n = 0; n < t.rank; n++) e.push([r[n], a[n] - r[n] - o[n]]);\n\n            return {\n              x: function () {\n                return t.pad(e);\n              }\n            };\n          }, \"Slice\", s);\n        }\n      }),\n          uc = an({\n        slice1d_: function (t, e, n) {\n          var r = $e(t, \"x\", \"slice1d\");\n          return S(1 === r.rank, function () {\n            return \"slice1d expects a rank-1 tensor, but got a rank-\" + r.rank + \" tensor\";\n          }), sc(r, [e], [n]);\n        }\n      }),\n          cc = an({\n        slice2d_: function (t, e, n) {\n          var r = $e(t, \"x\", \"slice2d\");\n          return S(2 === r.rank, function () {\n            return \"slice2d expects a rank-2 tensor, but got a rank-\" + r.rank + \" tensor\";\n          }), sc(r, e, n);\n        }\n      }),\n          lc = an({\n        slice3d_: function (t, e, n) {\n          var r = $e(t, \"x\", \"slice3d\");\n          return S(3 === r.rank, function () {\n            return \"slice3d expects a rank-3 tensor, but got a rank-\" + r.rank + \" tensor\";\n          }), sc(r, e, n);\n        }\n      }),\n          hc = an({\n        slice4d_: function (t, e, n) {\n          var r = $e(t, \"x\", \"slice4d\");\n          return S(4 === r.rank, function () {\n            return \"slice4d expects a rank-4 tensor, but got a rank-\" + r.rank + \" tensor\";\n          }), sc(r, e, n);\n        }\n      });\n\n      function pc(t, e, n, r, o) {\n        return e.rank < n.rank && (e = e.reshape(Je(e.shape, r))), t.rank < n.rank && (t = t.reshape(Je(t.shape, r))), {\n          $x: function () {\n            var r = t.mul(n.equal(e).cast(t.dtype));\n            return null == o ? r : r.transpose(o);\n          }\n        };\n      }\n\n      var fc = an({\n        all_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = $e(t, \"x\", \"all\", \"bool\"),\n              o = O(e, r.shape),\n              i = o,\n              a = tn(i, r.rank);\n          null != a && (r = r.transpose(a), i = nn(i.length, r.rank));\n          var s = Mt.runKernelFunc(function (t) {\n            return t.all(r, i);\n          }, {\n            $x: r\n          });\n\n          if (n) {\n            var u = Je(s.shape, o);\n            return s.reshape(u);\n          }\n\n          return s;\n        }\n      }),\n          dc = an({\n        any_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = $e(t, \"x\", \"any\", \"bool\"),\n              o = O(e, r.shape),\n              i = o,\n              a = tn(i, r.rank);\n          null != a && (r = r.transpose(a), i = nn(i.length, r.rank));\n          var s = Mt.runKernelFunc(function (t) {\n            return t.any(r, i);\n          }, {\n            $x: r\n          });\n\n          if (n) {\n            var u = Je(s.shape, o);\n            return s.reshape(u);\n          }\n\n          return s;\n        }\n      }),\n          mc = an({\n        argMax_: function (t, e) {\n          void 0 === e && (e = 0);\n          var n = $e(t, \"x\", \"argMax\");\n          null == e && (e = 0);\n          var r = O(e, n.shape),\n              o = tn(r, n.rank);\n          return null != o && (n = n.transpose(o), r = nn(r.length, n.rank)), Mt.runKernelFunc(function (t, e) {\n            var o = t.argMax(n, r[0]);\n            return e([n]), o;\n          }, {\n            $x: n\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return Sn(n);\n              }\n            };\n          });\n        }\n      }),\n          gc = an({\n        argMin_: function (t, e) {\n          void 0 === e && (e = 0);\n          var n = $e(t, \"x\", \"argMin\");\n          null == e && (e = 0);\n          var r = O(e, n.shape),\n              o = tn(r, n.rank);\n          return null != o && (n = n.transpose(o), r = nn(r.length, n.rank)), Mt.runKernelFunc(function (t, e) {\n            var o = t.argMin(n, r[0]);\n            return e([n]), o;\n          }, {\n            $x: n\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return Sn(n);\n              }\n            };\n          });\n        }\n      }),\n          vc = an({\n        logSumExp_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = $e(t, \"x\", \"logSumExp\"),\n              o = O(e, r.shape),\n              i = r.max(o, !0),\n              a = r.sub(i).exp().sum(o).log(),\n              s = i.reshape(a.shape).add(a);\n\n          if (n) {\n            var u = Je(s.shape, o);\n            return s.reshape(u);\n          }\n\n          return s;\n        }\n      }),\n          yc = an({\n        max_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = $e(t, \"x\", \"max\"),\n              o = r,\n              i = O(e, r.shape),\n              a = i,\n              s = tn(a, r.rank);\n          null != s && (r = r.transpose(s), a = nn(a.length, r.rank));\n          var u = Mt.runKernelFunc(function (t, e) {\n            var n = t.max(r, a);\n            return e([o, n]), n;\n          }, {\n            $x: r\n          }, function (t, e) {\n            return pc(t, e[1], e[0], i, s);\n          });\n\n          if (n) {\n            var c = Je(u.shape, i);\n            u = u.reshape(c);\n          }\n\n          return u;\n        }\n      }),\n          bc = an({\n        mean_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = $e(t, \"x\", \"mean\"),\n              o = O(e, r.shape),\n              i = A(Ye(r.shape, o)[1]);\n          return Nr(function (t) {\n            var r = pn(i);\n            return {\n              value: (r.dtype === t.dtype ? t : t.cast(r.dtype)).div(r).sum(e, n),\n              gradFunc: function (e) {\n                var n = t.shape.slice();\n                return o.forEach(function (t) {\n                  n[t] = 1;\n                }), e.reshape(n).mul(vn(t.shape, \"float32\")).div(i);\n              }\n            };\n          })(r);\n        }\n      }),\n          wc = an({\n        min_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = $e(t, \"x\", \"min\"),\n              o = r,\n              i = O(e, r.shape),\n              a = i,\n              s = tn(a, r.rank);\n          null != s && (r = r.transpose(s), a = nn(a.length, r.rank));\n          var u = Mt.runKernelFunc(function (t, e) {\n            var n = t.min(r, a);\n            return e([o, n]), n;\n          }, {\n            $x: r\n          }, function (t, e) {\n            return pc(t, e[1], e[0], i, s);\n          });\n\n          if (n) {\n            var c = Je(u.shape, i);\n            u = u.reshape(c);\n          }\n\n          return u;\n        }\n      }),\n          xc = an({\n        moments_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = O(e, (t = $e(t, \"x\", \"moments\")).shape),\n              o = t.mean(r, n),\n              i = o.shape;\n          n || (i = Je(o.shape, r));\n          var a = t.toFloat().sub(o.reshape(i)).square();\n          return {\n            mean: o,\n            variance: a.mean(r, n)\n          };\n        }\n      }),\n          Sc = an({\n        sum_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = $e(t, \"x\", \"sum\");\n          \"bool\" === r.dtype && (r = r.toInt());\n          var o = O(e, r.shape);\n          return Nr(function (t) {\n            var e = tn(o, t.rank),\n                r = o,\n                i = t;\n            null != e && (i = t.transpose(e), r = nn(r.length, t.rank));\n            var a = Mt.runKernelFunc(function (t) {\n              return t.sum(i, r);\n            }, {\n              permutedX: i\n            });\n\n            if (n) {\n              var s = Je(a.shape, o);\n              a = a.reshape(s);\n            }\n\n            return {\n              value: a,\n              gradFunc: function (e) {\n                var n = t.shape.slice();\n                return o.forEach(function (t) {\n                  n[t] = 1;\n                }), e.reshape(n).mul(vn(t.shape, \"float32\"));\n              }\n            };\n          })(r);\n        }\n      }),\n          Ec = an({\n        prod_: function (t, e, n) {\n          void 0 === e && (e = null), void 0 === n && (n = !1);\n          var r = $e(t, \"x\", \"prod\");\n          \"bool\" === r.dtype && (r = r.toInt());\n          var o = O(e, r.shape),\n              i = tn(o, r.rank),\n              a = o,\n              s = r;\n          null != i && (s = r.transpose(i), a = nn(a.length, r.rank));\n          var u = Mt.runKernelFunc(function (t) {\n            return t.prod(s, a);\n          }, {\n            permutedX: s\n          });\n\n          if (n) {\n            var c = Je(u.shape, o);\n            u = u.reshape(c);\n          }\n\n          return u;\n        }\n      }),\n          Cc = an({\n        elu_: function (t) {\n          var e = $e(t, \"x\", \"elu\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.elu(e);\n            return n([r]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return Mt.runKernelFunc(function (e) {\n                  return e.eluDer(t, n);\n                }, {\n                  dy: t,\n                  y: n\n                });\n              }\n            };\n          });\n        }\n      }),\n          Ic = an({\n        leakyRelu_: function (t, e) {\n          void 0 === e && (e = .2);\n          var n = $e(t, \"x\", \"leakyRelu\");\n          return nu(pn(e).mul(n), n);\n        }\n      }),\n          Ac = an({\n        prelu_: function (t, e) {\n          var n = $e(t, \"x\", \"prelu\"),\n              r = $e(e, \"alpha\", \"prelu\");\n          return Mt.runKernelFunc(function (t, e) {\n            var o = t.prelu(n, r);\n            return e([n, r]), o;\n          }, {\n            x: n,\n            alpha: r\n          }, function (t, e) {\n            var n = e[0],\n                r = e[1],\n                o = n.greater(0);\n            return {\n              x: function () {\n                return $s(o, t, t.mul(r));\n              },\n              alpha: function () {\n                var e = $s(o, Sn(t), t.mul(n)),\n                    i = Fr(r.shape, t.shape);\n                return i.length > 0 && (e = e.sum(i)), e.reshape(r.shape);\n              }\n            };\n          }, \"Prelu\");\n        }\n      }),\n          kc = an({\n        relu_: function (t) {\n          var e = $e(t, \"x\", \"relu\");\n          return \"bool\" === e.dtype ? e.toInt() : Mt.runKernelFunc(function (t, n) {\n            var r = t.relu(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                return t.mulStrict(n.step().toFloat());\n              }\n            };\n          });\n        }\n      }),\n          Tc = an({\n        relu6_: function (t) {\n          var e = $e(t, \"x\", \"relu6\");\n          return \"bool\" === e.dtype ? e.toInt() : Mt.runKernelFunc(function (t, n) {\n            var r = t.relu6(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0],\n                r = n.lessEqual(6).mul(n.step());\n            return {\n              $x: function () {\n                return t.mulStrict(r.toFloat());\n              }\n            };\n          });\n        }\n      }),\n          Nc = an({\n        selu_: function (t) {\n          var e = $e(t, \"x\", \"selu\");\n          return Mt.runKernelFunc(function (t, n) {\n            var r = t.selu(e);\n            return n([e]), r;\n          }, {\n            $x: e\n          }, function (t, e) {\n            var n = e[0];\n            return {\n              $x: function () {\n                var e = n.greater(pn(0)),\n                    r = pn(Ea),\n                    o = pn(Ca),\n                    i = t.mul(o),\n                    a = t.mul(r).mul(n.toFloat().exp());\n                return $s(e, i, a);\n              }\n            };\n          });\n        }\n      }),\n          Pc = an({\n        transpose_: function (t, e) {\n          var n = $e(t, \"x\", \"transpose\");\n          return null == e && (e = n.shape.map(function (t, e) {\n            return e;\n          }).reverse()), S(n.rank === e.length, function () {\n            return \"Error in transpose: rank of input \" + n.rank + \" must match length of perm \" + e + \".\";\n          }), e.forEach(function (t) {\n            S(t >= 0 && t < n.rank, function () {\n              return \"All entries in 'perm' must be between 0 and \" + (n.rank - 1) + \" but got \" + e;\n            });\n          }), n.rank <= 1 ? n.clone() : Mt.runKernelFunc(function (t) {\n            return t.transpose(n, e);\n          }, {\n            $x: n\n          }, function (t) {\n            var n = en(e);\n            return {\n              $x: function () {\n                return t.transpose(n);\n              }\n            };\n          });\n        }\n      }),\n          Rc = an({\n        localResponseNormalization_: function (t, e, n, r, o) {\n          void 0 === e && (e = 5), void 0 === n && (n = 1), void 0 === r && (r = 1), void 0 === o && (o = .5);\n          var i = $e(t, \"x\", \"localResponseNormalization\");\n          S(4 === i.rank || 3 === i.rank, function () {\n            return \"Error in localResponseNormalization: x must be rank 3 or 4 but got\\n               rank \" + i.rank + \".\";\n          }), S(T(e), function () {\n            return \"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius \" + e + \".\";\n          });\n          var a = i,\n              s = !1;\n          3 === i.rank && (s = !0, a = i.as4D(1, i.shape[0], i.shape[1], i.shape[2]));\n          var u = Mt.runKernelFunc(function (t, i) {\n            var s = t.localResponseNormalization4D(a, e, n, r, o);\n            return i([a, s]), s;\n          }, {\n            x4D: a\n          }, function (t, i) {\n            var a = i[0],\n                s = i[1];\n            return {\n              x4D: function () {\n                return Mt.runKernelFunc(function (i) {\n                  return i.LRNGrad(t, a, s, e, n, r, o);\n                }, {});\n              }\n            };\n          });\n          return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n        }\n      }),\n          _c = an({\n        norm_: function (t, e, n, r) {\n          void 0 === e && (e = \"euclidean\"), void 0 === n && (n = null), void 0 === r && (r = !1);\n\n          var o = function t(e, n, r) {\n            if (void 0 === r && (r = null), 0 === e.rank) return e.abs();\n            if (1 !== e.rank && null === r) return t(e.reshape([-1]), n, r);\n\n            if (1 === e.rank || \"number\" == typeof r || Array.isArray(r) && 1 === r.length) {\n              if (1 === n) return e.abs().sum(r);\n              if (n === 1 / 0) return e.abs().max(r);\n              if (n === -1 / 0) return e.abs().min(r);\n              if (\"euclidean\" === n || 2 === n) return e.abs().pow(pn(2, \"int32\")).sum(r).sqrt();\n              throw new Error(\"Error in norm: invalid ord value: \" + n);\n            }\n\n            if (Array.isArray(r) && 2 === r.length) {\n              if (1 === n) return e.abs().sum(r[0]).max(r[1] - 1);\n              if (n === 1 / 0) return e.abs().sum(r[1]).max(r[0]);\n              if (n === -1 / 0) return e.abs().sum(r[1]).min(r[0]);\n              if (\"fro\" === n || \"euclidean\" === n) return e.square().sum(r).sqrt();\n              throw new Error(\"Error in norm: invalid ord value: \" + n);\n            }\n\n            throw new Error(\"Error in norm: invalid axis: \" + r);\n          }(t = $e(t, \"x\", \"norm\"), e, n),\n              i = o.shape;\n\n          if (r) {\n            var a = O(n, t.shape);\n            i = Je(o.shape, a);\n          }\n\n          return o.reshape(i);\n        }\n      }),\n          Mc = an({\n        basicLSTMCell_: function (t, e, n, r, o, i) {\n          var a = $e(t, \"forgetBias\", \"basicLSTMCell\"),\n              s = $e(e, \"lstmKernel\", \"basicLSTMCell\"),\n              u = $e(n, \"lstmBias\", \"basicLSTMCell\"),\n              c = $e(r, \"data\", \"basicLSTMCell\"),\n              l = $e(o, \"c\", \"basicLSTMCell\"),\n              h = $e(i, \"h\", \"basicLSTMCell\"),\n              p = c.concat(h, 1).matMul(s).add(u),\n              f = p.shape[0],\n              d = p.shape[1] / 4,\n              m = [f, d],\n              g = p.slice([0, 0], m),\n              v = p.slice([0, d], m),\n              y = p.slice([0, 2 * d], m),\n              b = p.slice([0, 3 * d], m),\n              w = g.sigmoid().mulStrict(v.tanh()).addStrict(l.mulStrict(a.add(y).sigmoid())),\n              x = w.tanh().mulStrict(b.sigmoid());\n          return [w, x];\n        }\n      }),\n          Oc = an({\n        multiRNNCell_: function (t, e, n, r) {\n          for (var o = $e(e, \"data\", \"multiRNNCell\"), i = Ke(n, \"c\", \"multiRNNCell\"), a = Ke(r, \"h\", \"multiRNNCell\"), s = o, u = [], c = 0; c < t.length; c++) {\n            var l = t[c](s, i[c], a[c]);\n            u.push(l[0]), u.push(l[1]), s = l[1];\n          }\n\n          var h = [],\n              p = [];\n\n          for (c = 0; c < u.length; c += 2) h.push(u[c]), p.push(u[c + 1]);\n\n          return [h, p];\n        }\n      }),\n          Dc = an({\n        movingAverage_: function (t, e, n, r, o) {\n          void 0 === o && (o = !0);\n          var i = $e(t, \"v\", \"movingAverage\"),\n              a = $e(e, \"x\", \"movingAverage\"),\n              s = $e(n, \"decay\", \"movingAverage\");\n          Tt(i, a), S(k(i.shape, a.shape), function () {\n            return \"Shape mismatch in v and x\";\n          });\n          var u = pn(1),\n              c = u.sub(s),\n              l = a.sub(i).mul(c);\n\n          if (o) {\n            S(null != r, function () {\n              return \"When using zeroDebias: true, step is required.\";\n            });\n            var h = $e(r, \"step\", \"movingAverage\");\n            l = l.div(u.sub(lu(s, h)));\n          }\n\n          return i.add(l);\n        }\n      }),\n          Fc = an({\n        stridedSlice_: function (t, e, n, r, o, i, a, s, u) {\n          if (void 0 === o && (o = 0), void 0 === i && (i = 0), void 0 === a && (a = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), null == r && (r = new Array(e.length)), 0 !== a) throw new Error(\"ellipsis mask is not yet supported\");\n          var c = $e(t, \"x\", \"stridedSlice\"),\n              l = Er(s),\n              h = c.shape.slice();\n          l.forEach(function (t) {\n            e[t] = 0, n[t] = 1, h.splice(t, 0, 1);\n          }), c = c.reshape(h);\n\n          for (var p = 0; p < c.rank; p++) e[p] = Ir(o, e, r, c.shape, p), n[p] = Ar(i, n, r, c.shape, p), r[p] = r[p] || 1;\n\n          var f = Er(u);\n          f.forEach(function (t) {\n            n[t] = e[t] + 1, r[t] = 1;\n          });\n          var d = Cr(e, n, r),\n              m = d.filter(function (t, e) {\n            return -1 === f.indexOf(e);\n          });\n          return r.every(function (t) {\n            return 1 === t;\n          }) ? sc(c, e, d).reshape(m) : Mt.runKernelFunc(function (t) {\n            return t.stridedSlice(c, e, n, r);\n          }, {\n            $x: c\n          }).reshape(m);\n        }\n      }),\n          Lc = an({\n        topk_: function (t, e, n) {\n          void 0 === e && (e = 1), void 0 === n && (n = !0);\n          var r = $e(t, \"x\", \"topk\");\n          if (0 === r.rank) throw new Error(\"topk() expects the input to be of rank 1 or higher\");\n          var o = r.shape[r.shape.length - 1];\n          if (e > o) throw new Error(\"'k' passed to topk() must be <= the last dimension (\" + o + \") but got \" + e);\n          var i = Mt.runKernelFunc(function (t) {\n            return t.topk(r, e, n);\n          }, {\n            $x: r\n          });\n          return {\n            values: i[0],\n            indices: i[1]\n          };\n        }\n      }),\n          Bc = an({\n        scatterND_: function (t, e, n) {\n          var r = $e(t, \"indices\", \"scatterND\", \"int32\"),\n              o = $e(e, \"updates\", \"scatterND\");\n          return function (t, e, n) {\n            if (e.rank < 1) throw new Error(\"tf.scatterND() expects the indices to be rank 1 or higher, but the rank was \" + e.rank + \".\");\n            if (t.rank < 1) throw new Error(\"tf.scatterND() expects the updates to be rank 1 or higher, but the rank was \" + t.rank + \".\");\n            if (\"int32\" !== e.dtype) throw new Error(\"The dtype of 'indices' should be int32, but got dtype: \" + e.dtype);\n            if (n.length < 1) throw new Error(\"Output rank must be greater or equal to 1, but got shape: \" + n);\n\n            if (0 === n.length) {\n              if (0 === e.size) throw new Error(\"Indices specified for empty output. indices shape: \" + e.shape);\n              if (0 === t.size) throw new Error(\"Updates specified for empty output. updates shape: \" + t.shape);\n            }\n\n            !function (t, e, n) {\n              var r = e.rank > 1 ? e.shape[e.rank - 1] : 1,\n                  o = e.rank > 1 ? e.rank - 1 : 1,\n                  i = \"Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: \" + n.shape + \", indices.shape: \" + e.shape + \", shape: \" + t + \", sliceDim: \" + r + \", and batchDim: \" + o + \".\";\n              if (n.rank < o) throw new Error(i + \" update.rank < \" + o + \". \");\n              if (t.length < r + (n.rank - o)) throw new Error(i + \" Output shape length < \" + (r + (n.rank - o)));\n              if (n.rank !== o + t.length - r) throw new Error(i + \" update.rank != \" + (o + t.length - r));\n\n              for (var a = 0; a < o; ++a) if (n.shape[a] !== e.shape[a]) throw new Error(i + \" updates.shape[\" + a + \"] (\" + n.shape[a] + \") != indices.shape[\" + a + \"] (\" + e.shape[a] + \").\");\n\n              for (a = 0; a < n.rank - o; ++a) if (n.shape[a + o] !== t[a + r]) throw new Error(i + \" updates.shape[\" + (a + o) + \"] (\" + n.shape[a + o] + \") != shape[\" + (a + o) + \"] (\" + t[a + o] + \")\");\n            }(n, e, t);\n          }(o, r, n), Mt.runKernelFunc(function (t) {\n            return t.scatterND(r, o, n);\n          }, {\n            $indices: r,\n            $updates: o\n          });\n        }\n      }),\n          zc = an({\n        fft_: function (t) {\n          S(\"complex64\" === t.dtype, function () {\n            return \"The dtype for tf.spectral.fft() must be complex64 but got \" + t.dtype + \".\";\n          });\n          var e = t.shape[t.shape.length - 1],\n              n = t.size / e,\n              r = t.as2D(n, e);\n          return Mt.runKernelFunc(function (t) {\n            return t.fft(r);\n          }, {\n            input: t\n          }).reshape(t.shape);\n        }\n      }),\n          qc = an({\n        ifft_: function (t) {\n          S(\"complex64\" === t.dtype, function () {\n            return \"The dtype for tf.spectral.ifft() must be complex64 but got \" + t.dtype + \".\";\n          });\n          var e = t.shape[t.shape.length - 1],\n              n = t.size / e,\n              r = t.as2D(n, e);\n          return Mt.runKernelFunc(function (t) {\n            return t.ifft(r);\n          }, {\n            input: t\n          }).reshape(t.shape);\n        }\n      }),\n          Vc = an({\n        rfft_: function (t, e) {\n          S(\"float32\" === t.dtype, function () {\n            return \"The dtype for rfft() must be real value but got \" + t.dtype;\n          });\n          var n,\n              r = t.shape[t.shape.length - 1],\n              o = t.size / r;\n\n          if (null != e && e < r) {\n            var i = t.shape.map(function (t) {\n              return 0;\n            }),\n                a = t.shape.map(function (t) {\n              return t;\n            });\n            a[t.shape.length - 1] = e, n = t.slice(i, a), r = e;\n          } else if (null != e && e > r) {\n            var s = t.shape.map(function (t) {\n              return t;\n            });\n            s[t.shape.length - 1] = e - r, n = t.concat(yn(s), t.shape.length - 1), r = e;\n          } else n = t;\n\n          var u = n.zerosLike(),\n              c = sn(n, u).as2D(o, r),\n              l = zc(c),\n              h = Math.floor(r / 2) + 1,\n              p = un(l),\n              f = cn(l),\n              d = p.split([h, r - h], p.shape.length - 1),\n              m = f.split([h, r - h], f.shape.length - 1),\n              g = n.shape.slice();\n          return g[n.shape.length - 1] = h, sn(d[0], m[0]).reshape(g);\n        }\n      }),\n          Uc = an({\n        irfft_: function (t) {\n          var e = t.shape[t.shape.length - 1],\n              n = t.size / e;\n\n          if (e <= 2) {\n            var r = t.as2D(n, e),\n                o = qc(r);\n            return un(o);\n          }\n\n          var i = [n, 2 * (e - 1)],\n              a = un(t).as2D(n, e),\n              s = cn(t).as2D(n, e),\n              u = a.slice([0, 1], [n, e - 2]).reverse(1),\n              c = s.slice([0, 1], [n, e - 2]).reverse(1).mul(pn(-1)),\n              l = a.concat(u, 1),\n              h = s.concat(c, 1);\n          return r = sn(l, h).as2D(i[0], i[1]), o = qc(r), un(o);\n        }\n      }),\n          jc = Object.freeze({\n        fft: zc,\n        ifft: qc,\n        rfft: Vc,\n        irfft: Uc\n      }),\n          Wc = an({\n        sparseToDense_: function (t, e, n, r) {\n          void 0 === r && (r = 0);\n          var o = $e(t, \"sparseIndices\", \"sparseToDense\", \"int32\"),\n              i = $e(e, \"sparseValues\", \"sparseToDense\"),\n              a = $e(r, \"defaultValue\", \"sparseToDense\", i.dtype);\n          return function (t, e, n, r) {\n            if (\"int32\" !== t.dtype) throw new Error(\"tf.sparseToDense() expects the indices to be int32 type, but the dtype was \" + t.dtype + \".\");\n            if (t.rank > 2) throw new Error(\"sparseIndices should be a scalar, vector, or matrix, but got shape \" + t.shape + \".\");\n            var o = t.rank > 0 ? t.shape[0] : 1,\n                i = t.rank > 1 ? t.shape[1] : 1;\n            if (n.length !== i) throw new Error(\"outputShape has incorrect number of elements:, \" + n.length + \", should be: \" + i + \".\");\n            var a = e.size;\n            if (0 !== e.rank && (1 !== e.rank || a !== o)) throw new Error(\"sparseValues has incorrect shape \" + e.shape + \", should be [] or [\" + o + \"]\");\n            if (e.dtype !== r.dtype) throw new Error(\"sparseValues.dtype must match defaultValues.dtype\");\n          }(o, i, n, a), Mt.runKernelFunc(function (t) {\n            return t.sparseToDense(o, i, n, a);\n          }, {\n            $sparseIndices: o,\n            $sparseValues: i,\n            $defaultValue: a\n          });\n        }\n      }),\n          Gc = an({\n        gatherND_: function (t, e) {\n          var n = $e(e, \"indices\", \"gatherND\", \"int32\"),\n              r = $e(t, \"x\", \"gatherND\");\n          return Mt.runKernelFunc(function (t) {\n            return t.gatherND(r, n);\n          }, {\n            $x: r,\n            $indices: n\n          });\n        }\n      }),\n          Hc = an({\n        diag_: function (t) {\n          var e = $e(t, \"x\", \"diag\").flatten(),\n              n = t.shape.concat(t.shape);\n          return Mt.runKernelFunc(function (t) {\n            return t.diag(e);\n          }, {\n            $x: e\n          }).reshape(n);\n        }\n      }),\n          $c = an({\n        dropout_: function (t, e, n, r) {\n          var o = $e(t, \"x\", \"dropout\");\n          if (S(\"float32\" === o.dtype, function () {\n            return \"x has to be a floating point tensor since it's going to be scaled, but got a \" + o.dtype + \" tensor instead.\";\n          }), S(e >= 0 && e < 1, function () {\n            return \"rate must be a float in the range [0, 1), but got \" + e + \".\";\n          }), 0 === e) return t instanceof vt ? o.clone() : o;\n\n          var i = function (t, e) {\n            if (null == e) return t.shape.slice();\n            if (k(t.shape, e)) return e;\n\n            if (t.shape.length === e.length) {\n              for (var n = [], r = 0; r < t.shape.length; r++) null == e[r] && null != t.shape[r] ? n.push(t.shape[r]) : n.push(e[r]);\n\n              return n;\n            }\n\n            return e;\n          }(o, n),\n              a = 1 - e,\n              s = ir(i, 0, 1, \"float32\", r).add(a).floor().div(a);\n\n          return o.mul(s);\n        }\n      });\n\n      function Kc(t, e, n) {\n        for (var r = 1 - t % 2, o = new Float32Array(t), i = 0; i < t; ++i) {\n          var a = 2 * Math.PI * i / (t + r - 1);\n          o[i] = e - n * Math.cos(a);\n        }\n\n        return fn(o, \"float32\");\n      }\n\n      var Qc,\n          Xc = an({\n        hannWindow_: function (t) {\n          return Kc(t, .5, .5);\n        }\n      }),\n          Yc = an({\n        hammingWindow_: function (t) {\n          return Kc(t, .54, .46);\n        }\n      }),\n          Jc = an({\n        frame_: function (t, e, n, r, o) {\n          void 0 === r && (r = !1), void 0 === o && (o = 0);\n\n          for (var i = 0, a = []; i + e <= t.size;) a.push(sc(t, i, e)), i += n;\n\n          if (r) for (; i < t.size;) {\n            var s = i + e - t.size,\n                u = En([sc(t, i, e - s), bn([s], o)]);\n            a.push(u), i += n;\n          }\n          return 0 === a.length ? dn([], [0, e]) : En(a).as2D(a.length, e);\n        }\n      }),\n          Zc = an({\n        stft_: function (t, e, n, r, o) {\n          var i;\n          void 0 === o && (o = Xc), null == r && (i = e, r = Math.floor(Math.pow(2, Math.ceil(Math.log(i) / Math.log(2)))));\n\n          for (var a = Jc(t, e, n), s = uu(a, o(e)), u = [], c = 0; c < a.shape[0]; c++) u.push(Vc(s.slice([c, 0], [1, e]), r));\n\n          return En(u);\n        }\n      }),\n          tl = Object.freeze({\n        hannWindow: Xc,\n        hammingWindow: Yc,\n        frame: Jc,\n        stft: Zc\n      });\n      !function (t) {\n        t[t.NONE = 0] = \"NONE\", t[t.MEAN = 1] = \"MEAN\", t[t.SUM = 2] = \"SUM\", t[t.SUM_BY_NONZERO_WEIGHTS = 3] = \"SUM_BY_NONZERO_WEIGHTS\";\n      }(Qc || (Qc = {}));\n      var el = an({\n        absoluteDifference_: function (t, e, n, r) {\n          void 0 === r && (r = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var o = $e(t, \"labels\", \"absoluteDifference\"),\n              i = $e(e, \"predictions\", \"absoluteDifference\"),\n              a = null;\n          null != n && (a = $e(n, \"weights\", \"absoluteDifference\")), E(o.shape, i.shape, \"Error in absoluteDifference: \");\n          var s = o.sub(i).abs();\n          return nl(s, a, r);\n        }\n      }),\n          nl = an({\n        computeWeightedLoss_: function (t, e, n) {\n          void 0 === n && (n = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var r = $e(t, \"losses\", \"computeWeightedLoss\"),\n              o = null;\n          null != e && (o = $e(e, \"weights\", \"computeWeightedLoss\"));\n          var i = null == o ? r : r.mul(o);\n          if (n === Qc.NONE) return i;\n          if (n === Qc.SUM) return i.sum();\n\n          if (n === Qc.MEAN) {\n            if (null == o) return i.mean();\n            var a = r.size / o.size,\n                s = i.sum().div(o.sum());\n            return a > 1 ? s.div(pn(a)) : s;\n          }\n\n          if (n === Qc.SUM_BY_NONZERO_WEIGHTS) {\n            if (null == o) return i.sum().div(pn(r.size));\n            var u = o.mul(vn(r.shape)).notEqual(pn(0)).sum().toFloat();\n            return i.sum().div(u);\n          }\n\n          throw Error(\"Unknown reduction: \" + n);\n        }\n      }),\n          rl = an({\n        cosineDistance_: function (t, e, n, r, o) {\n          void 0 === o && (o = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var i = $e(t, \"labels\", \"cosineDistance\"),\n              a = $e(e, \"predictions\", \"cosineDistance\"),\n              s = null;\n          null != r && (s = $e(r, \"weights\", \"cosineDistance\")), E(i.shape, a.shape, \"Error in cosineDistance: \");\n          var u = pn(1).sub(i.mul(a).sum(n, !0));\n          return nl(u, s, o);\n        }\n      }),\n          ol = an({\n        hingeLoss_: function (t, e, n, r) {\n          void 0 === r && (r = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var o = $e(t, \"labels\", \"hingeLoss\"),\n              i = $e(e, \"predictions\", \"hingeLoss\"),\n              a = null;\n          null != n && (a = $e(n, \"weights\", \"hingeLoss\")), E(o.shape, i.shape, \"Error in hingeLoss: \");\n          var s = pn(1);\n          o = pn(2).mul(o).sub(s);\n          var u = s.sub(o.mul(i)).relu();\n          return nl(u, a, r);\n        }\n      }),\n          il = an({\n        huberLoss_: function (t, e, n, r, o) {\n          void 0 === r && (r = 1), void 0 === o && (o = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var i = $e(t, \"labels\", \"huberLoss\"),\n              a = $e(e, \"predictions\", \"huberLoss\"),\n              s = null;\n          null != n && (s = $e(n, \"weights\", \"huberLoss\")), E(i.shape, a.shape, \"Error in huberLoss: \");\n          var u = pn(r),\n              c = a.sub(i).abs(),\n              l = ou(c, u),\n              h = c.sub(l),\n              p = pn(.5).mul(l.square()).add(u.mul(h));\n          return nl(p, s, o);\n        }\n      }),\n          al = an({\n        logLoss_: function (t, e, n, r, o) {\n          void 0 === r && (r = 1e-7), void 0 === o && (o = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var i = $e(t, \"labels\", \"logLoss\"),\n              a = $e(e, \"predictions\", \"logLoss\"),\n              s = null;\n          null != n && (s = $e(n, \"weights\", \"logLoss\")), E(i.shape, a.shape, \"Error in logLoss: \");\n          var u = pn(1),\n              c = pn(r),\n              l = i.mul(a.add(c).log()).neg().sub(u.sub(i).mul(u.sub(a).add(c).log()));\n          return nl(l, s, o);\n        }\n      }),\n          sl = an({\n        meanSquaredError_: function (t, e, n, r) {\n          void 0 === r && (r = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var o = $e(t, \"labels\", \"meanSquaredError\"),\n              i = $e(e, \"predictions\", \"meanSquaredError\"),\n              a = null;\n          null != n && (a = $e(n, \"weights\", \"meanSquaredError\")), E(o.shape, i.shape, \"Error in meanSquaredError: \");\n          var s = o.squaredDifference(i);\n          return nl(s, a, r);\n        }\n      }),\n          ul = an({\n        sigmoidCrossEntropy_: function (t, e, n, r, o) {\n          void 0 === r && (r = 0), void 0 === o && (o = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var i = $e(t, \"multiClassLabels\", \"sigmoidCrossEntropy\"),\n              a = $e(e, \"logits\", \"sigmoidCrossEntropy\"),\n              s = null;\n\n          if (null != n && (s = $e(n, \"weights\", \"sigmoidCrossEntropy\")), E(i.shape, a.shape, \"Error in sigmoidCrossEntropy: \"), r > 0) {\n            var u = pn(r),\n                c = pn(1),\n                l = pn(.5);\n            i = i.mul(c.sub(u)).add(l.mul(u));\n          }\n\n          var h = function (t, e) {\n            var n = $e(t, \"labels\", \"sigmoidCrossEntropyWithLogits\"),\n                r = $e(e, \"logits\", \"sigmoidCrossEntropyWithLogits\");\n            E(n.shape, r.shape, \"Error in sigmoidCrossEntropyWithLogits: \");\n            var o = r.relu(),\n                i = r.mul(n),\n                a = r.abs().neg().exp().log1p();\n            return o.sub(i).add(a);\n          }(i, a);\n\n          return nl(h, s, o);\n        }\n      }),\n          cl = an({\n        softmaxCrossEntropy_: function (t, e, n, r, o) {\n          void 0 === r && (r = 0), void 0 === o && (o = Qc.SUM_BY_NONZERO_WEIGHTS);\n          var i = $e(t, \"onehotLabels\", \"softmaxCrossEntropy\"),\n              a = $e(e, \"logits\", \"softmaxCrossEntropy\"),\n              s = null;\n\n          if (null != n && (s = $e(n, \"weights\", \"softmaxCrossEntropy\")), E(i.shape, a.shape, \"Error in softmaxCrossEntropy: \"), r > 0) {\n            var u = pn(r),\n                c = pn(1),\n                l = pn(i.shape[1]);\n            i = i.mul(c.sub(u)).add(u.div(l));\n          }\n\n          var h = function (t, e, n) {\n            if (void 0 === n && (n = -1), -1 === n && (n = e.rank - 1), n !== e.rank - 1) throw Error(\"Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank \" + e.rank + \" and dim was \" + n);\n            return Nr(function (t, e, r) {\n              var o = e.logSumExp([n], !0),\n                  i = e.toFloat().sub(o);\n              return r([t, i]), {\n                value: i.mul(t).neg().sum([n]),\n                gradFunc: function (t, e) {\n                  var r = e[0],\n                      o = e[1],\n                      i = Je(t.shape, [n]);\n                  return [t.reshape(i).mul(r.toFloat().sub(o.exp())), t.reshape(i).mul(o.exp().sub(r.toFloat()))];\n                }\n              };\n            })(t, e);\n          }(i, a);\n\n          return nl(h, s, o);\n        }\n      }),\n          ll = Object.freeze({\n        get Reduction() {\n          return Qc;\n        },\n\n        absoluteDifference: el,\n        computeWeightedLoss: nl,\n        cosineDistance: rl,\n        hingeLoss: ol,\n        huberLoss: il,\n        logLoss: al,\n        meanSquaredError: sl,\n        sigmoidCrossEntropy: ul,\n        softmaxCrossEntropy: cl\n      });\n\n      function hl(t, e) {\n        return void 0 === e && (e = !1), Mt.tidy(function () {\n          if (2 !== t.shape.length) throw new Error(\"qr2d() requires a 2D Tensor, but got a \" + t.shape.length + \"D Tensor.\");\n\n          for (var n = t.shape[0], r = t.shape[1], o = Kn(n), i = t.clone(), a = dn([[1]], [1, 1]), s = a.clone(), u = n >= r ? r : n, c = function (t) {\n            var e,\n                u = i,\n                c = s,\n                l = o;\n            e = Mt.tidy(function () {\n              var e = i.slice([t, t], [n - t, 1]),\n                  u = e.norm(),\n                  c = i.slice([t, t], [1, 1]),\n                  l = dn([[-1]]).where(c.greater(0), dn([[1]])),\n                  h = c.sub(l.mul(u)),\n                  p = e.div(h);\n              s = 1 === p.shape[0] ? a.clone() : a.concat(p.slice([1, 0], [p.shape[0] - 1, p.shape[1]]), 0);\n              var f = l.matMul(h).div(u).neg(),\n                  d = i.slice([t, 0], [n - t, r]),\n                  m = f.mul(s);\n              if (0 === t) i = d.sub(m.matMul(s.transpose().matMul(d)));else {\n                var g = d.sub(m.matMul(s.transpose().matMul(d)));\n                i = i.slice([0, 0], [t, r]).concat(g, 0);\n              }\n              var v = o.slice([0, t], [n, o.shape[1] - t]);\n              if (0 === t) o = v.sub(v.matMul(s).matMul(m.transpose()));else {\n                var y = v.sub(v.matMul(s).matMul(m.transpose()));\n                o = o.slice([0, 0], [n, t]).concat(y, 1);\n              }\n              return [s, i, o];\n            }), s = e[0], i = e[1], o = e[2], je([u, c, l]);\n          }, l = 0; l < u; ++l) c(l);\n\n          return !e && n > r && (o = o.slice([0, 0], [n, r]), i = i.slice([0, 0], [r, r])), [o, i];\n        });\n      }\n\n      var pl = an({\n        gramSchmidt_: function (t) {\n          var e;\n\n          if (Array.isArray(t)) {\n            e = !1, S(null != t && t.length > 0, function () {\n              return \"Gram-Schmidt process: input must not be null, undefined, or empty\";\n            });\n\n            for (var n = t[0].shape[0], r = function (e) {\n              S(t[e].shape[0] === n, function () {\n                return \"Gram-Schmidt: Non-unique lengths found in the input vectors: (\" + t[e].shape[0] + \" vs. \" + n + \")\";\n              });\n            }, o = 1; o < t.length; ++o) r(o);\n          } else e = !0, t = Tn(t, t.shape[0], 0).map(function (t) {\n            return ur(t, [0]);\n          });\n\n          S(t.length <= t[0].shape[0], function () {\n            return \"Gram-Schmidt: Number of vectors (\" + t.length + \") exceeds number of dimensions (\" + t[0].shape[0] + \").\";\n          });\n\n          var i = [],\n              a = t,\n              s = function (t) {\n            i.push(Mt.tidy(function () {\n              var e = a[t];\n              if (t > 0) for (var n = 0; n < t; ++n) {\n                var r = Sc(i[n].mulStrict(e)).mul(i[n]);\n                e = e.sub(r);\n              }\n              return e.div(_c(e, \"euclidean\"));\n            }));\n          };\n\n          for (o = 0; o < t.length; ++o) s(o);\n\n          return e ? cr(i, 0) : i;\n        }\n      }),\n          fl = an({\n        qr_: function (t, e) {\n          if (void 0 === e && (e = !1), t.rank < 2) throw new Error(\"qr() requires input tensor to have a rank >= 2, but got rank \" + t.rank);\n          if (2 === t.rank) return hl(t, e);\n          var n = t.shape.slice(0, t.shape.length - 2).reduce(function (t, e) {\n            return t * e;\n          }),\n              r = pr(t.reshape([n, t.shape[t.shape.length - 2], t.shape[t.shape.length - 1]]), 0),\n              o = [],\n              i = [];\n          return r.forEach(function (t) {\n            var n = hl(t, e),\n                r = n[0],\n                a = n[1];\n            o.push(r), i.push(a);\n          }), [cr(o, 0).reshape(t.shape), cr(i, 0).reshape(t.shape)];\n        }\n      }),\n          dl = Object.freeze({\n        gramSchmidt: pl,\n        qr: fl\n      });\n\n      function ml(t, e, n, r, o) {\n        null == r && (r = .5), null == o && (o = Number.NEGATIVE_INFINITY);\n        var i = t.shape[0];\n        return n = Math.min(n, i), S(0 <= r && r <= 1, function () {\n          return \"iouThreshold must be in [0, 1], but was '\" + r + \"'\";\n        }), S(2 === t.rank, function () {\n          return \"boxes must be a 2D tensor, but was of rank '\" + t.rank + \"'\";\n        }), S(4 === t.shape[1], function () {\n          return \"boxes must have 4 columns, but 2nd dimension was \" + t.shape[1];\n        }), S(1 === e.rank, function () {\n          return \"scores must be a 1D tensor\";\n        }), S(e.shape[0] === i, function () {\n          return \"scores has incompatible shape with boxes. Expected \" + i + \", but was \" + e.shape[0];\n        }), {\n          maxOutputSize: n,\n          iouThreshold: r,\n          scoreThreshold: o\n        };\n      }\n\n      var gl = an({\n        resizeBilinear_: function (t, e, n) {\n          void 0 === n && (n = !1);\n          var r = $e(t, \"images\", \"resizeBilinear\");\n          S(3 === r.rank || 4 === r.rank, function () {\n            return \"Error in resizeBilinear: x must be rank 3 or 4, but got rank \" + r.rank + \".\";\n          }), S(2 === e.length, function () {\n            return \"Error in resizeBilinear: new shape must 2D, but got shape \" + e + \".\";\n          });\n          var o = r,\n              i = !1;\n          3 === r.rank && (i = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));\n          var a = e[0],\n              s = e[1],\n              u = Mt.runKernelFunc(function (t, e) {\n            return e([o]), t.resizeBilinear(o, a, s, n);\n          }, {\n            batchImages: o\n          }, function (t, e) {\n            return {\n              batchImages: function () {\n                return Mt.runKernelFunc(function (r) {\n                  return r.resizeBilinearBackprop(t, e[0], n);\n                }, {});\n              }\n            };\n          });\n          return i ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n        }\n      }),\n          vl = an({\n        resizeNearestNeighbor_: function (t, e, n) {\n          void 0 === n && (n = !1);\n          var r = $e(t, \"images\", \"resizeNearestNeighbor\");\n          S(3 === r.rank || 4 === r.rank, function () {\n            return \"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank \" + r.rank + \".\";\n          }), S(2 === e.length, function () {\n            return \"Error in resizeNearestNeighbor: new shape must 2D, but got shape \" + e + \".\";\n          }), S(\"float32\" === r.dtype || \"int32\" === r.dtype, function () {\n            return \"`images` must have `int32` or `float32` as dtype\";\n          });\n          var o = r,\n              i = !1;\n          3 === r.rank && (i = !0, o = r.as4D(1, r.shape[0], r.shape[1], r.shape[2]));\n          var a = e[0],\n              s = e[1],\n              u = Mt.runKernelFunc(function (t, e) {\n            return e([o]), t.resizeNearestNeighbor(o, a, s, n);\n          }, {\n            batchImages: o\n          }, function (t, e) {\n            return {\n              batchImages: function () {\n                return Mt.runKernelFunc(function (r) {\n                  return r.resizeNearestNeighborBackprop(t, e[0], n);\n                }, {});\n              }\n            };\n          });\n          return i ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n        }\n      }),\n          yl = an({\n        nonMaxSuppression_: function (t, e, n, r, o) {\n          void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY);\n          var i = $e(t, \"boxes\", \"nonMaxSuppression\"),\n              a = $e(e, \"scores\", \"nonMaxSuppression\"),\n              s = ml(i, a, n, r, o);\n          return n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold, Mt.runKernelFunc(function (t) {\n            return t.nonMaxSuppression(i, a, n, r, o);\n          }, {\n            $boxes: i\n          });\n        }\n      }),\n          bl = an({\n        cropAndResize_: function (t, e, n, r, o, i) {\n          var a = $e(t, \"image\", \"cropAndResize\", \"float32\"),\n              s = $e(e, \"boxes\", \"cropAndResize\", \"float32\"),\n              u = $e(n, \"boxInd\", \"cropAndResize\", \"int32\");\n          o = o || \"bilinear\", i = i || 0;\n          var c = s.shape[0];\n          return S(4 === a.rank, function () {\n            return \"Error in cropAndResize: image must be rank 4,but got rank \" + a.rank + \".\";\n          }), S(2 === s.rank && 4 === s.shape[1], function () {\n            return \"Error in cropAndResize: boxes must be have size [\" + c + \",4] but had shape \" + s.shape + \".\";\n          }), S(1 === u.rank && u.shape[0] === c, function () {\n            return \"Error in cropAndResize: boxInd must be have size [\" + c + \"] but had shape \" + s.shape + \".\";\n          }), S(2 === r.length, function () {\n            return \"Error in cropAndResize: cropSize must be of length 2, but got length \" + r.length + \".\";\n          }), S(r[0] >= 1 && r[1] >= 1, function () {\n            return \"cropSize must be atleast [1,1], but was \" + r;\n          }), S(\"bilinear\" === o || \"nearest\" === o, function () {\n            return \"method must be bilinear or nearest, but was \" + o;\n          }), Mt.runKernelFunc(function (t, e) {\n            return t.cropAndResize(a, s, u, r, o, i);\n          }, {\n            $image: a,\n            $boxes: s\n          });\n        }\n      }),\n          wl = Object.freeze({\n        resizeBilinear: gl,\n        resizeNearestNeighbor: vl,\n        nonMaxSuppression: yl,\n        nonMaxSuppressionAsync: function (t, e, n, r, o) {\n          return void 0 === r && (r = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), u(this, void 0, void 0, function () {\n            var i, a, s, u, l, h, p;\n            return c(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  return i = $e(t, \"boxes\", \"nonMaxSuppressionAsync\"), a = $e(e, \"scores\", \"nonMaxSuppressionAsync\"), s = ml(i, a, n, r, o), n = s.maxOutputSize, r = s.iouThreshold, o = s.scoreThreshold, [4, Promise.all([i.data(), a.data()])];\n\n                case 1:\n                  return u = c.sent(), l = u[0], h = u[1], p = ro(l, h, n, r, o), i !== t && i.dispose(), a !== e && a.dispose(), [2, p];\n              }\n            });\n          });\n        },\n        cropAndResize: bl\n      }),\n          xl = function (t, e) {\n        return !(t > 0 || \"linear\" !== e && \"relu\" !== e);\n      },\n          Sl = function (t, e, n) {\n        if (null == n || \"linear\" === n) return t;\n        if (\"relu\" === n) return t.mul(e.step());\n        throw new Error(\"Gradient for activation \" + n + \" has not been implemented yet.\");\n      },\n          El = function (t, e) {\n        var n = e,\n            r = Fr(t.shape, e.shape);\n        return r.length > 0 && (n = n.sum(r)), n.reshape(t.shape);\n      },\n          Cl = function (t, e, n) {\n        if (\"linear\" === e) return t;\n        if (\"relu\" === e) return kc(t);\n        if (\"elu\" === e) return Cc(t);\n        if (\"relu6\" === e) return Tc(t);\n        if (\"prelu\" === e) return Ac(t, n);\n        throw new Error(\"Unknown fused activation \" + e + \".\");\n      },\n          Il = an({\n        matMul_: function (t) {\n          var e,\n              n = t.a,\n              r = t.b,\n              o = t.transposeA,\n              i = void 0 !== o && o,\n              a = t.transposeB,\n              s = void 0 !== a && a,\n              u = t.bias,\n              c = t.activation,\n              l = void 0 === c ? \"linear\" : c,\n              h = t.preluActivationWeights;\n\n          if (!1 === xl(Mt.state.gradientDepth, l)) {\n            var p = Hu(n, r, i, s);\n            return null != u && (p = Qs(p, u)), Cl(p, l, h);\n          }\n\n          var f = $e(n, \"a\", \"fused matMul\"),\n              d = $e(r, \"b\", \"fused matMul\");\n          e = kt(f, d), f = e[0], d = e[1];\n          var m = i ? f.shape[f.rank - 2] : f.shape[f.rank - 1],\n              g = s ? d.shape[d.rank - 1] : d.shape[d.rank - 2],\n              v = i ? f.shape[f.rank - 1] : f.shape[f.rank - 2],\n              y = s ? d.shape[d.rank - 2] : d.shape[d.rank - 1],\n              b = f.shape.slice(0, -2),\n              w = d.shape.slice(0, -2),\n              x = A(b),\n              E = A(w);\n          S(f.rank >= 2 && d.rank >= 2 && f.rank === d.rank, function () {\n            return \"Error in fused matMul: inputs must have the same rank of at least 2, got ranks \" + f.rank + \" and \" + d.rank + \".\";\n          }), S(k(b, w), function () {\n            return \"Error in fused matMul: outer dimensions (\" + b + \") and (\" + w + \") of Tensors with shapes \" + f.shape + \" and \" + d.shape + \" must match.\";\n          }), S(m === g, function () {\n            return \"Error in fused matMul: inner shapes (\" + m + \") and (\" + g + \") of Tensors with shapes \" + f.shape + \" and \" + d.shape + \" and transposeA=\" + i + \" and transposeB=\" + s + \" must match.\";\n          });\n          var C,\n              I,\n              T = f.shape.slice(0, -2).concat([v, y]),\n              N = i ? f.as3D(x, m, v) : f.as3D(x, v, m),\n              P = s ? d.as3D(E, y, g) : d.as3D(E, g, y);\n          null != u && Lr(T, (C = kt(C = $e(u, \"bias\", \"fused matMul\"), f)[0]).shape), null != h && (I = $e(h, \"prelu weights\", \"fused matMul\"));\n          var R = {\n            $a: N,\n            $b: P\n          };\n          return null != u && (R.$bias = C), null != h && (R.$preluActivationWeights = I), Mt.runKernelFunc(function (t, e) {\n            var n = t.fusedBatchMatMul({\n              a: N,\n              b: P,\n              transposeA: i,\n              transposeB: s,\n              bias: C,\n              activation: l,\n              preluActivationWeights: I\n            });\n            return e([N, P, n]), n;\n          }, R, function (t, e) {\n            var n = e[0],\n                r = e[1],\n                o = e[2],\n                a = Sl(t, o, l),\n                c = {};\n            return null != u && (c = {\n              $bias: function () {\n                return El(C, a);\n              }\n            }), i || s ? !i && s ? Object.assign({\n              $a: function () {\n                return a.matMul(r, !1, !1);\n              },\n              $b: function () {\n                return a.matMul(n, !0, !1);\n              }\n            }, c) : i && !s ? Object.assign({\n              $a: function () {\n                return r.matMul(a, !1, !0);\n              },\n              $b: function () {\n                return n.matMul(a, !1, !1);\n              }\n            }, c) : Object.assign({\n              $a: function () {\n                return r.matMul(a, !0, !0);\n              },\n              $b: function () {\n                return a.matMul(n, !0, !0);\n              }\n            }, c) : Object.assign({\n              $a: function () {\n                return a.matMul(r, !1, !0);\n              },\n              $b: function () {\n                return n.matMul(a, !0, !1);\n              }\n            }, c);\n          }).reshape(T);\n        }\n      }),\n          Al = an({\n        conv2d_: function (t) {\n          var e = t.x,\n              n = t.filter,\n              r = t.strides,\n              o = t.pad,\n              i = t.dataFormat,\n              a = void 0 === i ? \"NHWC\" : i,\n              s = t.dilations,\n              u = void 0 === s ? [1, 1] : s,\n              c = t.dimRoundingMode,\n              l = t.bias,\n              h = t.activation,\n              p = void 0 === h ? \"linear\" : h,\n              f = t.preluActivationWeights;\n\n          if (p = p || \"linear\", !1 === xl(Mt.state.gradientDepth, p)) {\n            var d = Fu(e, n, r, o, a, u, c);\n            return null != l && (d = Qs(d, l)), Cl(d, p, f);\n          }\n\n          var m = $e(e, \"x\", \"conv2d\"),\n              g = $e(n, \"filter\", \"conv2d\"),\n              v = m,\n              y = !1;\n          3 === m.rank && (y = !0, v = m.as4D(1, m.shape[0], m.shape[1], m.shape[2])), S(4 === v.rank, function () {\n            return \"Error in fused conv2d: input must be rank 4, but got rank \" + v.rank + \".\";\n          }), S(4 === g.rank, function () {\n            return \"Error in fused conv2d: filter must be rank 4, but got rank \" + g.rank + \".\";\n          }), null != c && S(T(o), function () {\n            return \"Error in fused conv2d: pad must be an integer when using, dimRoundingMode \" + c + \" but got pad \" + o + \".\";\n          }), S(v.shape[3] === g.shape[2], function () {\n            return \"Error in conv2d: depth of input (\" + v.shape[3] + \") must match input depth for filter \" + g.shape[2] + \".\";\n          }), S(Kr(r, u), function () {\n            return \"Error in conv2D: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + u + \"'\";\n          }), S(\"NHWC\" === a, function () {\n            return \"Error in conv2d: got dataFormat of \" + a + \" but only NHWC is currently supported.\";\n          });\n          var b,\n              w,\n              x = qr(v.shape, g.shape, r, u, o, c);\n          null != l && (b = kt(b = $e(l, \"bias\", \"fused conv2d\"), m)[0], Lr(x.outShape, b.shape)), null != f && (w = $e(f, \"prelu weights\", \"fused conv2d\"));\n          var E = {\n            x: v,\n            $filter: g\n          };\n          null != l && (E.$bias = b), null != f && (E.$preluActivationWeights = w);\n          var C = Mt.runKernelFunc(function (t, e) {\n            var n = t.fusedConv2d({\n              input: v,\n              filter: g,\n              convInfo: x,\n              bias: b,\n              activation: p,\n              preluActivationWeights: w\n            });\n            return e([g, v, n]), n;\n          }, E, function (t, e) {\n            var n = e,\n                i = n[0],\n                a = n[1],\n                s = n[2],\n                c = Sl(t, s, p);\n            S($r(u), function () {\n              return \"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '\" + u + \"'\";\n            });\n            var h = {};\n            return null != l && (h = {\n              $bias: function () {\n                return El(b, c);\n              }\n            }), Object.assign({\n              x: function () {\n                return zu(a.shape, c, i, r, o);\n              },\n              $filter: function () {\n                return Bu(a, c, i.shape, r, o);\n              }\n            }, h);\n          });\n          return y ? C.as3D(C.shape[1], C.shape[2], C.shape[3]) : C;\n        }\n      }),\n          kl = an({\n        depthwiseConv2d_: function (t) {\n          var e = t.x,\n              n = t.filter,\n              r = t.strides,\n              o = t.pad,\n              i = t.dataFormat,\n              a = void 0 === i ? \"NHWC\" : i,\n              s = t.dilations,\n              u = void 0 === s ? [1, 1] : s,\n              c = t.dimRoundingMode,\n              l = t.bias,\n              h = t.activation,\n              p = void 0 === h ? \"linear\" : h,\n              f = t.preluActivationWeights;\n\n          if (!1 === xl(Mt.state.gradientDepth, p)) {\n            var d = qu(e, n, r, o, a, u, c);\n            return null != l && (d = Qs(d, l)), Cl(d, p, f);\n          }\n\n          var m = $e(e, \"x\", \"depthwiseConv2d\"),\n              g = $e(n, \"filter\", \"depthwiseConv2d\"),\n              v = m,\n              y = !1;\n          3 === m.rank && (y = !0, v = m.as4D(1, m.shape[0], m.shape[1], m.shape[2])), S(4 === v.rank, function () {\n            return \"Error in fused depthwiseConv2d: input must be rank 4, but got rank \" + v.rank + \".\";\n          }), S(4 === g.rank, function () {\n            return \"Error in fused depthwiseConv2d: filter must be rank 4, but got rank \" + g.rank + \".\";\n          }), S(v.shape[3] === g.shape[2], function () {\n            return \"Error in fused depthwiseConv2d: number of input channels (\" + v.shape[3] + \") must match the inChannels dimension in filter \" + g.shape[2] + \".\";\n          }), null == u && (u = [1, 1]), S(Kr(r, u), function () {\n            return \"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + u + \"'\";\n          }), null != c && S(T(o), function () {\n            return \"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode \" + c + \" but got pad \" + o + \".\";\n          });\n          var b,\n              w,\n              x = qr(v.shape, g.shape, r, u, o, c, !0);\n          null != l && (b = kt(b = $e(l, \"bias\", \"fused conv2d\"), m)[0], Lr(x.outShape, b.shape)), null != f && (w = $e(f, \"prelu weights\", \"fused depthwiseConv2d\"));\n          var E = {\n            x: v,\n            $filter: g\n          };\n          null != l && (E.$bias = b), null != f && (E.$preluActivationWeights = w);\n          var C = Mt.runKernelFunc(function (t, e) {\n            var n = t.fusedDepthwiseConv2D({\n              input: v,\n              filter: g,\n              convInfo: x,\n              bias: b,\n              activation: p,\n              preluActivationWeights: w\n            });\n            return e([v, g, n]), n;\n          }, E, function (t, e) {\n            S($r(u), function () {\n              return \"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\" + u + \"'\";\n            });\n            var n = e[0],\n                r = e[1],\n                o = e[2],\n                i = Sl(t, o, p),\n                a = {};\n            return null != l && (a = {\n              $bias: function () {\n                return El(b, i);\n              }\n            }), Object.assign({\n              x: function () {\n                return Vu(n.shape, i, r, x);\n              },\n              $filter: function () {\n                return Uu(n, i, r.shape, x);\n              }\n            }, a);\n          });\n          return y ? C.as3D(C.shape[1], C.shape[2], C.shape[3]) : C;\n        }\n      }),\n          Tl = Object.freeze({\n        matMul: Il,\n        conv2d: Al,\n        depthwiseConv2d: kl\n      }),\n          Nl = Object.freeze({\n        image: wl,\n        linalg: dl,\n        losses: ll,\n        spectral: jc,\n        fused: Tl,\n        signal: tl,\n        square: Ka,\n        conv1d: Du,\n        conv2d: Fu,\n        conv3d: Lu,\n        depthwiseConv2d: qu,\n        separableConv2d: ju,\n        conv2dTranspose: Wu,\n        conv3dTranspose: Gu,\n        op: an,\n        batchNormalization2d: Ds,\n        batchNormalization3d: Fs,\n        batchNormalization4d: Ls,\n        batchNormalization: Bs,\n        batchNorm: zs,\n        batchNorm2d: qs,\n        batchNorm3d: Vs,\n        batchNorm4d: Us,\n        booleanMaskAsync: function (t, e, n) {\n          return u(this, void 0, void 0, function () {\n            var r, o, i, a, s, u, l, h, p, f, d, m, g;\n            return c(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  for (r = $e(t, \"tensor\", \"boolMask\"), o = $e(e, \"mask\", \"boolMask\", \"bool\"), i = null == n ? 0 : n, a = o.rank, s = r.shape, S(a > 0, function () {\n                    return \"mask cannot be scalar\";\n                  }), E(s.slice(i, i + a), o.shape, \"mask's shape must match the first K dimensions of tensor's shape,\"), u = 1, l = i; l < i + a; l++) u *= s[l];\n\n                  return h = s.slice(0, i).concat([u], s.slice(i + a)), p = r.reshape(h), f = o.reshape([-1]), [4, Ks(f)];\n\n                case 1:\n                  return d = c.sent(), m = d.squeeze([1]), g = Pu(p, m, i), t !== r && r.dispose(), e !== o && o.dispose(), m.dispose(), p.dispose(), f.dispose(), d.dispose(), [2, g];\n              }\n            });\n          });\n        },\n        complex: sn,\n        real: un,\n        imag: cn,\n        concat: En,\n        concat1d: Cn,\n        concat2d: In,\n        concat3d: An,\n        concat4d: kn,\n        split: Tn,\n        matMul: Hu,\n        dot: $u,\n        outerProduct: Ku,\n        reverse: Qu,\n        reverse1d: Xu,\n        reverse2d: Yu,\n        reverse3d: Ju,\n        reverse4d: Zu,\n        maxPool: nc,\n        avgPool: rc,\n        pool: oc,\n        maxPool3d: ic,\n        avgPool3d: ac,\n        slice: sc,\n        slice1d: uc,\n        slice2d: cc,\n        slice3d: lc,\n        slice4d: hc,\n        abs: Qa,\n        acos: Xa,\n        acosh: Ya,\n        asin: Ja,\n        asinh: Za,\n        atan: ts,\n        atanh: es,\n        ceil: ns,\n        clipByValue: rs,\n        cos: os,\n        cosh: is,\n        erf: as,\n        exp: ss,\n        expm1: us,\n        floor: cs,\n        log: ls,\n        log1p: hs,\n        logSigmoid: ps,\n        neg: fs,\n        reciprocal: ds,\n        round: ms,\n        rsqrt: gs,\n        sigmoid: vs,\n        sign: ys,\n        isNaN: bs,\n        isInf: ws,\n        isFinite: xs,\n        sin: Ss,\n        sinh: Es,\n        softplus: Cs,\n        sqrt: Is,\n        step: As,\n        tan: ks,\n        tanh: Ts,\n        all: fc,\n        any: dc,\n        argMax: mc,\n        argMin: gc,\n        logSumExp: vc,\n        max: yc,\n        mean: bc,\n        min: wc,\n        moments: xc,\n        sum: Sc,\n        prod: Ec,\n        equal: gu,\n        equalStrict: vu,\n        greater: yu,\n        greaterEqual: bu,\n        greaterEqualStrict: wu,\n        greaterStrict: xu,\n        less: Su,\n        lessEqual: Eu,\n        lessEqualStrict: Cu,\n        lessStrict: Iu,\n        notEqual: Au,\n        notEqualStrict: ku,\n        add: Qs,\n        addN: Xs,\n        addStrict: Ys,\n        atan2: Js,\n        div: Zs,\n        divStrict: tu,\n        floorDiv: eu,\n        maximum: nu,\n        maximumStrict: ru,\n        minimum: ou,\n        minimumStrict: iu,\n        mod: au,\n        modStrict: su,\n        mul: uu,\n        mulStrict: cu,\n        pow: lu,\n        powStrict: hu,\n        squaredDifference: pu,\n        squaredDifferenceStrict: fu,\n        sub: du,\n        subStrict: mu,\n        elu: Cc,\n        leakyRelu: Ic,\n        prelu: Ac,\n        relu: kc,\n        relu6: Tc,\n        selu: Nc,\n        logicalAnd: js,\n        logicalNot: Ws,\n        logicalOr: Gs,\n        logicalXor: Hs,\n        where: $s,\n        whereAsync: Ks,\n        buffer: Vn,\n        print: function (t, e) {\n          void 0 === e && (e = !1), console.log(t.toString(e));\n        },\n        batchToSpaceND: Un,\n        cast: jn,\n        clone: Wn,\n        cumsum: Gn,\n        depthToSpace: Hn,\n        expandDims: $n,\n        eye: Kn,\n        multinomial: Qn,\n        oneHot: Xn,\n        pad: Yn,\n        pad1d: Jn,\n        pad2d: Zn,\n        pad3d: tr,\n        pad4d: er,\n        rand: nr,\n        randomNormal: rr,\n        randomGamma: or,\n        randomUniform: ir,\n        reshape: ar,\n        spaceToBatchND: sr,\n        squeeze: ur,\n        stack: cr,\n        tile: lr,\n        truncatedNormal: hr,\n        unstack: pr,\n        setdiff1dAsync: function (t, e) {\n          return u(this, void 0, void 0, function () {\n            var n, r, o, i, a, s, u, l, h, p;\n            return c(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  return n = $e(t, \"x\", \"setdiff1d\"), r = $e(e, \"y\", \"setdiff1d\"), S(n.dtype === r.dtype, function () {\n                    return \"x and y should have the same dtype, but got x (\" + n.dtype + \") and y (\" + r.dtype + \").\";\n                  }), S(1 === n.rank, function () {\n                    return \"x should be 1D tensor, but got x (\" + n.shape + \").\";\n                  }), S(1 === r.rank, function () {\n                    return \"y should be 1D tensor, but got y (\" + r.shape + \").\";\n                  }), [4, n.data()];\n\n                case 1:\n                  return o = c.sent(), [4, r.data()];\n\n                case 2:\n                  for (i = c.sent(), a = new Set(i), s = 0, h = 0; h < o.length; h++) a.has(o[h]) || s++;\n\n                  for (u = new ft([s], n.dtype), l = new ft([s], \"int32\"), h = 0, p = 0; h < o.length; h++) a.has(o[h]) || (u.values[p] = o[h], l.values[p] = h, p++);\n\n                  return [2, [u.toTensor(), l.toTensor()]];\n              }\n            });\n          });\n        },\n        fill: bn,\n        linspace: function (t, e, n) {\n          if (n <= 0) throw new Error(\"The number of values should be positive.\");\n          return Mt.runKernelFunc(function (r) {\n            return r.linspace(t, e, n);\n          }, {});\n        },\n        ones: vn,\n        range: wn,\n        scalar: pn,\n        tensor: ln,\n        tensor1d: fn,\n        tensor2d: dn,\n        tensor3d: mn,\n        tensor4d: gn,\n        tensor5d: function (t, e, n) {\n          if (C(t), null != e && 5 !== e.length) throw new Error(\"tensor5d() requires shape to have five numbers\");\n          var r = Ge(t, n);\n          if (5 !== r.length && 1 !== r.length) throw new Error(\"tensor5d() requires values to be number[][][][][] or flat/TypedArray\");\n          if (1 === r.length && null == e) throw new Error(\"tensor5d() requires shape to be provided when `values` are a flat array\");\n          return hn(t, e, r, n);\n        },\n        tensor6d: function (t, e, n) {\n          if (C(t), null != e && 6 !== e.length) throw new Error(\"tensor6d() requires shape to have six numbers\");\n          var r = Ge(t, n);\n          if (6 !== r.length && 1 !== r.length) throw new Error(\"tensor6d() requires values to be number[][][][][][] or flat/TypedArray\");\n          if (1 === r.length && null == e) throw new Error(\"tensor6d() requires shape to be provided when `values` are a flat array\");\n          return hn(t, e = e || r, r, n);\n        },\n        variable: function (t, e, n, r) {\n          return void 0 === e && (e = !0), Mt.makeVariable(t, e, n, r);\n        },\n        zeros: yn,\n        onesLike: xn,\n        zerosLike: Sn,\n        transpose: Pc,\n        softmax: Pr,\n        logSoftmax: Rr,\n        localResponseNormalization: Rc,\n        norm: _c,\n        gather: Pu,\n        unsortedSegmentSum: Ru,\n        basicLSTMCell: Mc,\n        multiRNNCell: Oc,\n        movingAverage: Dc,\n        stridedSlice: Fc,\n        topk: Lc,\n        scatterND: Bc,\n        fft: zc,\n        ifft: qc,\n        rfft: Vc,\n        irfft: Uc,\n        sparseToDense: Wc,\n        gatherND: Gc,\n        diag: Hc,\n        dropout: $c,\n        hannWindow: Xc,\n        hammingWindow: Yc,\n        frame: Jc,\n        stft: Zc,\n        inTopKAsync: function (t, e, n) {\n          return void 0 === n && (n = 1), u(this, void 0, void 0, function () {\n            var r, o, i, a, s, u, l, h, p, f, d, m, g, v;\n            return c(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  return r = $e(t, \"predictions\", \"inTopK\"), o = $e(e, \"targets\", \"inTopK\"), S(r.rank > 1, function () {\n                    return \"inTopK() expects the predictions to be of rank 2 or higher, but got \" + r.rank;\n                  }), S(r.rank - 1 === o.rank, function () {\n                    return \"predictions rank should be 1 larger than targets rank, but got predictions rank \" + r.rank + \" and targets rank \" + o.rank;\n                  }), E(r.shape.slice(0, r.shape.length - 1), o.shape, \"predictions's shape should be align with the targets' shape, except the last dimension.\"), i = r.shape[r.shape.length - 1], S(n > 0 && n <= i, function () {\n                    return \"'k' passed to inTopK() must be > 0 && <= the predictions last dimension (\" + i + \"), but got \" + n;\n                  }), [4, r.data()];\n\n                case 1:\n                  return a = c.sent(), [4, o.data()];\n\n                case 2:\n                  for (s = c.sent(), u = [a.length / i, i], h = u[1], p = F(\"bool\", l = u[0]), f = 0; f < l; f++) {\n                    for (d = f * h, m = a.subarray(d, d + h), g = [], v = 0; v < m.length; v++) g.push({\n                      value: m[v],\n                      index: v\n                    });\n\n                    for (g.sort(function (t, e) {\n                      return e.value - t.value;\n                    }), p[f] = 0, v = 0; v < n; v++) if (g[v].index === s[f]) {\n                      p[f] = 1;\n                      break;\n                    }\n                  }\n\n                  return t !== r && r.dispose(), e !== o && o.dispose(), [2, ln(p, o.shape, \"bool\")];\n              }\n            });\n          });\n        }\n      });\n\n      function Pl(t, e) {\n        Array.isArray(t) || (t = [t]), t.forEach(function (t) {\n          null != t && S(\"complex64\" !== t.dtype, function () {\n            return e + \" does not support complex64 tensors.\";\n          });\n        });\n      }\n\n      function Rl(t, e, n, r) {\n        if (\"linear\" === n) return t.linear(e);\n        if (\"relu\" === n) return t.relu(e);\n        if (\"elu\" === n) return t.elu(e);\n        if (\"relu6\" === n) return t.relu6(e);\n        if (\"prelu\" === n) return t.prelu(e, r);\n        throw new Error(\"Activation \" + n + \" has not been implemented for the CPU backend.\");\n      }\n\n      var _l = function (t) {\n        function e() {\n          var e = t.call(this) || this;\n\n          if (e.blockSize = 48, e.firstUse = !0, h().get(\"IS_BROWSER\")) {\n            var n = \"undefined\" != typeof OffscreenCanvas ? new OffscreenCanvas(300, 150) : \"undefined\" != typeof document ? document.createElement(\"canvas\") : null;\n            null !== n && (e.fromPixels2DContext = n.getContext(\"2d\"));\n          }\n\n          return e.data = new _r(e, Mt), e;\n        }\n\n        return s(e, t), e.prototype.write = function (t, e, n) {\n          this.firstUse && (this.firstUse = !1, h().get(\"IS_NODE\") && We(\"\\n============================\\nHi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\\n============================\\n\"));\n          var r = {};\n          return this.data.set(r, {\n            values: t,\n            dtype: n\n          }), r;\n        }, e.prototype.move = function (t, e, n, r) {\n          this.data.set(t, {\n            values: e,\n            dtype: r\n          });\n        }, e.prototype.numDataIds = function () {\n          return this.data.numDataIds();\n        }, e.prototype.fromPixels = function (t, e) {\n          if (null == t) throw new Error(\"pixels passed to tf.browser.fromPixels() can not be null\");\n          var n,\n              r,\n              o = t.data instanceof Uint8Array,\n              i = \"undefined\" != typeof ImageData && t instanceof ImageData,\n              a = \"undefined\" != typeof HTMLVideoElement && t instanceof HTMLVideoElement,\n              s = \"undefined\" != typeof HTMLImageElement && t instanceof HTMLImageElement,\n              u = a ? [t.videoWidth, t.videoHeight] : [t.width, t.height],\n              c = u[0],\n              l = u[1];\n          if (h().get(\"IS_NODE\") && null == t.getContext) throw new Error(\"When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package\");\n          if (null != t.getContext) n = t.getContext(\"2d\").getImageData(0, 0, c, l).data;else if (i || o) n = t.data;else {\n            if (!s && !a) throw new Error(\"pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData or {data: Uint32Array, width: number, height: number}, but was \" + t.constructor.name);\n            if (null == this.fromPixels2DContext) throw new Error(\"Can't read pixels from HTMLImageElement outside the browser.\");\n            this.fromPixels2DContext.canvas.width = c, this.fromPixels2DContext.canvas.height = l, this.fromPixels2DContext.drawImage(t, 0, 0, c, l), n = this.fromPixels2DContext.getImageData(0, 0, c, l).data;\n          }\n          if (4 === e) r = new Int32Array(n);else {\n            var p = c * l;\n            r = new Int32Array(p * e);\n\n            for (var f = 0; f < p; f++) for (var d = 0; d < e; ++d) r[f * e + d] = n[4 * f + d];\n          }\n          return mn(r, [l, c, e], \"int32\");\n        }, e.prototype.read = function (t) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (e) {\n              return [2, this.readSync(t)];\n            });\n          });\n        }, e.prototype.readSync = function (t) {\n          var e = this.data.get(t),\n              n = e.dtype,\n              r = e.complexTensors;\n          return \"complex64\" === n ? Zr(this.readSync(r.real.dataId), this.readSync(r.imag.dataId)) : this.data.get(t).values;\n        }, e.prototype.bufferSync = function (t) {\n          var e = this.readSync(t.dataId),\n              n = e;\n          if (\"string\" === t.dtype) try {\n            n = e.map(function (t) {\n              return ot(t);\n            });\n          } catch (t) {\n            throw new Error(\"Failed to decode encoded string bytes into utf-8\");\n          }\n          return Vn(t.shape, t.dtype, n);\n        }, e.prototype.makeOutput = function (t, e, n) {\n          var r = this.write(t, e, n);\n          return Mt.makeTensorFromDataId(r, e, n, this);\n        }, e.prototype.disposeData = function (t) {\n          if (this.data.has(t)) {\n            var e = this.data.get(t).complexTensors;\n            null != e && (e.real.dispose(), e.imag.dispose()), this.data.delete(t);\n          }\n        }, e.prototype.time = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e;\n            return c(this, function (n) {\n              return e = et(), t(), [2, {\n                kernelMs: et() - e\n              }];\n            });\n          });\n        }, e.prototype.memory = function () {\n          return {\n            unreliable: !0,\n            reasons: [\"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.\"]\n          };\n        }, e.prototype.complex = function (t, e) {\n          var n = this.makeOutput(null, t.shape, \"complex64\");\n          return this.data.get(n.dataId).complexTensors = {\n            real: Mt.keep(t.clone()),\n            imag: Mt.keep(e.clone())\n          }, n;\n        }, e.prototype.real = function (t) {\n          return this.data.get(t.dataId).complexTensors.real.clone();\n        }, e.prototype.imag = function (t) {\n          return this.data.get(t.dataId).complexTensors.imag.clone();\n        }, e.prototype.slice = function (t, e, n) {\n          if (Pl(t, \"slice\"), kr(t.shape, e, n)) {\n            var r = Tr(e, t.strides),\n                o = A(n);\n            return ln(this.readSync(t.dataId).subarray(r, r + o), n, t.dtype);\n          }\n\n          for (var i = Vn(n, t.dtype), a = this.bufferSync(t), s = 0; s < i.size; ++s) {\n            var u = i.indexToLoc(s).map(function (t, n) {\n              return t + e[n];\n            });\n            i.values[s] = a.get.apply(a, u);\n          }\n\n          return i.toTensor();\n        }, e.prototype.stridedSlice = function (t, e, n, r) {\n          Pl(t, \"stridedSlice\");\n          var o = Cr(e, n, r);\n          if (o.some(function (t) {\n            return 0 === t;\n          })) return ln([], o);\n\n          for (var i = Vn(o, t.dtype), a = this.bufferSync(t), s = 0; s < i.size; s++) {\n            for (var u = i.indexToLoc(s), c = new Array(u.length), l = 0; l < c.length; l++) c[l] = u[l] * r[l] + e[l];\n\n            i.set.apply(i, [a.get.apply(a, c)].concat(u));\n          }\n\n          return i.toTensor();\n        }, e.prototype.diag = function (t) {\n          for (var e = this.readSync(t.dataId), n = Vn([t.size, t.size], t.dtype), r = n.values, o = 0; o < e.length; o++) r[o * t.size + o] = e[o];\n\n          return n.toTensor();\n        }, e.prototype.unstack = function (t, e) {\n          for (var n = t.shape[e], r = new Array(t.rank - 1), o = 0, i = 0; i < t.rank; i++) i !== e && (r[o++] = t.shape[i]);\n\n          var a = new Array(t.rank).fill(0),\n              s = t.shape.slice();\n          s[e] = 1;\n          var u = new Array(n);\n\n          for (i = 0; i < u.length; i++) a[e] = i, u[i] = this.slice(t, a, s).reshape(r);\n\n          return u;\n        }, e.prototype.reverse = function (t, e) {\n          Pl(t, \"reverse\");\n\n          for (var n = Vn(t.shape, t.dtype), r = this.bufferSync(t), o = function (o) {\n            var i = n.indexToLoc(o),\n                a = i.slice();\n            e.forEach(function (e) {\n              return a[e] = t.shape[e] - 1 - a[e];\n            }), n.set.apply(n, [r.get.apply(r, a)].concat(i));\n          }, i = 0; i < n.size; i++) o(i);\n\n          return n.toTensor();\n        }, e.prototype.concat = function (t, e) {\n          var n = this;\n\n          if (\"complex64\" === t[0].dtype) {\n            var r = t.map(function (t) {\n              return un(t);\n            }),\n                o = t.map(function (t) {\n              return cn(t);\n            });\n            return sn(this.concat(r, e), this.concat(o, e));\n          }\n\n          var i = t.map(function (t) {\n            var n = A(t.shape.slice(e));\n            return t.as2D(-1, n);\n          }),\n              a = on(i.map(function (t) {\n            return t.shape;\n          }), 1),\n              s = Vn(a, t[0].dtype).values;\n\n          if (1 === i[0].shape[0]) {\n            var u = 0;\n            i.forEach(function (t) {\n              s.set(n.readSync(t.dataId), u), u += t.size;\n            });\n          } else {\n            var c = 0;\n            i.forEach(function (t) {\n              for (var e = n.readSync(t.dataId), r = 0, o = 0; o < t.shape[0]; ++o) for (var i = o * a[1] + c, u = 0; u < t.shape[1]; ++u) s[i + u] = e[r++];\n\n              c += t.shape[1];\n            });\n          }\n\n          var l = on(t.map(function (t) {\n            return t.shape;\n          }), e);\n          return ln(s, l, t[0].dtype);\n        }, e.prototype.neg = function (t) {\n          return Pl(t, \"neg\"), this.multiply(pn(-1), t);\n        }, e.prototype.add = function (t, e) {\n          return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function (t, e, n, r) {\n            return {\n              real: t + n,\n              imag: e + r\n            };\n          }) : this.broadcastedBinaryOp(t, e, It(t.dtype, e.dtype), function (t, e) {\n            return t + e;\n          });\n        }, e.prototype.addN = function (t) {\n          var e = this;\n          Pl(t, \"addN\");\n\n          for (var n = t.map(function (t) {\n            return e.readSync(t.dataId);\n          }), r = Vn(t[0].shape, t[0].dtype), o = r.values, i = 0; i < t.length; i++) for (var a = n[i], s = 0; s < o.length; s++) o[s] += a[s];\n\n          return r.toTensor();\n        }, e.prototype.subtract = function (t, e) {\n          return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function (t, e, n, r) {\n            return {\n              real: t - n,\n              imag: e - r\n            };\n          }) : this.broadcastedBinaryOp(t, e, It(t.dtype, e.dtype), function (t, e) {\n            return t - e;\n          });\n        }, e.prototype.pow = function (t, e) {\n          return Pl([t, e], \"pow\"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {\n            return Math.pow(t, e);\n          });\n        }, e.prototype.batchMatMul = function (t, e, n, r) {\n          Pl([t, e], \"matMul\");\n\n          for (var o = n ? t.shape[1] : t.shape[2], i = n ? t.shape[2] : t.shape[1], a = r ? e.shape[1] : e.shape[2], s = t.shape[0], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = n ? [t.strides[0], 1, t.strides[1]] : [t.strides[0], t.strides[1], 1], h = l[0], p = l[1], f = l[2], d = r ? [1, e.strides[1], e.strides[0]] : [e.strides[1], 1, e.strides[0]], m = d[0], g = d[1], v = d[2], y = i * a, b = Vn([s, i, a], t.dtype), w = b.values, x = this.blockSize, S = 0; S < s; S++) for (var E = 0; E < i; E += x) for (var C = 0; C < a; C += x) for (var I = 0; I < o; I += x) for (var A = Math.min(E + x, i), k = Math.min(C + x, a), T = Math.min(I + x, o), N = E; N < A; N++) for (var P = C; P < k; P++) {\n            for (var R = 0, _ = I; _ < T; _++) R += u[S * h + N * p + _ * f] * c[_ * m + P * g + S * v];\n\n            w[S * y + (N * a + P)] += R;\n          }\n\n          return b.toTensor();\n        }, e.prototype.fusedBatchMatMul = function (t) {\n          var e = t.a,\n              n = t.b,\n              r = t.transposeA,\n              o = t.transposeB,\n              i = t.bias,\n              a = t.activation,\n              s = t.preluActivationWeights,\n              u = this.batchMatMul(e, n, r, o);\n          return i && (u = this.add(u, i)), a && (u = Rl(this, u, a, s)), u;\n        }, e.prototype.multiply = function (t, e) {\n          return \"complex64\" === t.dtype || \"complex64\" === e.dtype ? this.broadcastedBinaryComplexOp(t.cast(\"complex64\"), e.cast(\"complex64\"), function (t, e, n, r) {\n            return {\n              real: t * n - e * r,\n              imag: t * r + e * n\n            };\n          }) : this.broadcastedBinaryOp(t, e, It(t.dtype, e.dtype), function (t, e) {\n            return t * e;\n          });\n        }, e.prototype.realDivide = function (t, e) {\n          return Pl([t, e], \"realDivide\"), this.broadcastedBinaryOp(t, e, \"float32\", function (t, e) {\n            return t / e;\n          });\n        }, e.prototype.floorDiv = function (t, e) {\n          return Pl([t, e], \"floorDiv\"), this.broadcastedBinaryOp(t, e, \"int32\", function (t, e) {\n            return Math.floor(t / e);\n          });\n        }, e.prototype.sum = function (t, e) {\n          Pl(t, \"sum\"), Ze(\"sum\", e, t.rank);\n\n          for (var n = Ye(t.shape, e), r = n[0], o = n[1], i = yn(r, It(t.dtype, \"int32\")), a = A(o), s = this.readSync(i.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {\n            for (var l = c * a, h = 0, p = 0; p < a; ++p) h += u[l + p];\n\n            s[c] = h;\n          }\n\n          return i;\n        }, e.prototype.prod = function (t, e) {\n          Pl(t, \"sum\");\n\n          for (var n = Ye(t.shape, e), r = n[0], o = n[1], i = yn(r, It(t.dtype, \"int32\")), a = A(o), s = this.readSync(i.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {\n            for (var l = c * a, h = 1, p = 0; p < a; ++p) h *= u[l + p];\n\n            s[c] = h;\n          }\n\n          return i;\n        }, e.prototype.unsortedSegmentSum = function (t, e, n) {\n          Pl(t, \"unsortedSegmentSum\");\n\n          for (var r = [], o = t.rank - e.rank, i = 0; i < o; ++i) e = e.expandDims(i + 1);\n\n          for (i = 0; i < n; ++i) {\n            var a = pn(i, \"int32\"),\n                s = gu(a, e).asType(\"float32\").mul(t).sum(0);\n            r.push(s);\n          }\n\n          return cr(r);\n        }, e.prototype.argMin = function (t, e) {\n          Pl(t, \"argMin\");\n          var n = [e];\n          Ze(\"argMin\", n, t.rank);\n\n          for (var r = Ye(t.shape, n), o = r[0], i = r[1], a = yn(o, \"int32\"), s = A(i), u = this.readSync(a.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {\n            for (var h = l * s, p = c[h], f = 0, d = 0; d < s; ++d) {\n              var m = c[h + d];\n              m < p && (p = m, f = d);\n            }\n\n            u[l] = f;\n          }\n\n          return a;\n        }, e.prototype.argMax = function (t, e) {\n          Pl(t, \"argMax\");\n          var n = [e];\n          Ze(\"argMax\", n, t.rank);\n\n          for (var r = Ye(t.shape, n), o = r[0], i = r[1], a = yn(o, \"int32\"), s = A(i), u = this.readSync(a.dataId), c = this.readSync(t.dataId), l = 0; l < u.length; ++l) {\n            for (var h = l * s, p = c[h], f = 0, d = 0; d < s; ++d) {\n              var m = c[h + d];\n              m > p && (p = m, f = d);\n            }\n\n            u[l] = f;\n          }\n\n          return a;\n        }, e.prototype.cumsum = function (t, e, n, r) {\n          if (Pl(t, \"cumsum\"), e !== t.rank - 1) throw new Error(\"backend.cumsum in CPU expects an inner-most axis=\" + (t.rank - 1) + \" but got axis=\" + e);\n\n          for (var o = It(t.dtype, \"int32\"), i = yn(t.shape, o), a = this.readSync(i.dataId), s = this.readSync(t.dataId), u = t.shape[t.rank - 1], c = r ? function (t, e) {\n            return t + u - e - 1;\n          } : function (t, e) {\n            return t + e;\n          }, l = 0; l < s.length; l += u) for (var h = 0; h < u; h++) {\n            var p = c(l, h);\n            if (0 === h) a[p] = n ? 0 : s[p];else {\n              var f = c(l, h - 1);\n              a[p] = n ? s[f] + a[f] : s[p] + a[f];\n            }\n          }\n\n          return i;\n        }, e.prototype.equal = function (t, e) {\n          return Pl([t, e], \"equal\"), this.broadcastedBinaryOp(t, e, \"bool\", function (t, e) {\n            return t === e ? 1 : 0;\n          });\n        }, e.prototype.notEqual = function (t, e) {\n          return Pl([t, e], \"notEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function (t, e) {\n            return t !== e ? 1 : 0;\n          });\n        }, e.prototype.less = function (t, e) {\n          return Pl([t, e], \"less\"), this.broadcastedBinaryOp(t, e, \"bool\", function (t, e) {\n            return t < e ? 1 : 0;\n          });\n        }, e.prototype.lessEqual = function (t, e) {\n          return Pl([t, e], \"lessEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function (t, e) {\n            return t <= e ? 1 : 0;\n          });\n        }, e.prototype.greater = function (t, e) {\n          return Pl([t, e], \"greater\"), this.broadcastedBinaryOp(t, e, \"bool\", function (t, e) {\n            return t > e ? 1 : 0;\n          });\n        }, e.prototype.greaterEqual = function (t, e) {\n          return Pl([t, e], \"greaterEqual\"), this.broadcastedBinaryOp(t, e, \"bool\", function (t, e) {\n            return t >= e ? 1 : 0;\n          });\n        }, e.prototype.logicalNot = function (t) {\n          Pl(t, \"logicalNot\");\n\n          for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r] ? 0 : 1;\n\n          return this.makeOutput(n, t.shape, \"bool\");\n        }, e.prototype.logicalAnd = function (t, e) {\n          return Pl([t, e], \"logicalAnd\"), this.broadcastedBinaryOp(t, e, \"bool\", function (t, e) {\n            return t && e;\n          });\n        }, e.prototype.logicalOr = function (t, e) {\n          return Pl([t, e], \"logicalOr\"), this.broadcastedBinaryOp(t, e, \"bool\", function (t, e) {\n            return t || e;\n          });\n        }, e.prototype.select = function (t, e, n) {\n          Pl([t, e, n], \"select\");\n\n          for (var r = this.readSync(t.dataId), o = this.readSync(e.dataId), i = this.readSync(n.dataId), a = yn(e.shape, It(e.dtype, n.dtype)), s = this.readSync(a.dataId), u = 0, c = 0 === t.rank || t.rank > 1 || 1 === e.rank ? 1 : A(e.shape.slice(1)), l = 0; l < r.length; l++) for (var h = 0; h < c; h++) 1 === r[l] ? s[u++] = o[l] : s[u++] = i[l];\n\n          return a;\n        }, e.prototype.where = function (t) {\n          Pl([t], \"where\");\n          var e = this.readSync(t.dataId);\n          return uo(t.shape, e);\n        }, e.prototype.topk = function (t, e, n) {\n          return Pl(t, \"topk\"), so(this.readSync(t.dataId), t.shape, t.dtype, e);\n        }, e.prototype.min = function (t, e) {\n          Pl(t, \"min\"), Ze(\"min\", e, t.rank);\n\n          for (var n = Ye(t.shape, e), r = n[0], o = n[1], i = yn(r, t.dtype), a = A(o), s = this.readSync(i.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {\n            for (var l = c * a, h = u[l], p = 0; p < a; ++p) {\n              var f = u[l + p];\n              f < h && (h = f);\n            }\n\n            s[c] = h;\n          }\n\n          return i;\n        }, e.prototype.minimum = function (t, e) {\n          return Pl([t, e], \"minimum\"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {\n            return Math.min(t, e);\n          });\n        }, e.prototype.mod = function (t, e) {\n          return Pl([t, e], \"mod\"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {\n            var n = t % e;\n            return t < 0 && e < 0 || t >= 0 && e >= 0 ? n : (n + e) % e;\n          });\n        }, e.prototype.max = function (t, e) {\n          Pl(t, \"max\"), Ze(\"max\", e, t.rank);\n\n          for (var n = Ye(t.shape, e), r = n[0], o = n[1], i = yn(r, t.dtype), a = A(o), s = this.readSync(i.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {\n            for (var l = c * a, h = u[l], p = 0; p < a; ++p) {\n              var f = u[l + p];\n              f > h && (h = f);\n            }\n\n            s[c] = h;\n          }\n\n          return i;\n        }, e.prototype.maximum = function (t, e) {\n          return Pl([t, e], \"maximum\"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {\n            return Math.max(t, e);\n          });\n        }, e.prototype.all = function (t, e) {\n          Pl(t, \"all\"), Ze(\"all\", e, t.rank);\n\n          for (var n = Ye(t.shape, e), r = n[0], o = n[1], i = yn(r, t.dtype), a = A(o), s = this.readSync(i.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {\n            for (var l = c * a, h = u[l], p = 0; p < a; ++p) {\n              var f = u[l + p];\n              h = h && f;\n            }\n\n            s[c] = h;\n          }\n\n          return i;\n        }, e.prototype.any = function (t, e) {\n          Pl(t, \"any\"), Ze(\"any\", e, t.rank);\n\n          for (var n = Ye(t.shape, e), r = n[0], o = n[1], i = yn(r, t.dtype), a = A(o), s = this.readSync(i.dataId), u = this.readSync(t.dataId), c = 0; c < s.length; ++c) {\n            for (var l = c * a, h = u[l], p = 0; p < a; ++p) {\n              var f = u[l + p];\n              h = h || f;\n            }\n\n            s[c] = h;\n          }\n\n          return i;\n        }, e.prototype.squaredDifference = function (t, e) {\n          return Pl([t, e], \"squaredDifference\"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {\n            var n = t - e;\n            return n * n;\n          });\n        }, e.prototype.ceil = function (t) {\n          Pl(t, \"ceil\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.ceil(e[r]);\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.floor = function (t) {\n          Pl(t, \"floor\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.floor(e[r]);\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.sign = function (t) {\n          Pl(t, \"x\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) e[r] < 0 ? n[r] = -1 : e[r] > 0 ? n[r] = 1 : n[r] = 0;\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.isNaN = function (t) {\n          Pl(t, \"x\");\n\n          for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isNaN(e[r]) && (n[r] = 1);\n\n          return this.makeOutput(n, t.shape, \"bool\");\n        }, e.prototype.isInf = function (t) {\n          Pl(t, \"x\");\n\n          for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Math.abs(e[r]) === 1 / 0 && (n[r] = 1);\n\n          return this.makeOutput(n, t.shape, \"bool\");\n        }, e.prototype.isFinite = function (t) {\n          Pl(t, \"x\");\n\n          for (var e = this.readSync(t.dataId), n = new Uint8Array(e.length), r = 0; r < e.length; ++r) Number.isFinite(e[r]) && (n[r] = 1);\n\n          return this.makeOutput(n, t.shape, \"bool\");\n        }, e.prototype.round = function (t) {\n          Pl(t, \"round\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {\n            var o = Math.floor(e[r]);\n            e[r] - o < .5 ? n[r] = Math.floor(e[r]) : e[r] - o > .5 ? n[r] = Math.ceil(e[r]) : n[r] = o % 2 == 0 ? o : o + 1;\n          }\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.exp = function (t) {\n          Pl(t, \"exp\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.exp(e[r]);\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.expm1 = function (t) {\n          Pl(t, \"expm1\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = Math.expm1(e[r]);\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.log = function (t) {\n          Pl(t, \"log\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {\n            var o = e[r];\n            n[r] = Math.log(o);\n          }\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.log1p = function (t) {\n          Pl(t, \"log1p\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {\n            var o = e[r];\n            n[r] = Math.log1p(o);\n          }\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.sqrt = function (t) {\n          Pl(t, \"sqrt\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {\n            var o = e[r];\n            n[r] = Math.sqrt(o);\n          }\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.rsqrt = function (t) {\n          Pl(t, \"rsqrt\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) {\n            var o = e[r];\n            n[r] = 1 / Math.sqrt(o);\n          }\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.reciprocal = function (t) {\n          Pl(t, \"reciprocal\");\n\n          for (var e = this.readSync(t.dataId), n = new Float32Array(e.length), r = 0; r < e.length; ++r) n[r] = 1 / e[r];\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.linear = function (t) {\n          return t;\n        }, e.prototype.relu = function (t) {\n          Pl(t, \"relu\");\n\n          for (var e = yn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) n[o] = Math.max(0, r[o]);\n\n          return e;\n        }, e.prototype.relu6 = function (t) {\n          Pl(t, \"relu\");\n\n          for (var e = yn(t.shape, t.dtype), n = this.readSync(e.dataId), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) n[o] = Math.min(Math.max(0, r[o]), 6);\n\n          return e;\n        }, e.prototype.prelu = function (t, e) {\n          return Pl([t, e], \"prelu\"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {\n            return t < 0 ? e * t : t;\n          });\n        }, e.prototype.elu = function (t) {\n          Pl(t, \"elu\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {\n            var o = n[r];\n            e[r] = o >= 0 ? o : Math.exp(o) - 1;\n          }\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.eluDer = function (t, e) {\n          Pl([t, e], \"eluDer\");\n\n          for (var n = new Float32Array(e.size), r = this.readSync(e.dataId), o = this.readSync(t.dataId), i = 0; i < r.length; ++i) {\n            var a = r[i];\n            n[i] = a >= 1 ? o[i] : o[i] * (a + 1);\n          }\n\n          return this.makeOutput(n, e.shape, \"float32\");\n        }, e.prototype.selu = function (t) {\n          Pl(t, \"selu\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {\n            var o = n[r];\n            e[r] = o >= 0 ? 1.0507009873554805 * o : 1.7580993408473768 * (Math.exp(o) - 1);\n          }\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.clip = function (t, e, n) {\n          Pl(t, \"clip\");\n\n          for (var r = new Float32Array(t.size), o = this.readSync(t.dataId), i = 0; i < o.length; ++i) {\n            var a = o[i];\n            r[i] = a > n ? n : a < e ? e : a;\n          }\n\n          return this.makeOutput(r, t.shape, \"float32\");\n        }, e.prototype.abs = function (t) {\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.abs(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.complexAbs = function (t) {\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < t.size; ++r) {\n            var o = n[2 * r],\n                i = n[2 * r + 1];\n            e[r] = Math.hypot(o, i);\n          }\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.int = function (t) {\n          Pl(t, \"int\");\n\n          for (var e = new Int32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = n[r];\n\n          return this.makeOutput(e, t.shape, \"int32\");\n        }, e.prototype.sigmoid = function (t) {\n          Pl(t, \"sigmoid\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = 1 / (1 + Math.exp(-n[r]));\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.softplus = function (t) {\n          Pl(t, \"softplus\");\n\n          for (var e = Math.log(1.1920928955078125e-7) + 2, n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {\n            var i,\n                a = r[o] > -e,\n                s = r[o] < e,\n                u = Math.exp(r[o]);\n            i = s ? u : a ? r[o] : Math.log(1 + u), n[o] = i;\n          }\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.sin = function (t) {\n          Pl(t, \"sin\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sin(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.cos = function (t) {\n          Pl(t, \"cos\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cos(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.tan = function (t) {\n          Pl(t, \"tan\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.tan(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.asin = function (t) {\n          Pl(t, \"asin\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asin(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.acos = function (t) {\n          Pl(t, \"acos\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acos(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.atan = function (t) {\n          Pl(t, \"atan\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atan(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.atan2 = function (t, e) {\n          return Pl([t, e], \"atan2\"), this.broadcastedBinaryOp(t, e, t.dtype, function (t, e) {\n            return Math.atan2(t, e);\n          });\n        }, e.prototype.sinh = function (t) {\n          Pl(t, \"sinh\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.sinh(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.cosh = function (t) {\n          Pl(t, \"cosh\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.cosh(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.tanh = function (t) {\n          Pl(t, \"tanh\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = N(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.asinh = function (t) {\n          Pl(t, \"asinh\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.asinh(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.acosh = function (t) {\n          Pl(t, \"acosh\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.acosh(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.atanh = function (t) {\n          Pl(t, \"atanh\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) e[r] = Math.atanh(n[r]);\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.erf = function (t) {\n          Pl(t, \"erf\");\n\n          for (var e = new Float32Array(t.size), n = this.readSync(t.dataId), r = 0; r < n.length; ++r) {\n            var o = Math.sign(n[r]),\n                i = Math.abs(n[r]),\n                a = 1 / (1 + .3275911 * i);\n            e[r] = o * (1 - ((((1.061405429 * a - 1.453152027) * a + 1.421413741) * a - .284496736) * a + .254829592) * a * Math.exp(-i * i));\n          }\n\n          return this.makeOutput(e, t.shape, \"float32\");\n        }, e.prototype.step = function (t, e) {\n          void 0 === e && (e = 0), Pl(t, \"step\");\n\n          for (var n = new Float32Array(t.size), r = this.readSync(t.dataId), o = 0; o < r.length; ++o) {\n            var i = r[o];\n            isNaN(i) ? n[o] = NaN : n[o] = i > 0 ? 1 : e;\n          }\n\n          return this.makeOutput(n, t.shape, \"float32\");\n        }, e.prototype.fusedConv2d = function (t) {\n          var e = t.input,\n              n = t.filter,\n              r = t.convInfo,\n              o = t.bias,\n              i = t.activation,\n              a = t.preluActivationWeights,\n              s = this.conv2d(e, n, r);\n          return o && (s = this.add(s, o)), i && (s = Rl(this, s, i, a)), s;\n        }, e.prototype.conv2d = function (t, e, n) {\n          Pl([t, e], \"conv2d\");\n\n          for (var r = n.filterHeight, o = n.filterWidth, i = n.dilationHeight, a = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = \"channelsLast\" === n.dataFormat, l = Vn(n.outShape, t.dtype), h = t.strides[0], p = c ? t.strides[1] : t.strides[2], f = c ? t.strides[2] : 1, d = c ? 1 : t.strides[1], m = l.strides[0], g = c ? l.strides[1] : l.strides[2], v = c ? l.strides[2] : 1, y = c ? 1 : l.strides[1], b = this.readSync(t.dataId), w = this.readSync(e.dataId), x = l.values, S = 0; S < n.batchSize; ++S) for (var E = S * h, C = S * m, I = 0; I < n.outHeight; ++I) for (var A = C + I * g, k = I * n.strideHeight - u, T = 0; T < r; T++) {\n            var N = k + T * i;\n            if (!(N < 0 || N >= n.inHeight)) for (var P = T * e.strides[0], R = E + N * p, _ = 0; _ < n.outWidth; ++_) for (var M = A + _ * v, O = _ * n.strideWidth - s, D = 0; D < o; D++) {\n              var F = O + D * a;\n              if (!(F < 0 || F >= n.inWidth)) for (var L = R + F * f, B = P + D * e.strides[1], z = 0; z < n.inChannels; ++z) {\n                for (var q = b[L + z * d], V = 0; V < n.outChannels; ++V) x[M + V * y] += q * w[B + V];\n\n                B += n.outChannels;\n              }\n            }\n          }\n\n          return l.toTensor();\n        }, e.prototype.conv3d = function (t, e, n) {\n          for (var r = n.filterDepth, o = n.filterHeight, i = n.filterWidth, a = n.dilationDepth, s = n.dilationHeight, u = n.dilationWidth, c = n.padInfo.front, l = n.padInfo.left, h = n.padInfo.top, p = Vn(n.outShape, t.dtype), f = this.readSync(t.dataId), d = this.readSync(e.dataId), m = p.values, g = 0; g < n.batchSize; ++g) for (var v = g * t.strides[0], y = g * p.strides[0], b = 0; b < n.outDepth; ++b) for (var w = y + b * p.strides[1], x = b * n.strideDepth - c, S = 0; S < r; S++) {\n            var E = x + S * a;\n            if (!(E < 0 || E >= n.inDepth)) for (var C = S * e.strides[0], I = v + E * t.strides[1], A = 0; A < n.outHeight; ++A) for (var k = w + A * p.strides[2], T = A * n.strideHeight - h, N = 0; N < o; N++) {\n              var P = T + N * s;\n              if (!(P < 0 || P >= n.inHeight)) for (var R = C + N * e.strides[1], _ = I + P * t.strides[2], M = 0; M < n.outWidth; ++M) for (var O = k + M * n.outChannels, D = M * n.strideWidth - l, F = 0; F < i; F++) {\n                var L = D + F * u;\n                if (!(L < 0 || L >= n.inWidth)) for (var B = R + F * e.strides[2], z = _ + L * n.inChannels, q = B, V = 0; V < n.inChannels; ++V) {\n                  for (var U = f[z + V], j = 0; j < n.outChannels; ++j) m[O + j] += U * d[q + j];\n\n                  q += n.outChannels;\n                }\n              }\n            }\n          }\n\n          return p.toTensor();\n        }, e.prototype.conv2dDerInput = function (t, e, n) {\n          Pl([t, e], \"conv2dDerInput\");\n\n          for (var r = Vn(n.inShape, \"float32\"), o = r.values, i = this.readSync(t.dataId), a = this.readSync(e.dataId), s = e.strides, u = s[0], c = s[1], l = s[2], h = n.batchSize, p = n.filterHeight, f = n.filterWidth, d = n.inChannels, m = n.inHeight, g = n.inWidth, v = n.outChannels, y = n.outHeight, b = n.outWidth, w = n.strideHeight, x = n.strideWidth, S = n.dataFormat, E = p - 1 - n.padInfo.top, C = f - 1 - n.padInfo.left, I = \"channelsLast\" === S, A = r.strides[0], k = I ? r.strides[1] : r.strides[2], T = I ? r.strides[2] : 1, N = I ? 1 : r.strides[1], P = t.strides[0], R = I ? t.strides[1] : t.strides[2], _ = I ? t.strides[2] : 1, M = I ? 1 : t.strides[1], O = 0; O < h; ++O) for (var D = 0; D < d; ++D) for (var F = 0; F < m; ++F) for (var L = F - E, B = Math.max(0, Math.ceil(L / w)), z = Math.min(y, (p + L) / w), q = 0; q < g; ++q) {\n            for (var V = q - C, U = Math.max(0, Math.ceil(V / x)), j = Math.min(b, (f + V) / x), W = 0, G = B; G < z; ++G) for (var H = G * w - L, $ = U; $ < j; ++$) for (var K = P * O + R * G + _ * $, Q = u * (p - 1 - H) + c * (f - 1 - ($ * x - V)) + l * D, X = 0; X < v; ++X) W += i[K + M * X] * a[Q + X];\n\n            o[A * O + k * F + T * q + N * D] = W;\n          }\n\n          return r.toTensor();\n        }, e.prototype.conv3dDerInput = function (t, e, n) {\n          for (var r = Vn(n.inShape, \"float32\"), o = r.values, i = r.strides, a = i[0], s = i[1], u = i[2], c = i[3], l = this.readSync(t.dataId), h = t.strides, p = h[0], f = h[1], d = h[2], m = h[3], g = this.readSync(e.dataId), v = e.strides, y = v[0], b = v[1], w = v[2], x = v[3], S = n.batchSize, E = n.filterDepth, C = n.filterHeight, I = n.filterWidth, A = n.inChannels, k = n.inDepth, T = n.inHeight, N = n.inWidth, P = n.outChannels, R = n.outDepth, _ = n.outHeight, M = n.outWidth, O = n.strideDepth, D = n.strideHeight, F = n.strideWidth, L = E - 1 - n.padInfo.front, B = C - 1 - n.padInfo.top, z = I - 1 - n.padInfo.left, q = 0; q < S; ++q) for (var V = 0; V < A; ++V) for (var U = 0; U < k; ++U) for (var j = U - L, W = Math.max(0, Math.ceil(j / O)), G = Math.min(R, (E + j) / O), H = 0; H < T; ++H) for (var $ = H - B, K = Math.max(0, Math.ceil($ / D)), Q = Math.min(_, (C + $) / D), X = 0; X < N; ++X) {\n            for (var Y = X - z, J = Math.max(0, Math.ceil(Y / F)), Z = Math.min(M, (I + Y) / F), tt = 0, et = W; et < G; ++et) for (var nt = et * O - j, rt = K; rt < Q; ++rt) for (var ot = rt * D - $, it = J; it < Z; ++it) for (var at = p * q + f * et + d * rt + m * it, st = y * (E - 1 - nt) + b * (C - 1 - ot) + w * (I - 1 - (it * F - Y)) + x * V, ut = 0; ut < P; ++ut) tt += l[at + ut] * g[st + ut];\n\n            o[a * q + s * U + u * H + c * X + V] = tt;\n          }\n\n          return r.toTensor();\n        }, e.prototype.conv2dDerFilter = function (t, e, n) {\n          Pl([t, e], \"conv2dDerFilter\");\n\n          for (var r = n.strideHeight, o = n.strideWidth, i = n.filterHeight, a = n.filterWidth, s = \"channelsLast\" === n.dataFormat, u = Vn(n.filterShape, \"float32\"), c = n.padInfo.left, l = n.padInfo.top, h = this.bufferSync(t), p = this.bufferSync(e), f = 0; f < i; ++f) for (var d = Math.max(0, Math.ceil((l - f) / r)), m = Math.min(n.outHeight, (n.inHeight + l - f) / r), g = 0; g < a; ++g) for (var v = Math.max(0, Math.ceil((c - g) / o)), y = Math.min(n.outWidth, (n.inWidth + c - g) / o), b = 0; b < n.inChannels; ++b) for (var w = 0; w < n.outChannels; ++w) {\n            for (var x = 0, S = 0; S < n.batchSize; ++S) for (var E = d; E < m; ++E) for (var C = f + E * r - l, I = v; I < y; ++I) {\n              var A = g + I * o - c;\n              x += s ? h.get(S, C, A, b) * p.get(S, E, I, w) : h.get(S, b, C, A) * p.get(S, w, E, I);\n            }\n\n            u.set(x, f, g, b, w);\n          }\n\n          return u.toTensor();\n        }, e.prototype.conv3dDerFilter = function (t, e, n) {\n          for (var r = n.strideDepth, o = n.strideHeight, i = n.strideWidth, a = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = Vn(n.filterShape, \"float32\"), l = c.values, h = c.strides, p = h[0], f = h[1], d = h[2], m = h[3], g = this.readSync(e.dataId), v = e.strides, y = v[0], b = v[1], w = v[2], x = v[3], S = this.readSync(t.dataId), E = t.strides, C = E[0], I = E[1], A = E[2], k = E[3], T = n.padInfo.front, N = n.padInfo.left, P = n.padInfo.top, R = 0; R < a; ++R) for (var _ = Math.max(0, Math.ceil((T - R) / r)), M = Math.min(n.outDepth, (n.inDepth + T - R) / r), O = R * p, D = 0; D < s; ++D) for (var F = Math.max(0, Math.ceil((P - D) / o)), L = Math.min(n.outHeight, (n.inHeight + P - D) / o), B = D * f + O, z = 0; z < u; ++z) for (var q = Math.max(0, Math.ceil((N - z) / i)), V = Math.min(n.outWidth, (n.inWidth + N - z) / i), U = z * d + B, j = 0; j < n.inChannels; ++j) for (var W = j * m + U, G = 0; G < n.outChannels; ++G) {\n            for (var H = 0, $ = 0; $ < n.batchSize; ++$) for (var K = $ * C, Q = $ * y, X = _; X < M; ++X) for (var Y = (R + X * r - T) * I + K, J = X * b + Q, Z = F; Z < L; ++Z) for (var tt = (D + Z * o - P) * A + Y, et = Z * w + J, nt = q; nt < V; ++nt) {\n              var rt = nt * x + et;\n              H += S[(z + nt * i - N) * k + tt + j] * g[rt + G];\n            }\n\n            l[W + G] = H;\n          }\n\n          return c.toTensor();\n        }, e.prototype.fusedDepthwiseConv2D = function (t) {\n          var e = t.input,\n              n = t.filter,\n              r = t.convInfo,\n              o = t.bias,\n              i = t.activation,\n              a = t.preluActivationWeights,\n              s = this.depthwiseConv2D(e, n, r);\n          return o && (s = this.add(s, o)), i && (s = Rl(this, s, i, a)), s;\n        }, e.prototype.depthwiseConv2D = function (t, e, n) {\n          Pl([t, e], \"depthwiseConv2D\");\n\n          for (var r = n.filterHeight, o = n.filterWidth, i = n.dilationHeight, a = n.dilationWidth, s = n.padInfo.left, u = n.padInfo.top, c = n.outChannels / n.inChannels, l = Vn(n.outShape, t.dtype), h = this.readSync(t.dataId), p = this.readSync(e.dataId), f = l.values, d = 0; d < n.batchSize; ++d) for (var m = d * t.strides[0], g = d * l.strides[0], v = 0; v < n.outHeight; ++v) for (var y = g + v * l.strides[1], b = v * n.strideHeight - s, w = 0; w < r; ++w) {\n            var x = b + w * i;\n            if (!(x < 0 || x >= n.inHeight)) for (var S = w * e.strides[0], E = m + x * t.strides[1], C = 0; C < n.outWidth; ++C) for (var I = y + C * l.strides[2], A = C * n.strideWidth - u, k = 0; k < o; ++k) {\n              var T = A + k * a;\n              if (!(T < 0 || T >= n.inWidth)) for (var N = S + k * e.strides[1], P = E + T * n.inChannels, R = I, _ = N, M = 0; M < n.inChannels; ++M) {\n                for (var O = h[P + M], D = 0; D < c; ++D) f[R + D] += O * p[_ + D];\n\n                R += c, _ += c;\n              }\n            }\n          }\n\n          return l.toTensor();\n        }, e.prototype.depthwiseConv2DDerInput = function (t, e, n) {\n          Pl([t, e], \"depthwiseConv2DDerInput\");\n\n          for (var r = Vn(n.inShape, \"float32\"), o = r.values, i = r.strides, a = i[0], s = i[1], u = i[2], c = this.readSync(t.dataId), l = t.strides, h = l[0], p = l[1], f = l[2], d = this.readSync(e.dataId), m = e.strides, g = m[0], v = m[1], y = m[2], b = n.batchSize, w = n.filterHeight, x = n.filterWidth, S = n.inChannels, E = n.inHeight, C = n.inWidth, I = n.outChannels, A = n.outHeight, k = n.outWidth, T = n.strideHeight, N = n.strideWidth, P = w - 1 - n.padInfo.top, R = x - 1 - n.padInfo.left, _ = I / S, M = 0; M < b; ++M) for (var O = 0; O < S; ++O) for (var D = 0; D < E; ++D) for (var F = D - P, L = Math.max(0, Math.ceil(F / T)), B = Math.min(A, (w + F) / T), z = 0; z < C; ++z) {\n            for (var q = z - R, V = Math.max(0, Math.ceil(q / N)), U = Math.min(k, (x + q) / N), j = 0, W = L; W < B; ++W) for (var G = W * T - F, H = V; H < U; ++H) for (var $ = h * M + p * W + f * H, K = g * (w - 1 - G) + v * (x - 1 - (H * N - q)) + y * O, Q = 0; Q < _; ++Q) j += c[$ + (O * _ + Q)] * d[K + Q];\n\n            o[a * M + s * D + u * z + O] = j;\n          }\n\n          return r.toTensor();\n        }, e.prototype.depthwiseConv2DDerFilter = function (t, e, n) {\n          Pl([t, e], \"depthwiseConv2DDerFilter\");\n\n          for (var r = n.strideHeight, o = n.strideWidth, i = n.filterHeight, a = n.filterWidth, s = Vn(n.filterShape, \"float32\"), u = n.padInfo.left, c = n.padInfo.top, l = n.outChannels / n.inChannels, h = this.bufferSync(t), p = this.bufferSync(e), f = 0; f < i; ++f) for (var d = Math.max(0, Math.ceil((c - f) / r)), m = Math.min(n.outHeight, (n.inHeight + c - f) / r), g = 0; g < a; ++g) for (var v = Math.max(0, Math.ceil((u - g) / o)), y = Math.min(n.outWidth, (n.inWidth + u - g) / o), b = 0; b < n.outChannels; ++b) {\n            for (var w = Math.trunc(b / l), x = b % l, S = 0, E = 0; E < n.batchSize; ++E) for (var C = d; C < m; ++C) for (var I = f + C * r - c, A = v; A < y; ++A) {\n              var k = g + A * o - u;\n              S += h.get(E, I, k, w) * p.get(E, C, A, b);\n            }\n\n            s.set(S, f, g, w, x);\n          }\n\n          return s.toTensor();\n        }, e.prototype.tile = function (t, e) {\n          return Pl(t, \"tile\"), ao(this.bufferSync(t), e);\n        }, e.prototype.pad = function (t, e, n) {\n          Pl(t, \"pad\");\n          var r = e.map(function (e, n) {\n            return e[0] + t.shape[n] + e[1];\n          }),\n              o = e.map(function (t) {\n            return t[0];\n          }),\n              i = this.bufferSync(t),\n              a = Vn(r, t.dtype);\n          0 !== n && a.values.fill(n);\n\n          for (var s = 0; s < t.size; s++) {\n            var u = i.indexToLoc(s),\n                c = u.map(function (t, e) {\n              return t + o[e];\n            });\n            a.set.apply(a, [i.get.apply(i, u)].concat(c));\n          }\n\n          return a.toTensor();\n        }, e.prototype.transpose = function (t, e) {\n          Pl(t, \"transpose\");\n\n          for (var n = new Array(t.rank), r = 0; r < n.length; r++) n[r] = t.shape[e[r]];\n\n          var o = this.readSync(t.dataId),\n              i = Vn(n, t.dtype),\n              a = this.bufferSync(t);\n\n          for (r = 0; r < t.size; ++r) {\n            for (var s = a.indexToLoc(r), u = new Array(s.length), c = 0; c < u.length; c++) u[c] = s[e[c]];\n\n            var l = i.locToIndex(u);\n            i.values[l] = o[r];\n          }\n\n          return i.toTensor();\n        }, e.prototype.gather = function (t, e, n) {\n          Pl([t, e], \"gather\");\n          var r = t.shape.slice(),\n              o = this.readSync(e.dataId);\n          r[n] = o.length;\n\n          for (var i = Vn(r, t.dtype), a = this.bufferSync(t), s = 0; s < i.size; ++s) {\n            var u = i.indexToLoc(s),\n                c = u.slice();\n            c[n] = o[u[n]];\n            var l = a.locToIndex(c);\n            i.values[s] = a.values[l];\n          }\n\n          return i.toTensor();\n        }, e.prototype.batchToSpaceND = function (t, e, n) {\n          Pl([t], \"batchToSpaceND\");\n          var r = e.reduce(function (t, e) {\n            return t * e;\n          }),\n              o = fr(t.shape, e, r),\n              i = dr(o.length, e.length),\n              a = mr(t.shape, e, r),\n              s = gr(n, e.length),\n              u = vr(a, n, e.length);\n          return t.reshape(o).transpose(i).reshape(a).slice(s, u);\n        }, e.prototype.spaceToBatchND = function (t, e, n) {\n          Pl([t], \"spaceToBatchND\");\n          var r = e.reduce(function (t, e) {\n            return t * e;\n          }),\n              o = [[0, 0]];\n          o.push.apply(o, n);\n\n          for (var i = 1 + e.length; i < t.shape.length; ++i) o.push([0, 0]);\n\n          var a = t.pad(o),\n              s = fr(a.shape, e, r, !1),\n              u = dr(s.length, e.length, !1),\n              c = mr(a.shape, e, r, !1);\n          return a.reshape(s).transpose(u).reshape(c);\n        }, e.prototype.pool = function (t, e, n) {\n          Pl(t, \"pool\");\n\n          for (var r = e.strideHeight, o = e.strideWidth, i = e.dilationHeight, a = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = \"max\" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, p = this.readSync(t.dataId), f = Vn(e.outShape, t.dtype), d = f.values, m = e.outShape[1] * e.outShape[2] * e.outShape[3], g = e.outShape[2] * e.outShape[3], v = e.outShape[3], y = 0; y < e.batchSize; ++y) for (var b = y * m, w = y * t.strides[0], x = 0; x < e.inChannels; ++x) for (var S = 0; S < e.outHeight; ++S) for (var E = S * r - c, C = Math.max(0, E), I = Math.min(e.inHeight, s + E), A = b + S * g, k = 0; k < e.outWidth; ++k) {\n            for (var T = k * o - l, N = Math.max(0, T), P = Math.min(e.inWidth, u + T), R = h, _ = 0, M = 0, O = C; O < I; O += i) {\n              for (var D = w + O * t.strides[1], F = N; F < P; F += a) {\n                var L = p[D + F * t.strides[2] + x];\n                \"max\" === n && L > R ? R = L : \"avg\" === n && (_ += L, M++);\n              }\n\n              if (isNaN(R)) break;\n            }\n\n            d[A + k * v + x] = \"avg\" === n ? _ / M : R;\n          }\n\n          return f.toTensor();\n        }, e.prototype.maxPool = function (t, e) {\n          return this.pool(t, e, \"max\");\n        }, e.prototype.maxPoolPositions = function (t, e) {\n          for (var n = Vn(e.outShape, \"int32\"), r = e.strideHeight, o = e.strideWidth, i = e.dilationHeight, a = e.dilationWidth, s = e.effectiveFilterHeight, u = e.effectiveFilterWidth, c = e.padInfo.top, l = e.padInfo.left, h = this.bufferSync(t), p = 0; p < e.batchSize; ++p) for (var f = 0; f < e.inChannels; ++f) for (var d = 0; d < e.outHeight; ++d) {\n            for (var m = d * r - c, g = m; g < 0;) g += i;\n\n            for (var v = Math.min(e.inHeight, s + m), y = 0; y < e.outWidth; ++y) {\n              for (var b = y * o - l, w = b; w < 0;) w += a;\n\n              for (var x = Math.min(e.inWidth, u + b), S = Number.NEGATIVE_INFINITY, E = -1, C = g; C < v; C += i) for (var I = C - m, A = w; A < x; A += a) {\n                var k = A - b,\n                    T = h.get(p, C, A, f);\n                T > S && (S = T, E = I * u + k);\n              }\n\n              n.set(E, p, d, y, f);\n            }\n          }\n\n          return n.toTensor();\n        }, e.prototype.maxPoolBackprop = function (t, e, n, r) {\n          Pl([e, n], \"maxPoolBackprop\");\n\n          for (var o = this.maxPoolPositions(e, r), i = r.strideHeight, a = r.strideWidth, s = r.dilationHeight, u = r.dilationWidth, c = r.effectiveFilterHeight, l = r.effectiveFilterWidth, h = l - 1 - r.padInfo.left, p = c - 1 - r.padInfo.top, f = Vn(e.shape, \"float32\"), d = this.bufferSync(o), m = this.bufferSync(t), g = 0; g < r.batchSize; ++g) for (var v = 0; v < r.inChannels; ++v) for (var y = 0; y < r.inHeight; ++y) for (var b = 0; b < r.inWidth; ++b) {\n            for (var w = y - p, x = b - h, S = 0, E = 0; E < c; E += s) {\n              var C = (w + E) / i;\n              if (!(C < 0 || C >= r.outHeight || Math.floor(C) !== C)) for (var I = 0; I < l; I += u) {\n                var A = (x + I) / a;\n\n                if (!(A < 0 || A >= r.outWidth || Math.floor(A) !== A)) {\n                  var k = c * l - 1 - d.get(g, C, A, v) === E * l + I ? 1 : 0;\n                  0 !== k && (S += m.get(g, C, A, v) * k);\n                }\n              }\n            }\n\n            f.set(S, g, y, b, v);\n          }\n\n          return f.toTensor();\n        }, e.prototype.avgPoolBackprop = function (t, e, n) {\n          Pl([t, e], \"avgPoolBackprop\");\n\n          for (var r = n.strideHeight, o = n.strideWidth, i = n.filterHeight, a = n.filterWidth, s = n.dilationHeight, u = n.dilationWidth, c = n.effectiveFilterHeight, l = n.effectiveFilterWidth, h = l - 1 - n.padInfo.left, p = c - 1 - n.padInfo.top, f = Vn(e.shape, \"float32\"), d = 1 / (i * a), m = this.bufferSync(t), g = 0; g < n.batchSize; ++g) for (var v = 0; v < n.inChannels; ++v) for (var y = 0; y < n.inHeight; ++y) for (var b = 0; b < n.inWidth; ++b) {\n            for (var w = y - p, x = b - h, S = 0, E = 0; E < c; E += s) {\n              var C = (w + E) / r;\n              if (!(C < 0 || C >= n.outHeight || Math.floor(C) !== C)) for (var I = 0; I < l; I += u) {\n                var A = (x + I) / o;\n                A < 0 || A >= n.outWidth || Math.floor(A) !== A || (S += m.get(g, C, A, v));\n              }\n            }\n\n            f.set(S * d, g, y, b, v);\n          }\n\n          return f.toTensor();\n        }, e.prototype.pool3d = function (t, e, n) {\n          Pl(t, \"pool3d\");\n\n          for (var r = e.strideDepth, o = e.strideHeight, i = e.strideWidth, a = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, p = e.padInfo.front, f = e.padInfo.top, d = e.padInfo.left, m = \"max\" === n ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, g = this.readSync(t.dataId), v = Vn(e.outShape, t.dtype), y = v.values, b = e.outShape[1] * e.outShape[2] * e.outShape[3] * e.outShape[4], w = e.outShape[2] * e.outShape[3] * e.outShape[4], x = e.outShape[3] * e.outShape[4], S = e.outShape[4], E = 0; E < e.batchSize; ++E) for (var C = E * b, I = E * t.strides[0], A = 0; A < e.inChannels; ++A) for (var k = 0; k < e.outDepth; ++k) {\n            for (var T = k * r - p, N = T; N < 0;) N += a;\n\n            for (var P = Math.min(e.inDepth, c + T), R = C + k * w, _ = 0; _ < e.outHeight; ++_) {\n              for (var M = _ * o - f, O = M; O < 0;) O += s;\n\n              for (var D = Math.min(e.inHeight, l + M), F = R + _ * x, L = 0; L < e.outWidth; ++L) {\n                for (var B = L * i - d, z = B; z < 0;) z += u;\n\n                for (var q = Math.min(e.inWidth, h + B), V = F + L * S, U = m, j = 0, W = 0, G = N; G < P; G += a) {\n                  for (var H = I + G * t.strides[1], $ = O; $ < D; $ += s) {\n                    for (var K = H + $ * t.strides[2], Q = z; Q < q; Q += u) {\n                      var X = g[K + Q * t.strides[3] + A];\n                      if (\"max\" === n && X > U ? U = X : \"avg\" === n && (j += X, W++), isNaN(U)) break;\n                    }\n\n                    if (isNaN(U)) break;\n                  }\n\n                  if (isNaN(U)) break;\n                }\n\n                y[V + A] = \"avg\" === n ? j / W : U;\n              }\n            }\n          }\n\n          return v.toTensor();\n        }, e.prototype.avgPool3d = function (t, e) {\n          return Pl(t, \"avgPool3d\"), this.pool3d(t, e, \"avg\").toFloat();\n        }, e.prototype.avgPool3dBackprop = function (t, e, n) {\n          Pl([t, e], \"avgPool3dBackprop\");\n\n          for (var r = n.strideDepth, o = n.strideHeight, i = n.strideWidth, a = n.filterDepth, s = n.filterHeight, u = n.filterWidth, c = n.dilationDepth, l = n.dilationHeight, h = n.dilationWidth, p = n.effectiveFilterDepth, f = n.effectiveFilterHeight, d = n.effectiveFilterWidth, m = p - 1 - n.padInfo.front, g = d - 1 - n.padInfo.left, v = f - 1 - n.padInfo.top, y = Vn(e.shape, \"float32\"), b = 1 / (a * s * u), w = this.bufferSync(t), x = 0; x < n.batchSize; ++x) for (var S = 0; S < n.inChannels; ++S) for (var E = 0; E < n.inDepth; ++E) for (var C = 0; C < n.inHeight; ++C) for (var I = 0; I < n.inWidth; ++I) {\n            for (var A = E - m, k = C - v, T = I - g, N = 0, P = 0; P < p; P += c) {\n              var R = (A + P) / r;\n              if (!(R < 0 || R >= n.outDepth || Math.floor(R) !== R)) for (var _ = 0; _ < f; _ += l) {\n                var M = (k + _) / o;\n                if (!(M < 0 || M >= n.outHeight || Math.floor(M) !== M)) for (var O = 0; O < d; O += h) {\n                  var D = (T + O) / i;\n                  D < 0 || D >= n.outWidth || Math.floor(D) !== D || (N += w.get(x, R, M, D, S));\n                }\n              }\n            }\n\n            y.set(N * b, x, E, C, I, S);\n          }\n\n          return y.toTensor();\n        }, e.prototype.maxPool3d = function (t, e) {\n          return Pl(t, \"maxPool3d\"), this.pool3d(t, e, \"max\").toFloat();\n        }, e.prototype.maxPool3dPositions = function (t, e) {\n          for (var n = Vn(e.outShape, \"int32\"), r = e.strideDepth, o = e.strideHeight, i = e.strideWidth, a = e.dilationDepth, s = e.dilationHeight, u = e.dilationWidth, c = e.effectiveFilterDepth, l = e.effectiveFilterHeight, h = e.effectiveFilterWidth, p = e.padInfo.front, f = e.padInfo.top, d = e.padInfo.left, m = this.bufferSync(t), g = 0; g < e.batchSize; ++g) for (var v = 0; v < e.inChannels; ++v) for (var y = 0; y < e.outDepth; ++y) {\n            for (var b = y * r - p, w = b; w < 0;) w += a;\n\n            for (var x = Math.min(e.inDepth, c + b), S = 0; S < e.outHeight; ++S) {\n              for (var E = S * o - f, C = E; C < 0;) C += s;\n\n              for (var I = Math.min(e.inHeight, l + E), A = 0; A < e.outWidth; ++A) {\n                for (var k = A * i - d, T = k; T < 0;) T += u;\n\n                for (var N = Math.min(e.inWidth, h + k), P = Number.NEGATIVE_INFINITY, R = -1, _ = w; _ < x; _ += a) for (var M = _ - b, O = C; O < I; O += s) for (var D = O - E, F = T; F < N; F += u) {\n                  var L = F - k,\n                      B = m.get(g, _, O, F, v);\n                  B >= P && (P = B, R = M * l * h + D * l + L);\n                }\n\n                n.set(R, g, y, S, A, v);\n              }\n            }\n          }\n\n          return n.toTensor();\n        }, e.prototype.maxPool3dBackprop = function (t, e, n, r) {\n          Pl([e, n], \"maxPool3dBackprop\");\n\n          for (var o = this.maxPool3dPositions(e, r), i = r.strideDepth, a = r.strideHeight, s = r.strideWidth, u = r.dilationDepth, c = r.dilationHeight, l = r.dilationWidth, h = r.effectiveFilterDepth, p = r.effectiveFilterHeight, f = r.effectiveFilterWidth, d = h - 1 - r.padInfo.front, m = f - 1 - r.padInfo.left, g = p - 1 - r.padInfo.top, v = Vn(e.shape, \"float32\"), y = this.bufferSync(o), b = this.bufferSync(t), w = 0; w < r.batchSize; ++w) for (var x = 0; x < r.inChannels; ++x) for (var S = 0; S < r.inDepth; ++S) for (var E = 0; E < r.inHeight; ++E) for (var C = 0; C < r.inWidth; ++C) {\n            for (var I = S - d, A = E - g, k = C - m, T = 0, N = 0; N < h; N += u) {\n              var P = (I + N) / i;\n              if (!(P < 0 || P >= r.outDepth || Math.floor(P) !== P)) for (var R = 0; R < p; R += c) {\n                var _ = (A + R) / a;\n\n                if (!(_ < 0 || _ >= r.outHeight || Math.floor(_) !== _)) for (var M = 0; M < f; M += l) {\n                  var O = (k + M) / s;\n\n                  if (!(O < 0 || O >= r.outWidth || Math.floor(O) !== O)) {\n                    var D = h * p * f - 1 - y.get(w, P, _, O, x) === N * p * f + R * f + M ? 1 : 0;\n                    0 !== D && (T += b.get(w, P, _, O, x) * D);\n                  }\n                }\n              }\n            }\n\n            v.set(T, w, S, E, C, x);\n          }\n\n          return v.toTensor();\n        }, e.prototype.cast = function (t, e) {\n          return Xr(t, e, this);\n        }, e.prototype.reshape = function (t, e) {\n          return Yr(t, e);\n        }, e.prototype.avgPool = function (t, e) {\n          return Pl(t, \"avgPool\"), this.pool(t, e, \"avg\").toFloat();\n        }, e.prototype.resizeBilinear = function (t, e, n, r) {\n          Pl(t, \"resizeBilinear\");\n\n          for (var o = t.shape, i = o[0], a = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(A([i, e, n, u])), h = [r && e > 1 ? a - 1 : a, r && n > 1 ? s - 1 : s], p = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = 0, d = h[0] / p[0], m = h[1] / p[1], g = 0; g < i; g++) for (var v = 0; v < e; v++) for (var y = d * v, b = Math.floor(y), w = y - b, x = Math.min(a - 1, Math.ceil(y)), S = g * t.strides[0] + b * t.strides[1], E = g * t.strides[0] + x * t.strides[1], C = 0; C < n; C++) for (var I = m * C, k = Math.floor(I), T = I - k, N = Math.min(s - 1, Math.ceil(I)), P = S + k * t.strides[2], R = E + k * t.strides[2], _ = S + +N * t.strides[2], M = E + N * t.strides[2], O = 0; O < u; O++) {\n            var D = c[P + O],\n                F = c[R + O],\n                L = D + (c[_ + O] - D) * T,\n                B = L + (F + (c[M + O] - F) * T - L) * w;\n            l[f++] = B;\n          }\n\n          return ln(l, [i, e, n, u]);\n        }, e.prototype.resizeBilinearBackprop = function (t, e, n) {\n          Pl([t, e], \"resizeBilinearBackprop\");\n\n          for (var r = e.shape, o = r[0], i = r[1], a = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * i * a * s), p = [n && c > 1 ? i - 1 : i, n && l > 1 ? a - 1 : a], f = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], d = p[0] / f[0], m = p[1] / f[1], g = this.readSync(t.dataId), v = 0, y = 0; y < o; y++) for (var b = y * e.strides[0], w = 0; w < c; w++) for (var x = w * d, S = Math.floor(x), E = Math.min(Math.ceil(x), i - 1), C = b + S * e.strides[1], I = b + E * e.strides[1], A = x - S, k = 1 - A, T = 0; T < l; T++) for (var N = T * m, P = Math.floor(N), R = Math.min(Math.ceil(N), a - 1), _ = N - P, M = 1 - _, O = C + P * e.strides[2], D = C + R * e.strides[2], F = I + P * e.strides[2], L = I + R * e.strides[2], B = k * M, z = k * _, q = A * M, V = A * _, U = 0; U < s; U++) {\n            var j = g[v++];\n            h[O + U] += j * B, h[D + U] += j * z, h[F + U] += j * q, h[L + U] += j * V;\n          }\n\n          return gn(h, [o, a, i, s], e.dtype);\n        }, e.prototype.resizeNearestNeighbor = function (t, e, n, r) {\n          Pl(t, \"resizeNearestNeighbor\");\n\n          for (var o = t.shape, i = o[0], a = o[1], s = o[2], u = o[3], c = this.readSync(t.dataId), l = new Float32Array(i * e * n * u), h = [r && e > 1 ? a - 1 : a, r && n > 1 ? s - 1 : s], p = [r && e > 1 ? e - 1 : e, r && n > 1 ? n - 1 : n], f = h[0] / p[0], d = h[1] / p[1], m = 0, g = 0; g < i; g++) for (var v = g * t.strides[0], y = 0; y < e; y++) for (var b = f * y, w = v + Math.min(a - 1, r ? Math.round(b) : Math.floor(b)) * t.strides[1], x = 0; x < n; x++) for (var S = d * x, E = w + Math.min(s - 1, r ? Math.round(S) : Math.floor(S)) * t.strides[2], C = 0; C < u; C++) {\n            var I = c[E + C];\n            l[m++] = I;\n          }\n\n          return ln(l, [i, e, n, u], t.dtype);\n        }, e.prototype.resizeNearestNeighborBackprop = function (t, e, n) {\n          Pl([t, e], \"resizeNearestNeighborBackprop\");\n\n          for (var r = e.shape, o = r[0], i = r[1], a = r[2], s = r[3], u = t.shape, c = u[1], l = u[2], h = new Float32Array(o * i * a * s), p = this.readSync(t.dataId), f = [n && c > 1 ? i - 1 : i, n && l > 1 ? a - 1 : a], d = [n && c > 1 ? c - 1 : c, n && l > 1 ? l - 1 : l], m = f[0] / d[0], g = f[1] / d[1], v = 1 / m, y = 1 / g, b = 2 * Math.ceil(v) + 2, w = 2 * Math.ceil(y) + 2, x = 0; x < o; x++) for (var S = x * e.strides[0], E = 0; E < i; E++) for (var C = S + E * e.strides[1], I = Math.floor(E * v), A = Math.floor(I - b / 2), k = 0; k < a; k++) for (var T = C + k * e.strides[2], N = Math.floor(k * y), P = Math.floor(N - w / 2), R = 0; R < s; R++) {\n            for (var _ = 0, M = 0; M < b; M++) {\n              var O = M + A;\n\n              if (!(O < 0 || O >= c)) {\n                var D = S + O * t.strides[1],\n                    F = O * m;\n                if (E === Math.min(i - 1, n ? Math.round(F) : Math.floor(F))) for (var L = 0; L < w; L++) {\n                  var B = L + P;\n\n                  if (!(B < 0 || B >= l)) {\n                    var z = D + B * t.strides[2],\n                        q = B * g;\n                    k === Math.min(a - 1, n ? Math.round(q) : Math.floor(q)) && (_ += p[z + R]);\n                  }\n                }\n              }\n            }\n\n            h[T + R] = _;\n          }\n\n          return gn(h, e.shape, e.dtype);\n        }, e.prototype.batchNormalization = function (t, e, n, r, o, i) {\n          Pl([t, e, n, o, i], \"batchNorm\");\n\n          for (var a = this.readSync(t.dataId), s = this.readSync(e.dataId), u = this.readSync(n.dataId), c = o ? this.readSync(o.dataId) : new Float32Array([1]), l = i ? this.readSync(i.dataId) : new Float32Array([0]), h = new Float32Array(a.length), p = l.length, f = c.length, d = u.length, m = s.length, g = 0, v = 0, y = 0, b = 0, w = 0; w < a.length; ++w) h[w] = l[g++] + (a[w] - s[v++]) * c[y++] / Math.sqrt(u[b++] + r), g >= p && (g = 0), v >= m && (v = 0), y >= f && (y = 0), b >= d && (b = 0);\n\n          return gn(h, t.shape);\n        }, e.prototype.localResponseNormalization4D = function (t, e, n, r, o) {\n          Pl(t, \"localResponseNormalization4D\");\n          var i = t.shape[3],\n              a = i - 1,\n              s = this.readSync(t.dataId),\n              u = t.size,\n              c = new Float32Array(u);\n\n          function l(t) {\n            for (var n = t % i, r = t - n + Math.max(0, n - e), o = t - n + Math.min(n + e, a), u = 0; r <= o; r++) {\n              var c = s[r];\n              u += c * c;\n            }\n\n            return u;\n          }\n\n          for (var h = 0; h < u; h++) {\n            var p = l(h),\n                f = s[h] * Math.pow(n + r * p, -o);\n            c[h] = f;\n          }\n\n          return gn(c, t.shape);\n        }, e.prototype.LRNGrad = function (t, e, n, r, o, i, a) {\n          Pl(t, \"LRNGrad\");\n\n          for (var s = t.shape[3], u = this.readSync(t.dataId), c = this.readSync(e.dataId), l = this.readSync(n.dataId), h = new Float32Array(t.size), p = t.size, f = 0; f < p; f++) {\n            for (var d = f % s, m = f - d + Math.max(0, d - r), g = f - d + Math.min(s, d + r + 1), v = 0, y = m; y < g; y++) v += Math.pow(c[y], 2);\n\n            for (v = i * v + o, y = m; y < g; y++) {\n              var b = -2 * i * a * c[y] * l[f] / v;\n              f === y && (b += Math.pow(v, -a)), b *= u[f], h[y] += b;\n            }\n          }\n\n          return gn(h, t.shape);\n        }, e.prototype.multinomial = function (t, e, n, r) {\n          Pl(t, \"multinomial\");\n\n          for (var o = e ? t : Pr(t), i = o.shape[0], a = o.shape[1], s = yn([i, n], \"int32\"), u = this.readSync(s.dataId), c = this.readSync(o.dataId), l = 0; l < i; ++l) {\n            var h = l * a,\n                p = new Float32Array(a - 1);\n            p[0] = c[h];\n\n            for (var f = 1; f < p.length; ++f) p[f] = p[f - 1] + c[h + f];\n\n            for (var d = Ln(r.toString()), m = l * n, g = 0; g < n; ++g) {\n              var v = d();\n              u[m + g] = p.length;\n\n              for (var y = 0; y < p.length; y++) if (v < p[y]) {\n                u[m + g] = y;\n                break;\n              }\n            }\n          }\n\n          return s;\n        }, e.prototype.oneHot = function (t, e, n, r) {\n          Pl(t, \"oneHot\");\n          var o = new Float32Array(t.size * e);\n          o.fill(r);\n\n          for (var i = this.readSync(t.dataId), a = 0; a < t.size; ++a) i[a] >= 0 && i[a] < e && (o[a * e + i[a]] = n);\n\n          return dn(o, [t.size, e], \"int32\");\n        }, e.prototype.nonMaxSuppression = function (t, e, n, r, o) {\n          return Pl(t, \"nonMaxSuppression\"), ro(this.readSync(t.dataId), this.readSync(e.dataId), n, r, o);\n        }, e.prototype.fft = function (t) {\n          return this.fftBatch(t, !1);\n        }, e.prototype.ifft = function (t) {\n          return this.fftBatch(t, !0);\n        }, e.prototype.fftBatch = function (t, e) {\n          for (var n = t.shape[0], r = t.shape[1], o = Vn(t.shape, \"float32\"), i = Vn(t.shape, \"float32\"), a = un(t).as2D(n, r), s = cn(t).as2D(n, r), u = 0; u < n; u++) for (var c = a.slice([u, 0], [1, r]), l = s.slice([u, 0], [1, r]), h = sn(c, l), p = this.readSync(this.fftImpl(h, e).dataId), f = 0; f < r; f++) {\n            var d = to(p, f);\n            o.values[u * r + f] = d.real, i.values[u * r + f] = d.imag;\n          }\n\n          return sn(o.toTensor(), i.toTensor()).as2D(n, r);\n        }, e.prototype.fftImpl = function (t, e) {\n          var n = t.as1D(),\n              r = n.size;\n\n          if (this.isExponentOf2(r)) {\n            var o = this.fftRadix2(n, r, e).as2D(t.shape[0], t.shape[1]);\n            return e && (o = sn(un(o).div(pn(r)), cn(o).div(pn(r)))), o;\n          }\n\n          var i = this.readSync(t.dataId),\n              a = function (t) {\n            for (var e = new Float32Array(t.length / 2), n = new Float32Array(t.length / 2), r = 0; r < t.length; r += 2) e[r / 2] = t[r], n[r / 2] = t[r + 1];\n\n            return {\n              real: e,\n              imag: n\n            };\n          }(this.fourierTransformByMatmul(i, r, e));\n\n          return sn(a.real, a.imag).as2D(t.shape[0], t.shape[1]);\n        }, e.prototype.isExponentOf2 = function (t) {\n          return 0 == (t & t - 1);\n        }, e.prototype.fftRadix2 = function (t, e, n) {\n          if (1 === e) return t;\n\n          var r = this.readSync(t.dataId),\n              o = e / 2,\n              i = function (t) {\n            for (var e = Math.ceil(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 0; o < t.length; o += 4) n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];\n\n            return {\n              real: n,\n              imag: r\n            };\n          }(r),\n              a = sn(i.real, i.imag).as1D(),\n              s = function (t) {\n            for (var e = Math.floor(t.length / 4), n = new Float32Array(e), r = new Float32Array(e), o = 2; o < t.length; o += 4) n[Math.floor(o / 4)] = t[o], r[Math.floor(o / 4)] = t[o + 1];\n\n            return {\n              real: n,\n              imag: r\n            };\n          }(r),\n              u = sn(s.real, s.imag).as1D();\n\n          a = this.fftRadix2(a, o, n), u = this.fftRadix2(u, o, n);\n\n          var c = function (t, e) {\n            for (var n = new Float32Array(t / 2), r = new Float32Array(t / 2), o = 0; o < Math.ceil(t / 2); o++) {\n              var i = (e ? 2 : -2) * Math.PI * (o / t);\n              n[o] = Math.cos(i), r[o] = Math.sin(i);\n            }\n\n            return {\n              real: n,\n              imag: r\n            };\n          }(e, n),\n              l = sn(c.real, c.imag).mul(u),\n              h = a.add(l),\n              p = a.sub(l),\n              f = un(h).concat(un(p)),\n              d = cn(h).concat(cn(p));\n\n          return sn(f, d).as1D();\n        }, e.prototype.fourierTransformByMatmul = function (t, e, n) {\n          for (var r = new Float32Array(2 * e), o = 0; o < e; o++) {\n            for (var i = 0, a = 0, s = 0; s < e; s++) {\n              var u = no(o * s, e, n),\n                  c = to(t, s);\n              i += c.real * u.real - c.imag * u.imag, a += c.real * u.imag + c.imag * u.real;\n            }\n\n            n && (i /= e, a /= e), eo(r, i, a, o);\n          }\n\n          return r;\n        }, e.prototype.depthToSpace = function (t, e, n) {\n          S(\"NHWC\" === n, function () {\n            return \"Only NHWC dataFormat supported on CPU for depthToSpace. Got \" + n;\n          }), S(e > 1, function () {\n            return \"blockSize should be > 1 for depthToSpace, but was: \" + e;\n          });\n\n          for (var r = t.shape[0], o = t.shape[1], i = t.shape[2], a = t.shape[3], s = o * e, u = i * e, c = a / (e * e), l = this.readSync(t.dataId), h = new Float32Array(r * s * u * c), p = 0, f = 0; f < r; ++f) for (var d = 0; d < s; ++d) for (var m = Math.floor(d / e), g = d % e, v = 0; v < u; ++v) for (var y = Math.floor(v / e), b = (g * e + v % e) * c, w = 0; w < c; ++w) {\n            var x = w + b + a * (y + i * (m + o * f));\n            h[p++] = l[x];\n          }\n\n          return gn(h, [r, s, u, c]);\n        }, e.prototype.broadcastedBinaryOp = function (t, e, n, r) {\n          var o = Lr(t.shape, e.shape),\n              i = Vn(o, n),\n              a = this.readSync(t.dataId),\n              s = this.readSync(e.dataId),\n              u = Dr(t.shape, o),\n              c = Dr(e.shape, o),\n              l = i.values;\n          if (u.length + c.length === 0) for (var h = 0; h < l.length; ++h) l[h] = r(a[h % a.length], s[h % s.length]);else {\n            var p = this.bufferSync(t),\n                f = this.bufferSync(e),\n                d = function (n) {\n              var o = i.indexToLoc(n),\n                  h = o.slice(-t.rank);\n              u.forEach(function (t) {\n                return h[t] = 0;\n              });\n              var d = p.locToIndex(h),\n                  m = o.slice(-e.rank);\n              c.forEach(function (t) {\n                return m[t] = 0;\n              });\n              var g = f.locToIndex(m);\n              l[n] = r(a[d], s[g]);\n            };\n\n            for (h = 0; h < l.length; ++h) d(h);\n          }\n          return i.toTensor();\n        }, e.prototype.broadcastedBinaryComplexOp = function (t, e, n) {\n          var r = Lr(t.shape, e.shape),\n              o = Vn(r, \"float32\"),\n              i = Vn(r, \"float32\"),\n              a = this.readSync(t.dataId),\n              s = this.readSync(e.dataId),\n              u = Dr(t.shape, r),\n              c = Dr(e.shape, r),\n              l = o.values,\n              h = i.values;\n          if (u.length + c.length === 0) for (var p = 0; p < l.length; p++) {\n            var f = p % a.length,\n                d = p % s.length,\n                m = n(a[2 * f], a[2 * f + 1], s[2 * d], s[2 * d + 1]);\n            l[p] = m.real, h[p] = m.imag;\n          } else {\n            var g = this.bufferSync(this.data.get(t.dataId).complexTensors.real),\n                v = this.bufferSync(this.data.get(e.dataId).complexTensors.real),\n                y = function (r) {\n              var i = o.indexToLoc(r),\n                  p = i.slice(-t.rank);\n              u.forEach(function (t) {\n                return p[t] = 0;\n              });\n              var f = g.locToIndex(p),\n                  d = i.slice(-e.rank);\n              c.forEach(function (t) {\n                return d[t] = 0;\n              });\n              var m = v.locToIndex(d),\n                  y = n(a[2 * f], a[2 * f + 1], s[2 * m], s[2 * m + 1]);\n              l[r] = y.real, h[r] = y.imag;\n            };\n\n            for (p = 0; p < l.length; p++) y(p);\n          }\n          return this.complex(o.toTensor(), i.toTensor());\n        }, e.prototype.split = function (t, e, n) {\n          return io(t, e, n);\n        }, e.prototype.dispose = function () {}, e.prototype.floatPrecision = function () {\n          return 32;\n        }, e.prototype.epsilon = function () {\n          return 1e-7;\n        }, e.prototype.cropAndResize = function (t, e, n, r, o, i) {\n          for (var a = t.shape, s = a[0], u = a[1], c = a[2], l = a[3], h = e.shape[0], p = r[0], f = r[1], d = Vn([h, p, f, l], t.dtype), m = this.readSync(e.dataId), g = this.readSync(n.dataId), v = this.readSync(t.dataId), y = t.strides, b = d.strides, w = 0; w < h; w++) {\n            var x = 4 * w,\n                S = m[x],\n                E = m[x + 1],\n                C = m[x + 2],\n                I = m[x + 3],\n                A = g[w];\n            if (!(A >= s)) for (var k = p > 1 ? (C - S) * (u - 1) / (p - 1) : 0, T = f > 1 ? (I - E) * (c - 1) / (f - 1) : 0, N = 0; N < p; N++) {\n              var P = p > 1 ? S * (u - 1) + N * k : .5 * (S + C) * (u - 1);\n              if (P < 0 || P > u - 1) for (var R = 0; R < f; R++) for (var _ = 0; _ < l; _++) {\n                var M = _ + R * b[2] + N * b[1] + w * b[0];\n                d.values[M] = i;\n              } else if (\"bilinear\" === o) {\n                var O = Math.floor(P),\n                    D = Math.ceil(P),\n                    F = P - O;\n\n                for (R = 0; R < f; R++) if ((G = f > 1 ? E * (c - 1) + R * T : .5 * (E + I) * (c - 1)) < 0 || G > c - 1) for (_ = 0; _ < l; _++) M = _ + R * b[2] + N * b[1] + w * b[0], d.values[M] = i;else {\n                  var L = Math.floor(G),\n                      B = Math.ceil(G),\n                      z = G - L;\n\n                  for (_ = 0; _ < l; _++) {\n                    var q = v[M = _ + L * y[2] + O * y[1] + A * y[0]],\n                        V = v[M = _ + B * y[2] + O * y[1] + A * y[0]],\n                        U = v[M = _ + L * y[2] + D * y[1] + A * y[0]],\n                        j = q + (V - q) * z,\n                        W = U + (v[M = _ + B * y[2] + D * y[1] + A * y[0]] - U) * z;\n                    M = _ + R * b[2] + N * b[1] + w * b[0], d.values[M] = j + (W - j) * F;\n                  }\n                }\n              } else for (R = 0; R < f; ++R) {\n                var G;\n                if ((G = f > 1 ? E * (c - 1) + R * T : .5 * (E + I) * (c - 1)) < 0 || G > c - 1) for (_ = 0; _ < l; _++) M = _ + R * b[2] + N * b[1] + w * b[0], d.values[M] = i;else {\n                  var H = Math.round(G),\n                      $ = Math.round(P);\n\n                  for (_ = 0; _ < l; _++) {\n                    var K = _ + H * y[2] + $ * y[1] + A * y[0],\n                        Q = _ + R * b[2] + N * b[1] + w * b[0];\n                    d.values[Q] = v[K];\n                  }\n                }\n              }\n            }\n          }\n\n          return d.toTensor();\n        }, e.prototype.sparseToDense = function (t, e, n, r) {\n          var o = xr(0, t, n),\n              i = o.sliceRank,\n              a = o.numUpdates,\n              s = o.sliceSize,\n              u = o.strides,\n              c = o.outputSize;\n          return this.scatter(t, e, n, c, s, a, i, u, r, !1);\n        }, e.prototype.gatherND = function (t, e) {\n          var n = e.shape,\n              r = n[n.length - 1],\n              o = yr(t, e),\n              i = o[0],\n              a = o[1],\n              s = o[2],\n              u = o[3];\n          if (0 === a) return ln([], i, t.dtype);\n\n          for (var c = new ft([a, s], t.dtype), l = this.readSync(e.dataId), h = this.readSync(t.dataId), p = 0; p < a; p++) {\n            for (var f = [], d = 0, m = 0; m < r; m++) {\n              var g = l[p * r + m];\n              d += g * u[m], f.push(g);\n            }\n\n            if (d < 0 || d >= t.size / s) throw new Error(\"Invalid indices: \" + f + \" does not index into \" + t.shape);\n\n            for (var v = 0; v < s; v++) c.values[p * s + v] = h[d * s + v];\n          }\n\n          return c.toTensor().reshape(i);\n        }, e.prototype.scatterND = function (t, e, n) {\n          var r = xr(0, t, n),\n              o = r.sliceRank,\n              i = r.numUpdates,\n              a = r.sliceSize,\n              s = r.strides,\n              u = r.outputSize,\n              c = pn(0);\n          return this.scatter(t, e, n, u, a, i, o, s, c, !0);\n        }, e.prototype.fill = function (t, e, n) {\n          var r = L(n = n || $(e), A(t));\n          return r.fill(e), Mt.makeTensor(r, t, n, this);\n        }, e.prototype.onesLike = function (t) {\n          if (\"string\" === t.dtype) throw new Error(\"onesLike is not supported for string tensors\");\n          return this.fill(t.shape, 1, t.dtype);\n        }, e.prototype.zerosLike = function (t) {\n          var e = L(t.dtype, A(t.shape));\n          return this.makeOutput(e, t.shape, t.dtype);\n        }, e.prototype.linspace = function (t, e, n) {\n          return Jr(t, e, n);\n        }, e.prototype.scatter = function (t, e, n, r, o, i, a, s, u, c) {\n          var l = [r / o, o],\n              h = this.readSync(t.dataId),\n              p = this.readSync(e.dataId);\n          if (0 === r) return ln([], n, e.dtype);\n          var f = new ft(l, e.dtype);\n          f.values.fill(this.readSync(u.dataId)[0]);\n\n          for (var d = 0; d < i; d++) {\n            for (var m = [], g = 0, v = 0; v < a; v++) {\n              var y = h[d * a + v];\n              m.push(y), g += y * s[v];\n            }\n\n            if (g < 0 || g >= r / o) throw new Error(\"Invalid indices: \" + m + \" does not index into \" + n);\n\n            for (var b = 0; b < o; b++) c ? f.values[g * o + b] += p[d * o + b] : f.values[g * o + b] = 0 === e.rank ? p[0] : p[d * o + b];\n          }\n\n          return f.toTensor().reshape(n);\n        }, e;\n      }(Mr);\n\n      Mt.registerBackend(\"cpu\", function () {\n        return new _l();\n      }, 1), g({\n        kernelName: \"Square\",\n        backendName: \"cpu\",\n        kernelFunc: function (t) {\n          var e = t.inputs,\n              n = t.backend,\n              r = e.x,\n              o = n;\n          Pl(r, \"square\");\n\n          for (var i = o.data.get(r.dataId).values, a = new Float32Array(i.length), s = 0; s < i.length; ++s) {\n            var u = i[s];\n            a[s] = u * u;\n          }\n\n          return {\n            dataId: o.write(a, r.shape, r.dtype),\n            shape: r.shape,\n            dtype: r.dtype\n          };\n        }\n      }), g({\n        kernelName: \"Square\",\n        backendName: \"webgl\",\n        kernelFunc: function (t) {\n          var e = t.inputs,\n              n = t.backend,\n              r = e.x,\n              o = n,\n              i = new Ia(r.shape, \"return x * x;\");\n          return o.runWebGLProgram(i, [r], r.dtype);\n        }\n      });\n\n      var Ml = function () {\n        function t() {}\n\n        return t.prototype.fetch = function (t, e) {\n          return fetch(t, e);\n        }, t.prototype.now = function () {\n          return performance.now();\n        }, t.prototype.encode = function (t, e) {\n          if (\"utf-8\" !== e && \"utf8\" !== e) throw new Error(\"Browser's encoder only supports utf-8, but got \" + e);\n          return null == this.textEncoder && (this.textEncoder = new TextEncoder()), this.textEncoder.encode(t);\n        }, t.prototype.decode = function (t, e) {\n          return new TextDecoder(e).decode(t);\n        }, t;\n      }();\n\n      h().get(\"IS_BROWSER\") && h().setPlatform(\"browser\", new Ml());\n\n      var Ol,\n          Dl = function () {\n        function t() {\n          this.util = n(73), this.textEncoder = new this.util.TextEncoder();\n        }\n\n        return t.prototype.fetch = function (t, e) {\n          return null != h().global.fetch ? h().global.fetch(t, e) : (null == Ol && (Ol = n(72)), Ol(t, e));\n        }, t.prototype.now = function () {\n          var t = r.hrtime();\n          return 1e3 * t[0] + t[1] / 1e6;\n        }, t.prototype.encode = function (t, e) {\n          if (\"utf-8\" !== e && \"utf8\" !== e) throw new Error(\"Node built-in encoder only supports utf-8, but got \" + e);\n          return this.textEncoder.encode(t);\n        }, t.prototype.decode = function (t, e) {\n          return 0 === t.length ? \"\" : new this.util.TextDecoder(e).decode(t);\n        }, t;\n      }();\n\n      h().get(\"IS_NODE\") && h().setPlatform(\"node\", new Dl());\n      var Fl = {\n        float32: 4,\n        int32: 4,\n        uint16: 2,\n        uint8: 1,\n        bool: 1\n      },\n          Ll = 4;\n\n      function Bl(t, e) {\n        for (var n = {}, r = 0, o = function (e) {\n          var o = e.name,\n              i = e.dtype,\n              a = e.shape,\n              s = A(a),\n              u = void 0;\n\n          if ((\"quantization\" in e)) {\n            var c = e.quantization;\n            if (\"uint8\" !== c.dtype && \"uint16\" !== c.dtype) throw new Error(\"Weight \" + e.name + \" has unknown quantization dtype \" + c.dtype + \". Supported quantization dtypes are: 'uint8' and 'uint16'.\");\n            var l = Fl[c.dtype],\n                h = t.slice(r, r + s * l),\n                p = \"uint8\" === c.dtype ? new Uint8Array(h) : new Uint16Array(h);\n            if (\"float32\" === i) u = Float32Array.from(p, function (t) {\n              return t * c.scale + c.min;\n            });else {\n              if (\"int32\" !== i) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + i);\n              u = Int32Array.from(p, function (t) {\n                return Math.round(t * c.scale + c.min);\n              });\n            }\n            r += s * l;\n          } else if (\"string\" === i) {\n            var f = A(e.shape);\n            u = [];\n\n            for (var d = 0; d < f; d++) {\n              var m = new Uint32Array(t.slice(r, r + Ll))[0];\n              r += Ll;\n              var g = new Uint8Array(t.slice(r, r + m));\n              u.push(g), r += m;\n            }\n          } else {\n            var v = Fl[i];\n            if (h = t.slice(r, r + s * v), \"float32\" === i) u = new Float32Array(h);else if (\"int32\" === i) u = new Int32Array(h);else {\n              if (\"bool\" !== i) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + i);\n              u = new Uint8Array(h);\n            }\n            r += s * v;\n          }\n\n          n[o] = ln(u, a, i);\n        }, i = 0, a = e; i < a.length; i++) o(a[i]);\n\n        return n;\n      }\n\n      function zl(t) {\n        if (null === t) throw new Error(\"Invalid input value: \" + JSON.stringify(t));\n        var e = 0,\n            n = [];\n        t.forEach(function (t) {\n          if (e += t.byteLength, n.push(t.byteLength === t.buffer.byteLength ? t : new t.constructor(t)), !(t instanceof Float32Array || t instanceof Int32Array || t instanceof Uint8Array)) throw new Error(\"Unsupported TypedArray subtype: \" + t.constructor.name);\n        });\n        var r = new Uint8Array(e),\n            o = 0;\n        return n.forEach(function (t) {\n          r.set(new Uint8Array(t.buffer), o), o += t.byteLength;\n        }), r.buffer;\n      }\n\n      var ql = void 0 !== o && (\"undefined\" == typeof Blob || \"undefined\" == typeof atob || \"undefined\" == typeof btoa);\n\n      function Vl(t) {\n        return ql ? o.byteLength(t) : new Blob([t]).size;\n      }\n\n      function Ul(t) {\n        var e = 0;\n        t.forEach(function (t) {\n          e += t.byteLength;\n        });\n        var n = new Uint8Array(e),\n            r = 0;\n        return t.forEach(function (t) {\n          n.set(new Uint8Array(t), r), r += t.byteLength;\n        }), n.buffer;\n      }\n\n      function jl(t) {\n        for (t = t.trim(); t.endsWith(\"/\");) t = t.slice(0, t.length - 1);\n\n        var e = t.split(\"/\");\n        return e[e.length - 1];\n      }\n\n      function Wl(t) {\n        if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");\n        return {\n          dateSaved: new Date(),\n          modelTopologyType: \"JSON\",\n          modelTopologyBytes: null == t.modelTopology ? 0 : Vl(JSON.stringify(t.modelTopology)),\n          weightSpecsBytes: null == t.weightSpecs ? 0 : Vl(JSON.stringify(t.weightSpecs)),\n          weightDataBytes: null == t.weightData ? 0 : t.weightData.byteLength\n        };\n      }\n\n      var Gl = function () {\n        function t() {\n          this.saveRouters = [], this.loadRouters = [];\n        }\n\n        return t.getInstance = function () {\n          return null == t.instance && (t.instance = new t()), t.instance;\n        }, t.registerSaveRouter = function (e) {\n          t.getInstance().saveRouters.push(e);\n        }, t.registerLoadRouter = function (e) {\n          t.getInstance().loadRouters.push(e);\n        }, t.getSaveHandlers = function (e) {\n          return t.getHandlers(e, \"save\");\n        }, t.getLoadHandlers = function (e, n) {\n          return t.getHandlers(e, \"load\", n);\n        }, t.getHandlers = function (e, n, r) {\n          var o = [];\n          return (\"load\" === n ? t.getInstance().loadRouters : t.getInstance().saveRouters).forEach(function (t) {\n            var n = t(e, r);\n            null !== n && o.push(n);\n          }), o;\n        }, t;\n      }(),\n          Hl = \"://\",\n          $l = function () {\n        function t() {\n          this.managers = {};\n        }\n\n        return t.getInstance = function () {\n          return null == t.instance && (t.instance = new t()), t.instance;\n        }, t.registerManager = function (e, n) {\n          S(null != e, function () {\n            return \"scheme must not be undefined or null.\";\n          }), e.endsWith(Hl) && (e = e.slice(0, e.indexOf(Hl))), S(e.length > 0, function () {\n            return \"scheme must not be an empty string.\";\n          });\n          var r = t.getInstance();\n          S(null == r.managers[e], function () {\n            return \"A model store manager is already registered for scheme '\" + e + \"'.\";\n          }), r.managers[e] = n;\n        }, t.getManager = function (t) {\n          var e = this.getInstance().managers[t];\n          if (null == e) throw new Error(\"Cannot find model manager for scheme '\" + t + \"'\");\n          return e;\n        }, t.getSchemes = function () {\n          return Object.keys(this.getInstance().managers);\n        }, t;\n      }();\n\n      function Kl(t) {\n        if (-1 === t.indexOf(Hl)) throw new Error(\"The url string provided does not contain a scheme. Supported schemes are: \" + $l.getSchemes().join(\",\"));\n        return {\n          scheme: t.split(Hl)[0],\n          path: t.split(Hl)[1]\n        };\n      }\n\n      function Ql(t, e, n) {\n        return void 0 === n && (n = !1), u(this, void 0, void 0, function () {\n          var r, o, i, a, s, u, l, h, p;\n          return c(this, function (c) {\n            switch (c.label) {\n              case 0:\n                return S(t !== e, function () {\n                  return \"Old path and new path are the same: '\" + t + \"'\";\n                }), S((r = Gl.getLoadHandlers(t)).length > 0, function () {\n                  return \"Copying failed because no load handler is found for source URL \" + t + \".\";\n                }), S(r.length < 2, function () {\n                  return \"Copying failed because more than one (\" + r.length + \") load handlers for source URL \" + t + \".\";\n                }), o = r[0], S((i = Gl.getSaveHandlers(e)).length > 0, function () {\n                  return \"Copying failed because no save handler is found for destination URL \" + e + \".\";\n                }), S(i.length < 2, function () {\n                  return \"Copying failed because more than one (\" + r.length + \") save handlers for destination URL \" + e + \".\";\n                }), a = i[0], s = Kl(t).scheme, u = Kl(t).path, l = s === Kl(t).scheme, [4, o.load()];\n\n              case 1:\n                return h = c.sent(), n && l ? [4, $l.getManager(s).removeModel(u)] : [3, 3];\n\n              case 2:\n                c.sent(), c.label = 3;\n\n              case 3:\n                return [4, a.save(h)];\n\n              case 4:\n                return p = c.sent(), !n || l ? [3, 6] : [4, $l.getManager(s).removeModel(u)];\n\n              case 5:\n                c.sent(), c.label = 6;\n\n              case 6:\n                return [2, p.modelArtifactsInfo];\n            }\n          });\n        });\n      }\n\n      var Xl = \"models_store\",\n          Yl = \"model_info_store\";\n\n      function Jl() {\n        if (!h().getBool(\"IS_BROWSER\")) throw new Error(\"Failed to obtain IndexedDB factory because the current environmentis not a web browser.\");\n        var t = window,\n            e = t.indexedDB || t.mozIndexedDB || t.webkitIndexedDB || t.msIndexedDB || t.shimIndexedDB;\n        if (null == e) throw new Error(\"The current browser does not appear to support IndexedDB.\");\n        return e;\n      }\n\n      function Zl(t) {\n        var e = t.result;\n        e.createObjectStore(Xl, {\n          keyPath: \"modelPath\"\n        }), e.createObjectStore(Yl, {\n          keyPath: \"modelPath\"\n        });\n      }\n\n      var th = function () {\n        function t(t) {\n          if (this.indexedDB = Jl(), null == t || !t) throw new Error(\"For IndexedDB, modelPath must not be null, undefined or empty.\");\n          this.modelPath = t;\n        }\n\n        return t.prototype.save = function (t) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (e) {\n              if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");\n              return [2, this.databaseAction(this.modelPath, t)];\n            });\n          });\n        }, t.prototype.load = function () {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              return [2, this.databaseAction(this.modelPath)];\n            });\n          });\n        }, t.prototype.databaseAction = function (t, e) {\n          var n = this;\n          return new Promise(function (t, r) {\n            var o = n.indexedDB.open(\"tensorflowjs\", 1);\n            o.onupgradeneeded = function () {\n              return Zl(o);\n            }, o.onsuccess = function () {\n              var i = o.result;\n\n              if (null == e) {\n                var a = i.transaction(Xl, \"readonly\"),\n                    s = a.objectStore(Xl).get(n.modelPath);\n                s.onsuccess = function () {\n                  if (null == s.result) return i.close(), r(new Error(\"Cannot find model with path '\" + n.modelPath + \"' in IndexedDB.\"));\n                  t(s.result.modelArtifacts);\n                }, s.onerror = function (t) {\n                  return i.close(), r(s.error);\n                }, a.oncomplete = function () {\n                  return i.close();\n                };\n              } else {\n                var u,\n                    c = Wl(e),\n                    l = i.transaction(Yl, \"readwrite\"),\n                    h = l.objectStore(Yl),\n                    p = h.put({\n                  modelPath: n.modelPath,\n                  modelArtifactsInfo: c\n                });\n                p.onsuccess = function () {\n                  var o = (u = i.transaction(Xl, \"readwrite\")).objectStore(Xl).put({\n                    modelPath: n.modelPath,\n                    modelArtifacts: e,\n                    modelArtifactsInfo: c\n                  });\n                  o.onsuccess = function () {\n                    return t({\n                      modelArtifactsInfo: c\n                    });\n                  }, o.onerror = function (t) {\n                    var e = (h = l.objectStore(Yl)).delete(n.modelPath);\n                    e.onsuccess = function () {\n                      return i.close(), r(o.error);\n                    }, e.onerror = function (t) {\n                      return i.close(), r(o.error);\n                    };\n                  };\n                }, p.onerror = function (t) {\n                  return i.close(), r(p.error);\n                }, l.oncomplete = function () {\n                  null == u ? i.close() : u.oncomplete = function () {\n                    return i.close();\n                  };\n                };\n              }\n            }, o.onerror = function (t) {\n              return r(o.error);\n            };\n          });\n        }, t.URL_SCHEME = \"indexeddb://\", t;\n      }(),\n          eh = function (t) {\n        return h().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(th.URL_SCHEME) ? (e = t.slice(th.URL_SCHEME.length), new th(e)) : null;\n        var e;\n      };\n\n      Gl.registerSaveRouter(eh), Gl.registerLoadRouter(eh);\n\n      var nh = function () {\n        function t() {\n          this.indexedDB = Jl();\n        }\n\n        return t.prototype.listModels = function () {\n          return u(this, void 0, void 0, function () {\n            var t = this;\n            return c(this, function (e) {\n              return [2, new Promise(function (e, n) {\n                var r = t.indexedDB.open(\"tensorflowjs\", 1);\n                r.onupgradeneeded = function () {\n                  return Zl(r);\n                }, r.onsuccess = function () {\n                  var t = r.result,\n                      o = t.transaction(Yl, \"readonly\"),\n                      i = o.objectStore(Yl).getAll();\n                  i.onsuccess = function () {\n                    for (var t = {}, n = 0, r = i.result; n < r.length; n++) {\n                      var o = r[n];\n                      t[o.modelPath] = o.modelArtifactsInfo;\n                    }\n\n                    e(t);\n                  }, i.onerror = function (e) {\n                    return t.close(), n(i.error);\n                  }, o.oncomplete = function () {\n                    return t.close();\n                  };\n                }, r.onerror = function (t) {\n                  return n(r.error);\n                };\n              })];\n            });\n          });\n        }, t.prototype.removeModel = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e = this;\n            return c(this, function (n) {\n              var r;\n              return t = (r = t).startsWith(th.URL_SCHEME) ? r.slice(th.URL_SCHEME.length) : r, [2, new Promise(function (n, r) {\n                var o = e.indexedDB.open(\"tensorflowjs\", 1);\n                o.onupgradeneeded = function () {\n                  return Zl(o);\n                }, o.onsuccess = function () {\n                  var e,\n                      i = o.result,\n                      a = i.transaction(Yl, \"readwrite\"),\n                      s = a.objectStore(Yl),\n                      u = s.get(t);\n                  u.onsuccess = function () {\n                    if (null == u.result) return i.close(), r(new Error(\"Cannot find model with path '\" + t + \"' in IndexedDB.\"));\n\n                    var o = s.delete(t),\n                        a = function () {\n                      var o = (e = i.transaction(Xl, \"readwrite\")).objectStore(Xl).delete(t);\n                      o.onsuccess = function () {\n                        return n(u.result.modelArtifactsInfo);\n                      }, o.onerror = function (t) {\n                        return r(u.error);\n                      };\n                    };\n\n                    o.onsuccess = a, o.onerror = function (t) {\n                      return a(), i.close(), r(u.error);\n                    };\n                  }, u.onerror = function (t) {\n                    return i.close(), r(u.error);\n                  }, a.oncomplete = function () {\n                    null == e ? i.close() : e.oncomplete = function () {\n                      return i.close();\n                    };\n                  };\n                }, o.onerror = function (t) {\n                  return r(o.error);\n                };\n              })];\n            });\n          });\n        }, t;\n      }();\n\n      if (h().getBool(\"IS_BROWSER\")) try {\n        $l.registerManager(th.URL_SCHEME, new nh());\n      } catch (a) {}\n      var rh = \"/\",\n          oh = \"tensorflowjs_models\",\n          ih = \"info\",\n          ah = \"model_topology\",\n          sh = \"weight_specs\",\n          uh = \"weight_data\",\n          ch = \"model_metadata\";\n\n      function lh(t) {\n        return {\n          info: [oh, t, ih].join(rh),\n          topology: [oh, t, ah].join(rh),\n          weightSpecs: [oh, t, sh].join(rh),\n          weightData: [oh, t, uh].join(rh),\n          modelMetadata: [oh, t, ch].join(rh)\n        };\n      }\n\n      function hh(t) {\n        var e = t.split(rh);\n        if (e.length < 3) throw new Error(\"Invalid key format: \" + t);\n        return e.slice(1, e.length - 1).join(rh);\n      }\n\n      var ph = function () {\n        function t(t) {\n          if (!h().getBool(\"IS_BROWSER\") || void 0 === window.localStorage) throw new Error(\"The current environment does not support local storage.\");\n          if (this.LS = window.localStorage, null == t || !t) throw new Error(\"For local storage, modelPath must not be null, undefined or empty.\");\n          this.modelPath = t, this.keys = lh(this.modelPath);\n        }\n\n        return t.prototype.save = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n, r;\n            return c(this, function (i) {\n              if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");\n              e = JSON.stringify(t.modelTopology), n = JSON.stringify(t.weightSpecs), r = Wl(t);\n\n              try {\n                return this.LS.setItem(this.keys.info, JSON.stringify(r)), this.LS.setItem(this.keys.topology, e), this.LS.setItem(this.keys.weightSpecs, n), this.LS.setItem(this.keys.weightData, (a = t.weightData, ql ? o.from(a).toString(\"base64\") : btoa(String.fromCharCode.apply(null, new Uint8Array(a))))), this.LS.setItem(this.keys.modelMetadata, JSON.stringify({\n                  format: t.format,\n                  generatedBy: t.generatedBy,\n                  convertedBy: t.convertedBy\n                })), [2, {\n                  modelArtifactsInfo: r\n                }];\n              } catch (t) {\n                throw this.LS.removeItem(this.keys.info), this.LS.removeItem(this.keys.topology), this.LS.removeItem(this.keys.weightSpecs), this.LS.removeItem(this.keys.weightData), this.LS.removeItem(this.keys.modelMetadata), new Error(\"Failed to save model '\" + this.modelPath + \"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=\" + r.modelTopologyBytes + \", weightSpecsBytes=\" + r.weightSpecsBytes + \", weightDataBytes=\" + r.weightDataBytes + \".\");\n              }\n\n              var a;\n              return [2];\n            });\n          });\n        }, t.prototype.load = function () {\n          return u(this, void 0, void 0, function () {\n            var t, e, n, r, i, a, s;\n            return c(this, function (u) {\n              if (null == (t = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error(\"In local storage, there is no model with name '\" + this.modelPath + \"'\");\n              if (\"JSON\" !== t.modelTopologyType) throw new Error(\"BrowserLocalStorage does not support loading non-JSON model topology yet.\");\n              if (e = {}, null == (n = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error(\"In local storage, the topology of model '\" + this.modelPath + \"' is missing.\");\n              if (e.modelTopology = n, null == (r = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error(\"In local storage, the weight specs of model '\" + this.modelPath + \"' are missing.\");\n              if (e.weightSpecs = r, null != (i = this.LS.getItem(this.keys.modelMetadata)) && (a = JSON.parse(i), e.format = a.format, e.generatedBy = a.generatedBy, e.convertedBy = a.convertedBy), null == (s = this.LS.getItem(this.keys.weightData))) throw new Error(\"In local storage, the binary weight values of model '\" + this.modelPath + \"' are missing.\");\n              return e.weightData = function (t) {\n                if (ql) {\n                  var e = o.from(t, \"base64\");\n                  return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n                }\n\n                for (var n = atob(t), r = new Uint8Array(n.length), i = 0; i < n.length; ++i) r.set([n.charCodeAt(i)], i);\n\n                return r.buffer;\n              }(s), [2, e];\n            });\n          });\n        }, t.URL_SCHEME = \"localstorage://\", t;\n      }(),\n          fh = function (t) {\n        return h().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(ph.URL_SCHEME) ? (e = t.slice(ph.URL_SCHEME.length), new ph(e)) : null;\n        var e;\n      };\n\n      Gl.registerSaveRouter(fh), Gl.registerLoadRouter(fh);\n\n      var dh = function () {\n        function t() {\n          S(h().getBool(\"IS_BROWSER\"), function () {\n            return \"Current environment is not a web browser\";\n          }), S(void 0 !== window.localStorage, function () {\n            return \"Current browser does not appear to support localStorage\";\n          }), this.LS = window.localStorage;\n        }\n\n        return t.prototype.listModels = function () {\n          return u(this, void 0, void 0, function () {\n            var t, e, n, r, o, i;\n            return c(this, function (a) {\n              for (t = {}, e = oh + rh, n = rh + ih, r = 0; r < this.LS.length; ++r) (o = this.LS.key(r)).startsWith(e) && o.endsWith(n) && (i = hh(o), t[i] = JSON.parse(this.LS.getItem(o)));\n\n              return [2, t];\n            });\n          });\n        }, t.prototype.removeModel = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n;\n            return c(this, function (r) {\n              var o;\n              if (t = (o = t).startsWith(ph.URL_SCHEME) ? o.slice(ph.URL_SCHEME.length) : o, e = lh(t), null == this.LS.getItem(e.info)) throw new Error(\"Cannot find model at path '\" + t + \"'\");\n              return n = JSON.parse(this.LS.getItem(e.info)), this.LS.removeItem(e.info), this.LS.removeItem(e.topology), this.LS.removeItem(e.weightSpecs), this.LS.removeItem(e.weightData), [2, n];\n            });\n          });\n        }, t;\n      }();\n\n      if (h().getBool(\"IS_BROWSER\")) try {\n        $l.registerManager(ph.URL_SCHEME, new dh());\n      } catch (a) {}\n      var mh = \"model\",\n          gh = \".json\",\n          vh = \".weights.bin\";\n\n      function yh(t) {\n        return new Promise(function (t) {\n          return setTimeout(t);\n        }).then(t);\n      }\n\n      var bh = function () {\n        function t(e) {\n          if (!h().getBool(\"IS_BROWSER\")) throw new Error(\"browserDownloads() cannot proceed because the current environment is not a browser.\");\n          e.startsWith(t.URL_SCHEME) && (e = e.slice(t.URL_SCHEME.length)), null != e && 0 !== e.length || (e = mh), this.modelTopologyFileName = e + gh, this.weightDataFileName = e + vh;\n        }\n\n        return t.prototype.save = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n, r, o, i, a;\n            return c(this, function (s) {\n              switch (s.label) {\n                case 0:\n                  if (\"undefined\" == typeof document) throw new Error(\"Browser downloads are not supported in this environment since `document` is not present\");\n                  if (e = window.URL.createObjectURL(new Blob([t.weightData], {\n                    type: \"application/octet-stream\"\n                  })), !(t.modelTopology instanceof ArrayBuffer)) return [3, 1];\n                  throw new Error(\"BrowserDownloads.save() does not support saving model topology in binary formats yet.\");\n\n                case 1:\n                  return n = [{\n                    paths: [\"./\" + this.weightDataFileName],\n                    weights: t.weightSpecs\n                  }], r = {\n                    modelTopology: t.modelTopology,\n                    format: t.format,\n                    generatedBy: t.generatedBy,\n                    convertedBy: t.convertedBy,\n                    weightsManifest: n\n                  }, o = window.URL.createObjectURL(new Blob([JSON.stringify(r)], {\n                    type: \"application/json\"\n                  })), (i = null == this.jsonAnchor ? document.createElement(\"a\") : this.jsonAnchor).download = this.modelTopologyFileName, i.href = o, [4, yh(function () {\n                    return i.dispatchEvent(new MouseEvent(\"click\"));\n                  })];\n\n                case 2:\n                  return s.sent(), null == t.weightData ? [3, 4] : ((a = null == this.weightDataAnchor ? document.createElement(\"a\") : this.weightDataAnchor).download = this.weightDataFileName, a.href = e, [4, yh(function () {\n                    return a.dispatchEvent(new MouseEvent(\"click\"));\n                  })]);\n\n                case 3:\n                  s.sent(), s.label = 4;\n\n                case 4:\n                  return [2, {\n                    modelArtifactsInfo: Wl(t)\n                  }];\n              }\n            });\n          });\n        }, t.URL_SCHEME = \"downloads://\", t;\n      }(),\n          wh = function () {\n        function t(t) {\n          if (null == t || t.length < 1) throw new Error(\"When calling browserFiles, at least 1 file is required, but received \" + t);\n          this.files = t;\n        }\n\n        return t.prototype.load = function () {\n          return u(this, void 0, void 0, function () {\n            var t,\n                e,\n                n = this;\n            return c(this, function (r) {\n              return t = this.files[0], e = this.files.slice(1), [2, new Promise(function (r, o) {\n                var i = new FileReader();\n                i.onload = function (i) {\n                  var a = JSON.parse(i.target.result),\n                      s = a.modelTopology;\n\n                  if (null != s) {\n                    0 === e.length && r({\n                      modelTopology: s\n                    });\n                    var u = a.weightsManifest;\n\n                    if (null != u) {\n                      var c;\n\n                      try {\n                        c = n.checkManifestAndWeightFiles(u, e);\n                      } catch (t) {\n                        return void o(t);\n                      }\n\n                      var l = [],\n                          h = [],\n                          p = [];\n                      u.forEach(function (t) {\n                        t.paths.forEach(function (t) {\n                          h.push(t), p.push(null);\n                        }), l.push.apply(l, t.weights);\n                      }), u.forEach(function (t) {\n                        t.paths.forEach(function (t) {\n                          var e = new FileReader();\n                          e.onload = function (e) {\n                            var n = e.target.result,\n                                o = h.indexOf(t);\n                            p[o] = n, -1 === p.indexOf(null) && r({\n                              modelTopology: s,\n                              weightSpecs: l,\n                              weightData: Ul(p)\n                            });\n                          }, e.onerror = function (e) {\n                            return o(\"Failed to weights data from file of path '\" + t + \"'.\");\n                          }, e.readAsArrayBuffer(c[t]);\n                        });\n                      });\n                    } else o(new Error(\"weightManifest field is missing from file \" + t.name));\n                  } else o(new Error(\"modelTopology field is missing from file \" + t.name));\n                }, i.onerror = function (e) {\n                  return o(\"Failed to read model topology and weights manifest JSON from file '\" + t.name + \"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.\");\n                }, i.readAsText(t);\n              })];\n            });\n          });\n        }, t.prototype.checkManifestAndWeightFiles = function (t, e) {\n          for (var n = [], r = e.map(function (t) {\n            return jl(t.name);\n          }), o = {}, i = 0, a = t; i < a.length; i++) a[i].paths.forEach(function (t) {\n            var i = jl(t);\n            if (-1 !== n.indexOf(i)) throw new Error(\"Duplicate file basename found in weights manifest: '\" + i + \"'\");\n            if (n.push(i), -1 === r.indexOf(i)) throw new Error(\"Weight file with basename '\" + i + \"' is not provided.\");\n            o[t] = e[r.indexOf(i)];\n          });\n\n          if (n.length !== e.length) throw new Error(\"Mismatch in the number of files in weights manifest (\" + n.length + \") and the number of weight files provided (\" + e.length + \").\");\n          return o;\n        }, t;\n      }();\n\n      function xh(t, e, n, r) {\n        !function (t) {\n          S(null != t && Array.isArray(t) && t.length > 0, function () {\n            return \"promises must be a none empty array\";\n          });\n        }(t), function (t, e) {\n          S(t >= 0 && t <= 1, function () {\n            return \"Progress fraction must be in range [0, 1], but got startFraction \" + t;\n          }), S(e >= 0 && e <= 1, function () {\n            return \"Progress fraction must be in range [0, 1], but got endFraction \" + e;\n          }), S(e >= t, function () {\n            return \"startFraction must be no more than endFraction, but got startFraction \" + t + \" and endFraction \" + e;\n          });\n        }(n = null == n ? 0 : n, r = null == r ? 1 : r);\n        var o = 0;\n        return Promise.all(t.map(function (i) {\n          return i.then(function (i) {\n            var a = n + ++o / t.length * (r - n);\n            return e(a), i;\n          }), i;\n        }));\n      }\n\n      function Sh(t, e) {\n        return u(this, void 0, void 0, function () {\n          var n, r, o, i, a, s, u, l, p;\n          return c(this, function (c) {\n            switch (c.label) {\n              case 0:\n                return null == e && (e = {}), n = null == e.fetchFunc ? h().platform.fetch : e.fetchFunc, r = t.map(function (t) {\n                  return n(t, e.requestInit, {\n                    isBinary: !0\n                  });\n                }), o = 0, i = .5, null != e.onProgress ? [3, 2] : [4, Promise.all(r)];\n\n              case 1:\n                return a = c.sent(), [3, 4];\n\n              case 2:\n                return [4, xh(r, e.onProgress, o, i)];\n\n              case 3:\n                a = c.sent(), c.label = 4;\n\n              case 4:\n                return s = a.map(function (t) {\n                  return t.arrayBuffer();\n                }), u = .5, l = 1, null != e.onProgress ? [3, 6] : [4, Promise.all(s)];\n\n              case 5:\n                return p = c.sent(), [3, 8];\n\n              case 6:\n                return [4, xh(s, e.onProgress, u, l)];\n\n              case 7:\n                p = c.sent(), c.label = 8;\n\n              case 8:\n                return [2, p];\n            }\n          });\n        });\n      }\n\n      function Eh(t) {\n        var e = this;\n        return function (n, r, o) {\n          return void 0 === r && (r = \"\"), u(e, void 0, void 0, function () {\n            var e, i, a, s, u, l, h, p, f, d;\n            return c(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  if (e = n.map(function () {\n                    return !1;\n                  }), i = {}, a = null != o ? o.map(function () {\n                    return !1;\n                  }) : [], s = [], n.forEach(function (t, n) {\n                    var r = 0;\n                    t.weights.forEach(function (t) {\n                      var u = \"quantization\" in t ? t.quantization.dtype : t.dtype,\n                          c = Fl[u] * A(t.shape),\n                          l = function () {\n                        e[n] = !0, null == i[n] && (i[n] = []), i[n].push({\n                          manifestEntry: t,\n                          groupOffset: r,\n                          sizeBytes: c\n                        });\n                      };\n\n                      null != o ? o.forEach(function (e, n) {\n                        e === t.name && (l(), a[n] = !0);\n                      }) : l(), s.push(t.name), r += c;\n                    });\n                  }), !a.every(function (t) {\n                    return t;\n                  })) throw u = o.filter(function (t, e) {\n                    return !a[e];\n                  }), new Error(\"Could not find weights in manifest with names: \" + u.join(\", \") + \". \\nManifest JSON has weights with names: \" + s.join(\", \") + \".\");\n                  return l = e.reduce(function (t, e, n) {\n                    return e && t.push(n), t;\n                  }, []), h = [], l.forEach(function (t) {\n                    n[t].paths.forEach(function (t) {\n                      var e = r + (r.endsWith(\"/\") ? \"\" : \"/\") + t;\n                      h.push(e);\n                    });\n                  }), [4, t(h)];\n\n                case 1:\n                  return p = c.sent(), f = {}, d = 0, l.forEach(function (t) {\n                    for (var e = n[t].paths.length, r = 0, o = 0; o < e; o++) r += p[d + o].byteLength;\n\n                    for (var a = new ArrayBuffer(r), s = new Uint8Array(a), u = 0, c = 0; c < e; c++) {\n                      var l = new Uint8Array(p[d + c]);\n                      s.set(l, u), u += l.byteLength;\n                    }\n\n                    i[t].forEach(function (t) {\n                      var e = Bl(a.slice(t.groupOffset, t.groupOffset + t.sizeBytes), [t.manifestEntry]);\n\n                      for (var n in e) f[n] = e[n];\n                    }), d += e;\n                  }), [2, f];\n              }\n            });\n          });\n        };\n      }\n\n      Gl.registerSaveRouter(function (t) {\n        return h().getBool(\"IS_BROWSER\") && !Array.isArray(t) && t.startsWith(bh.URL_SCHEME) ? (void 0 === (e = t.slice(bh.URL_SCHEME.length)) && (e = \"model\"), new bh(e)) : null;\n        var e;\n      });\n\n      var Ch = function () {\n        function t(t, e) {\n          if (this.DEFAULT_METHOD = \"POST\", null == e && (e = {}), this.weightPathPrefix = e.weightPathPrefix, this.onProgress = e.onProgress, null != e.fetchFunc ? (S(\"function\" == typeof e.fetchFunc, function () {\n            return \"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)\";\n          }), this.fetch = e.fetchFunc) : this.fetch = h().platform.fetch, S(null != t && t.length > 0, function () {\n            return \"URL path for http must not be null, undefined or empty.\";\n          }), Array.isArray(t) && S(2 === t.length, function () {\n            return \"URL paths for http must have a length of 2, (actual length is \" + t.length + \").\";\n          }), this.path = t, null != e.requestInit && null != e.requestInit.body) throw new Error(\"requestInit is expected to have no pre-existing body, but has one.\");\n          this.requestInit = e.requestInit || {};\n        }\n\n        return t.prototype.save = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n, r, o;\n            return c(this, function (i) {\n              switch (i.label) {\n                case 0:\n                  if (t.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.\");\n                  return (e = Object.assign({\n                    method: this.DEFAULT_METHOD\n                  }, this.requestInit)).body = new FormData(), n = [{\n                    paths: [\"./model.weights.bin\"],\n                    weights: t.weightSpecs\n                  }], r = {\n                    modelTopology: t.modelTopology,\n                    format: t.format,\n                    generatedBy: t.generatedBy,\n                    convertedBy: t.convertedBy,\n                    userDefinedMetadata: t.userDefinedMetadata,\n                    weightsManifest: n\n                  }, e.body.append(\"model.json\", new Blob([JSON.stringify(r)], {\n                    type: \"application/json\"\n                  }), \"model.json\"), null != t.weightData && e.body.append(\"model.weights.bin\", new Blob([t.weightData], {\n                    type: \"application/octet-stream\"\n                  }), \"model.weights.bin\"), [4, this.fetch(this.path, e)];\n\n                case 1:\n                  if ((o = i.sent()).ok) return [2, {\n                    modelArtifactsInfo: Wl(t),\n                    responses: [o]\n                  }];\n                  throw new Error(\"BrowserHTTPRequest.save() failed due to HTTP response status \" + o.status + \".\");\n              }\n            });\n          });\n        }, t.prototype.load = function () {\n          return u(this, void 0, void 0, function () {\n            var t, e, n, r, o, i, a, s;\n            return c(this, function (u) {\n              switch (u.label) {\n                case 0:\n                  return [4, this.fetch(this.path, this.requestInit)];\n\n                case 1:\n                  if (!(t = u.sent()).ok) throw new Error(\"Request to \" + this.path + \" failed with status code \" + t.status + \". Please verify this URL points to the model JSON of the model to load.\");\n                  u.label = 2;\n\n                case 2:\n                  return u.trys.push([2, 4,, 5]), [4, t.json()];\n\n                case 3:\n                  return e = u.sent(), [3, 5];\n\n                case 4:\n                  throw u.sent(), n = \"Failed to parse model JSON of response from \" + this.path + \".\", this.path.endsWith(\".pb\") ? n += \" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.\" : n += \" Please make sure the server is serving valid JSON for this request.\", new Error(n);\n\n                case 5:\n                  if (r = e.modelTopology, o = e.weightsManifest, null == r && null == o) throw new Error(\"The JSON from HTTP path \" + this.path + \" contains neither model topology or manifest for weights.\");\n                  return null == o ? [3, 7] : [4, this.loadWeights(o)];\n\n                case 6:\n                  s = u.sent(), i = s[0], a = s[1], u.label = 7;\n\n                case 7:\n                  return [2, {\n                    modelTopology: r,\n                    weightSpecs: i,\n                    weightData: a\n                  }];\n              }\n            });\n          });\n        }, t.prototype.loadWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e, n, r, o, i, a, s, u, l, h, p;\n            return c(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  for (e = Array.isArray(this.path) ? this.path[1] : this.path, n = function (t) {\n                    var e = t.lastIndexOf(\"/\"),\n                        n = t.lastIndexOf(\"?\");\n                    return [t.substring(0, e) + \"/\", n > e ? t.substring(n) : \"\"];\n                  }(e), r = n[0], o = n[1], i = this.weightPathPrefix || r, a = [], s = 0, u = t; s < u.length; s++) l = u[s], a.push.apply(a, l.weights);\n\n                  return h = [], t.forEach(function (t) {\n                    t.paths.forEach(function (t) {\n                      h.push(i + t + o);\n                    });\n                  }), [4, Sh(h, {\n                    requestInit: this.requestInit,\n                    fetchFunc: this.fetch,\n                    onProgress: this.onProgress\n                  })];\n\n                case 1:\n                  return p = c.sent(), [2, [a, Ul(p)]];\n              }\n            });\n          });\n        }, t.URL_SCHEME_REGEX = /^https?:\\/\\//, t;\n      }();\n\n      function Ih(t) {\n        return null != t.match(Ch.URL_SCHEME_REGEX);\n      }\n\n      var Ah = function (t, e) {\n        return \"undefined\" == typeof fetch ? null : (Array.isArray(t) ? t.every(function (t) {\n          return Ih(t);\n        }) : Ih(t)) ? kh(t, {\n          onProgress: e\n        }) : null;\n      };\n\n      function kh(t, e) {\n        return new Ch(t, e);\n      }\n\n      Gl.registerSaveRouter(Ah), Gl.registerLoadRouter(Ah);\n\n      var Th = function () {\n        function t(t) {\n          this.modelArtifacts = t;\n        }\n\n        return t.prototype.load = function () {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              return [2, this.modelArtifacts];\n            });\n          });\n        }, t;\n      }(),\n          Nh = function () {\n        function t(t) {\n          this.saveHandler = t;\n        }\n\n        return t.prototype.save = function (t) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (e) {\n              return [2, this.saveHandler(t)];\n            });\n          });\n        }, t;\n      }(),\n          Ph = Object.freeze({\n        browserFiles: function (t) {\n          return new wh(t);\n        },\n        browserHTTPRequest: function (t, e) {\n          return kh(t, e);\n        },\n        concatenateArrayBuffers: Ul,\n        decodeWeights: Bl,\n        encodeWeights: function (t, e) {\n          return u(this, void 0, void 0, function () {\n            var n,\n                r,\n                o,\n                i,\n                a,\n                s = this;\n            return c(this, function (l) {\n              switch (l.label) {\n                case 0:\n                  for (n = [], r = [], o = Array.isArray(t) ? t.map(function (t) {\n                    return t.name;\n                  }) : Object.keys(t), i = function (i) {\n                    var a = o[i],\n                        l = Array.isArray(t) ? t[i].tensor : t[a];\n                    if (\"float32\" !== l.dtype && \"int32\" !== l.dtype && \"bool\" !== l.dtype && \"string\" !== l.dtype) throw new Error(\"Unsupported dtype in weight '\" + a + \"': \" + l.dtype);\n                    var h = {\n                      name: a,\n                      shape: l.shape,\n                      dtype: l.dtype\n                    };\n\n                    if (\"string\" === l.dtype) {\n                      var p = new Promise(function (t) {\n                        return u(s, void 0, void 0, function () {\n                          var e, n, r, o, i, a, s;\n                          return c(this, function (u) {\n                            switch (u.label) {\n                              case 0:\n                                return [4, l.bytes()];\n\n                              case 1:\n                                for (e = u.sent(), n = e.reduce(function (t, e) {\n                                  return t + e.length;\n                                }, 0) + Ll * e.length, r = new Uint8Array(n), o = 0, i = 0; i < e.length; i++) a = e[i], s = new Uint8Array(new Uint32Array([a.length]).buffer), r.set(s, o), o += Ll, r.set(a, o), o += a.length;\n\n                                return t(r), [2];\n                            }\n                          });\n                        });\n                      });\n                      r.push(p);\n                    } else r.push(l.data());\n\n                    null != e && (h.group = e), n.push(h);\n                  }, a = 0; a < o.length; ++a) i(a);\n\n                  return [4, Promise.all(r)];\n\n                case 1:\n                  return [2, {\n                    data: zl(l.sent()),\n                    specs: n\n                  }];\n              }\n            });\n          });\n        },\n        fromMemory: function (t, e, n, r) {\n          return 1 === arguments.length ? null != t.modelTopology || null != t.weightSpecs ? new Th(t) : (console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"), new Th({\n            modelTopology: t\n          })) : (console.warn(\"Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.\"), new Th({\n            modelTopology: t,\n            weightSpecs: e,\n            weightData: n,\n            trainingConfig: r\n          }));\n        },\n        getLoadHandlers: function (t, e) {\n          return Gl.getLoadHandlers(t, e);\n        },\n        getModelArtifactsInfoForJSON: Wl,\n        getSaveHandlers: function (t) {\n          return Gl.getSaveHandlers(t);\n        },\n        http: kh,\n        isHTTPScheme: Ih,\n        loadWeights: function (t, e, n, r) {\n          return void 0 === e && (e = \"\"), u(this, void 0, void 0, function () {\n            return c(this, function (o) {\n              return [2, Eh(function (t) {\n                return Sh(t, {\n                  requestInit: r\n                });\n              })(t, e, n)];\n            });\n          });\n        },\n        registerLoadRouter: function (t) {\n          return Gl.registerLoadRouter(t);\n        },\n        registerSaveRouter: function (t) {\n          return Gl.registerSaveRouter(t);\n        },\n        weightsLoaderFactory: Eh,\n        withSaveHandler: function (t) {\n          return new Nh(t);\n        },\n        copyModel: function (t, e) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (n) {\n              return [2, Ql(t, e, !1)];\n            });\n          });\n        },\n        listModels: function () {\n          return u(this, void 0, void 0, function () {\n            var t, e, n, r, o, i, a;\n            return c(this, function (s) {\n              switch (s.label) {\n                case 0:\n                  t = $l.getSchemes(), e = {}, n = 0, r = t, s.label = 1;\n\n                case 1:\n                  return n < r.length ? (o = r[n], [4, $l.getManager(o).listModels()]) : [3, 4];\n\n                case 2:\n                  for (a in i = s.sent()) e[o + Hl + a] = i[a];\n\n                  s.label = 3;\n\n                case 3:\n                  return n++, [3, 1];\n\n                case 4:\n                  return [2, e];\n              }\n            });\n          });\n        },\n        moveModel: function (t, e) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (n) {\n              return [2, Ql(t, e, !0)];\n            });\n          });\n        },\n        removeModel: function (t) {\n          return u(this, void 0, void 0, function () {\n            var e;\n            return c(this, function (n) {\n              return e = Kl(t), [2, $l.getManager(e.scheme).removeModel(e.path)];\n            });\n          });\n        }\n      }),\n          Rh = an({\n        confusionMatrix_: function (t, e, n) {\n          var r = $e(t, \"labels\", \"confusionMatrix\"),\n              o = $e(e, \"predictions\", \"confusionMatrix\");\n          S(null == n || n > 0 && Number.isInteger(n), function () {\n            return \"If provided, numClasses must be a positive integer, but got \" + n;\n          }), S(1 === r.rank, function () {\n            return \"Expected the rank of labels to be 1, but got \" + r.rank;\n          }), S(1 === o.rank, function () {\n            return \"Expected the rank of predictions to be 1, but got \" + o.rank;\n          }), S(r.shape[0] === o.shape[0], function () {\n            return \"Mismatch in the number of examples: \" + r.shape[0] + \" vs. \" + o.shape[0] + \". Labels and predictions should have the same number of elements.\";\n          }), S(n > 0 && Number.isInteger(n), function () {\n            return \"numClasses is required to be a positive integer, but got \" + n;\n          });\n          var i = Xn(r.asType(\"int32\"), n),\n              a = Xn(o.asType(\"int32\"), n);\n          return i.transpose().matMul(a).asType(\"int32\");\n        }\n      }),\n          _h = (Object.freeze({\n        confusionMatrix: Rh\n      }), an({\n        fromPixels_: function (t, e) {\n          if (void 0 === e && (e = 3), e > 4) throw new Error(\"Cannot construct Tensor with more than 4 channels from pixels.\");\n          var n = \"undefined\" != typeof HTMLVideoElement && t instanceof HTMLVideoElement;\n          if (n && n && t.readyState < 2) throw new Error(\"The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.\");\n          return Mt.fromPixels(t, e);\n        }\n      })),\n          Mh = (Object.freeze({\n        toPixels: function (t, e) {\n          return u(this, void 0, void 0, function () {\n            var n, r, o, i, a, s, u, l, h, p, f, d, m, g, v, y, b, w, x, S, E, C, I;\n            return c(this, function (c) {\n              switch (c.label) {\n                case 0:\n                  if (n = $e(t, \"img\", \"toPixels\"), t instanceof vt || (n = n.toInt()), 2 !== n.rank && 3 !== n.rank) throw new Error(\"toPixels only supports rank 2 or 3 tensors, got rank \" + n.rank + \".\");\n                  if (r = n.shape.slice(0, 2), o = r[0], i = r[1], (a = 2 === n.rank ? 1 : n.shape[2]) > 4 || 2 === a) throw new Error(\"toPixels only supports depth of size 1, 3 or 4 but got \" + a);\n                  return [4, n.data()];\n\n                case 1:\n                  return s = c.sent(), u = n.min(), l = n.max(), [4, Promise.all([u.data(), l.data()])];\n\n                case 2:\n                  if (h = c.sent(), p = h[0], f = h[1], d = p[0], m = f[0], u.dispose(), l.dispose(), \"float32\" === n.dtype) {\n                    if (d < 0 || m > 1) throw new Error(\"Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [\" + d + \" - \" + m + \"].\");\n                  } else {\n                    if (\"int32\" !== n.dtype) throw new Error(\"Unsupported type for toPixels: \" + n.dtype + \". Please use float32 or int32 tensors.\");\n                    if (d < 0 || m > 255) throw new Error(\"Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [\" + d + \" - \" + m + \"].\");\n                  }\n\n                  for (g = \"float32\" === n.dtype ? 255 : 1, v = new Uint8ClampedArray(i * o * 4), y = 0; y < o * i; ++y) b = void 0, w = void 0, x = void 0, S = void 0, 1 === a ? (b = s[y] * g, w = s[y] * g, x = s[y] * g, S = 255) : 3 === a ? (b = s[3 * y] * g, w = s[3 * y + 1] * g, x = s[3 * y + 2] * g, S = 255) : 4 === a && (b = s[4 * y] * g, w = s[4 * y + 1] * g, x = s[4 * y + 2] * g, S = s[4 * y + 3] * g), v[0 + (E = 4 * y)] = Math.round(b), v[E + 1] = Math.round(w), v[E + 2] = Math.round(x), v[E + 3] = Math.round(S);\n\n                  return null != e && (e.width = i, e.height = o, C = e.getContext(\"2d\"), I = new ImageData(v, i, o), C.putImageData(I, 0, 0)), n !== t && n.dispose(), [2, v];\n              }\n            });\n          });\n        },\n        fromPixels: _h\n      }), function () {\n        function t() {}\n\n        return t.prototype.getClassName = function () {\n          return this.constructor.className;\n        }, t.fromConfig = function (t, e) {\n          return new t(e);\n        }, t;\n      }()),\n          Oh = function () {\n        function t() {\n          this.classNameMap = {};\n        }\n\n        return t.getMap = function () {\n          return null == t.instance && (t.instance = new t()), t.instance;\n        }, t.register = function (e) {\n          t.getMap().classNameMap[e.className] = [e, e.fromConfig];\n        }, t;\n      }();\n\n      function Dh(t) {\n        S(null != t.className, function () {\n          return \"Class being registered does not have the static className property defined.\";\n        }), S(\"string\" == typeof t.className, function () {\n          return \"className is required to be a string, but got type \" + typeof t.className;\n        }), S(t.className.length > 0, function () {\n          return \"Class being registered has an empty-string as its className, which is disallowed.\";\n        }), Oh.register(t);\n      }\n\n      Object.freeze({\n        Serializable: Mh,\n        SerializationMap: Oh,\n        registerClass: Dh\n      });\n      var Fh = .001,\n          Lh = .1;\n\n      function Bh() {\n        return 32 === Mt.backend.floatPrecision() ? Fh : Lh;\n      }\n\n      function zh(t, e, n) {\n        var r = !0;\n\n        if ((V(t) || V(e)) && (r = !1), V(t) && V(e) && (r = !0), r) {\n          var o = t.constructor.name,\n              i = e.constructor.name;\n          if (o !== i) throw new Error(\"Arrays are of different type. Actual: \" + o + \". Expected: \" + i);\n        }\n\n        if (Array.isArray(t) && Array.isArray(e)) {\n          var a = Ge(t),\n              s = Ge(e);\n          if (!k(a, s)) throw new Error(\"Arrays have different shapes. Actual: [\" + a + \"]. Expected: [\" + s + \"]\");\n        }\n\n        var u = V(t) ? t : I(t),\n            c = V(e) ? e : I(e);\n        if (u.length !== c.length) throw new Error(\"Arrays have different lengths actual: \" + u.length + \" vs expected: \" + c.length + \".\\nActual:   \" + u + \".\\nExpected: \" + c + \".\");\n\n        for (var l = 0; l < c.length; ++l) {\n          var h = u[l],\n              p = c[l];\n          if (!n(h, p)) throw new Error(\"Arrays differ: actual[\" + l + \"] = \" + h + \", expected[\" + l + \"] = \" + p + \".\\nActual:   \" + u + \".\\nExpected: \" + c + \".\");\n        }\n      }\n\n      function qh(t, e, n) {\n        return !isFinite(t) && !isFinite(e) || !(isNaN(t) || isNaN(e) || Math.abs(t - e) > n);\n      }\n\n      Object.freeze({\n        TEST_EPSILON_FLOAT16: Lh,\n        expectArraysClose: function (t, e, n) {\n          return null == n && (n = Bh()), zh(t, e, function (t, e) {\n            return qh(t, e, n);\n          });\n        },\n        testEpsilon: Bh,\n        expectPromiseToFail: function (t, e) {\n          t().then(function () {\n            return e.fail();\n          }, function () {\n            return e();\n          });\n        },\n        expectArraysEqual: function (t, e) {\n          var n = \"string\" == typeof e || \"number\" == typeof e || \"boolean\" == typeof e ? [e] : e;\n          return W(t) || W(t[0]) || W(e) || W(e[0]) ? zh(t, n, function (t, e) {\n            return t == e;\n          }) : zh(t, e, function (t, e) {\n            return qh(t, e, 0);\n          });\n        },\n        expectNumbersClose: function (t, e, n) {\n          if (null == n && (n = Bh()), !qh(t, e, n)) throw new Error(\"Numbers differ: actual === \" + t + \", expected === \" + e);\n        },\n        expectValuesInRange: function (t, e, n) {\n          for (var r = 0; r < t.length; r++) if (t[r] < e || t[r] > n) throw new Error(\"Value out of range:\" + t[r] + \" low: \" + e + \", high: \" + n);\n        },\n        expectArrayBuffersEqual: function (t, e) {\n          expect(new Float32Array(t)).toEqual(new Float32Array(e));\n        }\n      }), Object.freeze({\n        gpgpu_util: Bi,\n        webgl_util: ze,\n        forceHalfFloat: function () {\n          h().set(\"WEBGL_FORCE_F16_TEXTURES\", !0);\n        },\n        MathBackendWebGL: $a,\n        setWebGLContext: Vt,\n        GPGPUContext: zi\n      });\n\n      var Vh = function (t) {\n        function e() {\n          return null !== t && t.apply(this, arguments) || this;\n        }\n\n        return s(e, t), e.prototype.minimize = function (t, e, n) {\n          void 0 === e && (e = !1);\n          var r = this.computeGradients(t, n),\n              o = r.value,\n              i = r.grads;\n\n          if (null != n) {\n            var a = n.map(function (t) {\n              return {\n                name: t.name,\n                tensor: i[t.name]\n              };\n            });\n            this.applyGradients(a);\n          } else this.applyGradients(i);\n\n          return je(i), e ? o : (o.dispose(), null);\n        }, Object.defineProperty(e.prototype, \"iterations\", {\n          get: function () {\n            return null == this.iterations_ && (this.iterations_ = 0), this.iterations_;\n          },\n          enumerable: !0,\n          configurable: !0\n        }), e.prototype.incrementIterations = function () {\n          this.iterations_ = this.iterations + 1;\n        }, e.prototype.computeGradients = function (t, e) {\n          return function (t, e) {\n            S(K(t), function () {\n              return \"The f passed in variableGrads(f) must be a function\";\n            }), S(null == e || Array.isArray(e) && e.every(function (t) {\n              return t instanceof Et;\n            }), function () {\n              return \"The varList passed in variableGrads(f, varList) must be an array of variables\";\n            });\n            var n = null != e;\n            if (!n) for (var r in e = [], Mt.registeredVariables) e.push(Mt.registeredVariables[r]);\n            var o = n ? e.filter(function (t) {\n              return !t.trainable;\n            }) : null,\n                i = e.length;\n            S((e = e.filter(function (t) {\n              return t.trainable;\n            })).length > 0, function () {\n              return \"variableGrads() expects at least one of the input variables to be trainable, but none of the \" + i + \" variables is trainable.\";\n            });\n            var a = Mt.gradients(t, e, null, !0),\n                s = a.value,\n                u = a.grads;\n            S(u.some(function (t) {\n              return null != t;\n            }), function () {\n              return \"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\";\n            }), S(0 === s.rank, function () {\n              return \"The f passed in variableGrads(f) must return a scalar, but it returned a rank-\" + s.rank + \" tensor\";\n            });\n            var c = {};\n            return e.forEach(function (t, e) {\n              null != u[e] && (c[t.name] = u[e]);\n            }), null != o && o.forEach(function (t) {\n              return c[t.name] = null;\n            }), {\n              value: s,\n              grads: c\n            };\n          }(t, e);\n        }, e.prototype.dispose = function () {\n          null != this.iterations_ && je(this.iterations_);\n        }, e.prototype.saveIterations = function () {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              return null == this.iterations_ && (this.iterations_ = 0), [2, {\n                name: \"iter\",\n                tensor: pn(this.iterations_, \"int32\")\n              }];\n            });\n          });\n        }, e.prototype.getWeights = function () {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              throw new Error(\"getWeights() is not implemented for this optimizer yet.\");\n            });\n          });\n        }, e.prototype.setWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              throw new Error(\"setWeights() is not implemented for this optimizer class \" + this.getClassName());\n            });\n          });\n        }, e.prototype.extractIterations = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e;\n            return c(this, function (n) {\n              switch (n.label) {\n                case 0:\n                  return e = this, [4, t[0].tensor.data()];\n\n                case 1:\n                  return e.iterations_ = n.sent()[0], [2, t.slice(1)];\n              }\n            });\n          });\n        }, e;\n      }(Mh);\n\n      Object.defineProperty(Vh, Symbol.hasInstance, {\n        value: function (t) {\n          return null != t.minimize && null != t.computeGradients && null != t.applyGradients;\n        }\n      });\n\n      var Uh = function (t) {\n        function e(e, n, r) {\n          void 0 === r && (r = null);\n          var o = t.call(this) || this;\n          return o.learningRate = e, o.rho = n, o.epsilon = r, o.accumulatedGrads = [], o.accumulatedUpdates = [], null == r && (o.epsilon = Mt.backend.epsilon()), o;\n        }\n\n        return s(e, t), e.prototype.applyGradients = function (t) {\n          var e = this;\n          (Array.isArray(t) ? t.map(function (t) {\n            return t.name;\n          }) : Object.keys(t)).forEach(function (n, r) {\n            var o = Mt.registeredVariables[n];\n            null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {\n              originalName: n + \"/accum_grad\",\n              variable: Ue(function () {\n                return Sn(o).variable(!1);\n              })\n            }), null == e.accumulatedUpdates[r] && (e.accumulatedUpdates[r] = {\n              originalName: n + \"/accum_var\",\n              variable: Ue(function () {\n                return Sn(o).variable(!1);\n              })\n            });\n            var i = Array.isArray(t) ? t[r].tensor : t[n];\n\n            if (null != i) {\n              var a = e.accumulatedGrads[r].variable,\n                  s = e.accumulatedUpdates[r].variable;\n              Ue(function () {\n                var t = a.mul(e.rho).add(i.square().mul(1 - e.rho)),\n                    n = s.add(e.epsilon).sqrt().div(a.add(e.epsilon).sqrt()).mul(i),\n                    r = s.mul(e.rho).add(n.square().mul(1 - e.rho));\n                a.assign(t), s.assign(r);\n                var u = n.mul(-e.learningRate).add(o);\n                o.assign(u);\n              });\n            }\n          }), this.incrementIterations();\n        }, e.prototype.dispose = function () {\n          null != this.accumulatedUpdates && (je(this.accumulatedGrads.map(function (t) {\n            return t.variable;\n          })), je(this.accumulatedUpdates.map(function (t) {\n            return t.variable;\n          })));\n        }, e.prototype.getWeights = function () {\n          return u(this, void 0, void 0, function () {\n            var t;\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return t = this.accumulatedGrads.concat(this.accumulatedUpdates), [4, this.saveIterations()];\n\n                case 1:\n                  return [2, [e.sent()].concat(t.map(function (t) {\n                    return {\n                      name: t.originalName,\n                      tensor: t.variable\n                    };\n                  }))];\n              }\n            });\n          });\n        }, e.prototype.setWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e;\n            return c(this, function (n) {\n              switch (n.label) {\n                case 0:\n                  return [4, this.extractIterations(t)];\n\n                case 1:\n                  return t = n.sent(), e = t.length / 2, this.accumulatedGrads = t.slice(0, e).map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  }), this.accumulatedUpdates = t.slice(e, 2 * e).map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  }), [2];\n              }\n            });\n          });\n        }, e.prototype.getConfig = function () {\n          return {\n            learningRate: this.learningRate,\n            rho: this.rho,\n            epsilon: this.epsilon\n          };\n        }, e.fromConfig = function (t, e) {\n          return new t(e.learningRate, e.rho, e.epsilon);\n        }, e.className = \"Adadelta\", e;\n      }(Vh);\n\n      Dh(Uh);\n\n      var jh = function (t) {\n        function e(e, n) {\n          void 0 === n && (n = .1);\n          var r = t.call(this) || this;\n          return r.learningRate = e, r.initialAccumulatorValue = n, r.accumulatedGrads = [], r;\n        }\n\n        return s(e, t), e.prototype.applyGradients = function (t) {\n          var e = this;\n          (Array.isArray(t) ? t.map(function (t) {\n            return t.name;\n          }) : Object.keys(t)).forEach(function (n, r) {\n            var o = Mt.registeredVariables[n];\n            null == e.accumulatedGrads[r] && (e.accumulatedGrads[r] = {\n              originalName: n + \"/accumulator\",\n              variable: Ue(function () {\n                return bn(o.shape, e.initialAccumulatorValue).variable(!1);\n              })\n            });\n            var i = Array.isArray(t) ? t[r].tensor : t[n];\n\n            if (null != i) {\n              var a = e.accumulatedGrads[r].variable;\n              Ue(function () {\n                var t = a.add(i.square());\n                a.assign(t);\n                var n = i.div(t.add(Mt.backend.epsilon()).sqrt()).mul(-e.learningRate).add(o);\n                o.assign(n);\n              });\n            }\n          }), this.incrementIterations();\n        }, e.prototype.dispose = function () {\n          null != this.accumulatedGrads && je(this.accumulatedGrads.map(function (t) {\n            return t.variable;\n          }));\n        }, e.prototype.getWeights = function () {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, this.saveIterations()];\n\n                case 1:\n                  return [2, [t.sent()].concat(this.accumulatedGrads.map(function (t) {\n                    return {\n                      name: t.originalName,\n                      tensor: t.variable\n                    };\n                  }))];\n              }\n            });\n          });\n        }, e.prototype.setWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return [4, this.extractIterations(t)];\n\n                case 1:\n                  return t = e.sent(), this.accumulatedGrads = t.map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  }), [2];\n              }\n            });\n          });\n        }, e.prototype.getConfig = function () {\n          return {\n            learningRate: this.learningRate,\n            initialAccumulatorValue: this.initialAccumulatorValue\n          };\n        }, e.fromConfig = function (t, e) {\n          return new t(e.learningRate, e.initialAccumulatorValue);\n        }, e.className = \"Adagrad\", e;\n      }(Vh);\n\n      Dh(jh);\n\n      var Wh = function (t) {\n        function e(e, n, r, o) {\n          void 0 === o && (o = null);\n          var i = t.call(this) || this;\n          return i.learningRate = e, i.beta1 = n, i.beta2 = r, i.epsilon = o, i.accumulatedFirstMoment = [], i.accumulatedSecondMoment = [], Ue(function () {\n            i.accBeta1 = pn(n).variable(), i.accBeta2 = pn(r).variable();\n          }), null == o && (i.epsilon = Mt.backend.epsilon()), i;\n        }\n\n        return s(e, t), e.prototype.applyGradients = function (t) {\n          var e = this,\n              n = Array.isArray(t) ? t.map(function (t) {\n            return t.name;\n          }) : Object.keys(t);\n          Ue(function () {\n            var r = du(1, e.accBeta1),\n                o = du(1, e.accBeta2);\n            n.forEach(function (n, i) {\n              var a = Mt.registeredVariables[n];\n              null == e.accumulatedFirstMoment[i] && (e.accumulatedFirstMoment[i] = {\n                originalName: n + \"/m\",\n                variable: Ue(function () {\n                  return Sn(a).variable(!1);\n                })\n              }), null == e.accumulatedSecondMoment[i] && (e.accumulatedSecondMoment[i] = {\n                originalName: n + \"/v\",\n                variable: Ue(function () {\n                  return Sn(a).variable(!1);\n                })\n              });\n              var s = Array.isArray(t) ? t[i].tensor : t[n];\n\n              if (null != s) {\n                var u = e.accumulatedFirstMoment[i].variable,\n                    c = e.accumulatedSecondMoment[i].variable,\n                    l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),\n                    h = c.mul(e.beta2).add(s.square().mul(1 - e.beta2)),\n                    p = l.div(r),\n                    f = h.div(o);\n                u.assign(l), c.assign(h);\n                var d = p.div(f.sqrt().add(e.epsilon)).mul(-e.learningRate).add(a);\n                a.assign(d);\n              }\n            }), e.accBeta1.assign(e.accBeta1.mul(e.beta1)), e.accBeta2.assign(e.accBeta2.mul(e.beta2));\n          }), this.incrementIterations();\n        }, e.prototype.dispose = function () {\n          this.accBeta1.dispose(), this.accBeta2.dispose(), null != this.accumulatedFirstMoment && je(this.accumulatedFirstMoment.map(function (t) {\n            return t.variable;\n          })), null != this.accumulatedSecondMoment && je(this.accumulatedSecondMoment.map(function (t) {\n            return t.variable;\n          }));\n        }, e.prototype.getWeights = function () {\n          return u(this, void 0, void 0, function () {\n            var t;\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return t = this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment), [4, this.saveIterations()];\n\n                case 1:\n                  return [2, [e.sent()].concat(t.map(function (t) {\n                    return {\n                      name: t.originalName,\n                      tensor: t.variable\n                    };\n                  }))];\n              }\n            });\n          });\n        }, e.prototype.setWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e,\n                n = this;\n            return c(this, function (r) {\n              switch (r.label) {\n                case 0:\n                  return [4, this.extractIterations(t)];\n\n                case 1:\n                  return t = r.sent(), Ue(function () {\n                    n.accBeta1.assign(lu(n.beta1, n.iterations_ + 1)), n.accBeta2.assign(lu(n.beta2, n.iterations_ + 1));\n                  }), e = t.length / 2, this.accumulatedFirstMoment = t.slice(0, e).map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  }), this.accumulatedSecondMoment = t.slice(e, 2 * e).map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  }), [2];\n              }\n            });\n          });\n        }, e.prototype.getConfig = function () {\n          return {\n            learningRate: this.learningRate,\n            beta1: this.beta1,\n            beta2: this.beta2,\n            epsilon: this.epsilon\n          };\n        }, e.fromConfig = function (t, e) {\n          return new t(e.learningRate, e.beta1, e.beta2, e.epsilon);\n        }, e.className = \"Adam\", e;\n      }(Vh);\n\n      Dh(Wh);\n\n      var Gh = function (t) {\n        function e(e, n, r, o, i) {\n          void 0 === o && (o = null), void 0 === i && (i = 0);\n          var a = t.call(this) || this;\n          return a.learningRate = e, a.beta1 = n, a.beta2 = r, a.epsilon = o, a.decay = i, a.accumulatedFirstMoment = [], a.accumulatedWeightedInfNorm = [], Ue(function () {\n            a.iteration = pn(0).variable(), a.accBeta1 = pn(n).variable();\n          }), null == o && (a.epsilon = Mt.backend.epsilon()), a;\n        }\n\n        return s(e, t), e.prototype.applyGradients = function (t) {\n          var e = this,\n              n = Array.isArray(t) ? t.map(function (t) {\n            return t.name;\n          }) : Object.keys(t);\n          Ue(function () {\n            var r = du(1, e.accBeta1),\n                o = Zs(-e.learningRate, e.iteration.mul(e.decay).add(1));\n            n.forEach(function (n, i) {\n              var a = Mt.registeredVariables[n];\n              null == e.accumulatedFirstMoment[i] && (e.accumulatedFirstMoment[i] = {\n                originalName: n + \"/m\",\n                variable: Sn(a).variable(!1)\n              }), null == e.accumulatedWeightedInfNorm[i] && (e.accumulatedWeightedInfNorm[i] = {\n                originalName: n + \"/v\",\n                variable: Sn(a).variable(!1)\n              });\n              var s = Array.isArray(t) ? t[i].tensor : t[n];\n\n              if (null != s) {\n                var u = e.accumulatedFirstMoment[i].variable,\n                    c = e.accumulatedWeightedInfNorm[i].variable,\n                    l = u.mul(e.beta1).add(s.mul(1 - e.beta1)),\n                    h = c.mul(e.beta2),\n                    p = s.abs(),\n                    f = h.maximum(p);\n                u.assign(l), c.assign(f);\n                var d = o.div(r).mul(l.div(f.add(e.epsilon))).add(a);\n                a.assign(d);\n              }\n            }), e.iteration.assign(e.iteration.add(1)), e.accBeta1.assign(e.accBeta1.mul(e.beta1));\n          }), this.incrementIterations();\n        }, e.prototype.dispose = function () {\n          this.accBeta1.dispose(), this.iteration.dispose(), null != this.accumulatedFirstMoment && je(this.accumulatedFirstMoment.map(function (t) {\n            return t.variable;\n          })), null != this.accumulatedWeightedInfNorm && je(this.accumulatedWeightedInfNorm.map(function (t) {\n            return t.variable;\n          }));\n        }, e.prototype.getWeights = function () {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              throw new Error(\"getWeights() is not implemented for Adamax yet.\");\n            });\n          });\n        }, e.prototype.setWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              throw new Error(\"setWeights() is not implemented for Adamax yet.\");\n            });\n          });\n        }, e.prototype.getConfig = function () {\n          return {\n            learningRate: this.learningRate,\n            beta1: this.beta1,\n            beta2: this.beta2,\n            epsilon: this.epsilon,\n            decay: this.decay\n          };\n        }, e.fromConfig = function (t, e) {\n          return new t(e.learningRate, e.beta1, e.beta2, e.epsilon, e.decay);\n        }, e.className = \"Adamax\", e;\n      }(Vh);\n\n      Dh(Gh);\n\n      var Hh = function (t) {\n        function e(e) {\n          var n = t.call(this) || this;\n          return n.learningRate = e, n.setLearningRate(e), n;\n        }\n\n        return s(e, t), e.prototype.applyGradients = function (t) {\n          var e = this;\n          (Array.isArray(t) ? t.map(function (t) {\n            return t.name;\n          }) : Object.keys(t)).forEach(function (n, r) {\n            var o = Array.isArray(t) ? t[r].tensor : t[n];\n\n            if (null != o) {\n              var i = Mt.registeredVariables[n];\n              Ue(function () {\n                var t = e.c.mul(o).add(i);\n                i.assign(t);\n              });\n            }\n          }), this.incrementIterations();\n        }, e.prototype.setLearningRate = function (t) {\n          this.learningRate = t, null != this.c && this.c.dispose(), this.c = function (t) {\n            return Mt.keep(t);\n          }(pn(-t));\n        }, e.prototype.dispose = function () {\n          this.c.dispose();\n        }, e.prototype.getWeights = function () {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, this.saveIterations()];\n\n                case 1:\n                  return [2, [t.sent()]];\n              }\n            });\n          });\n        }, e.prototype.setWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return [4, this.extractIterations(t)];\n\n                case 1:\n                  if (0 !== (t = e.sent()).length) throw new Error(\"SGD optimizer does not have settable weights.\");\n                  return [2];\n              }\n            });\n          });\n        }, e.prototype.getConfig = function () {\n          return {\n            learningRate: this.learningRate\n          };\n        }, e.fromConfig = function (t, e) {\n          return new t(e.learningRate);\n        }, e.className = \"SGD\", e;\n      }(Vh);\n\n      Dh(Hh);\n\n      var $h = function (t) {\n        function e(e, n, r) {\n          void 0 === r && (r = !1);\n          var o = t.call(this, e) || this;\n          return o.learningRate = e, o.momentum = n, o.useNesterov = r, o.accumulations = [], o.m = pn(o.momentum), o;\n        }\n\n        return s(e, t), e.prototype.applyGradients = function (t) {\n          var e = this;\n          (Array.isArray(t) ? t.map(function (t) {\n            return t.name;\n          }) : Object.keys(t)).forEach(function (n, r) {\n            var o = Mt.registeredVariables[n];\n            null == e.accumulations[r] && (e.accumulations[r] = {\n              originalName: n + \"/momentum\",\n              variable: Ue(function () {\n                return Sn(o).variable(!1);\n              })\n            });\n            var i = e.accumulations[r].variable,\n                a = Array.isArray(t) ? t[r].tensor : t[n];\n            null != a && Ue(function () {\n              var t,\n                  n = e.m.mul(i).add(a);\n              t = e.useNesterov ? e.c.mul(a.add(n.mul(e.m))).add(o) : e.c.mul(n).add(o), i.assign(n), o.assign(t);\n            });\n          }), this.incrementIterations();\n        }, e.prototype.dispose = function () {\n          this.m.dispose(), null != this.accumulations && je(this.accumulations.map(function (t) {\n            return t.variable;\n          }));\n        }, e.prototype.setMomentum = function (t) {\n          this.momentum = t;\n        }, e.prototype.getWeights = function () {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (t) {\n              switch (t.label) {\n                case 0:\n                  return [4, this.saveIterations()];\n\n                case 1:\n                  return [2, [t.sent()].concat(this.accumulations.map(function (t) {\n                    return {\n                      name: t.originalName,\n                      tensor: t.variable\n                    };\n                  }))];\n              }\n            });\n          });\n        }, e.prototype.setWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return [4, this.extractIterations(t)];\n\n                case 1:\n                  return t = e.sent(), this.accumulations = t.map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  }), [2];\n              }\n            });\n          });\n        }, e.prototype.getConfig = function () {\n          return {\n            learningRate: this.learningRate,\n            momentum: this.momentum,\n            useNesterov: this.useNesterov\n          };\n        }, e.fromConfig = function (t, e) {\n          return new t(e.learningRate, e.momentum, e.useNesterov);\n        }, e.className = \"Momentum\", e;\n      }(Hh);\n\n      Dh($h);\n\n      var Kh = function (t) {\n        function e(e, n, r, o, i) {\n          void 0 === n && (n = .9), void 0 === r && (r = 0), void 0 === o && (o = null), void 0 === i && (i = !1);\n          var a = t.call(this) || this;\n          return a.learningRate = e, a.decay = n, a.momentum = r, a.epsilon = o, a.accumulatedMeanSquares = [], a.accumulatedMoments = [], a.accumulatedMeanGrads = [], a.centered = i, null == o && (a.epsilon = Mt.backend.epsilon()), a;\n        }\n\n        return s(e, t), e.prototype.applyGradients = function (t) {\n          var e = this;\n          (Array.isArray(t) ? t.map(function (t) {\n            return t.name;\n          }) : Object.keys(t)).forEach(function (n, r) {\n            var o = Mt.registeredVariables[n];\n            null == e.accumulatedMeanSquares[r] && (e.accumulatedMeanSquares[r] = {\n              originalName: n + \"/rms\",\n              variable: Ue(function () {\n                return Sn(o).variable(!1);\n              })\n            }), null == e.accumulatedMoments[r] && (e.accumulatedMoments[r] = {\n              originalName: n + \"/momentum\",\n              variable: Ue(function () {\n                return Sn(o).variable(!1);\n              })\n            }), null == e.accumulatedMeanGrads[r] && e.centered && (e.accumulatedMeanGrads[r] = {\n              originalName: n + \"/mg\",\n              variable: Ue(function () {\n                return Sn(o).variable(!1);\n              })\n            });\n            var i = Array.isArray(t) ? t[r].tensor : t[n];\n\n            if (null != i) {\n              var a = e.accumulatedMeanSquares[r].variable,\n                  s = e.accumulatedMoments[r].variable;\n              Ue(function () {\n                var t = a.mul(e.decay).add(i.square().mul(1 - e.decay));\n\n                if (e.centered) {\n                  var n = e.accumulatedMeanGrads[r].variable,\n                      u = n.mul(e.decay).add(i.mul(1 - e.decay)),\n                      c = s.mul(e.momentum).add(i.mul(e.learningRate).div(t.sub(u.square().add(e.epsilon)).sqrt()));\n                  a.assign(t), n.assign(u), s.assign(c);\n                  var l = o.sub(c);\n                  o.assign(l);\n                } else {\n                  var h = a.mul(e.decay).add(i.square().mul(1 - e.decay));\n                  c = s.mul(e.momentum).add(i.mul(e.learningRate).div(h.add(e.epsilon).sqrt())), a.assign(h), s.assign(c), l = o.sub(c), o.assign(l);\n                }\n              });\n            }\n          }), this.incrementIterations();\n        }, e.prototype.dispose = function () {\n          null != this.accumulatedMeanSquares && je(this.accumulatedMeanSquares.map(function (t) {\n            return t.variable;\n          })), null != this.accumulatedMeanGrads && this.centered && je(this.accumulatedMeanGrads.map(function (t) {\n            return t.variable;\n          })), null != this.accumulatedMoments && je(this.accumulatedMoments.map(function (t) {\n            return t.variable;\n          }));\n        }, e.prototype.getWeights = function () {\n          return u(this, void 0, void 0, function () {\n            var t;\n            return c(this, function (e) {\n              switch (e.label) {\n                case 0:\n                  return t = this.accumulatedMeanSquares.concat(this.accumulatedMoments), this.centered && t.push.apply(t, this.accumulatedMeanGrads), [4, this.saveIterations()];\n\n                case 1:\n                  return [2, [e.sent()].concat(t.map(function (t) {\n                    return {\n                      name: t.originalName,\n                      tensor: t.variable\n                    };\n                  }))];\n              }\n            });\n          });\n        }, e.prototype.setWeights = function (t) {\n          return u(this, void 0, void 0, function () {\n            var e;\n            return c(this, function (n) {\n              switch (n.label) {\n                case 0:\n                  return [4, this.extractIterations(t)];\n\n                case 1:\n                  return t = n.sent(), e = this.centered ? t.length / 3 : t.length / 2, this.accumulatedMeanSquares = t.slice(0, e).map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  }), this.accumulatedMoments = t.slice(e, 2 * e).map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  }), this.centered && (this.accumulatedMeanGrads = t.slice(2 * e, 3 * e).map(function (t) {\n                    return {\n                      originalName: t.name,\n                      variable: t.tensor.variable(!1)\n                    };\n                  })), [2];\n              }\n            });\n          });\n        }, e.prototype.getConfig = function () {\n          return {\n            learningRate: this.learningRate,\n            decay: this.decay,\n            momentum: this.momentum,\n            epsilon: this.epsilon,\n            centered: this.centered\n          };\n        }, e.fromConfig = function (t, e) {\n          return new t(e.learningRate, e.decay, e.momentum, e.epsilon, e.centered);\n        }, e.className = \"RMSProp\", e;\n      }(Vh);\n\n      Dh(Kh);\n\n      var Qh = function () {\n        function t() {}\n\n        return t.sgd = function (t) {\n          return new Hh(t);\n        }, t.momentum = function (t, e, n) {\n          return void 0 === n && (n = !1), new $h(t, e, n);\n        }, t.rmsprop = function (t, e, n, r, o) {\n          return void 0 === e && (e = .9), void 0 === n && (n = 0), void 0 === r && (r = null), void 0 === o && (o = !1), new Kh(t, e, n, r, o);\n        }, t.adam = function (t, e, n, r) {\n          return void 0 === t && (t = .001), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), new Wh(t, e, n, r);\n        }, t.adadelta = function (t, e, n) {\n          return void 0 === t && (t = .001), void 0 === e && (e = .95), void 0 === n && (n = null), new Uh(t, e, n);\n        }, t.adamax = function (t, e, n, r, o) {\n          return void 0 === t && (t = .002), void 0 === e && (e = .9), void 0 === n && (n = .999), void 0 === r && (r = null), void 0 === o && (o = 0), new Gh(t, e, n, r, o);\n        }, t.adagrad = function (t, e) {\n          return void 0 === e && (e = .1), new jh(t, e);\n        }, t;\n      }(),\n          Xh = (Qh.sgd, Qh.momentum, Qh.adadelta, Qh.adagrad, Qh.rmsprop, Qh.adamax, Qh.adam, \"undefined\" != typeof requestAnimationFrame ? requestAnimationFrame : void 0 !== i ? i : function (t) {\n        return t();\n      });\n\n      function Yh() {\n        return new Promise(function (t) {\n          return Xh(function () {\n            return t();\n          });\n        });\n      }\n\n      mt = Nl;\n    }).call(this, n(8), n(47), n(38).Buffer, n(69).setImmediate);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r;\n    n.r(e), n.d(e, \"Level\", function () {\n      return r;\n    }), n.d(e, \"verbosity\", function () {\n      return o;\n    }), n.d(e, \"log\", function () {\n      return i;\n    }), n.d(e, \"logWithDuration\", function () {\n      return a;\n    }), function (t) {\n      t[t.NONE = 0] = \"NONE\", t[t.WARN = 5] = \"WARN\", t[t.INFO = 10] = \"INFO\", t[t.DEBUG = 20] = \"DEBUG\";\n    }(r || (r = {}));\n    let o = 10;\n\n    function i(t, e = \"Magenta.js\", n = 10) {\n      if (0 === n) throw Error(\"Logging level cannot be NONE.\");\n\n      if (o >= n) {\n        (5 === n ? console.warn : console.log)(\"%c \".concat(e, \" \"), \"background:magenta; color:white\", t);\n      }\n    }\n\n    function a(t, e, n = \"Magenta.js\", r = 10) {\n      i(\"\".concat(t, \" in \").concat(((performance.now() - e) / 1e3).toPrecision(3), \"s\"), n, r);\n    }\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e), n.d(e, \"MultipleTimeSignatureException\", function () {\n      return a;\n    }), n.d(e, \"BadTimeSignatureException\", function () {\n      return s;\n    }), n.d(e, \"NegativeTimeException\", function () {\n      return u;\n    }), n.d(e, \"MultipleTempoException\", function () {\n      return c;\n    }), n.d(e, \"QuantizationStatusException\", function () {\n      return l;\n    }), n.d(e, \"clone\", function () {\n      return h;\n    }), n.d(e, \"stepsPerQuarterToStepsPerSecond\", function () {\n      return p;\n    }), n.d(e, \"quantizeToStep\", function () {\n      return f;\n    }), n.d(e, \"quantizeNoteSequence\", function () {\n      return g;\n    }), n.d(e, \"isQuantizedSequence\", function () {\n      return v;\n    }), n.d(e, \"assertIsQuantizedSequence\", function () {\n      return y;\n    }), n.d(e, \"isRelativeQuantizedSequence\", function () {\n      return b;\n    }), n.d(e, \"assertIsRelativeQuantizedSequence\", function () {\n      return w;\n    }), n.d(e, \"isAbsoluteQuantizedSequence\", function () {\n      return x;\n    }), n.d(e, \"assertIsAbsoluteQuantizedSequence\", function () {\n      return S;\n    }), n.d(e, \"unquantizeSequence\", function () {\n      return E;\n    }), n.d(e, \"mergeInstruments\", function () {\n      return C;\n    }), n.d(e, \"replaceInstruments\", function () {\n      return I;\n    }), n.d(e, \"mergeConsecutiveNotes\", function () {\n      return A;\n    }), n.d(e, \"concatenate\", function () {\n      return k;\n    }), n.d(e, \"trim\", function () {\n      return T;\n    }), n.d(e, \"split\", function () {\n      return R;\n    });\n    var r = n(2),\n        o = n(1);\n    const i = .5;\n\n    class a extends Error {\n      constructor(t) {\n        super(t), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class s extends Error {\n      constructor(t) {\n        super(t), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class u extends Error {\n      constructor(t) {\n        super(t), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class c extends Error {\n      constructor(t) {\n        super(t), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class l extends Error {\n      constructor(t) {\n        super(t), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    function h(t) {\n      return r.a.decode(r.a.encode(t).finish());\n    }\n\n    function p(t, e) {\n      return t * e / 60;\n    }\n\n    function f(t, e, n = i) {\n      const r = t * e;\n      return Math.floor(r + (1 - n));\n    }\n\n    function d(t) {\n      return t.controlChanges.concat(t.textAnnotations);\n    }\n\n    function m(t) {\n      if (t.tempos && 0 !== t.tempos.length) {\n        if (t.tempos.sort((t, e) => t.time - e.time), 0 !== t.tempos[0].time && t.tempos[0].qpm !== o.DEFAULT_QUARTERS_PER_MINUTE) throw new c(\"NoteSequence has an implicit tempo change from initial \" + \"\".concat(o.DEFAULT_QUARTERS_PER_MINUTE, \" qpm to \") + \"\".concat(t.tempos[0].qpm, \" qpm at \").concat(t.tempos[0].time, \" seconds.\"));\n\n        for (let e = 1; e < t.tempos.length; e++) if (t.tempos[e].qpm !== t.tempos[0].qpm) throw new c(\"NoteSequence has at least one tempo change from \" + \"\".concat(t.tempos[0].qpm, \" qpm to \").concat(t.tempos[e].qpm) + \"qpm at \".concat(t.tempos[e].time, \" seconds.\"));\n      }\n    }\n\n    function g(t, e) {\n      const n = h(t);\n\n      if (n.quantizationInfo = r.a.QuantizationInfo.create({\n        stepsPerQuarter: e\n      }), n.timeSignatures.length > 0) {\n        if (n.timeSignatures.sort((t, e) => t.time - e.time), 0 !== n.timeSignatures[0].time && (4 !== n.timeSignatures[0].numerator || 4 !== n.timeSignatures[0].denominator)) throw new a(\"NoteSequence has an implicit change from initial 4/4 time \" + \"signature to \".concat(n.timeSignatures[0].numerator, \"/\") + \"\".concat(n.timeSignatures[0].denominator, \" at \") + \"\".concat(n.timeSignatures[0].time, \" seconds.\"));\n\n        for (let t = 1; t < n.timeSignatures.length; t++) {\n          const e = n.timeSignatures[t];\n          if (e.numerator !== n.timeSignatures[0].numerator || e.denominator !== n.timeSignatures[0].denominator) throw new a(\"NoteSequence has at least one time signature change from \" + \"\".concat(n.timeSignatures[0].numerator, \"/\") + \"\".concat(n.timeSignatures[0].denominator, \" to \") + \"\".concat(e.numerator, \"/\").concat(e.denominator, \" \") + \"at \".concat(e.time, \" seconds\"));\n        }\n\n        n.timeSignatures[0].time = 0, n.timeSignatures = [n.timeSignatures[0]];\n      } else {\n        const t = r.a.TimeSignature.create({\n          numerator: 4,\n          denominator: 4,\n          time: 0\n        });\n        n.timeSignatures.push(t);\n      }\n\n      const i = n.timeSignatures[0];\n      if (!(c = i.denominator) || 0 != (c & c - 1)) throw new s(\"Denominator is not a power of 2. Time signature: \" + \"\".concat(i.numerator, \"/\").concat(i.denominator));\n      var c;\n      if (0 === i.numerator) throw new s(\"Numerator is 0. Time signature: \" + \"\".concat(i.numerator, \"/\").concat(i.denominator));\n      if (n.tempos.length > 0) m(n), n.tempos[0].time = 0, n.tempos = [n.tempos[0]];else {\n        const t = r.a.Tempo.create({\n          qpm: o.DEFAULT_QUARTERS_PER_MINUTE,\n          time: 0\n        });\n        n.tempos.push(t);\n      }\n      const l = p(e, n.tempos[0].qpm);\n      return n.totalQuantizedSteps = f(t.totalTime, l), function (t, e) {\n        for (const n of t.notes) {\n          if (n.quantizedStartStep = f(n.startTime, e), n.quantizedEndStep = f(n.endTime, e), n.quantizedEndStep === n.quantizedStartStep && (n.quantizedEndStep += 1), n.quantizedStartStep < 0 || n.quantizedEndStep < 0) throw new u(\"Got negative note time: start_step = \" + \"\".concat(n.quantizedStartStep, \", end_step = \") + \"\".concat(n.quantizedEndStep));\n          n.quantizedEndStep > t.totalQuantizedSteps && (t.totalQuantizedSteps = n.quantizedEndStep);\n        }\n\n        d(t).forEach(t => {\n          if (t.quantizedStep = f(t.time, e), t.quantizedStep < 0) throw new u(\"Got negative event time: step = \".concat(t.quantizedStep));\n        });\n      }(n, l), n;\n    }\n\n    function v(t) {\n      return t.quantizationInfo && (t.quantizationInfo.stepsPerQuarter > 0 || t.quantizationInfo.stepsPerSecond > 0);\n    }\n\n    function y(t) {\n      if (!v(t)) throw new l(\"NoteSequence \".concat(t.id, \" is not quantized (missing quantizationInfo)\"));\n    }\n\n    function b(t) {\n      return t.quantizationInfo && t.quantizationInfo.stepsPerQuarter > 0;\n    }\n\n    function w(t) {\n      if (!b(t)) throw new l(\"NoteSequence \".concat(t.id, \" is not quantized or is quantized based on absolute timing\"));\n    }\n\n    function x(t) {\n      return t.quantizationInfo && t.quantizationInfo.stepsPerSecond > 0;\n    }\n\n    function S(t) {\n      if (!x(t)) throw new l(\"NoteSequence \".concat(t.id, \" is not quantized or is quantized based on relative timing\"));\n    }\n\n    function E(t, e) {\n      w(t), m(t);\n      const n = h(t);\n      e ? n.tempos && n.tempos.length > 0 ? n.tempos[0].qpm = e : n.tempos.push(r.a.Tempo.create({\n        time: 0,\n        qpm: e\n      })) : e = t.tempos && t.tempos.length > 0 ? n.tempos[0].qpm : o.DEFAULT_QUARTERS_PER_MINUTE;\n\n      const i = t => t / n.quantizationInfo.stepsPerQuarter * (60 / e);\n\n      return n.totalTime = i(n.totalQuantizedSteps), n.notes.forEach(t => {\n        t.startTime = i(t.quantizedStartStep), t.endTime = i(t.quantizedEndStep), n.totalTime = Math.max(n.totalTime, t.endTime), delete t.quantizedStartStep, delete t.quantizedEndStep;\n      }), d(n).forEach(t => {\n        t.time = i(t.time);\n      }), delete n.totalQuantizedSteps, delete n.quantizationInfo, n;\n    }\n\n    function C(t) {\n      const e = h(t),\n            n = e.notes.concat(e.pitchBends).concat(e.controlChanges),\n            r = Array.from(new Set(n.filter(t => !t.isDrum).map(t => t.program)));\n      return n.forEach(t => {\n        t.isDrum ? (t.program = 0, t.instrument = r.length) : t.instrument = r.indexOf(t.program);\n      }), e;\n    }\n\n    function I(t, e) {\n      const n = new Set(t.notes.map(t => t.instrument)),\n            o = new Set(e.notes.map(t => t.instrument)),\n            i = [];\n      t.notes.forEach(t => {\n        o.has(t.instrument) || i.push(r.a.Note.create(t));\n      }), e.notes.forEach(t => {\n        n.has(t.instrument) && i.push(r.a.Note.create(t));\n      });\n      const a = h(t);\n      return a.notes = i.sort((t, e) => {\n        const n = t.instrument - e.instrument;\n        return n || t.quantizedStartStep - e.quantizedStartStep;\n      }), a;\n    }\n\n    function A(t) {\n      y(t);\n      const e = h(t);\n      e.notes = [];\n      const n = t.notes.sort((t, e) => {\n        const n = t.instrument - e.instrument;\n        return n || t.quantizedStartStep - e.quantizedStartStep;\n      }),\n            o = new r.a.Note();\n      o.pitch = n[0].pitch, o.instrument = n[0].instrument, o.quantizedStartStep = n[0].quantizedStartStep, o.quantizedEndStep = n[0].quantizedEndStep, e.notes.push(o);\n      let i = 0;\n\n      for (let t = 1; t < n.length; t++) {\n        const o = n[t],\n              a = e.notes[i];\n        if (a.instrument === o.instrument && a.pitch === o.pitch && o.quantizedStartStep === a.quantizedEndStep && o.quantizedStartStep % 16 != 0) e.notes[i].quantizedEndStep += o.quantizedEndStep - o.quantizedStartStep;else {\n          const o = new r.a.Note();\n          o.pitch = n[t].pitch, o.instrument = n[t].instrument, o.quantizedStartStep = n[t].quantizedStartStep, o.quantizedEndStep = n[t].quantizedEndStep, e.notes.push(o), i++;\n        }\n      }\n\n      return e;\n    }\n\n    function k(t, e) {\n      if (e && e.length !== t.length) throw new Error(\"Number of sequences to concatenate and their individual\\n durations does not match.\");\n\n      if (v(t[0])) {\n        for (let e = 0; e < t.length; ++e) if (y(t[e]), t[e].quantizationInfo.stepsPerQuarter !== t[0].quantizationInfo.stepsPerQuarter) throw new Error(\"Not all sequences have the same quantizationInfo\");\n\n        return N(t, \"totalQuantizedSteps\", \"quantizedStartStep\", \"quantizedEndStep\", e);\n      }\n\n      return N(t, \"totalTime\", \"startTime\", \"endTime\", e);\n    }\n\n    function T(t, e, n, r) {\n      return v(t) ? P(t, e, n, \"totalQuantizedSteps\", \"quantizedStartStep\", \"quantizedEndStep\", r) : P(t, e, n, \"totalTime\", \"startTime\", \"endTime\", r);\n    }\n\n    function N(t, e, n, o, i) {\n      let a,\n          s = 0;\n\n      for (let u = 0; u < t.length; ++u) {\n        const c = i ? i[u] : t[u][e];\n        if (0 === c) throw Error(\"Sequence \".concat(t[u].id, \" has no \").concat(e, \", and no individual duration was provided.\"));\n        0 === u ? a = h(t[0]) : Array.prototype.push.apply(a.notes, t[u].notes.map(t => {\n          const e = r.a.Note.create(t);\n          return e[n] += s, e[o] += s, e;\n        })), s += c;\n      }\n\n      return a[e] = s, a;\n    }\n\n    function P(t, e, n, r, o, i, a) {\n      const s = h(t);\n      s[r] = n, s.notes = s.notes.filter(t => t[o] >= e && t[o] <= n && (a || t[i] <= n));\n\n      for (let t = 0; t < s.notes.length; t++) s.notes[t][o] -= e, s.notes[t][i] -= e, a && (s.notes[t][i] = Math.min(s.notes[t][i], n));\n\n      return s[r] = Math.min(t[r] - e, n), s;\n    }\n\n    function R(t, e) {\n      y(t);\n      const n = h(t),\n            o = n.notes.sort((t, e) => t.quantizedStartStep - e.quantizedStartStep),\n            i = [];\n      let a = 0,\n          s = [];\n\n      for (let t = 0; t < o.length; t++) {\n        const u = o[t],\n              c = u.quantizedStartStep,\n              l = u.quantizedEndStep;\n        if (u.quantizedStartStep -= a, u.quantizedEndStep -= a, !(u.quantizedStartStep < 0)) if (u.quantizedEndStep <= e) s.push(u);else {\n          if (u.quantizedStartStep < e) {\n            const t = r.a.Note.create(u);\n            t.quantizedEndStep = e, t.startTime = t.endTime = void 0, s.push(t), u.quantizedStartStep = a + e, u.quantizedEndStep = l;\n          } else u.quantizedStartStep = c, u.quantizedEndStep = l;\n\n          if ((u.quantizedEndStep > e || u.quantizedStartStep > e) && (t -= 1), 0 !== s.length) {\n            const t = h(n);\n            t.notes = s, t.totalQuantizedSteps = e, i.push(t);\n          }\n\n          s = [], a += e;\n        }\n      }\n\n      if (0 !== s.length) {\n        const t = h(n);\n        t.notes = s, t.totalQuantizedSteps = e, i.push(t);\n      }\n\n      return i;\n    }\n  }, function (t, e, n) {\n    \"use strict\";\n\n    (function (t) {\n      var r = e;\n\n      function o(t, e, n) {\n        for (var r = Object.keys(e), o = 0; o < r.length; ++o) void 0 !== t[r[o]] && n || (t[r[o]] = e[r[o]]);\n\n        return t;\n      }\n\n      function i(t) {\n        function e(t, n) {\n          if (!(this instanceof e)) return new e(t, n);\n          Object.defineProperty(this, \"message\", {\n            get: function () {\n              return t;\n            }\n          }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, \"stack\", {\n            value: new Error().stack || \"\"\n          }), n && o(this, n);\n        }\n\n        return (e.prototype = Object.create(Error.prototype)).constructor = e, Object.defineProperty(e.prototype, \"name\", {\n          get: function () {\n            return t;\n          }\n        }), e.prototype.toString = function () {\n          return this.name + \": \" + this.message;\n        }, e;\n      }\n\n      r.asPromise = n(21), r.base64 = n(22), r.EventEmitter = n(23), r.float = n(24), r.inquire = n(25), r.utf8 = n(26), r.pool = n(27), r.LongBits = n(28), r.global = \"undefined\" != typeof window && window || void 0 !== t && t || \"undefined\" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isNode = Boolean(r.global.process && r.global.process.versions && r.global.process.versions.node), r.isInteger = Number.isInteger || function (t) {\n        return \"number\" == typeof t && isFinite(t) && Math.floor(t) === t;\n      }, r.isString = function (t) {\n        return \"string\" == typeof t || t instanceof String;\n      }, r.isObject = function (t) {\n        return t && \"object\" == typeof t;\n      }, r.isset = r.isSet = function (t, e) {\n        var n = t[e];\n        return !(null == n || !t.hasOwnProperty(e)) && (\"object\" != typeof n || (Array.isArray(n) ? n.length : Object.keys(n).length) > 0);\n      }, r.Buffer = function () {\n        try {\n          var t = r.inquire(\"buffer\").Buffer;\n          return t.prototype.utf8Write ? t : null;\n        } catch (t) {\n          return null;\n        }\n      }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function (t) {\n        return \"number\" == typeof t ? r.Buffer ? r._Buffer_allocUnsafe(t) : new r.Array(t) : r.Buffer ? r._Buffer_from(t) : \"undefined\" == typeof Uint8Array ? t : new Uint8Array(t);\n      }, r.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire(\"long\"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function (t) {\n        return t ? r.LongBits.from(t).toHash() : r.LongBits.zeroHash;\n      }, r.longFromHash = function (t, e) {\n        var n = r.LongBits.fromHash(t);\n        return r.Long ? r.Long.fromBits(n.lo, n.hi, e) : n.toNumber(Boolean(e));\n      }, r.merge = o, r.lcFirst = function (t) {\n        return t.charAt(0).toLowerCase() + t.substring(1);\n      }, r.newError = i, r.ProtocolError = i(\"ProtocolError\"), r.oneOfGetter = function (t) {\n        for (var e = {}, n = 0; n < t.length; ++n) e[t[n]] = 1;\n\n        return function () {\n          for (var t = Object.keys(this), n = t.length - 1; n > -1; --n) if (1 === e[t[n]] && void 0 !== this[t[n]] && null !== this[t[n]]) return t[n];\n        };\n      }, r.oneOfSetter = function (t) {\n        return function (e) {\n          for (var n = 0; n < t.length; ++n) t[n] !== e && delete this[t[n]];\n        };\n      }, r.toJSONOptions = {\n        longs: String,\n        enums: String,\n        bytes: String,\n        json: !0\n      }, r._configure = function () {\n        var t = r.Buffer;\n        t ? (r._Buffer_from = t.from !== Uint8Array.from && t.from || function (e, n) {\n          return new t(e, n);\n        }, r._Buffer_allocUnsafe = t.allocUnsafe || function (e) {\n          return new t(e);\n        }) : r._Buffer_from = r._Buffer_allocUnsafe = null;\n      };\n    }).call(this, n(8));\n  }, function (t, e) {\n    var n;\n\n    n = function () {\n      return this;\n    }();\n\n    try {\n      n = n || new Function(\"return this\")();\n    } catch (t) {\n      \"object\" == typeof window && (n = window);\n    }\n\n    t.exports = n;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.d(e, \"d\", function () {\n      return h;\n    }), n.d(e, \"c\", function () {\n      return p;\n    }), n.d(e, \"e\", function () {\n      return f;\n    }), n.d(e, \"g\", function () {\n      return d;\n    }), n.d(e, \"h\", function () {\n      return g;\n    }), n.d(e, \"a\", function () {\n      return y;\n    }), n.d(e, \"f\", function () {\n      return b;\n    }), n.d(e, \"b\", function () {\n      return S;\n    });\n    var r = n(18),\n        o = n(15),\n        i = n(43),\n        a = n(5);\n    const s = 16e3,\n          u = window,\n          c = u.webkitOfflineAudioContext,\n          l = c ? new u.webkitOfflineAudioContext(1, 44100, 44100) : new u.OfflineAudioContext(1, s, s);\n\n    async function h(t) {\n      return fetch(t).then(t => t.arrayBuffer()).then(t => l.decodeAudioData(t));\n    }\n\n    async function p(t) {\n      const e = new FileReader();\n      return new Promise((n, r) => {\n        e.onerror = () => {\n          e.abort(), r(new DOMException(\"Something went wrong reading that file.\"));\n        }, e.onload = () => {\n          n(e.result);\n        }, e.readAsArrayBuffer(t);\n      }).then(t => l.decodeAudioData(t));\n    }\n\n    function f(t, e) {\n      e.power || (e.power = 2);\n\n      const n = function (t, e) {\n        const n = e.nFft || 2048,\n              r = e.winLength || n,\n              o = e.hopLength || Math.floor(r / 4);\n        let i = S(r);\n        i = b(i, n);\n\n        const a = function (t, e, n) {\n          const r = Math.floor((t.length - e) / n) + 1,\n                o = Array.from({\n            length: r\n          }, (t, n) => new Float32Array(e));\n\n          for (let i = 0; i < r; i++) {\n            const r = i * n,\n                  a = t.slice(r, r + e);\n            o[i].set(a), a.length;\n          }\n\n          return o;\n        }(t = function (t, e) {\n          const n = w(t, e);\n\n          for (let t = 0; t < e; t++) n[t] = n[2 * e - t], n[n.length - t - 1] = n[n.length - 2 * e + t - 1];\n\n          return n;\n        }(t, Math.floor(n / 2)), n, o),\n              s = [],\n              u = a.length,\n              c = n + 2;\n\n        for (let t = 0; t < u; t++) {\n          const e = new Float32Array(c);\n          s[t] = e;\n        }\n\n        for (let t = 0; t < u; t++) {\n          const e = x(y(a[t], i));\n          s[t].set(e.slice(0, c));\n        }\n\n        return s;\n      }(t, e),\n            _ref = function (t, e) {\n        const n = t.map(t => function (t, e) {\n          return t.map(t => Math.pow(t, e));\n        }(function (t) {\n          const e = new Float32Array(t.length / 2);\n\n          for (let n = 0; n < t.length / 2; n++) e[n] = Math.sqrt(t[2 * n] * t[2 * n] + t[2 * n + 1] * t[2 * n + 1]);\n\n          return e;\n        }(t), e)),\n              r = t[0].length - 1;\n        return [n, r];\n      }(n, e.power),\n            _ref2 = _slicedToArray(_ref, 2),\n            r = _ref2[0],\n            o = _ref2[1];\n\n      return e.nFft = o, function (t, e) {\n        const n = [];\n\n        for (let r = 0; r < t.length; r++) n[r] = v(t[r], e);\n\n        return n;\n      }(r, function (t) {\n        const e = t.fMin || 0,\n              n = t.fMax || t.sampleRate / 2,\n              r = t.nMels || 128,\n              o = t.nFft || 2048,\n              i = function (t, e) {\n          return E(0, t / 2, Math.floor(1 + e / 2));\n        }(t.sampleRate, o),\n              a = function (t, e, n) {\n          const r = C(e),\n                o = C(n);\n          return E(r, o, t).map(t => function (t) {\n            return 700 * (Math.exp(t / 1125) - 1);\n          }(t));\n        }(r + 2, e, n),\n              s = function (t) {\n          const e = new Float32Array(t.length - 1);\n\n          for (let n = 0; n < t.length; n++) e[n] = t[n + 1] - t[n];\n\n          return e;\n        }(a),\n              u = function (t, e) {\n          const n = [];\n\n          for (let r = 0; r < t.length; r++) n[r] = new Float32Array(e.length);\n\n          for (let r = 0; r < t.length; r++) for (let o = 0; o < e.length; o++) n[r][o] = t[r] - e[o];\n\n          return n;\n        }(a, i),\n              c = u[0].length,\n              l = [];\n\n        for (let t = 0; t < r; t++) {\n          l[t] = new Float32Array(c);\n\n          for (let e = 0; e < u[t].length; e++) {\n            const n = -u[t][e] / s[t],\n                  r = u[t + 2][e] / s[t + 1],\n                  o = Math.max(0, Math.min(n, r));\n            l[t][e] = o;\n          }\n        }\n\n        for (let t = 0; t < l.length; t++) {\n          const e = 2 / (a[2 + t] - a[t]);\n          l[t] = l[t].map(t => t * e);\n        }\n\n        return l;\n      }(e));\n    }\n\n    function d(t, e = 1e-10, n = 80) {\n      const r = t.length,\n            o = t[0].length,\n            i = [];\n\n      for (let t = 0; t < r; t++) i[t] = new Float32Array(o);\n\n      for (let n = 0; n < r; n++) for (let r = 0; r < o; r++) {\n        const o = t[n][r];\n        i[n][r] = 10 * Math.log10(Math.max(e, o));\n      }\n\n      if (n) {\n        if (n < 0) throw new Error(\"topDb must be non-negative.\");\n\n        for (let t = 0; t < r; t++) {\n          const e = i[t].reduce((t, e) => Math.max(t, e));\n\n          for (let r = 0; r < o; r++) i[t][r] = Math.max(i[t][r], e - n);\n        }\n      }\n\n      return i;\n    }\n\n    function m(t) {\n      if (1 === t.numberOfChannels) return t.getChannelData(0);\n      if (2 !== t.numberOfChannels) throw Error(\"\".concat(t.numberOfChannels, \" channel audio is not supported.\"));\n      const e = t.getChannelData(0),\n            n = t.getChannelData(1),\n            r = new Float32Array(t.length);\n\n      for (let o = 0; o < t.length; ++o) r[o] = (e[o] + n[o]) / 2;\n\n      return r;\n    }\n\n    async function g(t, e = s) {\n      if (t.sampleRate === e) return m(t);\n      const n = t.sampleRate,\n            r = t.length * e / n;\n\n      if (c) {\n        a.log(\"Safari does not support WebAudio resampling, so this may be slow.\", \"O&F\", 5);\n        const e = m(t),\n              n = new Float32Array(r);\n        return i(o(n, [r]), o(e, [e.length])), n;\n      }\n\n      {\n        const e = l.createBufferSource();\n        return e.buffer = t, e.connect(l.destination), e.start(), l.startRendering().then(t => t.getChannelData(0));\n      }\n    }\n\n    function v(t, e) {\n      if (t.length !== e[0].length) throw new Error(\"Each entry in filterbank should have dimensions \" + \"matching FFT. |mags| = \".concat(t.length, \", \") + \"|filterbank[0]| = \".concat(e[0].length, \".\"));\n      const n = new Float32Array(e.length);\n\n      for (let r = 0; r < e.length; r++) {\n        const o = y(t, e[r]);\n        n[r] = o.reduce((t, e) => t + e);\n      }\n\n      return n;\n    }\n\n    function y(t, e) {\n      if (t.length !== e.length) return console.error(\"Buffer length \".concat(t.length, \" != window length \").concat(e.length, \".\")), null;\n      const n = new Float32Array(t.length);\n\n      for (let r = 0; r < t.length; r++) n[r] = e[r] * t[r];\n\n      return n;\n    }\n\n    function b(t, e) {\n      if (t.length > e) throw new Error(\"Data is longer than length.\");\n      const n = Math.floor((e - t.length) / 2);\n      return w(t, [n, e - t.length - n]);\n    }\n\n    function w(t, e) {\n      var _e2, _e3;\n\n      let n, r;\n      \"object\" == typeof e ? (_e2 = e, _e3 = _slicedToArray(_e2, 2), n = _e3[0], r = _e3[1], _e2) : n = r = e;\n      const o = new Float32Array(t.length + n + r);\n      return o.set(t, n), o;\n    }\n\n    function x(t) {\n      const e = new r(t.length),\n            n = e.createComplexArray(),\n            o = e.toComplexArray(t);\n      return e.transform(n, o), n;\n    }\n\n    function S(t) {\n      const e = new Float32Array(t);\n\n      for (let n = 0; n < t; n++) e[n] = .5 * (1 - Math.cos(2 * Math.PI * n / (t - 1)));\n\n      return e;\n    }\n\n    function E(t, e, n) {\n      const r = (e - t) / (n - 1),\n            o = new Float32Array(n);\n\n      for (let e = 0; e < n; e++) o[e] = t + r * e;\n\n      return o;\n    }\n\n    function C(t) {\n      return 1125 * Math.log(1 + t / 700);\n    }\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e), n.d(e, \"DEFAULT_DRUM_PITCH_CLASSES\", function () {\n      return u;\n    }), n.d(e, \"converterFromSpec\", function () {\n      return c;\n    }), n.d(e, \"DataConverter\", function () {\n      return l;\n    }), n.d(e, \"DrumsConverter\", function () {\n      return h;\n    }), n.d(e, \"DrumRollConverter\", function () {\n      return p;\n    }), n.d(e, \"DrumsOneHotConverter\", function () {\n      return f;\n    }), n.d(e, \"MelodyConverter\", function () {\n      return d;\n    }), n.d(e, \"TrioConverter\", function () {\n      return m;\n    }), n.d(e, \"MultitrackConverter\", function () {\n      return g;\n    }), n.d(e, \"GrooveConverter\", function () {\n      return v;\n    });\n    var r = n(0),\n        o = n(2),\n        i = n(1),\n        a = n(11),\n        s = n(6);\n    const u = [[36, 35], [38, 27, 28, 31, 32, 33, 34, 37, 39, 40, 56, 65, 66, 75, 85], [42, 44, 54, 68, 69, 70, 71, 73, 78, 80], [46, 67, 72, 74, 79, 81], [45, 29, 41, 61, 64, 84], [48, 47, 60, 63, 77, 86, 87], [50, 30, 43, 62, 76, 83], [49, 55, 57, 58], [51, 52, 53, 59, 82]];\n\n    function c(t) {\n      switch (t.type) {\n        case \"MelodyConverter\":\n          return new d(t.args);\n\n        case \"DrumsConverter\":\n          return new h(t.args);\n\n        case \"DrumRollConverter\":\n          return new p(t.args);\n\n        case \"TrioConverter\":\n          return new m(t.args);\n\n        case \"DrumsOneHotConverter\":\n          return new f(t.args);\n\n        case \"MultitrackConverter\":\n          return new g(t.args);\n\n        case \"GrooveConverter\":\n          return new v(t.args);\n\n        default:\n          throw new Error(\"Unknown DataConverter type: \".concat(t));\n      }\n    }\n\n    class l {\n      constructor(t) {\n        this.NUM_SPLITS = 0, this.SEGMENTED_BY_TRACK = !1, this.numSteps = t.numSteps, this.numSegments = t.numSegments;\n      }\n\n      tensorSteps(t) {\n        return r.scalar(t.shape[0], \"int32\");\n      }\n\n    }\n\n    class h extends l {\n      constructor(t) {\n        super(t), this.pitchClasses = t.pitchClasses || u, this.pitchToClass = new Map();\n\n        for (let t = 0; t < this.pitchClasses.length; ++t) this.pitchClasses[t].forEach(e => {\n          this.pitchToClass.set(e, t);\n        });\n\n        this.depth = this.pitchClasses.length;\n      }\n\n      toTensor(t) {\n        s.assertIsQuantizedSequence(t);\n        const e = this.numSteps || t.totalQuantizedSteps,\n              n = r.buffer([e, this.pitchClasses.length + 1], \"int32\");\n\n        for (let t = 0; t < e; ++t) n.set(1, t, -1);\n\n        return t.notes.forEach(t => {\n          n.set(1, t.quantizedStartStep, this.pitchToClass.get(t.pitch)), n.set(0, t.quantizedStartStep, -1);\n        }), n.toTensor();\n      }\n\n      async toNoteSequence(t, e, n) {\n        const r = y(e, n),\n              i = t.argMax(1),\n              a = await i.data();\n        i.dispose();\n\n        for (let t = 0; t < a.length; ++t) for (let e = 0; e < this.pitchClasses.length; e++) a[t] >> e & 1 && r.notes.push(o.a.Note.create({\n          pitch: this.pitchClasses[e][0],\n          quantizedStartStep: t,\n          quantizedEndStep: t + 1,\n          isDrum: !0\n        }));\n\n        return r.totalQuantizedSteps = a.length, r;\n      }\n\n    }\n\n    class p extends h {\n      async toNoteSequence(t, e, n) {\n        const r = y(e, n),\n              i = await t.data();\n\n        for (let e = 0; e < t.shape[0]; ++e) {\n          const t = i.slice(e * this.depth, (e + 1) * this.depth);\n\n          for (let n = 0; n < t.length; ++n) t[n] && r.notes.push(o.a.Note.create({\n            pitch: this.pitchClasses[n][0],\n            quantizedStartStep: e,\n            quantizedEndStep: e + 1,\n            isDrum: !0\n          }));\n        }\n\n        return r.totalQuantizedSteps = t.shape[0], r;\n      }\n\n    }\n\n    class f extends h {\n      constructor(t) {\n        super(t), this.depth = Math.pow(2, this.pitchClasses.length);\n      }\n\n      toTensor(t) {\n        s.assertIsRelativeQuantizedSequence(t);\n        const e = this.numSteps || t.totalQuantizedSteps,\n              n = Array(e).fill(0);\n\n        for (const _ref3 of t.notes) {\n          const e = _ref3.pitch;\n          const r = _ref3.quantizedStartStep;\n          n[r] += Math.pow(2, this.pitchToClass.get(e));\n        }\n\n        return r.tidy(() => r.oneHot(r.tensor1d(n, \"int32\"), this.depth));\n      }\n\n    }\n\n    class d extends l {\n      constructor(t) {\n        super(t), this.NOTE_OFF = 1, this.FIRST_PITCH = 2, this.minPitch = t.minPitch, this.maxPitch = t.maxPitch, this.ignorePolyphony = void 0 === t.ignorePolyphony || t.ignorePolyphony, this.depth = t.maxPitch - t.minPitch + 1 + this.FIRST_PITCH;\n      }\n\n      toTensor(t) {\n        s.assertIsQuantizedSequence(t);\n        const e = this.numSteps || t.totalQuantizedSteps,\n              n = t.notes.sort((t, e) => t.quantizedStartStep === e.quantizedStartStep ? e.pitch - t.pitch : t.quantizedStartStep - e.quantizedStartStep),\n              o = r.buffer([e], \"int32\");\n        let i = -1;\n        return n.forEach(t => {\n          if (t.quantizedStartStep === i) {\n            if (this.ignorePolyphony) return;\n            throw new Error(\"`NoteSequence` is not monophonic.\");\n          }\n\n          if (t.pitch < this.minPitch || t.pitch > this.maxPitch) throw Error(\"`NoteSequence` has a pitch outside of the valid range: \" + \"\".concat(t.pitch));\n          o.set(t.pitch - this.minPitch + this.FIRST_PITCH, t.quantizedStartStep), o.set(this.NOTE_OFF, t.quantizedEndStep), i = t.quantizedStartStep;\n        }), r.tidy(() => r.oneHot(o.toTensor(), this.depth));\n      }\n\n      async toNoteSequence(t, e, n) {\n        const r = y(e, n),\n              i = t.argMax(1),\n              a = await i.data();\n        i.dispose();\n        let s = null;\n\n        for (let t = 0; t < a.length; ++t) {\n          const e = a[t];\n\n          switch (e) {\n            case 0:\n              break;\n\n            case 1:\n              s && (s.quantizedEndStep = t, r.notes.push(s), s = null);\n              break;\n\n            default:\n              s && (s.quantizedEndStep = t, r.notes.push(s)), s = o.a.Note.create({\n                pitch: e - this.FIRST_PITCH + this.minPitch,\n                quantizedStartStep: t\n              });\n          }\n        }\n\n        return s && (s.quantizedEndStep = a.length, r.notes.push(s)), r.totalQuantizedSteps = a.length, r;\n      }\n\n    }\n\n    class m extends l {\n      constructor(t) {\n        super(t), this.NUM_SPLITS = 3, this.MEL_PROG_RANGE = [0, 31], this.BASS_PROG_RANGE = [32, 39], t.melArgs.numSteps = t.numSteps, t.bassArgs.numSteps = t.numSteps, t.drumsArgs.numSteps = t.numSteps, this.melConverter = new d(t.melArgs), this.bassConverter = new d(t.bassArgs), this.drumsConverter = new f(t.drumsArgs), this.depth = this.melConverter.depth + this.bassConverter.depth + this.drumsConverter.depth;\n      }\n\n      toTensor(t) {\n        s.assertIsQuantizedSequence(t);\n        const e = s.clone(t),\n              n = s.clone(t),\n              o = s.clone(t);\n        return e.notes = t.notes.filter(t => !t.isDrum && t.program >= this.MEL_PROG_RANGE[0] && t.program <= this.MEL_PROG_RANGE[1]), n.notes = t.notes.filter(t => !t.isDrum && t.program >= this.BASS_PROG_RANGE[0] && t.program <= this.BASS_PROG_RANGE[1]), o.notes = t.notes.filter(t => t.isDrum), r.tidy(() => r.concat([this.melConverter.toTensor(e), this.bassConverter.toTensor(n), this.drumsConverter.toTensor(o)], -1));\n      }\n\n      async toNoteSequence(t, e, n) {\n        const o = r.split(t, [this.melConverter.depth, this.bassConverter.depth, this.drumsConverter.depth], -1),\n              i = await this.melConverter.toNoteSequence(o[0], e, n);\n        i.notes.forEach(t => {\n          t.instrument = 0, t.program = 0;\n        });\n        const a = await this.bassConverter.toNoteSequence(o[1], e, n);\n        i.notes.push(...a.notes.map(t => (t.instrument = 1, t.program = this.BASS_PROG_RANGE[0], t)));\n        const s = await this.drumsConverter.toNoteSequence(o[2], e, n);\n        return i.notes.push(...s.notes.map(t => (t.instrument = 2, t))), o.forEach(t => t.dispose()), i;\n      }\n\n    }\n\n    class g extends l {\n      constructor(t) {\n        super(t), this.SEGMENTED_BY_TRACK = !0, this.stepsPerQuarter = t.stepsPerQuarter, this.totalSteps = t.totalSteps, this.numVelocityBins = t.numVelocityBins, this.minPitch = t.minPitch ? t.minPitch : i.MIN_MIDI_PITCH, this.maxPitch = t.maxPitch ? t.maxPitch : i.MAX_MIDI_PITCH, this.numPitches = this.maxPitch - this.minPitch + 1, this.performanceEventDepth = 2 * this.numPitches + this.totalSteps + this.numVelocityBins, this.numPrograms = i.MAX_MIDI_PROGRAM - i.MIN_MIDI_PROGRAM + 2, this.endToken = this.performanceEventDepth + this.numPrograms, this.depth = this.endToken + 1, this.endTensor = r.tidy(() => r.oneHot(r.tensor1d([this.endToken], \"int32\"), this.depth).as1D());\n      }\n\n      trackToTensor(t) {\n        const e = this.numSteps / this.numSegments;\n        let n = void 0;\n\n        if (t) {\n          for (; t.events.length > e - 2;) t.events.pop();\n\n          (n = r.buffer([t.events.length + 2], \"int32\")).set(this.performanceEventDepth + (t.isDrum ? this.numPrograms - 1 : t.program), 0), t.events.forEach((t, e) => {\n            switch (t.type) {\n              case \"note-on\":\n                n.set(t.pitch - this.minPitch, e + 1);\n                break;\n\n              case \"note-off\":\n                n.set(this.numPitches + t.pitch - this.minPitch, e + 1);\n                break;\n\n              case \"time-shift\":\n                n.set(2 * this.numPitches + t.steps - 1, e + 1);\n                break;\n\n              case \"velocity-change\":\n                n.set(2 * this.numPitches + this.totalSteps + t.velocityBin - 1, e + 1);\n                break;\n\n              default:\n                throw new Error(\"Unrecognized performance event: \".concat(t));\n            }\n          }), n.set(this.endToken, t.events.length + 1);\n        } else n = r.buffer([1], \"int32\", new Int32Array([this.endToken]));\n\n        return r.tidy(() => {\n          const t = r.oneHot(n.toTensor(), this.depth);\n          return t.pad([[0, e - t.shape[0]], [0, 0]]);\n        });\n      }\n\n      toTensor(t) {\n        if (s.assertIsRelativeQuantizedSequence(t), t.quantizationInfo.stepsPerQuarter !== this.stepsPerQuarter) throw new Error(\"Steps per quarter note mismatch: \".concat(t.quantizationInfo.stepsPerQuarter, \" != \").concat(this.stepsPerQuarter));\n        const e = s.clone(t);\n        e.notes = t.notes.filter(t => t.pitch >= this.minPitch && t.pitch <= this.maxPitch);\n        const n = new Set(e.notes.map(t => t.instrument)),\n              o = Array.from(n).map(t => a.Performance.fromNoteSequence(e, this.totalSteps, this.numVelocityBins, t)).sort((t, e) => e.isDrum ? -1 : t.isDrum ? 1 : t.program - e.program);\n\n        for (; o.length > this.numSegments;) o.pop();\n\n        for (o.forEach(t => t.setNumSteps(this.totalSteps)); o.length < this.numSegments;) o.push(void 0);\n\n        return r.tidy(() => r.concat(o.map(t => this.trackToTensor(t)), 0));\n      }\n\n      tokensToTrack(t) {\n        const e = t.indexOf(this.endToken),\n              n = e >= 0 ? e : t.length,\n              r = t.slice(0, n),\n              o = r.filter(t => t < this.performanceEventDepth),\n              i = r.filter(t => t >= this.performanceEventDepth),\n              _ref4 = i.length ? i[0] - this.performanceEventDepth < this.numPrograms - 1 ? [i[0] - this.performanceEventDepth, !1] : [0, !0] : [0, !1],\n              _ref5 = _slicedToArray(_ref4, 2),\n              s = _ref5[0],\n              u = _ref5[1],\n              c = Array.from(o).map(t => {\n          if (t < this.numPitches) return {\n            type: \"note-on\",\n            pitch: this.minPitch + t\n          };\n          if (t < 2 * this.numPitches) return {\n            type: \"note-off\",\n            pitch: this.minPitch + t - this.numPitches\n          };\n          if (t < 2 * this.numPitches + this.totalSteps) return {\n            type: \"time-shift\",\n            steps: t - 2 * this.numPitches + 1\n          };\n          if (t < 2 * this.numPitches + this.totalSteps + this.numVelocityBins) return {\n            type: \"velocity-change\",\n            velocityBin: t - 2 * this.numPitches - this.totalSteps + 1\n          };\n          throw new Error(\"Invalid performance event token: \".concat(t));\n        });\n\n        return new a.Performance(c, this.totalSteps, this.numVelocityBins, s, u);\n      }\n\n      async toNoteSequence(t, e = this.stepsPerQuarter, n) {\n        const o = y(e, n);\n        o.totalQuantizedSteps = this.totalSteps;\n        const i = r.tidy(() => r.split(t.argMax(1), this.numSegments));\n        return (await Promise.all(i.map(async t => {\n          const e = await t.data(),\n                n = this.tokensToTrack(e);\n          return t.dispose(), n;\n        }))).forEach((t, e) => {\n          t.setNumSteps(this.totalSteps), o.notes.push(...t.toNoteSequence(e).notes);\n        }), o;\n      }\n\n    }\n\n    class v extends l {\n      constructor(t) {\n        super(t), this.TAPIFY_CHANNEL = 3, this.stepsPerQuarter = t.stepsPerQuarter || i.DEFAULT_STEPS_PER_QUARTER, this.pitchClasses = t.pitchClasses || u, this.pitchToClass = new Map();\n\n        for (let t = 0; t < this.pitchClasses.length; ++t) this.pitchClasses[t].forEach(e => {\n          this.pitchToClass.set(e, t);\n        });\n\n        this.humanize = t.humanize || !1, this.tapify = t.tapify || !1, this.splitInstruments = t.splitInstruments || !1, this.depth = 3;\n      }\n\n      toTensor(t) {\n        const e = s.isRelativeQuantizedSequence(t) ? t : s.quantizeNoteSequence(t, this.stepsPerQuarter),\n              n = this.numSteps,\n              o = e.tempos && e.tempos.length ? e.tempos[0].qpm : i.DEFAULT_QUARTERS_PER_MINUTE,\n              a = 60 / o / this.stepsPerQuarter,\n              u = [];\n\n        for (let t = 0; t < n; ++t) u.push(new Map());\n\n        e.notes.forEach(t => {\n          if (!this.tapify && !this.pitchToClass.has(t.pitch)) return;\n          const e = t.quantizedStartStep;\n          if (e >= u.length) throw Error(\"Model does not support sequences with more than \".concat(n, \" steps (\").concat(n * a, \" seconds at qpm \").concat(o, \").\"));\n          const r = this.tapify ? this.TAPIFY_CHANNEL : this.pitchToClass.get(t.pitch);\n          (!u[e].has(r) || u[e].get(r).velocity < t.velocity) && u[e].set(r, t);\n        });\n        const c = this.pitchClasses.length,\n              l = r.buffer([n, c]),\n              h = r.buffer([n, c]),\n              p = r.buffer([n, c]);\n\n        function f(t) {\n          if (void 0 === t.startTime) return 0;\n          const e = t.startTime;\n          return 2 * (t.quantizedStartStep * a - e) / a;\n        }\n\n        for (let t = 0; t < n; ++t) for (let e = 0; e < c; ++e) {\n          const n = u[t].get(e);\n          l.set(n ? 1 : 0, t, e), this.humanize || this.tapify || h.set(n ? n.velocity / i.MAX_MIDI_VELOCITY : 0, t, e), this.humanize || p.set(n ? f(n) : 0, t, e);\n        }\n\n        return r.tidy(() => {\n          const t = l.toTensor(),\n                e = h.toTensor(),\n                o = p.toTensor(),\n                i = this.splitInstruments ? n * c : n;\n          return r.concat([t.as2D(i, -1), e.as2D(i, -1), o.as2D(i, -1)], 1);\n        });\n      }\n\n      async toNoteSequence(t, e, n = i.DEFAULT_QUARTERS_PER_MINUTE) {\n        if (e && e !== this.stepsPerQuarter) throw Error(\"`stepsPerQuarter` is set by the model.\");\n        e = this.stepsPerQuarter;\n        const r = this.splitInstruments ? t.shape[0] / this.pitchClasses.length : t.shape[0],\n              a = 60 / n / this.stepsPerQuarter,\n              s = o.a.create({\n          totalTime: r * a,\n          tempos: [{\n            qpm: n\n          }]\n        }),\n              u = await t.data();\n\n        function c(t, e, n) {\n          return Math.min(Math.max(t, e), n);\n        }\n\n        const l = this.pitchClasses.length;\n\n        for (let t = 0; t < r; ++t) {\n          const e = u.slice(t * l * this.depth, (t + 1) * l * this.depth);\n\n          for (let n = 0; n < l; ++n) {\n            const r = e[this.splitInstruments ? n * this.depth : n],\n                  u = e[this.splitInstruments ? n * this.depth + 1 : l + n],\n                  h = e[this.splitInstruments ? n * this.depth + 2 : 2 * l + n];\n\n            if (r > .5) {\n              const e = c(Math.round(u * i.MAX_MIDI_VELOCITY), i.MIN_MIDI_VELOCITY, i.MAX_MIDI_VELOCITY),\n                    r = c(h / 2, -.5, .5);\n              s.notes.push(o.a.Note.create({\n                pitch: this.pitchClasses[n][0],\n                startTime: (t - r) * a,\n                endTime: (t - r + 1) * a,\n                velocity: e,\n                isDrum: !0\n              }));\n            }\n          }\n        }\n\n        return s;\n      }\n\n    }\n\n    function y(t = i.DEFAULT_STEPS_PER_QUARTER, e = i.DEFAULT_QUARTERS_PER_MINUTE) {\n      return o.a.create({\n        quantizationInfo: {\n          stepsPerQuarter: t\n        },\n        tempos: [{\n          qpm: e\n        }]\n      });\n    }\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e), n.d(e, \"Performance\", function () {\n      return s;\n    });\n    var r = n(2),\n        o = n(1),\n        i = n(6),\n        a = n(5);\n\n    class s {\n      constructor(t, e, n, r, o) {\n        this.events = t, this.maxShiftSteps = e, this.numVelocityBins = n, this.program = r, this.isDrum = o;\n      }\n\n      static fromNoteSequence(t, e, n, r) {\n        i.assertIsQuantizedSequence(t);\n        const a = t.notes.filter((t, e) => void 0 === r || t.instrument === r),\n              u = a.sort((t, e) => t.startTime === e.startTime ? t.pitch - e.pitch : t.startTime - e.startTime),\n              c = u.map((t, e) => ({\n          step: t.quantizedStartStep,\n          index: e,\n          isOffset: 0\n        })),\n              l = u.map((t, e) => ({\n          step: t.quantizedEndStep,\n          index: e,\n          isOffset: 1\n        })),\n              h = c.concat(l).sort((t, e) => t.step === e.step ? t.index === e.index ? t.isOffset - e.isOffset : t.index - e.index : t.step - e.step),\n              p = n ? Math.ceil((o.MIDI_VELOCITIES - 1) / n) : void 0,\n              f = [];\n        let d = 0,\n            m = n;\n\n        for (const t of h) {\n          if (t.step > d) {\n            for (; t.step > d + e;) f.push({\n              type: \"time-shift\",\n              steps: e\n            }), d += e;\n\n            f.push({\n              type: \"time-shift\",\n              steps: t.step - d\n            }), d = t.step;\n          }\n\n          if (t.isOffset) f.push({\n            type: \"note-off\",\n            pitch: u[t.index].pitch\n          });else {\n            if (p) {\n              const e = Math.floor((u[t.index].velocity - o.MIN_MIDI_VELOCITY - 1) / p) + 1;\n              e !== m && (f.push({\n                type: \"velocity-change\",\n                velocityBin: e\n              }), m = e);\n            }\n\n            f.push({\n              type: \"note-on\",\n              pitch: u[t.index].pitch\n            });\n          }\n        }\n\n        const g = !!a.some(t => t.isDrum) && (!a.some(t => !t.isDrum) || void 0),\n              v = Array.from(new Set(a.map(t => t.program))),\n              y = g || 1 !== v.length ? void 0 : v[0],\n              b = new s(f, e, n, y, g);\n        return b.setNumSteps(t.totalQuantizedSteps), b;\n      }\n\n      getNumSteps() {\n        return this.events.filter(t => \"time-shift\" === t.type).map(t => t.steps).reduce((t, e) => t + e, 0);\n      }\n\n      setNumSteps(t) {\n        let e = this.getNumSteps();\n\n        if (e < t) {\n          if (this.events.length) {\n            const n = this.events[this.events.length - 1];\n\n            if (\"time-shift\" === n.type) {\n              const r = Math.min(t - e, this.maxShiftSteps - n.steps);\n              n.steps += r, e += r;\n            }\n          }\n\n          for (; e < t;) e + this.maxShiftSteps > t ? (this.events.push({\n            type: \"time-shift\",\n            steps: t - e\n          }), e = t) : (this.events.push({\n            type: \"time-shift\",\n            steps: this.maxShiftSteps\n          }), e += this.maxShiftSteps);\n        } else if (e > t) for (; this.events.length && e > t;) {\n          const n = this.events[this.events.length - 1];\n          \"time-shift\" === n.type ? e - n.steps < t ? (n.steps -= e - t, e = t) : (this.events.pop(), e -= n.steps) : this.events.pop();\n        }\n      }\n\n      toNoteSequence(t) {\n        const e = this.numVelocityBins ? Math.ceil((o.MIDI_VELOCITIES - 1) / this.numVelocityBins) : void 0,\n              n = r.a.create();\n        let i = 0,\n            s = void 0;\n        const u = new Map();\n\n        for (let t = o.MIN_MIDI_PITCH; t <= o.MAX_MIDI_PITCH; ++t) u.set(t, []);\n\n        for (const c of this.events) switch (c.type) {\n          case \"note-on\":\n            u.get(c.pitch).push([i, s]);\n            break;\n\n          case \"note-off\":\n            const l = u.get(c.pitch);\n\n            if (l.length) {\n              const _l$shift = l.shift(),\n                    _l$shift2 = _slicedToArray(_l$shift, 2),\n                    e = _l$shift2[0],\n                    o = _l$shift2[1];\n\n              i > e ? n.notes.push(r.a.Note.create({\n                pitch: c.pitch,\n                velocity: o,\n                instrument: t,\n                quantizedStartStep: e,\n                quantizedEndStep: i,\n                program: this.program,\n                isDrum: this.isDrum\n              })) : a.log(\"Ignoring zero-length note: \" + \"(pitch = \".concat(c.pitch, \", step = \").concat(i, \")\"), \"Performance\");\n            } else a.log(\"Ignoring note-off with no previous note-on:\" + \"(pitch = \".concat(c.pitch, \", step = \").concat(i, \")\"), \"Performance\");\n\n            break;\n\n          case \"time-shift\":\n            i += c.steps;\n            break;\n\n          case \"velocity-change\":\n            if (!e) throw new Error(\"Unexpected velocity change event: \".concat(c));\n            s = o.MIN_MIDI_VELOCITY + (c.velocityBin - 1) * e + 1;\n            break;\n\n          default:\n            throw new Error(\"Unrecognized performance event: \".concat(c));\n        }\n\n        return u.forEach((e, o) => {\n          for (const _ref6 of e) {\n            var _ref7 = _slicedToArray(_ref6, 2);\n\n            const s = _ref7[0];\n            const u = _ref7[1];\n            i > s ? n.notes.push(r.a.Note.create({\n              pitch: o,\n              velocity: u,\n              instrument: t,\n              quantizedStartStep: s,\n              quantizedEndStep: i,\n              program: this.program,\n              isDrum: this.isDrum\n            })) : a.log(\"Ignoring zero-length note: \" + \"(pitch = \".concat(o, \", step = \").concat(i, \")\"), \"Performance\");\n          }\n        }), n.totalQuantizedSteps = i, n;\n      }\n\n    }\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = h;\n    var r,\n        o = n(7),\n        i = o.LongBits,\n        a = o.base64,\n        s = o.utf8;\n\n    function u(t, e, n) {\n      this.fn = t, this.len = e, this.next = void 0, this.val = n;\n    }\n\n    function c() {}\n\n    function l(t) {\n      this.head = t.head, this.tail = t.tail, this.len = t.len, this.next = t.states;\n    }\n\n    function h() {\n      this.len = 0, this.head = new u(c, 0, 0), this.tail = this.head, this.states = null;\n    }\n\n    function p(t, e, n) {\n      e[n] = 255 & t;\n    }\n\n    function f(t, e) {\n      this.len = t, this.next = void 0, this.val = e;\n    }\n\n    function d(t, e, n) {\n      for (; t.hi;) e[n++] = 127 & t.lo | 128, t.lo = (t.lo >>> 7 | t.hi << 25) >>> 0, t.hi >>>= 7;\n\n      for (; t.lo > 127;) e[n++] = 127 & t.lo | 128, t.lo = t.lo >>> 7;\n\n      e[n++] = t.lo;\n    }\n\n    function m(t, e, n) {\n      e[n] = 255 & t, e[n + 1] = t >>> 8 & 255, e[n + 2] = t >>> 16 & 255, e[n + 3] = t >>> 24;\n    }\n\n    h.create = o.Buffer ? function () {\n      return (h.create = function () {\n        return new r();\n      })();\n    } : function () {\n      return new h();\n    }, h.alloc = function (t) {\n      return new o.Array(t);\n    }, o.Array !== Array && (h.alloc = o.pool(h.alloc, o.Array.prototype.subarray)), h.prototype._push = function (t, e, n) {\n      return this.tail = this.tail.next = new u(t, e, n), this.len += e, this;\n    }, f.prototype = Object.create(u.prototype), f.prototype.fn = function (t, e, n) {\n      for (; t > 127;) e[n++] = 127 & t | 128, t >>>= 7;\n\n      e[n] = t;\n    }, h.prototype.uint32 = function (t) {\n      return this.len += (this.tail = this.tail.next = new f((t >>>= 0) < 128 ? 1 : t < 16384 ? 2 : t < 2097152 ? 3 : t < 268435456 ? 4 : 5, t)).len, this;\n    }, h.prototype.int32 = function (t) {\n      return t < 0 ? this._push(d, 10, i.fromNumber(t)) : this.uint32(t);\n    }, h.prototype.sint32 = function (t) {\n      return this.uint32((t << 1 ^ t >> 31) >>> 0);\n    }, h.prototype.uint64 = function (t) {\n      var e = i.from(t);\n      return this._push(d, e.length(), e);\n    }, h.prototype.int64 = h.prototype.uint64, h.prototype.sint64 = function (t) {\n      var e = i.from(t).zzEncode();\n      return this._push(d, e.length(), e);\n    }, h.prototype.bool = function (t) {\n      return this._push(p, 1, t ? 1 : 0);\n    }, h.prototype.fixed32 = function (t) {\n      return this._push(m, 4, t >>> 0);\n    }, h.prototype.sfixed32 = h.prototype.fixed32, h.prototype.fixed64 = function (t) {\n      var e = i.from(t);\n      return this._push(m, 4, e.lo)._push(m, 4, e.hi);\n    }, h.prototype.sfixed64 = h.prototype.fixed64, h.prototype.float = function (t) {\n      return this._push(o.float.writeFloatLE, 4, t);\n    }, h.prototype.double = function (t) {\n      return this._push(o.float.writeDoubleLE, 8, t);\n    };\n    var g = o.Array.prototype.set ? function (t, e, n) {\n      e.set(t, n);\n    } : function (t, e, n) {\n      for (var r = 0; r < t.length; ++r) e[n + r] = t[r];\n    };\n    h.prototype.bytes = function (t) {\n      var e = t.length >>> 0;\n      if (!e) return this._push(p, 1, 0);\n\n      if (o.isString(t)) {\n        var n = h.alloc(e = a.length(t));\n        a.decode(t, n, 0), t = n;\n      }\n\n      return this.uint32(e)._push(g, e, t);\n    }, h.prototype.string = function (t) {\n      var e = s.length(t);\n      return e ? this.uint32(e)._push(s.write, e, t) : this._push(p, 1, 0);\n    }, h.prototype.fork = function () {\n      return this.states = new l(this), this.head = this.tail = new u(c, 0, 0), this.len = 0, this;\n    }, h.prototype.reset = function () {\n      return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(c, 0, 0), this.len = 0), this;\n    }, h.prototype.ldelim = function () {\n      var t = this.head,\n          e = this.tail,\n          n = this.len;\n      return this.reset().uint32(n), n && (this.tail.next = t.next, this.tail = e, this.len += n), this;\n    }, h.prototype.finish = function () {\n      for (var t = this.head.next, e = this.constructor.alloc(this.len), n = 0; t;) t.fn(t.val, e, n), n += t.len, t = t.next;\n\n      return e;\n    }, h._configure = function (t) {\n      r = t;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = u;\n    var r,\n        o = n(7),\n        i = o.LongBits,\n        a = o.utf8;\n\n    function s(t, e) {\n      return RangeError(\"index out of range: \" + t.pos + \" + \" + (e || 1) + \" > \" + t.len);\n    }\n\n    function u(t) {\n      this.buf = t, this.pos = 0, this.len = t.length;\n    }\n\n    var c,\n        l = \"undefined\" != typeof Uint8Array ? function (t) {\n      if (t instanceof Uint8Array || Array.isArray(t)) return new u(t);\n      throw Error(\"illegal buffer\");\n    } : function (t) {\n      if (Array.isArray(t)) return new u(t);\n      throw Error(\"illegal buffer\");\n    };\n\n    function h() {\n      var t = new i(0, 0),\n          e = 0;\n\n      if (!(this.len - this.pos > 4)) {\n        for (; e < 3; ++e) {\n          if (this.pos >= this.len) throw s(this);\n          if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128) return t;\n        }\n\n        return t.lo = (t.lo | (127 & this.buf[this.pos++]) << 7 * e) >>> 0, t;\n      }\n\n      for (; e < 4; ++e) if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 7 * e) >>> 0, this.buf[this.pos++] < 128) return t;\n\n      if (t.lo = (t.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t.hi = (t.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return t;\n\n      if (e = 0, this.len - this.pos > 4) {\n        for (; e < 5; ++e) if (t.hi = (t.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128) return t;\n      } else for (; e < 5; ++e) {\n        if (this.pos >= this.len) throw s(this);\n        if (t.hi = (t.hi | (127 & this.buf[this.pos]) << 7 * e + 3) >>> 0, this.buf[this.pos++] < 128) return t;\n      }\n\n      throw Error(\"invalid varint encoding\");\n    }\n\n    function p(t, e) {\n      return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0;\n    }\n\n    function f() {\n      if (this.pos + 8 > this.len) throw s(this, 8);\n      return new i(p(this.buf, this.pos += 4), p(this.buf, this.pos += 4));\n    }\n\n    u.create = o.Buffer ? function (t) {\n      return (u.create = function (t) {\n        return o.Buffer.isBuffer(t) ? new r(t) : l(t);\n      })(t);\n    } : l, u.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, u.prototype.uint32 = (c = 4294967295, function () {\n      if (c = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return c;\n      if (c = (c | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return c;\n      if (c = (c | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return c;\n      if (c = (c | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return c;\n      if (c = (c | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return c;\n      if ((this.pos += 5) > this.len) throw this.pos = this.len, s(this, 10);\n      return c;\n    }), u.prototype.int32 = function () {\n      return 0 | this.uint32();\n    }, u.prototype.sint32 = function () {\n      var t = this.uint32();\n      return t >>> 1 ^ -(1 & t) | 0;\n    }, u.prototype.bool = function () {\n      return 0 !== this.uint32();\n    }, u.prototype.fixed32 = function () {\n      if (this.pos + 4 > this.len) throw s(this, 4);\n      return p(this.buf, this.pos += 4);\n    }, u.prototype.sfixed32 = function () {\n      if (this.pos + 4 > this.len) throw s(this, 4);\n      return 0 | p(this.buf, this.pos += 4);\n    }, u.prototype.float = function () {\n      if (this.pos + 4 > this.len) throw s(this, 4);\n      var t = o.float.readFloatLE(this.buf, this.pos);\n      return this.pos += 4, t;\n    }, u.prototype.double = function () {\n      if (this.pos + 8 > this.len) throw s(this, 4);\n      var t = o.float.readDoubleLE(this.buf, this.pos);\n      return this.pos += 8, t;\n    }, u.prototype.bytes = function () {\n      var t = this.uint32(),\n          e = this.pos,\n          n = this.pos + t;\n      if (n > this.len) throw s(this, t);\n      return this.pos += t, Array.isArray(this.buf) ? this.buf.slice(e, n) : e === n ? new this.buf.constructor(0) : this._slice.call(this.buf, e, n);\n    }, u.prototype.string = function () {\n      var t = this.bytes();\n      return a.read(t, 0, t.length);\n    }, u.prototype.skip = function (t) {\n      if (\"number\" == typeof t) {\n        if (this.pos + t > this.len) throw s(this, t);\n        this.pos += t;\n      } else do {\n        if (this.pos >= this.len) throw s(this);\n      } while (128 & this.buf[this.pos++]);\n\n      return this;\n    }, u.prototype.skipType = function (t) {\n      switch (t) {\n        case 0:\n          this.skip();\n          break;\n\n        case 1:\n          this.skip(8);\n          break;\n\n        case 2:\n          this.skip(this.uint32());\n          break;\n\n        case 3:\n          for (; 4 != (t = 7 & this.uint32());) this.skipType(t);\n\n          break;\n\n        case 5:\n          this.skip(4);\n          break;\n\n        default:\n          throw Error(\"invalid wire type \" + t + \" at offset \" + this.pos);\n      }\n\n      return this;\n    }, u._configure = function (t) {\n      r = t;\n      var e = o.Long ? \"toLong\" : \"toNumber\";\n      o.merge(u.prototype, {\n        int64: function () {\n          return h.call(this)[e](!1);\n        },\n        uint64: function () {\n          return h.call(this)[e](!0);\n        },\n        sint64: function () {\n          return h.call(this).zzDecode()[e](!1);\n        },\n        fixed64: function () {\n          return f.call(this)[e](!0);\n        },\n        sfixed64: function () {\n          return f.call(this)[e](!1);\n        }\n      });\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r,\n        o,\n        i = n(19),\n        a = i.Reader,\n        s = i.Writer,\n        u = i.util,\n        c = i.roots.default || (i.roots.default = {});\n    c.tensorflow = ((o = {}).magenta = ((r = {}).NoteSequence = function () {\n      function t(t) {\n        if (this.timeSignatures = [], this.keySignatures = [], this.tempos = [], this.notes = [], this.pitchBends = [], this.controlChanges = [], this.partInfos = [], this.textAnnotations = [], this.sectionAnnotations = [], this.sectionGroups = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n      }\n\n      var e, n;\n      return t.prototype.id = \"\", t.prototype.filename = \"\", t.prototype.referenceNumber = u.Long ? u.Long.fromBits(0, 0, !1) : 0, t.prototype.collectionName = \"\", t.prototype.ticksPerQuarter = 0, t.prototype.timeSignatures = u.emptyArray, t.prototype.keySignatures = u.emptyArray, t.prototype.tempos = u.emptyArray, t.prototype.notes = u.emptyArray, t.prototype.totalTime = 0, t.prototype.totalQuantizedSteps = u.Long ? u.Long.fromBits(0, 0, !1) : 0, t.prototype.pitchBends = u.emptyArray, t.prototype.controlChanges = u.emptyArray, t.prototype.partInfos = u.emptyArray, t.prototype.sourceInfo = null, t.prototype.textAnnotations = u.emptyArray, t.prototype.sectionAnnotations = u.emptyArray, t.prototype.sectionGroups = u.emptyArray, t.prototype.quantizationInfo = null, t.prototype.subsequenceInfo = null, t.prototype.sequenceMetadata = null, t.create = function (e) {\n        return new t(e);\n      }, t.encode = function (t, e) {\n        if (e || (e = s.create()), null != t.id && t.hasOwnProperty(\"id\") && e.uint32(10).string(t.id), null != t.filename && t.hasOwnProperty(\"filename\") && e.uint32(18).string(t.filename), null != t.collectionName && t.hasOwnProperty(\"collectionName\") && e.uint32(26).string(t.collectionName), null != t.ticksPerQuarter && t.hasOwnProperty(\"ticksPerQuarter\") && e.uint32(32).int32(t.ticksPerQuarter), null != t.timeSignatures && t.timeSignatures.length) for (var n = 0; n < t.timeSignatures.length; ++n) c.tensorflow.magenta.NoteSequence.TimeSignature.encode(t.timeSignatures[n], e.uint32(42).fork()).ldelim();\n        if (null != t.keySignatures && t.keySignatures.length) for (n = 0; n < t.keySignatures.length; ++n) c.tensorflow.magenta.NoteSequence.KeySignature.encode(t.keySignatures[n], e.uint32(50).fork()).ldelim();\n        if (null != t.tempos && t.tempos.length) for (n = 0; n < t.tempos.length; ++n) c.tensorflow.magenta.NoteSequence.Tempo.encode(t.tempos[n], e.uint32(58).fork()).ldelim();\n        if (null != t.notes && t.notes.length) for (n = 0; n < t.notes.length; ++n) c.tensorflow.magenta.NoteSequence.Note.encode(t.notes[n], e.uint32(66).fork()).ldelim();\n        if (null != t.totalTime && t.hasOwnProperty(\"totalTime\") && e.uint32(73).double(t.totalTime), null != t.pitchBends && t.pitchBends.length) for (n = 0; n < t.pitchBends.length; ++n) c.tensorflow.magenta.NoteSequence.PitchBend.encode(t.pitchBends[n], e.uint32(82).fork()).ldelim();\n        if (null != t.controlChanges && t.controlChanges.length) for (n = 0; n < t.controlChanges.length; ++n) c.tensorflow.magenta.NoteSequence.ControlChange.encode(t.controlChanges[n], e.uint32(90).fork()).ldelim();\n        if (null != t.partInfos && t.partInfos.length) for (n = 0; n < t.partInfos.length; ++n) c.tensorflow.magenta.NoteSequence.PartInfo.encode(t.partInfos[n], e.uint32(98).fork()).ldelim();\n        if (null != t.sourceInfo && t.hasOwnProperty(\"sourceInfo\") && c.tensorflow.magenta.NoteSequence.SourceInfo.encode(t.sourceInfo, e.uint32(106).fork()).ldelim(), null != t.textAnnotations && t.textAnnotations.length) for (n = 0; n < t.textAnnotations.length; ++n) c.tensorflow.magenta.NoteSequence.TextAnnotation.encode(t.textAnnotations[n], e.uint32(114).fork()).ldelim();\n        if (null != t.quantizationInfo && t.hasOwnProperty(\"quantizationInfo\") && c.tensorflow.magenta.NoteSequence.QuantizationInfo.encode(t.quantizationInfo, e.uint32(122).fork()).ldelim(), null != t.totalQuantizedSteps && t.hasOwnProperty(\"totalQuantizedSteps\") && e.uint32(128).int64(t.totalQuantizedSteps), null != t.subsequenceInfo && t.hasOwnProperty(\"subsequenceInfo\") && c.tensorflow.magenta.NoteSequence.SubsequenceInfo.encode(t.subsequenceInfo, e.uint32(138).fork()).ldelim(), null != t.referenceNumber && t.hasOwnProperty(\"referenceNumber\") && e.uint32(144).int64(t.referenceNumber), null != t.sequenceMetadata && t.hasOwnProperty(\"sequenceMetadata\") && c.tensorflow.magenta.SequenceMetadata.encode(t.sequenceMetadata, e.uint32(154).fork()).ldelim(), null != t.sectionAnnotations && t.sectionAnnotations.length) for (n = 0; n < t.sectionAnnotations.length; ++n) c.tensorflow.magenta.NoteSequence.SectionAnnotation.encode(t.sectionAnnotations[n], e.uint32(162).fork()).ldelim();\n        if (null != t.sectionGroups && t.sectionGroups.length) for (n = 0; n < t.sectionGroups.length; ++n) c.tensorflow.magenta.NoteSequence.SectionGroup.encode(t.sectionGroups[n], e.uint32(170).fork()).ldelim();\n        return e;\n      }, t.encodeDelimited = function (t, e) {\n        return this.encode(t, e).ldelim();\n      }, t.decode = function (t, e) {\n        t instanceof a || (t = a.create(t));\n\n        for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence(); t.pos < n;) {\n          var o = t.uint32();\n\n          switch (o >>> 3) {\n            case 1:\n              r.id = t.string();\n              break;\n\n            case 2:\n              r.filename = t.string();\n              break;\n\n            case 18:\n              r.referenceNumber = u.Long ? t.int64().toNumber() : t.int64();\n              break;\n\n            case 3:\n              r.collectionName = t.string();\n              break;\n\n            case 4:\n              r.ticksPerQuarter = t.int32();\n              break;\n\n            case 5:\n              r.timeSignatures && r.timeSignatures.length || (r.timeSignatures = []), r.timeSignatures.push(c.tensorflow.magenta.NoteSequence.TimeSignature.decode(t, t.uint32()));\n              break;\n\n            case 6:\n              r.keySignatures && r.keySignatures.length || (r.keySignatures = []), r.keySignatures.push(c.tensorflow.magenta.NoteSequence.KeySignature.decode(t, t.uint32()));\n              break;\n\n            case 7:\n              r.tempos && r.tempos.length || (r.tempos = []), r.tempos.push(c.tensorflow.magenta.NoteSequence.Tempo.decode(t, t.uint32()));\n              break;\n\n            case 8:\n              r.notes && r.notes.length || (r.notes = []), r.notes.push(c.tensorflow.magenta.NoteSequence.Note.decode(t, t.uint32()));\n              break;\n\n            case 9:\n              r.totalTime = t.double();\n              break;\n\n            case 16:\n              r.totalQuantizedSteps = u.Long ? t.int64().toNumber() : t.int64();\n              break;\n\n            case 10:\n              r.pitchBends && r.pitchBends.length || (r.pitchBends = []), r.pitchBends.push(c.tensorflow.magenta.NoteSequence.PitchBend.decode(t, t.uint32()));\n              break;\n\n            case 11:\n              r.controlChanges && r.controlChanges.length || (r.controlChanges = []), r.controlChanges.push(c.tensorflow.magenta.NoteSequence.ControlChange.decode(t, t.uint32()));\n              break;\n\n            case 12:\n              r.partInfos && r.partInfos.length || (r.partInfos = []), r.partInfos.push(c.tensorflow.magenta.NoteSequence.PartInfo.decode(t, t.uint32()));\n              break;\n\n            case 13:\n              r.sourceInfo = c.tensorflow.magenta.NoteSequence.SourceInfo.decode(t, t.uint32());\n              break;\n\n            case 14:\n              r.textAnnotations && r.textAnnotations.length || (r.textAnnotations = []), r.textAnnotations.push(c.tensorflow.magenta.NoteSequence.TextAnnotation.decode(t, t.uint32()));\n              break;\n\n            case 20:\n              r.sectionAnnotations && r.sectionAnnotations.length || (r.sectionAnnotations = []), r.sectionAnnotations.push(c.tensorflow.magenta.NoteSequence.SectionAnnotation.decode(t, t.uint32()));\n              break;\n\n            case 21:\n              r.sectionGroups && r.sectionGroups.length || (r.sectionGroups = []), r.sectionGroups.push(c.tensorflow.magenta.NoteSequence.SectionGroup.decode(t, t.uint32()));\n              break;\n\n            case 15:\n              r.quantizationInfo = c.tensorflow.magenta.NoteSequence.QuantizationInfo.decode(t, t.uint32());\n              break;\n\n            case 17:\n              r.subsequenceInfo = c.tensorflow.magenta.NoteSequence.SubsequenceInfo.decode(t, t.uint32());\n              break;\n\n            case 19:\n              r.sequenceMetadata = c.tensorflow.magenta.SequenceMetadata.decode(t, t.uint32());\n              break;\n\n            default:\n              t.skipType(7 & o);\n          }\n        }\n\n        return r;\n      }, t.decodeDelimited = function (t) {\n        return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n      }, t.verify = function (t) {\n        if (\"object\" != typeof t || null === t) return \"object expected\";\n        if (null != t.id && t.hasOwnProperty(\"id\") && !u.isString(t.id)) return \"id: string expected\";\n        if (null != t.filename && t.hasOwnProperty(\"filename\") && !u.isString(t.filename)) return \"filename: string expected\";\n        if (null != t.referenceNumber && t.hasOwnProperty(\"referenceNumber\") && !(u.isInteger(t.referenceNumber) || t.referenceNumber && u.isInteger(t.referenceNumber.low) && u.isInteger(t.referenceNumber.high))) return \"referenceNumber: integer|Long expected\";\n        if (null != t.collectionName && t.hasOwnProperty(\"collectionName\") && !u.isString(t.collectionName)) return \"collectionName: string expected\";\n        if (null != t.ticksPerQuarter && t.hasOwnProperty(\"ticksPerQuarter\") && !u.isInteger(t.ticksPerQuarter)) return \"ticksPerQuarter: integer expected\";\n\n        if (null != t.timeSignatures && t.hasOwnProperty(\"timeSignatures\")) {\n          if (!Array.isArray(t.timeSignatures)) return \"timeSignatures: array expected\";\n\n          for (var e = 0; e < t.timeSignatures.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.TimeSignature.verify(t.timeSignatures[e])) return \"timeSignatures.\" + n;\n        }\n\n        if (null != t.keySignatures && t.hasOwnProperty(\"keySignatures\")) {\n          if (!Array.isArray(t.keySignatures)) return \"keySignatures: array expected\";\n\n          for (e = 0; e < t.keySignatures.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.KeySignature.verify(t.keySignatures[e])) return \"keySignatures.\" + n;\n        }\n\n        if (null != t.tempos && t.hasOwnProperty(\"tempos\")) {\n          if (!Array.isArray(t.tempos)) return \"tempos: array expected\";\n\n          for (e = 0; e < t.tempos.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.Tempo.verify(t.tempos[e])) return \"tempos.\" + n;\n        }\n\n        if (null != t.notes && t.hasOwnProperty(\"notes\")) {\n          if (!Array.isArray(t.notes)) return \"notes: array expected\";\n\n          for (e = 0; e < t.notes.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.Note.verify(t.notes[e])) return \"notes.\" + n;\n        }\n\n        if (null != t.totalTime && t.hasOwnProperty(\"totalTime\") && \"number\" != typeof t.totalTime) return \"totalTime: number expected\";\n        if (null != t.totalQuantizedSteps && t.hasOwnProperty(\"totalQuantizedSteps\") && !(u.isInteger(t.totalQuantizedSteps) || t.totalQuantizedSteps && u.isInteger(t.totalQuantizedSteps.low) && u.isInteger(t.totalQuantizedSteps.high))) return \"totalQuantizedSteps: integer|Long expected\";\n\n        if (null != t.pitchBends && t.hasOwnProperty(\"pitchBends\")) {\n          if (!Array.isArray(t.pitchBends)) return \"pitchBends: array expected\";\n\n          for (e = 0; e < t.pitchBends.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.PitchBend.verify(t.pitchBends[e])) return \"pitchBends.\" + n;\n        }\n\n        if (null != t.controlChanges && t.hasOwnProperty(\"controlChanges\")) {\n          if (!Array.isArray(t.controlChanges)) return \"controlChanges: array expected\";\n\n          for (e = 0; e < t.controlChanges.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.ControlChange.verify(t.controlChanges[e])) return \"controlChanges.\" + n;\n        }\n\n        if (null != t.partInfos && t.hasOwnProperty(\"partInfos\")) {\n          if (!Array.isArray(t.partInfos)) return \"partInfos: array expected\";\n\n          for (e = 0; e < t.partInfos.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.PartInfo.verify(t.partInfos[e])) return \"partInfos.\" + n;\n        }\n\n        if (null != t.sourceInfo && t.hasOwnProperty(\"sourceInfo\") && (n = c.tensorflow.magenta.NoteSequence.SourceInfo.verify(t.sourceInfo))) return \"sourceInfo.\" + n;\n\n        if (null != t.textAnnotations && t.hasOwnProperty(\"textAnnotations\")) {\n          if (!Array.isArray(t.textAnnotations)) return \"textAnnotations: array expected\";\n\n          for (e = 0; e < t.textAnnotations.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.TextAnnotation.verify(t.textAnnotations[e])) return \"textAnnotations.\" + n;\n        }\n\n        if (null != t.sectionAnnotations && t.hasOwnProperty(\"sectionAnnotations\")) {\n          if (!Array.isArray(t.sectionAnnotations)) return \"sectionAnnotations: array expected\";\n\n          for (e = 0; e < t.sectionAnnotations.length; ++e) if (n = c.tensorflow.magenta.NoteSequence.SectionAnnotation.verify(t.sectionAnnotations[e])) return \"sectionAnnotations.\" + n;\n        }\n\n        if (null != t.sectionGroups && t.hasOwnProperty(\"sectionGroups\")) {\n          if (!Array.isArray(t.sectionGroups)) return \"sectionGroups: array expected\";\n\n          for (e = 0; e < t.sectionGroups.length; ++e) {\n            var n;\n            if (n = c.tensorflow.magenta.NoteSequence.SectionGroup.verify(t.sectionGroups[e])) return \"sectionGroups.\" + n;\n          }\n        }\n\n        return null != t.quantizationInfo && t.hasOwnProperty(\"quantizationInfo\") && (n = c.tensorflow.magenta.NoteSequence.QuantizationInfo.verify(t.quantizationInfo)) ? \"quantizationInfo.\" + n : null != t.subsequenceInfo && t.hasOwnProperty(\"subsequenceInfo\") && (n = c.tensorflow.magenta.NoteSequence.SubsequenceInfo.verify(t.subsequenceInfo)) ? \"subsequenceInfo.\" + n : null != t.sequenceMetadata && t.hasOwnProperty(\"sequenceMetadata\") && (n = c.tensorflow.magenta.SequenceMetadata.verify(t.sequenceMetadata)) ? \"sequenceMetadata.\" + n : null;\n      }, t.fromObject = function (t) {\n        if (t instanceof c.tensorflow.magenta.NoteSequence) return t;\n        var e = new c.tensorflow.magenta.NoteSequence();\n\n        if (null != t.id && (e.id = String(t.id)), null != t.filename && (e.filename = String(t.filename)), null != t.referenceNumber && (u.Long ? (e.referenceNumber = u.Long.fromValue(t.referenceNumber)).unsigned = !1 : \"string\" == typeof t.referenceNumber ? e.referenceNumber = parseInt(t.referenceNumber, 10) : \"number\" == typeof t.referenceNumber ? e.referenceNumber = t.referenceNumber : \"object\" == typeof t.referenceNumber && (e.referenceNumber = new u.LongBits(t.referenceNumber.low >>> 0, t.referenceNumber.high >>> 0).toNumber())), null != t.collectionName && (e.collectionName = String(t.collectionName)), null != t.ticksPerQuarter && (e.ticksPerQuarter = 0 | t.ticksPerQuarter), t.timeSignatures) {\n          if (!Array.isArray(t.timeSignatures)) throw TypeError(\".tensorflow.magenta.NoteSequence.timeSignatures: array expected\");\n          e.timeSignatures = [];\n\n          for (var n = 0; n < t.timeSignatures.length; ++n) {\n            if (\"object\" != typeof t.timeSignatures[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.timeSignatures: object expected\");\n            e.timeSignatures[n] = c.tensorflow.magenta.NoteSequence.TimeSignature.fromObject(t.timeSignatures[n]);\n          }\n        }\n\n        if (t.keySignatures) {\n          if (!Array.isArray(t.keySignatures)) throw TypeError(\".tensorflow.magenta.NoteSequence.keySignatures: array expected\");\n\n          for (e.keySignatures = [], n = 0; n < t.keySignatures.length; ++n) {\n            if (\"object\" != typeof t.keySignatures[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.keySignatures: object expected\");\n            e.keySignatures[n] = c.tensorflow.magenta.NoteSequence.KeySignature.fromObject(t.keySignatures[n]);\n          }\n        }\n\n        if (t.tempos) {\n          if (!Array.isArray(t.tempos)) throw TypeError(\".tensorflow.magenta.NoteSequence.tempos: array expected\");\n\n          for (e.tempos = [], n = 0; n < t.tempos.length; ++n) {\n            if (\"object\" != typeof t.tempos[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.tempos: object expected\");\n            e.tempos[n] = c.tensorflow.magenta.NoteSequence.Tempo.fromObject(t.tempos[n]);\n          }\n        }\n\n        if (t.notes) {\n          if (!Array.isArray(t.notes)) throw TypeError(\".tensorflow.magenta.NoteSequence.notes: array expected\");\n\n          for (e.notes = [], n = 0; n < t.notes.length; ++n) {\n            if (\"object\" != typeof t.notes[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.notes: object expected\");\n            e.notes[n] = c.tensorflow.magenta.NoteSequence.Note.fromObject(t.notes[n]);\n          }\n        }\n\n        if (null != t.totalTime && (e.totalTime = Number(t.totalTime)), null != t.totalQuantizedSteps && (u.Long ? (e.totalQuantizedSteps = u.Long.fromValue(t.totalQuantizedSteps)).unsigned = !1 : \"string\" == typeof t.totalQuantizedSteps ? e.totalQuantizedSteps = parseInt(t.totalQuantizedSteps, 10) : \"number\" == typeof t.totalQuantizedSteps ? e.totalQuantizedSteps = t.totalQuantizedSteps : \"object\" == typeof t.totalQuantizedSteps && (e.totalQuantizedSteps = new u.LongBits(t.totalQuantizedSteps.low >>> 0, t.totalQuantizedSteps.high >>> 0).toNumber())), t.pitchBends) {\n          if (!Array.isArray(t.pitchBends)) throw TypeError(\".tensorflow.magenta.NoteSequence.pitchBends: array expected\");\n\n          for (e.pitchBends = [], n = 0; n < t.pitchBends.length; ++n) {\n            if (\"object\" != typeof t.pitchBends[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.pitchBends: object expected\");\n            e.pitchBends[n] = c.tensorflow.magenta.NoteSequence.PitchBend.fromObject(t.pitchBends[n]);\n          }\n        }\n\n        if (t.controlChanges) {\n          if (!Array.isArray(t.controlChanges)) throw TypeError(\".tensorflow.magenta.NoteSequence.controlChanges: array expected\");\n\n          for (e.controlChanges = [], n = 0; n < t.controlChanges.length; ++n) {\n            if (\"object\" != typeof t.controlChanges[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.controlChanges: object expected\");\n            e.controlChanges[n] = c.tensorflow.magenta.NoteSequence.ControlChange.fromObject(t.controlChanges[n]);\n          }\n        }\n\n        if (t.partInfos) {\n          if (!Array.isArray(t.partInfos)) throw TypeError(\".tensorflow.magenta.NoteSequence.partInfos: array expected\");\n\n          for (e.partInfos = [], n = 0; n < t.partInfos.length; ++n) {\n            if (\"object\" != typeof t.partInfos[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.partInfos: object expected\");\n            e.partInfos[n] = c.tensorflow.magenta.NoteSequence.PartInfo.fromObject(t.partInfos[n]);\n          }\n        }\n\n        if (null != t.sourceInfo) {\n          if (\"object\" != typeof t.sourceInfo) throw TypeError(\".tensorflow.magenta.NoteSequence.sourceInfo: object expected\");\n          e.sourceInfo = c.tensorflow.magenta.NoteSequence.SourceInfo.fromObject(t.sourceInfo);\n        }\n\n        if (t.textAnnotations) {\n          if (!Array.isArray(t.textAnnotations)) throw TypeError(\".tensorflow.magenta.NoteSequence.textAnnotations: array expected\");\n\n          for (e.textAnnotations = [], n = 0; n < t.textAnnotations.length; ++n) {\n            if (\"object\" != typeof t.textAnnotations[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.textAnnotations: object expected\");\n            e.textAnnotations[n] = c.tensorflow.magenta.NoteSequence.TextAnnotation.fromObject(t.textAnnotations[n]);\n          }\n        }\n\n        if (t.sectionAnnotations) {\n          if (!Array.isArray(t.sectionAnnotations)) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionAnnotations: array expected\");\n\n          for (e.sectionAnnotations = [], n = 0; n < t.sectionAnnotations.length; ++n) {\n            if (\"object\" != typeof t.sectionAnnotations[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionAnnotations: object expected\");\n            e.sectionAnnotations[n] = c.tensorflow.magenta.NoteSequence.SectionAnnotation.fromObject(t.sectionAnnotations[n]);\n          }\n        }\n\n        if (t.sectionGroups) {\n          if (!Array.isArray(t.sectionGroups)) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionGroups: array expected\");\n\n          for (e.sectionGroups = [], n = 0; n < t.sectionGroups.length; ++n) {\n            if (\"object\" != typeof t.sectionGroups[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.sectionGroups: object expected\");\n            e.sectionGroups[n] = c.tensorflow.magenta.NoteSequence.SectionGroup.fromObject(t.sectionGroups[n]);\n          }\n        }\n\n        if (null != t.quantizationInfo) {\n          if (\"object\" != typeof t.quantizationInfo) throw TypeError(\".tensorflow.magenta.NoteSequence.quantizationInfo: object expected\");\n          e.quantizationInfo = c.tensorflow.magenta.NoteSequence.QuantizationInfo.fromObject(t.quantizationInfo);\n        }\n\n        if (null != t.subsequenceInfo) {\n          if (\"object\" != typeof t.subsequenceInfo) throw TypeError(\".tensorflow.magenta.NoteSequence.subsequenceInfo: object expected\");\n          e.subsequenceInfo = c.tensorflow.magenta.NoteSequence.SubsequenceInfo.fromObject(t.subsequenceInfo);\n        }\n\n        if (null != t.sequenceMetadata) {\n          if (\"object\" != typeof t.sequenceMetadata) throw TypeError(\".tensorflow.magenta.NoteSequence.sequenceMetadata: object expected\");\n          e.sequenceMetadata = c.tensorflow.magenta.SequenceMetadata.fromObject(t.sequenceMetadata);\n        }\n\n        return e;\n      }, t.toObject = function (t, e) {\n        e || (e = {});\n        var n = {};\n\n        if ((e.arrays || e.defaults) && (n.timeSignatures = [], n.keySignatures = [], n.tempos = [], n.notes = [], n.pitchBends = [], n.controlChanges = [], n.partInfos = [], n.textAnnotations = [], n.sectionAnnotations = [], n.sectionGroups = []), e.defaults) {\n          if (n.id = \"\", n.filename = \"\", n.collectionName = \"\", n.ticksPerQuarter = 0, n.totalTime = 0, n.sourceInfo = null, n.quantizationInfo = null, u.Long) {\n            var r = new u.Long(0, 0, !1);\n            n.totalQuantizedSteps = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n          } else n.totalQuantizedSteps = e.longs === String ? \"0\" : 0;\n\n          n.subsequenceInfo = null, u.Long ? (r = new u.Long(0, 0, !1), n.referenceNumber = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r) : n.referenceNumber = e.longs === String ? \"0\" : 0, n.sequenceMetadata = null;\n        }\n\n        if (null != t.id && t.hasOwnProperty(\"id\") && (n.id = t.id), null != t.filename && t.hasOwnProperty(\"filename\") && (n.filename = t.filename), null != t.collectionName && t.hasOwnProperty(\"collectionName\") && (n.collectionName = t.collectionName), null != t.ticksPerQuarter && t.hasOwnProperty(\"ticksPerQuarter\") && (n.ticksPerQuarter = t.ticksPerQuarter), t.timeSignatures && t.timeSignatures.length) {\n          n.timeSignatures = [];\n\n          for (var o = 0; o < t.timeSignatures.length; ++o) n.timeSignatures[o] = c.tensorflow.magenta.NoteSequence.TimeSignature.toObject(t.timeSignatures[o], e);\n        }\n\n        if (t.keySignatures && t.keySignatures.length) for (n.keySignatures = [], o = 0; o < t.keySignatures.length; ++o) n.keySignatures[o] = c.tensorflow.magenta.NoteSequence.KeySignature.toObject(t.keySignatures[o], e);\n        if (t.tempos && t.tempos.length) for (n.tempos = [], o = 0; o < t.tempos.length; ++o) n.tempos[o] = c.tensorflow.magenta.NoteSequence.Tempo.toObject(t.tempos[o], e);\n        if (t.notes && t.notes.length) for (n.notes = [], o = 0; o < t.notes.length; ++o) n.notes[o] = c.tensorflow.magenta.NoteSequence.Note.toObject(t.notes[o], e);\n        if (null != t.totalTime && t.hasOwnProperty(\"totalTime\") && (n.totalTime = e.json && !isFinite(t.totalTime) ? String(t.totalTime) : t.totalTime), t.pitchBends && t.pitchBends.length) for (n.pitchBends = [], o = 0; o < t.pitchBends.length; ++o) n.pitchBends[o] = c.tensorflow.magenta.NoteSequence.PitchBend.toObject(t.pitchBends[o], e);\n        if (t.controlChanges && t.controlChanges.length) for (n.controlChanges = [], o = 0; o < t.controlChanges.length; ++o) n.controlChanges[o] = c.tensorflow.magenta.NoteSequence.ControlChange.toObject(t.controlChanges[o], e);\n        if (t.partInfos && t.partInfos.length) for (n.partInfos = [], o = 0; o < t.partInfos.length; ++o) n.partInfos[o] = c.tensorflow.magenta.NoteSequence.PartInfo.toObject(t.partInfos[o], e);\n        if (null != t.sourceInfo && t.hasOwnProperty(\"sourceInfo\") && (n.sourceInfo = c.tensorflow.magenta.NoteSequence.SourceInfo.toObject(t.sourceInfo, e)), t.textAnnotations && t.textAnnotations.length) for (n.textAnnotations = [], o = 0; o < t.textAnnotations.length; ++o) n.textAnnotations[o] = c.tensorflow.magenta.NoteSequence.TextAnnotation.toObject(t.textAnnotations[o], e);\n        if (null != t.quantizationInfo && t.hasOwnProperty(\"quantizationInfo\") && (n.quantizationInfo = c.tensorflow.magenta.NoteSequence.QuantizationInfo.toObject(t.quantizationInfo, e)), null != t.totalQuantizedSteps && t.hasOwnProperty(\"totalQuantizedSteps\") && (\"number\" == typeof t.totalQuantizedSteps ? n.totalQuantizedSteps = e.longs === String ? String(t.totalQuantizedSteps) : t.totalQuantizedSteps : n.totalQuantizedSteps = e.longs === String ? u.Long.prototype.toString.call(t.totalQuantizedSteps) : e.longs === Number ? new u.LongBits(t.totalQuantizedSteps.low >>> 0, t.totalQuantizedSteps.high >>> 0).toNumber() : t.totalQuantizedSteps), null != t.subsequenceInfo && t.hasOwnProperty(\"subsequenceInfo\") && (n.subsequenceInfo = c.tensorflow.magenta.NoteSequence.SubsequenceInfo.toObject(t.subsequenceInfo, e)), null != t.referenceNumber && t.hasOwnProperty(\"referenceNumber\") && (\"number\" == typeof t.referenceNumber ? n.referenceNumber = e.longs === String ? String(t.referenceNumber) : t.referenceNumber : n.referenceNumber = e.longs === String ? u.Long.prototype.toString.call(t.referenceNumber) : e.longs === Number ? new u.LongBits(t.referenceNumber.low >>> 0, t.referenceNumber.high >>> 0).toNumber() : t.referenceNumber), null != t.sequenceMetadata && t.hasOwnProperty(\"sequenceMetadata\") && (n.sequenceMetadata = c.tensorflow.magenta.SequenceMetadata.toObject(t.sequenceMetadata, e)), t.sectionAnnotations && t.sectionAnnotations.length) for (n.sectionAnnotations = [], o = 0; o < t.sectionAnnotations.length; ++o) n.sectionAnnotations[o] = c.tensorflow.magenta.NoteSequence.SectionAnnotation.toObject(t.sectionAnnotations[o], e);\n        if (t.sectionGroups && t.sectionGroups.length) for (n.sectionGroups = [], o = 0; o < t.sectionGroups.length; ++o) n.sectionGroups[o] = c.tensorflow.magenta.NoteSequence.SectionGroup.toObject(t.sectionGroups[o], e);\n        return n;\n      }, t.prototype.toJSON = function () {\n        return this.constructor.toObject(this, i.util.toJSONOptions);\n      }, t.Note = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.pitch = 0, t.prototype.pitchName = 0, t.prototype.velocity = 0, t.prototype.startTime = 0, t.prototype.quantizedStartStep = u.Long ? u.Long.fromBits(0, 0, !1) : 0, t.prototype.endTime = 0, t.prototype.quantizedEndStep = u.Long ? u.Long.fromBits(0, 0, !1) : 0, t.prototype.numerator = 0, t.prototype.denominator = 0, t.prototype.instrument = 0, t.prototype.program = 0, t.prototype.isDrum = !1, t.prototype.part = 0, t.prototype.voice = 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.pitch && t.hasOwnProperty(\"pitch\") && e.uint32(8).int32(t.pitch), null != t.velocity && t.hasOwnProperty(\"velocity\") && e.uint32(16).int32(t.velocity), null != t.startTime && t.hasOwnProperty(\"startTime\") && e.uint32(25).double(t.startTime), null != t.endTime && t.hasOwnProperty(\"endTime\") && e.uint32(33).double(t.endTime), null != t.numerator && t.hasOwnProperty(\"numerator\") && e.uint32(40).int32(t.numerator), null != t.denominator && t.hasOwnProperty(\"denominator\") && e.uint32(48).int32(t.denominator), null != t.instrument && t.hasOwnProperty(\"instrument\") && e.uint32(56).int32(t.instrument), null != t.program && t.hasOwnProperty(\"program\") && e.uint32(64).int32(t.program), null != t.isDrum && t.hasOwnProperty(\"isDrum\") && e.uint32(72).bool(t.isDrum), null != t.part && t.hasOwnProperty(\"part\") && e.uint32(80).int32(t.part), null != t.pitchName && t.hasOwnProperty(\"pitchName\") && e.uint32(88).int32(t.pitchName), null != t.voice && t.hasOwnProperty(\"voice\") && e.uint32(96).int32(t.voice), null != t.quantizedStartStep && t.hasOwnProperty(\"quantizedStartStep\") && e.uint32(104).int64(t.quantizedStartStep), null != t.quantizedEndStep && t.hasOwnProperty(\"quantizedEndStep\") && e.uint32(112).int64(t.quantizedEndStep), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.Note(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.pitch = t.int32();\n                break;\n\n              case 11:\n                r.pitchName = t.int32();\n                break;\n\n              case 2:\n                r.velocity = t.int32();\n                break;\n\n              case 3:\n                r.startTime = t.double();\n                break;\n\n              case 13:\n                r.quantizedStartStep = u.Long ? t.int64().toNumber() : t.int64();\n                break;\n\n              case 4:\n                r.endTime = t.double();\n                break;\n\n              case 14:\n                r.quantizedEndStep = u.Long ? t.int64().toNumber() : t.int64();\n                break;\n\n              case 5:\n                r.numerator = t.int32();\n                break;\n\n              case 6:\n                r.denominator = t.int32();\n                break;\n\n              case 7:\n                r.instrument = t.int32();\n                break;\n\n              case 8:\n                r.program = t.int32();\n                break;\n\n              case 9:\n                r.isDrum = t.bool();\n                break;\n\n              case 10:\n                r.part = t.int32();\n                break;\n\n              case 12:\n                r.voice = t.int32();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          if (\"object\" != typeof t || null === t) return \"object expected\";\n          if (null != t.pitch && t.hasOwnProperty(\"pitch\") && !u.isInteger(t.pitch)) return \"pitch: integer expected\";\n          if (null != t.pitchName && t.hasOwnProperty(\"pitchName\")) switch (t.pitchName) {\n            default:\n              return \"pitchName: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n            case 16:\n            case 17:\n            case 18:\n            case 19:\n            case 20:\n            case 21:\n            case 22:\n            case 23:\n            case 24:\n            case 25:\n            case 26:\n            case 27:\n            case 28:\n            case 29:\n            case 30:\n            case 31:\n            case 32:\n            case 33:\n            case 34:\n            case 35:\n          }\n          return null != t.velocity && t.hasOwnProperty(\"velocity\") && !u.isInteger(t.velocity) ? \"velocity: integer expected\" : null != t.startTime && t.hasOwnProperty(\"startTime\") && \"number\" != typeof t.startTime ? \"startTime: number expected\" : null != t.quantizedStartStep && t.hasOwnProperty(\"quantizedStartStep\") && !(u.isInteger(t.quantizedStartStep) || t.quantizedStartStep && u.isInteger(t.quantizedStartStep.low) && u.isInteger(t.quantizedStartStep.high)) ? \"quantizedStartStep: integer|Long expected\" : null != t.endTime && t.hasOwnProperty(\"endTime\") && \"number\" != typeof t.endTime ? \"endTime: number expected\" : null != t.quantizedEndStep && t.hasOwnProperty(\"quantizedEndStep\") && !(u.isInteger(t.quantizedEndStep) || t.quantizedEndStep && u.isInteger(t.quantizedEndStep.low) && u.isInteger(t.quantizedEndStep.high)) ? \"quantizedEndStep: integer|Long expected\" : null != t.numerator && t.hasOwnProperty(\"numerator\") && !u.isInteger(t.numerator) ? \"numerator: integer expected\" : null != t.denominator && t.hasOwnProperty(\"denominator\") && !u.isInteger(t.denominator) ? \"denominator: integer expected\" : null != t.instrument && t.hasOwnProperty(\"instrument\") && !u.isInteger(t.instrument) ? \"instrument: integer expected\" : null != t.program && t.hasOwnProperty(\"program\") && !u.isInteger(t.program) ? \"program: integer expected\" : null != t.isDrum && t.hasOwnProperty(\"isDrum\") && \"boolean\" != typeof t.isDrum ? \"isDrum: boolean expected\" : null != t.part && t.hasOwnProperty(\"part\") && !u.isInteger(t.part) ? \"part: integer expected\" : null != t.voice && t.hasOwnProperty(\"voice\") && !u.isInteger(t.voice) ? \"voice: integer expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.Note) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.Note();\n\n          switch (null != t.pitch && (e.pitch = 0 | t.pitch), t.pitchName) {\n            case \"UNKNOWN_PITCH_NAME\":\n            case 0:\n              e.pitchName = 0;\n              break;\n\n            case \"F_FLAT_FLAT\":\n            case 1:\n              e.pitchName = 1;\n              break;\n\n            case \"C_FLAT_FLAT\":\n            case 2:\n              e.pitchName = 2;\n              break;\n\n            case \"G_FLAT_FLAT\":\n            case 3:\n              e.pitchName = 3;\n              break;\n\n            case \"D_FLAT_FLAT\":\n            case 4:\n              e.pitchName = 4;\n              break;\n\n            case \"A_FLAT_FLAT\":\n            case 5:\n              e.pitchName = 5;\n              break;\n\n            case \"E_FLAT_FLAT\":\n            case 6:\n              e.pitchName = 6;\n              break;\n\n            case \"B_FLAT_FLAT\":\n            case 7:\n              e.pitchName = 7;\n              break;\n\n            case \"F_FLAT\":\n            case 8:\n              e.pitchName = 8;\n              break;\n\n            case \"C_FLAT\":\n            case 9:\n              e.pitchName = 9;\n              break;\n\n            case \"G_FLAT\":\n            case 10:\n              e.pitchName = 10;\n              break;\n\n            case \"D_FLAT\":\n            case 11:\n              e.pitchName = 11;\n              break;\n\n            case \"A_FLAT\":\n            case 12:\n              e.pitchName = 12;\n              break;\n\n            case \"E_FLAT\":\n            case 13:\n              e.pitchName = 13;\n              break;\n\n            case \"B_FLAT\":\n            case 14:\n              e.pitchName = 14;\n              break;\n\n            case \"F\":\n            case 15:\n              e.pitchName = 15;\n              break;\n\n            case \"C\":\n            case 16:\n              e.pitchName = 16;\n              break;\n\n            case \"G\":\n            case 17:\n              e.pitchName = 17;\n              break;\n\n            case \"D\":\n            case 18:\n              e.pitchName = 18;\n              break;\n\n            case \"A\":\n            case 19:\n              e.pitchName = 19;\n              break;\n\n            case \"E\":\n            case 20:\n              e.pitchName = 20;\n              break;\n\n            case \"B\":\n            case 21:\n              e.pitchName = 21;\n              break;\n\n            case \"F_SHARP\":\n            case 22:\n              e.pitchName = 22;\n              break;\n\n            case \"C_SHARP\":\n            case 23:\n              e.pitchName = 23;\n              break;\n\n            case \"G_SHARP\":\n            case 24:\n              e.pitchName = 24;\n              break;\n\n            case \"D_SHARP\":\n            case 25:\n              e.pitchName = 25;\n              break;\n\n            case \"A_SHARP\":\n            case 26:\n              e.pitchName = 26;\n              break;\n\n            case \"E_SHARP\":\n            case 27:\n              e.pitchName = 27;\n              break;\n\n            case \"B_SHARP\":\n            case 28:\n              e.pitchName = 28;\n              break;\n\n            case \"F_SHARP_SHARP\":\n            case 29:\n              e.pitchName = 29;\n              break;\n\n            case \"C_SHARP_SHARP\":\n            case 30:\n              e.pitchName = 30;\n              break;\n\n            case \"G_SHARP_SHARP\":\n            case 31:\n              e.pitchName = 31;\n              break;\n\n            case \"D_SHARP_SHARP\":\n            case 32:\n              e.pitchName = 32;\n              break;\n\n            case \"A_SHARP_SHARP\":\n            case 33:\n              e.pitchName = 33;\n              break;\n\n            case \"E_SHARP_SHARP\":\n            case 34:\n              e.pitchName = 34;\n              break;\n\n            case \"B_SHARP_SHARP\":\n            case 35:\n              e.pitchName = 35;\n          }\n\n          return null != t.velocity && (e.velocity = 0 | t.velocity), null != t.startTime && (e.startTime = Number(t.startTime)), null != t.quantizedStartStep && (u.Long ? (e.quantizedStartStep = u.Long.fromValue(t.quantizedStartStep)).unsigned = !1 : \"string\" == typeof t.quantizedStartStep ? e.quantizedStartStep = parseInt(t.quantizedStartStep, 10) : \"number\" == typeof t.quantizedStartStep ? e.quantizedStartStep = t.quantizedStartStep : \"object\" == typeof t.quantizedStartStep && (e.quantizedStartStep = new u.LongBits(t.quantizedStartStep.low >>> 0, t.quantizedStartStep.high >>> 0).toNumber())), null != t.endTime && (e.endTime = Number(t.endTime)), null != t.quantizedEndStep && (u.Long ? (e.quantizedEndStep = u.Long.fromValue(t.quantizedEndStep)).unsigned = !1 : \"string\" == typeof t.quantizedEndStep ? e.quantizedEndStep = parseInt(t.quantizedEndStep, 10) : \"number\" == typeof t.quantizedEndStep ? e.quantizedEndStep = t.quantizedEndStep : \"object\" == typeof t.quantizedEndStep && (e.quantizedEndStep = new u.LongBits(t.quantizedEndStep.low >>> 0, t.quantizedEndStep.high >>> 0).toNumber())), null != t.numerator && (e.numerator = 0 | t.numerator), null != t.denominator && (e.denominator = 0 | t.denominator), null != t.instrument && (e.instrument = 0 | t.instrument), null != t.program && (e.program = 0 | t.program), null != t.isDrum && (e.isDrum = Boolean(t.isDrum)), null != t.part && (e.part = 0 | t.part), null != t.voice && (e.voice = 0 | t.voice), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n\n          if (e.defaults) {\n            if (n.pitch = 0, n.velocity = 0, n.startTime = 0, n.endTime = 0, n.numerator = 0, n.denominator = 0, n.instrument = 0, n.program = 0, n.isDrum = !1, n.part = 0, n.pitchName = e.enums === String ? \"UNKNOWN_PITCH_NAME\" : 0, n.voice = 0, u.Long) {\n              var r = new u.Long(0, 0, !1);\n              n.quantizedStartStep = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n            } else n.quantizedStartStep = e.longs === String ? \"0\" : 0;\n\n            u.Long ? (r = new u.Long(0, 0, !1), n.quantizedEndStep = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r) : n.quantizedEndStep = e.longs === String ? \"0\" : 0;\n          }\n\n          return null != t.pitch && t.hasOwnProperty(\"pitch\") && (n.pitch = t.pitch), null != t.velocity && t.hasOwnProperty(\"velocity\") && (n.velocity = t.velocity), null != t.startTime && t.hasOwnProperty(\"startTime\") && (n.startTime = e.json && !isFinite(t.startTime) ? String(t.startTime) : t.startTime), null != t.endTime && t.hasOwnProperty(\"endTime\") && (n.endTime = e.json && !isFinite(t.endTime) ? String(t.endTime) : t.endTime), null != t.numerator && t.hasOwnProperty(\"numerator\") && (n.numerator = t.numerator), null != t.denominator && t.hasOwnProperty(\"denominator\") && (n.denominator = t.denominator), null != t.instrument && t.hasOwnProperty(\"instrument\") && (n.instrument = t.instrument), null != t.program && t.hasOwnProperty(\"program\") && (n.program = t.program), null != t.isDrum && t.hasOwnProperty(\"isDrum\") && (n.isDrum = t.isDrum), null != t.part && t.hasOwnProperty(\"part\") && (n.part = t.part), null != t.pitchName && t.hasOwnProperty(\"pitchName\") && (n.pitchName = e.enums === String ? c.tensorflow.magenta.NoteSequence.PitchName[t.pitchName] : t.pitchName), null != t.voice && t.hasOwnProperty(\"voice\") && (n.voice = t.voice), null != t.quantizedStartStep && t.hasOwnProperty(\"quantizedStartStep\") && (\"number\" == typeof t.quantizedStartStep ? n.quantizedStartStep = e.longs === String ? String(t.quantizedStartStep) : t.quantizedStartStep : n.quantizedStartStep = e.longs === String ? u.Long.prototype.toString.call(t.quantizedStartStep) : e.longs === Number ? new u.LongBits(t.quantizedStartStep.low >>> 0, t.quantizedStartStep.high >>> 0).toNumber() : t.quantizedStartStep), null != t.quantizedEndStep && t.hasOwnProperty(\"quantizedEndStep\") && (\"number\" == typeof t.quantizedEndStep ? n.quantizedEndStep = e.longs === String ? String(t.quantizedEndStep) : t.quantizedEndStep : n.quantizedEndStep = e.longs === String ? u.Long.prototype.toString.call(t.quantizedEndStep) : e.longs === Number ? new u.LongBits(t.quantizedEndStep.low >>> 0, t.quantizedEndStep.high >>> 0).toNumber() : t.quantizedEndStep), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.PitchName = (e = {}, (n = Object.create(e))[e[0] = \"UNKNOWN_PITCH_NAME\"] = 0, n[e[1] = \"F_FLAT_FLAT\"] = 1, n[e[2] = \"C_FLAT_FLAT\"] = 2, n[e[3] = \"G_FLAT_FLAT\"] = 3, n[e[4] = \"D_FLAT_FLAT\"] = 4, n[e[5] = \"A_FLAT_FLAT\"] = 5, n[e[6] = \"E_FLAT_FLAT\"] = 6, n[e[7] = \"B_FLAT_FLAT\"] = 7, n[e[8] = \"F_FLAT\"] = 8, n[e[9] = \"C_FLAT\"] = 9, n[e[10] = \"G_FLAT\"] = 10, n[e[11] = \"D_FLAT\"] = 11, n[e[12] = \"A_FLAT\"] = 12, n[e[13] = \"E_FLAT\"] = 13, n[e[14] = \"B_FLAT\"] = 14, n[e[15] = \"F\"] = 15, n[e[16] = \"C\"] = 16, n[e[17] = \"G\"] = 17, n[e[18] = \"D\"] = 18, n[e[19] = \"A\"] = 19, n[e[20] = \"E\"] = 20, n[e[21] = \"B\"] = 21, n[e[22] = \"F_SHARP\"] = 22, n[e[23] = \"C_SHARP\"] = 23, n[e[24] = \"G_SHARP\"] = 24, n[e[25] = \"D_SHARP\"] = 25, n[e[26] = \"A_SHARP\"] = 26, n[e[27] = \"E_SHARP\"] = 27, n[e[28] = \"B_SHARP\"] = 28, n[e[29] = \"F_SHARP_SHARP\"] = 29, n[e[30] = \"C_SHARP_SHARP\"] = 30, n[e[31] = \"G_SHARP_SHARP\"] = 31, n[e[32] = \"D_SHARP_SHARP\"] = 32, n[e[33] = \"A_SHARP_SHARP\"] = 33, n[e[34] = \"E_SHARP_SHARP\"] = 34, n[e[35] = \"B_SHARP_SHARP\"] = 35, n), t.TimeSignature = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.time = 0, t.prototype.numerator = 0, t.prototype.denominator = 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.time && t.hasOwnProperty(\"time\") && e.uint32(9).double(t.time), null != t.numerator && t.hasOwnProperty(\"numerator\") && e.uint32(16).int32(t.numerator), null != t.denominator && t.hasOwnProperty(\"denominator\") && e.uint32(24).int32(t.denominator), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.TimeSignature(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = t.double();\n                break;\n\n              case 2:\n                r.numerator = t.int32();\n                break;\n\n              case 3:\n                r.denominator = t.int32();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          return \"object\" != typeof t || null === t ? \"object expected\" : null != t.time && t.hasOwnProperty(\"time\") && \"number\" != typeof t.time ? \"time: number expected\" : null != t.numerator && t.hasOwnProperty(\"numerator\") && !u.isInteger(t.numerator) ? \"numerator: integer expected\" : null != t.denominator && t.hasOwnProperty(\"denominator\") && !u.isInteger(t.denominator) ? \"denominator: integer expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.TimeSignature) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.TimeSignature();\n          return null != t.time && (e.time = Number(t.time)), null != t.numerator && (e.numerator = 0 | t.numerator), null != t.denominator && (e.denominator = 0 | t.denominator), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return e.defaults && (n.time = 0, n.numerator = 0, n.denominator = 0), null != t.time && t.hasOwnProperty(\"time\") && (n.time = e.json && !isFinite(t.time) ? String(t.time) : t.time), null != t.numerator && t.hasOwnProperty(\"numerator\") && (n.numerator = t.numerator), null != t.denominator && t.hasOwnProperty(\"denominator\") && (n.denominator = t.denominator), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.KeySignature = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.time = 0, t.prototype.key = 0, t.prototype.mode = 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.time && t.hasOwnProperty(\"time\") && e.uint32(9).double(t.time), null != t.key && t.hasOwnProperty(\"key\") && e.uint32(16).int32(t.key), null != t.mode && t.hasOwnProperty(\"mode\") && e.uint32(24).int32(t.mode), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.KeySignature(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = t.double();\n                break;\n\n              case 2:\n                r.key = t.int32();\n                break;\n\n              case 3:\n                r.mode = t.int32();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          if (\"object\" != typeof t || null === t) return \"object expected\";\n          if (null != t.time && t.hasOwnProperty(\"time\") && \"number\" != typeof t.time) return \"time: number expected\";\n          if (null != t.key && t.hasOwnProperty(\"key\")) switch (t.key) {\n            default:\n              return \"key: enum value expected\";\n\n            case 0:\n            case 1:\n            case 1:\n            case 2:\n            case 3:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 6:\n            case 7:\n            case 8:\n            case 8:\n            case 9:\n            case 10:\n            case 10:\n            case 11:\n          }\n          if (null != t.mode && t.hasOwnProperty(\"mode\")) switch (t.mode) {\n            default:\n              return \"mode: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n          }\n          return null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.KeySignature) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.KeySignature();\n\n          switch (null != t.time && (e.time = Number(t.time)), t.key) {\n            case \"C\":\n            case 0:\n              e.key = 0;\n              break;\n\n            case \"C_SHARP\":\n            case 1:\n              e.key = 1;\n              break;\n\n            case \"D_FLAT\":\n            case 1:\n              e.key = 1;\n              break;\n\n            case \"D\":\n            case 2:\n              e.key = 2;\n              break;\n\n            case \"D_SHARP\":\n            case 3:\n              e.key = 3;\n              break;\n\n            case \"E_FLAT\":\n            case 3:\n              e.key = 3;\n              break;\n\n            case \"E\":\n            case 4:\n              e.key = 4;\n              break;\n\n            case \"F\":\n            case 5:\n              e.key = 5;\n              break;\n\n            case \"F_SHARP\":\n            case 6:\n              e.key = 6;\n              break;\n\n            case \"G_FLAT\":\n            case 6:\n              e.key = 6;\n              break;\n\n            case \"G\":\n            case 7:\n              e.key = 7;\n              break;\n\n            case \"G_SHARP\":\n            case 8:\n              e.key = 8;\n              break;\n\n            case \"A_FLAT\":\n            case 8:\n              e.key = 8;\n              break;\n\n            case \"A\":\n            case 9:\n              e.key = 9;\n              break;\n\n            case \"A_SHARP\":\n            case 10:\n              e.key = 10;\n              break;\n\n            case \"B_FLAT\":\n            case 10:\n              e.key = 10;\n              break;\n\n            case \"B\":\n            case 11:\n              e.key = 11;\n          }\n\n          switch (t.mode) {\n            case \"MAJOR\":\n            case 0:\n              e.mode = 0;\n              break;\n\n            case \"MINOR\":\n            case 1:\n              e.mode = 1;\n              break;\n\n            case \"NOT_SPECIFIED\":\n            case 2:\n              e.mode = 2;\n              break;\n\n            case \"MIXOLYDIAN\":\n            case 3:\n              e.mode = 3;\n              break;\n\n            case \"DORIAN\":\n            case 4:\n              e.mode = 4;\n              break;\n\n            case \"PHRYGIAN\":\n            case 5:\n              e.mode = 5;\n              break;\n\n            case \"LYDIAN\":\n            case 6:\n              e.mode = 6;\n              break;\n\n            case \"LOCRIAN\":\n            case 7:\n              e.mode = 7;\n          }\n\n          return e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return e.defaults && (n.time = 0, n.key = e.enums === String ? \"C\" : 0, n.mode = e.enums === String ? \"MAJOR\" : 0), null != t.time && t.hasOwnProperty(\"time\") && (n.time = e.json && !isFinite(t.time) ? String(t.time) : t.time), null != t.key && t.hasOwnProperty(\"key\") && (n.key = e.enums === String ? c.tensorflow.magenta.NoteSequence.KeySignature.Key[t.key] : t.key), null != t.mode && t.hasOwnProperty(\"mode\") && (n.mode = e.enums === String ? c.tensorflow.magenta.NoteSequence.KeySignature.Mode[t.mode] : t.mode), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t.Key = function () {\n          var t = {},\n              e = Object.create(t);\n          return e[t[0] = \"C\"] = 0, e[t[1] = \"C_SHARP\"] = 1, e.D_FLAT = 1, e[t[2] = \"D\"] = 2, e[t[3] = \"D_SHARP\"] = 3, e.E_FLAT = 3, e[t[4] = \"E\"] = 4, e[t[5] = \"F\"] = 5, e[t[6] = \"F_SHARP\"] = 6, e.G_FLAT = 6, e[t[7] = \"G\"] = 7, e[t[8] = \"G_SHARP\"] = 8, e.A_FLAT = 8, e[t[9] = \"A\"] = 9, e[t[10] = \"A_SHARP\"] = 10, e.B_FLAT = 10, e[t[11] = \"B\"] = 11, e;\n        }(), t.Mode = function () {\n          var t = {},\n              e = Object.create(t);\n          return e[t[0] = \"MAJOR\"] = 0, e[t[1] = \"MINOR\"] = 1, e[t[2] = \"NOT_SPECIFIED\"] = 2, e[t[3] = \"MIXOLYDIAN\"] = 3, e[t[4] = \"DORIAN\"] = 4, e[t[5] = \"PHRYGIAN\"] = 5, e[t[6] = \"LYDIAN\"] = 6, e[t[7] = \"LOCRIAN\"] = 7, e;\n        }(), t;\n      }(), t.Tempo = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.time = 0, t.prototype.qpm = 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.time && t.hasOwnProperty(\"time\") && e.uint32(9).double(t.time), null != t.qpm && t.hasOwnProperty(\"qpm\") && e.uint32(17).double(t.qpm), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.Tempo(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = t.double();\n                break;\n\n              case 2:\n                r.qpm = t.double();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          return \"object\" != typeof t || null === t ? \"object expected\" : null != t.time && t.hasOwnProperty(\"time\") && \"number\" != typeof t.time ? \"time: number expected\" : null != t.qpm && t.hasOwnProperty(\"qpm\") && \"number\" != typeof t.qpm ? \"qpm: number expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.Tempo) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.Tempo();\n          return null != t.time && (e.time = Number(t.time)), null != t.qpm && (e.qpm = Number(t.qpm)), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return e.defaults && (n.time = 0, n.qpm = 0), null != t.time && t.hasOwnProperty(\"time\") && (n.time = e.json && !isFinite(t.time) ? String(t.time) : t.time), null != t.qpm && t.hasOwnProperty(\"qpm\") && (n.qpm = e.json && !isFinite(t.qpm) ? String(t.qpm) : t.qpm), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.PitchBend = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.time = 0, t.prototype.bend = 0, t.prototype.instrument = 0, t.prototype.program = 0, t.prototype.isDrum = !1, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.time && t.hasOwnProperty(\"time\") && e.uint32(9).double(t.time), null != t.bend && t.hasOwnProperty(\"bend\") && e.uint32(16).int32(t.bend), null != t.instrument && t.hasOwnProperty(\"instrument\") && e.uint32(24).int32(t.instrument), null != t.program && t.hasOwnProperty(\"program\") && e.uint32(32).int32(t.program), null != t.isDrum && t.hasOwnProperty(\"isDrum\") && e.uint32(40).bool(t.isDrum), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.PitchBend(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = t.double();\n                break;\n\n              case 2:\n                r.bend = t.int32();\n                break;\n\n              case 3:\n                r.instrument = t.int32();\n                break;\n\n              case 4:\n                r.program = t.int32();\n                break;\n\n              case 5:\n                r.isDrum = t.bool();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          return \"object\" != typeof t || null === t ? \"object expected\" : null != t.time && t.hasOwnProperty(\"time\") && \"number\" != typeof t.time ? \"time: number expected\" : null != t.bend && t.hasOwnProperty(\"bend\") && !u.isInteger(t.bend) ? \"bend: integer expected\" : null != t.instrument && t.hasOwnProperty(\"instrument\") && !u.isInteger(t.instrument) ? \"instrument: integer expected\" : null != t.program && t.hasOwnProperty(\"program\") && !u.isInteger(t.program) ? \"program: integer expected\" : null != t.isDrum && t.hasOwnProperty(\"isDrum\") && \"boolean\" != typeof t.isDrum ? \"isDrum: boolean expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.PitchBend) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.PitchBend();\n          return null != t.time && (e.time = Number(t.time)), null != t.bend && (e.bend = 0 | t.bend), null != t.instrument && (e.instrument = 0 | t.instrument), null != t.program && (e.program = 0 | t.program), null != t.isDrum && (e.isDrum = Boolean(t.isDrum)), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return e.defaults && (n.time = 0, n.bend = 0, n.instrument = 0, n.program = 0, n.isDrum = !1), null != t.time && t.hasOwnProperty(\"time\") && (n.time = e.json && !isFinite(t.time) ? String(t.time) : t.time), null != t.bend && t.hasOwnProperty(\"bend\") && (n.bend = t.bend), null != t.instrument && t.hasOwnProperty(\"instrument\") && (n.instrument = t.instrument), null != t.program && t.hasOwnProperty(\"program\") && (n.program = t.program), null != t.isDrum && t.hasOwnProperty(\"isDrum\") && (n.isDrum = t.isDrum), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.ControlChange = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.time = 0, t.prototype.quantizedStep = u.Long ? u.Long.fromBits(0, 0, !1) : 0, t.prototype.controlNumber = 0, t.prototype.controlValue = 0, t.prototype.instrument = 0, t.prototype.program = 0, t.prototype.isDrum = !1, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.time && t.hasOwnProperty(\"time\") && e.uint32(9).double(t.time), null != t.controlNumber && t.hasOwnProperty(\"controlNumber\") && e.uint32(16).int32(t.controlNumber), null != t.controlValue && t.hasOwnProperty(\"controlValue\") && e.uint32(24).int32(t.controlValue), null != t.instrument && t.hasOwnProperty(\"instrument\") && e.uint32(32).int32(t.instrument), null != t.program && t.hasOwnProperty(\"program\") && e.uint32(40).int32(t.program), null != t.isDrum && t.hasOwnProperty(\"isDrum\") && e.uint32(48).bool(t.isDrum), null != t.quantizedStep && t.hasOwnProperty(\"quantizedStep\") && e.uint32(56).int64(t.quantizedStep), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.ControlChange(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = t.double();\n                break;\n\n              case 7:\n                r.quantizedStep = u.Long ? t.int64().toNumber() : t.int64();\n                break;\n\n              case 2:\n                r.controlNumber = t.int32();\n                break;\n\n              case 3:\n                r.controlValue = t.int32();\n                break;\n\n              case 4:\n                r.instrument = t.int32();\n                break;\n\n              case 5:\n                r.program = t.int32();\n                break;\n\n              case 6:\n                r.isDrum = t.bool();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          return \"object\" != typeof t || null === t ? \"object expected\" : null != t.time && t.hasOwnProperty(\"time\") && \"number\" != typeof t.time ? \"time: number expected\" : null != t.quantizedStep && t.hasOwnProperty(\"quantizedStep\") && !(u.isInteger(t.quantizedStep) || t.quantizedStep && u.isInteger(t.quantizedStep.low) && u.isInteger(t.quantizedStep.high)) ? \"quantizedStep: integer|Long expected\" : null != t.controlNumber && t.hasOwnProperty(\"controlNumber\") && !u.isInteger(t.controlNumber) ? \"controlNumber: integer expected\" : null != t.controlValue && t.hasOwnProperty(\"controlValue\") && !u.isInteger(t.controlValue) ? \"controlValue: integer expected\" : null != t.instrument && t.hasOwnProperty(\"instrument\") && !u.isInteger(t.instrument) ? \"instrument: integer expected\" : null != t.program && t.hasOwnProperty(\"program\") && !u.isInteger(t.program) ? \"program: integer expected\" : null != t.isDrum && t.hasOwnProperty(\"isDrum\") && \"boolean\" != typeof t.isDrum ? \"isDrum: boolean expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.ControlChange) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.ControlChange();\n          return null != t.time && (e.time = Number(t.time)), null != t.quantizedStep && (u.Long ? (e.quantizedStep = u.Long.fromValue(t.quantizedStep)).unsigned = !1 : \"string\" == typeof t.quantizedStep ? e.quantizedStep = parseInt(t.quantizedStep, 10) : \"number\" == typeof t.quantizedStep ? e.quantizedStep = t.quantizedStep : \"object\" == typeof t.quantizedStep && (e.quantizedStep = new u.LongBits(t.quantizedStep.low >>> 0, t.quantizedStep.high >>> 0).toNumber())), null != t.controlNumber && (e.controlNumber = 0 | t.controlNumber), null != t.controlValue && (e.controlValue = 0 | t.controlValue), null != t.instrument && (e.instrument = 0 | t.instrument), null != t.program && (e.program = 0 | t.program), null != t.isDrum && (e.isDrum = Boolean(t.isDrum)), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          if (e.defaults) if (n.time = 0, n.controlNumber = 0, n.controlValue = 0, n.instrument = 0, n.program = 0, n.isDrum = !1, u.Long) {\n            var r = new u.Long(0, 0, !1);\n            n.quantizedStep = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n          } else n.quantizedStep = e.longs === String ? \"0\" : 0;\n          return null != t.time && t.hasOwnProperty(\"time\") && (n.time = e.json && !isFinite(t.time) ? String(t.time) : t.time), null != t.controlNumber && t.hasOwnProperty(\"controlNumber\") && (n.controlNumber = t.controlNumber), null != t.controlValue && t.hasOwnProperty(\"controlValue\") && (n.controlValue = t.controlValue), null != t.instrument && t.hasOwnProperty(\"instrument\") && (n.instrument = t.instrument), null != t.program && t.hasOwnProperty(\"program\") && (n.program = t.program), null != t.isDrum && t.hasOwnProperty(\"isDrum\") && (n.isDrum = t.isDrum), null != t.quantizedStep && t.hasOwnProperty(\"quantizedStep\") && (\"number\" == typeof t.quantizedStep ? n.quantizedStep = e.longs === String ? String(t.quantizedStep) : t.quantizedStep : n.quantizedStep = e.longs === String ? u.Long.prototype.toString.call(t.quantizedStep) : e.longs === Number ? new u.LongBits(t.quantizedStep.low >>> 0, t.quantizedStep.high >>> 0).toNumber() : t.quantizedStep), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.PartInfo = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.part = 0, t.prototype.name = \"\", t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.part && t.hasOwnProperty(\"part\") && e.uint32(8).int32(t.part), null != t.name && t.hasOwnProperty(\"name\") && e.uint32(18).string(t.name), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.PartInfo(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.part = t.int32();\n                break;\n\n              case 2:\n                r.name = t.string();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          return \"object\" != typeof t || null === t ? \"object expected\" : null != t.part && t.hasOwnProperty(\"part\") && !u.isInteger(t.part) ? \"part: integer expected\" : null != t.name && t.hasOwnProperty(\"name\") && !u.isString(t.name) ? \"name: string expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.PartInfo) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.PartInfo();\n          return null != t.part && (e.part = 0 | t.part), null != t.name && (e.name = String(t.name)), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return e.defaults && (n.part = 0, n.name = \"\"), null != t.part && t.hasOwnProperty(\"part\") && (n.part = t.part), null != t.name && t.hasOwnProperty(\"name\") && (n.name = t.name), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.SourceInfo = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.sourceType = 0, t.prototype.encodingType = 0, t.prototype.parser = 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.sourceType && t.hasOwnProperty(\"sourceType\") && e.uint32(8).int32(t.sourceType), null != t.encodingType && t.hasOwnProperty(\"encodingType\") && e.uint32(16).int32(t.encodingType), null != t.parser && t.hasOwnProperty(\"parser\") && e.uint32(24).int32(t.parser), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.SourceInfo(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.sourceType = t.int32();\n                break;\n\n              case 2:\n                r.encodingType = t.int32();\n                break;\n\n              case 3:\n                r.parser = t.int32();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          if (\"object\" != typeof t || null === t) return \"object expected\";\n          if (null != t.sourceType && t.hasOwnProperty(\"sourceType\")) switch (t.sourceType) {\n            default:\n              return \"sourceType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n          }\n          if (null != t.encodingType && t.hasOwnProperty(\"encodingType\")) switch (t.encodingType) {\n            default:\n              return \"encodingType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n          }\n          if (null != t.parser && t.hasOwnProperty(\"parser\")) switch (t.parser) {\n            default:\n              return \"parser: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n            case 4:\n            case 5:\n            case 6:\n          }\n          return null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.SourceInfo) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.SourceInfo();\n\n          switch (t.sourceType) {\n            case \"UNKNOWN_SOURCE_TYPE\":\n            case 0:\n              e.sourceType = 0;\n              break;\n\n            case \"SCORE_BASED\":\n            case 1:\n              e.sourceType = 1;\n              break;\n\n            case \"PERFORMANCE_BASED\":\n            case 2:\n              e.sourceType = 2;\n          }\n\n          switch (t.encodingType) {\n            case \"UNKNOWN_ENCODING_TYPE\":\n            case 0:\n              e.encodingType = 0;\n              break;\n\n            case \"MUSIC_XML\":\n            case 1:\n              e.encodingType = 1;\n              break;\n\n            case \"ABC\":\n            case 2:\n              e.encodingType = 2;\n              break;\n\n            case \"MIDI\":\n            case 3:\n              e.encodingType = 3;\n              break;\n\n            case \"MUSICNET\":\n            case 4:\n              e.encodingType = 4;\n          }\n\n          switch (t.parser) {\n            case \"UNKNOWN_PARSER\":\n            case 0:\n              e.parser = 0;\n              break;\n\n            case \"MUSIC21\":\n            case 1:\n              e.parser = 1;\n              break;\n\n            case \"PRETTY_MIDI\":\n            case 2:\n              e.parser = 2;\n              break;\n\n            case \"MAGENTA_MUSIC_XML\":\n            case 3:\n              e.parser = 3;\n              break;\n\n            case \"MAGENTA_MUSICNET\":\n            case 4:\n              e.parser = 4;\n              break;\n\n            case \"MAGENTA_ABC\":\n            case 5:\n              e.parser = 5;\n              break;\n\n            case \"TONEJS_MIDI_CONVERT\":\n            case 6:\n              e.parser = 6;\n          }\n\n          return e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return e.defaults && (n.sourceType = e.enums === String ? \"UNKNOWN_SOURCE_TYPE\" : 0, n.encodingType = e.enums === String ? \"UNKNOWN_ENCODING_TYPE\" : 0, n.parser = e.enums === String ? \"UNKNOWN_PARSER\" : 0), null != t.sourceType && t.hasOwnProperty(\"sourceType\") && (n.sourceType = e.enums === String ? c.tensorflow.magenta.NoteSequence.SourceInfo.SourceType[t.sourceType] : t.sourceType), null != t.encodingType && t.hasOwnProperty(\"encodingType\") && (n.encodingType = e.enums === String ? c.tensorflow.magenta.NoteSequence.SourceInfo.EncodingType[t.encodingType] : t.encodingType), null != t.parser && t.hasOwnProperty(\"parser\") && (n.parser = e.enums === String ? c.tensorflow.magenta.NoteSequence.SourceInfo.Parser[t.parser] : t.parser), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t.SourceType = function () {\n          var t = {},\n              e = Object.create(t);\n          return e[t[0] = \"UNKNOWN_SOURCE_TYPE\"] = 0, e[t[1] = \"SCORE_BASED\"] = 1, e[t[2] = \"PERFORMANCE_BASED\"] = 2, e;\n        }(), t.EncodingType = function () {\n          var t = {},\n              e = Object.create(t);\n          return e[t[0] = \"UNKNOWN_ENCODING_TYPE\"] = 0, e[t[1] = \"MUSIC_XML\"] = 1, e[t[2] = \"ABC\"] = 2, e[t[3] = \"MIDI\"] = 3, e[t[4] = \"MUSICNET\"] = 4, e;\n        }(), t.Parser = function () {\n          var t = {},\n              e = Object.create(t);\n          return e[t[0] = \"UNKNOWN_PARSER\"] = 0, e[t[1] = \"MUSIC21\"] = 1, e[t[2] = \"PRETTY_MIDI\"] = 2, e[t[3] = \"MAGENTA_MUSIC_XML\"] = 3, e[t[4] = \"MAGENTA_MUSICNET\"] = 4, e[t[5] = \"MAGENTA_ABC\"] = 5, e[t[6] = \"TONEJS_MIDI_CONVERT\"] = 6, e;\n        }(), t;\n      }(), t.TextAnnotation = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.time = 0, t.prototype.quantizedStep = u.Long ? u.Long.fromBits(0, 0, !1) : 0, t.prototype.text = \"\", t.prototype.annotationType = 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.time && t.hasOwnProperty(\"time\") && e.uint32(9).double(t.time), null != t.text && t.hasOwnProperty(\"text\") && e.uint32(18).string(t.text), null != t.annotationType && t.hasOwnProperty(\"annotationType\") && e.uint32(24).int32(t.annotationType), null != t.quantizedStep && t.hasOwnProperty(\"quantizedStep\") && e.uint32(32).int64(t.quantizedStep), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.TextAnnotation(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = t.double();\n                break;\n\n              case 4:\n                r.quantizedStep = u.Long ? t.int64().toNumber() : t.int64();\n                break;\n\n              case 2:\n                r.text = t.string();\n                break;\n\n              case 3:\n                r.annotationType = t.int32();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          if (\"object\" != typeof t || null === t) return \"object expected\";\n          if (null != t.time && t.hasOwnProperty(\"time\") && \"number\" != typeof t.time) return \"time: number expected\";\n          if (null != t.quantizedStep && t.hasOwnProperty(\"quantizedStep\") && !(u.isInteger(t.quantizedStep) || t.quantizedStep && u.isInteger(t.quantizedStep.low) && u.isInteger(t.quantizedStep.high))) return \"quantizedStep: integer|Long expected\";\n          if (null != t.text && t.hasOwnProperty(\"text\") && !u.isString(t.text)) return \"text: string expected\";\n          if (null != t.annotationType && t.hasOwnProperty(\"annotationType\")) switch (t.annotationType) {\n            default:\n              return \"annotationType: enum value expected\";\n\n            case 0:\n            case 1:\n            case 2:\n          }\n          return null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.TextAnnotation) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.TextAnnotation();\n\n          switch (null != t.time && (e.time = Number(t.time)), null != t.quantizedStep && (u.Long ? (e.quantizedStep = u.Long.fromValue(t.quantizedStep)).unsigned = !1 : \"string\" == typeof t.quantizedStep ? e.quantizedStep = parseInt(t.quantizedStep, 10) : \"number\" == typeof t.quantizedStep ? e.quantizedStep = t.quantizedStep : \"object\" == typeof t.quantizedStep && (e.quantizedStep = new u.LongBits(t.quantizedStep.low >>> 0, t.quantizedStep.high >>> 0).toNumber())), null != t.text && (e.text = String(t.text)), t.annotationType) {\n            case \"UNKNOWN\":\n            case 0:\n              e.annotationType = 0;\n              break;\n\n            case \"CHORD_SYMBOL\":\n            case 1:\n              e.annotationType = 1;\n              break;\n\n            case \"BEAT\":\n            case 2:\n              e.annotationType = 2;\n          }\n\n          return e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          if (e.defaults) if (n.time = 0, n.text = \"\", n.annotationType = e.enums === String ? \"UNKNOWN\" : 0, u.Long) {\n            var r = new u.Long(0, 0, !1);\n            n.quantizedStep = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n          } else n.quantizedStep = e.longs === String ? \"0\" : 0;\n          return null != t.time && t.hasOwnProperty(\"time\") && (n.time = e.json && !isFinite(t.time) ? String(t.time) : t.time), null != t.text && t.hasOwnProperty(\"text\") && (n.text = t.text), null != t.annotationType && t.hasOwnProperty(\"annotationType\") && (n.annotationType = e.enums === String ? c.tensorflow.magenta.NoteSequence.TextAnnotation.TextAnnotationType[t.annotationType] : t.annotationType), null != t.quantizedStep && t.hasOwnProperty(\"quantizedStep\") && (\"number\" == typeof t.quantizedStep ? n.quantizedStep = e.longs === String ? String(t.quantizedStep) : t.quantizedStep : n.quantizedStep = e.longs === String ? u.Long.prototype.toString.call(t.quantizedStep) : e.longs === Number ? new u.LongBits(t.quantizedStep.low >>> 0, t.quantizedStep.high >>> 0).toNumber() : t.quantizedStep), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t.TextAnnotationType = function () {\n          var t = {},\n              e = Object.create(t);\n          return e[t[0] = \"UNKNOWN\"] = 0, e[t[1] = \"CHORD_SYMBOL\"] = 1, e[t[2] = \"BEAT\"] = 2, e;\n        }(), t;\n      }(), t.QuantizationInfo = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        var e;\n        return t.prototype.stepsPerQuarter = 0, t.prototype.stepsPerSecond = 0, Object.defineProperty(t.prototype, \"resolution\", {\n          get: u.oneOfGetter(e = [\"stepsPerQuarter\", \"stepsPerSecond\"]),\n          set: u.oneOfSetter(e)\n        }), t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.stepsPerQuarter && t.hasOwnProperty(\"stepsPerQuarter\") && e.uint32(8).int32(t.stepsPerQuarter), null != t.stepsPerSecond && t.hasOwnProperty(\"stepsPerSecond\") && e.uint32(16).int32(t.stepsPerSecond), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.QuantizationInfo(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.stepsPerQuarter = t.int32();\n                break;\n\n              case 2:\n                r.stepsPerSecond = t.int32();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          if (\"object\" != typeof t || null === t) return \"object expected\";\n          var e = {};\n          if (null != t.stepsPerQuarter && t.hasOwnProperty(\"stepsPerQuarter\") && (e.resolution = 1, !u.isInteger(t.stepsPerQuarter))) return \"stepsPerQuarter: integer expected\";\n\n          if (null != t.stepsPerSecond && t.hasOwnProperty(\"stepsPerSecond\")) {\n            if (1 === e.resolution) return \"resolution: multiple values\";\n            if (e.resolution = 1, !u.isInteger(t.stepsPerSecond)) return \"stepsPerSecond: integer expected\";\n          }\n\n          return null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.QuantizationInfo) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.QuantizationInfo();\n          return null != t.stepsPerQuarter && (e.stepsPerQuarter = 0 | t.stepsPerQuarter), null != t.stepsPerSecond && (e.stepsPerSecond = 0 | t.stepsPerSecond), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return null != t.stepsPerQuarter && t.hasOwnProperty(\"stepsPerQuarter\") && (n.stepsPerQuarter = t.stepsPerQuarter, e.oneofs && (n.resolution = \"stepsPerQuarter\")), null != t.stepsPerSecond && t.hasOwnProperty(\"stepsPerSecond\") && (n.stepsPerSecond = t.stepsPerSecond, e.oneofs && (n.resolution = \"stepsPerSecond\")), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.SubsequenceInfo = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.startTimeOffset = 0, t.prototype.endTimeOffset = 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.startTimeOffset && t.hasOwnProperty(\"startTimeOffset\") && e.uint32(9).double(t.startTimeOffset), null != t.endTimeOffset && t.hasOwnProperty(\"endTimeOffset\") && e.uint32(17).double(t.endTimeOffset), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.SubsequenceInfo(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.startTimeOffset = t.double();\n                break;\n\n              case 2:\n                r.endTimeOffset = t.double();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          return \"object\" != typeof t || null === t ? \"object expected\" : null != t.startTimeOffset && t.hasOwnProperty(\"startTimeOffset\") && \"number\" != typeof t.startTimeOffset ? \"startTimeOffset: number expected\" : null != t.endTimeOffset && t.hasOwnProperty(\"endTimeOffset\") && \"number\" != typeof t.endTimeOffset ? \"endTimeOffset: number expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.SubsequenceInfo) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.SubsequenceInfo();\n          return null != t.startTimeOffset && (e.startTimeOffset = Number(t.startTimeOffset)), null != t.endTimeOffset && (e.endTimeOffset = Number(t.endTimeOffset)), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return e.defaults && (n.startTimeOffset = 0, n.endTimeOffset = 0), null != t.startTimeOffset && t.hasOwnProperty(\"startTimeOffset\") && (n.startTimeOffset = e.json && !isFinite(t.startTimeOffset) ? String(t.startTimeOffset) : t.startTimeOffset), null != t.endTimeOffset && t.hasOwnProperty(\"endTimeOffset\") && (n.endTimeOffset = e.json && !isFinite(t.endTimeOffset) ? String(t.endTimeOffset) : t.endTimeOffset), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.SectionAnnotation = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.time = 0, t.prototype.sectionId = u.Long ? u.Long.fromBits(0, 0, !1) : 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.time && t.hasOwnProperty(\"time\") && e.uint32(9).double(t.time), null != t.sectionId && t.hasOwnProperty(\"sectionId\") && e.uint32(32).int64(t.sectionId), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.SectionAnnotation(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.time = t.double();\n                break;\n\n              case 4:\n                r.sectionId = u.Long ? t.int64().toNumber() : t.int64();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          return \"object\" != typeof t || null === t ? \"object expected\" : null != t.time && t.hasOwnProperty(\"time\") && \"number\" != typeof t.time ? \"time: number expected\" : null != t.sectionId && t.hasOwnProperty(\"sectionId\") && !(u.isInteger(t.sectionId) || t.sectionId && u.isInteger(t.sectionId.low) && u.isInteger(t.sectionId.high)) ? \"sectionId: integer|Long expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.SectionAnnotation) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.SectionAnnotation();\n          return null != t.time && (e.time = Number(t.time)), null != t.sectionId && (u.Long ? (e.sectionId = u.Long.fromValue(t.sectionId)).unsigned = !1 : \"string\" == typeof t.sectionId ? e.sectionId = parseInt(t.sectionId, 10) : \"number\" == typeof t.sectionId ? e.sectionId = t.sectionId : \"object\" == typeof t.sectionId && (e.sectionId = new u.LongBits(t.sectionId.low >>> 0, t.sectionId.high >>> 0).toNumber())), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          if (e.defaults) if (n.time = 0, u.Long) {\n            var r = new u.Long(0, 0, !1);\n            n.sectionId = e.longs === String ? r.toString() : e.longs === Number ? r.toNumber() : r;\n          } else n.sectionId = e.longs === String ? \"0\" : 0;\n          return null != t.time && t.hasOwnProperty(\"time\") && (n.time = e.json && !isFinite(t.time) ? String(t.time) : t.time), null != t.sectionId && t.hasOwnProperty(\"sectionId\") && (\"number\" == typeof t.sectionId ? n.sectionId = e.longs === String ? String(t.sectionId) : t.sectionId : n.sectionId = e.longs === String ? u.Long.prototype.toString.call(t.sectionId) : e.longs === Number ? new u.LongBits(t.sectionId.low >>> 0, t.sectionId.high >>> 0).toNumber() : t.sectionId), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.Section = function () {\n        function t(t) {\n          if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        var e;\n        return t.prototype.sectionId = u.Long ? u.Long.fromBits(0, 0, !1) : 0, t.prototype.sectionGroup = null, Object.defineProperty(t.prototype, \"sectionType\", {\n          get: u.oneOfGetter(e = [\"sectionId\", \"sectionGroup\"]),\n          set: u.oneOfSetter(e)\n        }), t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          return e || (e = s.create()), null != t.sectionId && t.hasOwnProperty(\"sectionId\") && e.uint32(8).int64(t.sectionId), null != t.sectionGroup && t.hasOwnProperty(\"sectionGroup\") && c.tensorflow.magenta.NoteSequence.SectionGroup.encode(t.sectionGroup, e.uint32(18).fork()).ldelim(), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.Section(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.sectionId = u.Long ? t.int64().toNumber() : t.int64();\n                break;\n\n              case 2:\n                r.sectionGroup = c.tensorflow.magenta.NoteSequence.SectionGroup.decode(t, t.uint32());\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          if (\"object\" != typeof t || null === t) return \"object expected\";\n          var e = {};\n          if (null != t.sectionId && t.hasOwnProperty(\"sectionId\") && (e.sectionType = 1, !(u.isInteger(t.sectionId) || t.sectionId && u.isInteger(t.sectionId.low) && u.isInteger(t.sectionId.high)))) return \"sectionId: integer|Long expected\";\n\n          if (null != t.sectionGroup && t.hasOwnProperty(\"sectionGroup\")) {\n            if (1 === e.sectionType) return \"sectionType: multiple values\";\n            e.sectionType = 1;\n            var n = c.tensorflow.magenta.NoteSequence.SectionGroup.verify(t.sectionGroup);\n            if (n) return \"sectionGroup.\" + n;\n          }\n\n          return null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.Section) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.Section();\n\n          if (null != t.sectionId && (u.Long ? (e.sectionId = u.Long.fromValue(t.sectionId)).unsigned = !1 : \"string\" == typeof t.sectionId ? e.sectionId = parseInt(t.sectionId, 10) : \"number\" == typeof t.sectionId ? e.sectionId = t.sectionId : \"object\" == typeof t.sectionId && (e.sectionId = new u.LongBits(t.sectionId.low >>> 0, t.sectionId.high >>> 0).toNumber())), null != t.sectionGroup) {\n            if (\"object\" != typeof t.sectionGroup) throw TypeError(\".tensorflow.magenta.NoteSequence.Section.sectionGroup: object expected\");\n            e.sectionGroup = c.tensorflow.magenta.NoteSequence.SectionGroup.fromObject(t.sectionGroup);\n          }\n\n          return e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n          return null != t.sectionId && t.hasOwnProperty(\"sectionId\") && (\"number\" == typeof t.sectionId ? n.sectionId = e.longs === String ? String(t.sectionId) : t.sectionId : n.sectionId = e.longs === String ? u.Long.prototype.toString.call(t.sectionId) : e.longs === Number ? new u.LongBits(t.sectionId.low >>> 0, t.sectionId.high >>> 0).toNumber() : t.sectionId, e.oneofs && (n.sectionType = \"sectionId\")), null != t.sectionGroup && t.hasOwnProperty(\"sectionGroup\") && (n.sectionGroup = c.tensorflow.magenta.NoteSequence.SectionGroup.toObject(t.sectionGroup, e), e.oneofs && (n.sectionType = \"sectionGroup\")), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t.SectionGroup = function () {\n        function t(t) {\n          if (this.sections = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n        }\n\n        return t.prototype.sections = u.emptyArray, t.prototype.numTimes = 0, t.create = function (e) {\n          return new t(e);\n        }, t.encode = function (t, e) {\n          if (e || (e = s.create()), null != t.sections && t.sections.length) for (var n = 0; n < t.sections.length; ++n) c.tensorflow.magenta.NoteSequence.Section.encode(t.sections[n], e.uint32(10).fork()).ldelim();\n          return null != t.numTimes && t.hasOwnProperty(\"numTimes\") && e.uint32(16).int32(t.numTimes), e;\n        }, t.encodeDelimited = function (t, e) {\n          return this.encode(t, e).ldelim();\n        }, t.decode = function (t, e) {\n          t instanceof a || (t = a.create(t));\n\n          for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.NoteSequence.SectionGroup(); t.pos < n;) {\n            var o = t.uint32();\n\n            switch (o >>> 3) {\n              case 1:\n                r.sections && r.sections.length || (r.sections = []), r.sections.push(c.tensorflow.magenta.NoteSequence.Section.decode(t, t.uint32()));\n                break;\n\n              case 2:\n                r.numTimes = t.int32();\n                break;\n\n              default:\n                t.skipType(7 & o);\n            }\n          }\n\n          return r;\n        }, t.decodeDelimited = function (t) {\n          return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n        }, t.verify = function (t) {\n          if (\"object\" != typeof t || null === t) return \"object expected\";\n\n          if (null != t.sections && t.hasOwnProperty(\"sections\")) {\n            if (!Array.isArray(t.sections)) return \"sections: array expected\";\n\n            for (var e = 0; e < t.sections.length; ++e) {\n              var n = c.tensorflow.magenta.NoteSequence.Section.verify(t.sections[e]);\n              if (n) return \"sections.\" + n;\n            }\n          }\n\n          return null != t.numTimes && t.hasOwnProperty(\"numTimes\") && !u.isInteger(t.numTimes) ? \"numTimes: integer expected\" : null;\n        }, t.fromObject = function (t) {\n          if (t instanceof c.tensorflow.magenta.NoteSequence.SectionGroup) return t;\n          var e = new c.tensorflow.magenta.NoteSequence.SectionGroup();\n\n          if (t.sections) {\n            if (!Array.isArray(t.sections)) throw TypeError(\".tensorflow.magenta.NoteSequence.SectionGroup.sections: array expected\");\n            e.sections = [];\n\n            for (var n = 0; n < t.sections.length; ++n) {\n              if (\"object\" != typeof t.sections[n]) throw TypeError(\".tensorflow.magenta.NoteSequence.SectionGroup.sections: object expected\");\n              e.sections[n] = c.tensorflow.magenta.NoteSequence.Section.fromObject(t.sections[n]);\n            }\n          }\n\n          return null != t.numTimes && (e.numTimes = 0 | t.numTimes), e;\n        }, t.toObject = function (t, e) {\n          e || (e = {});\n          var n = {};\n\n          if ((e.arrays || e.defaults) && (n.sections = []), e.defaults && (n.numTimes = 0), t.sections && t.sections.length) {\n            n.sections = [];\n\n            for (var r = 0; r < t.sections.length; ++r) n.sections[r] = c.tensorflow.magenta.NoteSequence.Section.toObject(t.sections[r], e);\n          }\n\n          return null != t.numTimes && t.hasOwnProperty(\"numTimes\") && (n.numTimes = t.numTimes), n;\n        }, t.prototype.toJSON = function () {\n          return this.constructor.toObject(this, i.util.toJSONOptions);\n        }, t;\n      }(), t;\n    }(), r.SequenceMetadata = function () {\n      function t(t) {\n        if (this.genre = [], this.composers = [], t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n      }\n\n      return t.prototype.title = \"\", t.prototype.artist = \"\", t.prototype.genre = u.emptyArray, t.prototype.composers = u.emptyArray, t.create = function (e) {\n        return new t(e);\n      }, t.encode = function (t, e) {\n        if (e || (e = s.create()), null != t.title && t.hasOwnProperty(\"title\") && e.uint32(10).string(t.title), null != t.artist && t.hasOwnProperty(\"artist\") && e.uint32(18).string(t.artist), null != t.genre && t.genre.length) for (var n = 0; n < t.genre.length; ++n) e.uint32(26).string(t.genre[n]);\n        if (null != t.composers && t.composers.length) for (n = 0; n < t.composers.length; ++n) e.uint32(34).string(t.composers[n]);\n        return e;\n      }, t.encodeDelimited = function (t, e) {\n        return this.encode(t, e).ldelim();\n      }, t.decode = function (t, e) {\n        t instanceof a || (t = a.create(t));\n\n        for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.SequenceMetadata(); t.pos < n;) {\n          var o = t.uint32();\n\n          switch (o >>> 3) {\n            case 1:\n              r.title = t.string();\n              break;\n\n            case 2:\n              r.artist = t.string();\n              break;\n\n            case 3:\n              r.genre && r.genre.length || (r.genre = []), r.genre.push(t.string());\n              break;\n\n            case 4:\n              r.composers && r.composers.length || (r.composers = []), r.composers.push(t.string());\n              break;\n\n            default:\n              t.skipType(7 & o);\n          }\n        }\n\n        return r;\n      }, t.decodeDelimited = function (t) {\n        return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n      }, t.verify = function (t) {\n        if (\"object\" != typeof t || null === t) return \"object expected\";\n        if (null != t.title && t.hasOwnProperty(\"title\") && !u.isString(t.title)) return \"title: string expected\";\n        if (null != t.artist && t.hasOwnProperty(\"artist\") && !u.isString(t.artist)) return \"artist: string expected\";\n\n        if (null != t.genre && t.hasOwnProperty(\"genre\")) {\n          if (!Array.isArray(t.genre)) return \"genre: array expected\";\n\n          for (var e = 0; e < t.genre.length; ++e) if (!u.isString(t.genre[e])) return \"genre: string[] expected\";\n        }\n\n        if (null != t.composers && t.hasOwnProperty(\"composers\")) {\n          if (!Array.isArray(t.composers)) return \"composers: array expected\";\n\n          for (e = 0; e < t.composers.length; ++e) if (!u.isString(t.composers[e])) return \"composers: string[] expected\";\n        }\n\n        return null;\n      }, t.fromObject = function (t) {\n        if (t instanceof c.tensorflow.magenta.SequenceMetadata) return t;\n        var e = new c.tensorflow.magenta.SequenceMetadata();\n\n        if (null != t.title && (e.title = String(t.title)), null != t.artist && (e.artist = String(t.artist)), t.genre) {\n          if (!Array.isArray(t.genre)) throw TypeError(\".tensorflow.magenta.SequenceMetadata.genre: array expected\");\n          e.genre = [];\n\n          for (var n = 0; n < t.genre.length; ++n) e.genre[n] = String(t.genre[n]);\n        }\n\n        if (t.composers) {\n          if (!Array.isArray(t.composers)) throw TypeError(\".tensorflow.magenta.SequenceMetadata.composers: array expected\");\n\n          for (e.composers = [], n = 0; n < t.composers.length; ++n) e.composers[n] = String(t.composers[n]);\n        }\n\n        return e;\n      }, t.toObject = function (t, e) {\n        e || (e = {});\n        var n = {};\n\n        if ((e.arrays || e.defaults) && (n.genre = [], n.composers = []), e.defaults && (n.title = \"\", n.artist = \"\"), null != t.title && t.hasOwnProperty(\"title\") && (n.title = t.title), null != t.artist && t.hasOwnProperty(\"artist\") && (n.artist = t.artist), t.genre && t.genre.length) {\n          n.genre = [];\n\n          for (var r = 0; r < t.genre.length; ++r) n.genre[r] = t.genre[r];\n        }\n\n        if (t.composers && t.composers.length) for (n.composers = [], r = 0; r < t.composers.length; ++r) n.composers[r] = t.composers[r];\n        return n;\n      }, t.prototype.toJSON = function () {\n        return this.constructor.toObject(this, i.util.toJSONOptions);\n      }, t;\n    }(), r.VelocityRange = function () {\n      function t(t) {\n        if (t) for (var e = Object.keys(t), n = 0; n < e.length; ++n) null != t[e[n]] && (this[e[n]] = t[e[n]]);\n      }\n\n      return t.prototype.min = 0, t.prototype.max = 0, t.create = function (e) {\n        return new t(e);\n      }, t.encode = function (t, e) {\n        return e || (e = s.create()), null != t.min && t.hasOwnProperty(\"min\") && e.uint32(8).int32(t.min), null != t.max && t.hasOwnProperty(\"max\") && e.uint32(16).int32(t.max), e;\n      }, t.encodeDelimited = function (t, e) {\n        return this.encode(t, e).ldelim();\n      }, t.decode = function (t, e) {\n        t instanceof a || (t = a.create(t));\n\n        for (var n = void 0 === e ? t.len : t.pos + e, r = new c.tensorflow.magenta.VelocityRange(); t.pos < n;) {\n          var o = t.uint32();\n\n          switch (o >>> 3) {\n            case 1:\n              r.min = t.int32();\n              break;\n\n            case 2:\n              r.max = t.int32();\n              break;\n\n            default:\n              t.skipType(7 & o);\n          }\n        }\n\n        return r;\n      }, t.decodeDelimited = function (t) {\n        return t instanceof a || (t = new a(t)), this.decode(t, t.uint32());\n      }, t.verify = function (t) {\n        return \"object\" != typeof t || null === t ? \"object expected\" : null != t.min && t.hasOwnProperty(\"min\") && !u.isInteger(t.min) ? \"min: integer expected\" : null != t.max && t.hasOwnProperty(\"max\") && !u.isInteger(t.max) ? \"max: integer expected\" : null;\n      }, t.fromObject = function (t) {\n        if (t instanceof c.tensorflow.magenta.VelocityRange) return t;\n        var e = new c.tensorflow.magenta.VelocityRange();\n        return null != t.min && (e.min = 0 | t.min), null != t.max && (e.max = 0 | t.max), e;\n      }, t.toObject = function (t, e) {\n        e || (e = {});\n        var n = {};\n        return e.defaults && (n.min = 0, n.max = 0), null != t.min && t.hasOwnProperty(\"min\") && (n.min = t.min), null != t.max && t.hasOwnProperty(\"max\") && (n.max = t.max), n;\n      }, t.prototype.toJSON = function () {\n        return this.constructor.toObject(this, i.util.toJSONOptions);\n      }, t;\n    }(), r), o), t.exports = c;\n  }, function (t, e, n) {\n    var r = n(50),\n        o = n(51),\n        i = \"undefined\" != typeof Float64Array;\n\n    function a(t, e) {\n      return t[0] - e[0];\n    }\n\n    function s() {\n      var t,\n          e = this.stride,\n          n = new Array(e.length);\n\n      for (t = 0; t < n.length; ++t) n[t] = [Math.abs(e[t]), t];\n\n      n.sort(a);\n      var r = new Array(n.length);\n\n      for (t = 0; t < r.length; ++t) r[t] = n[t][1];\n\n      return r;\n    }\n\n    function u(t, e) {\n      var n = [\"View\", e, \"d\", t].join(\"\");\n      e < 0 && (n = \"View_Nil\" + t);\n      var o = \"generic\" === t;\n\n      if (-1 === e) {\n        var i = \"function \" + n + \"(a){this.data=a;};var proto=\" + n + \".prototype;proto.dtype='\" + t + \"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new \" + n + \"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_\" + n + \"(a){return new \" + n + \"(a);}\";\n        return new Function(i)();\n      }\n\n      if (0 === e) {\n        i = \"function \" + n + \"(a,d) {this.data = a;this.offset = d};var proto=\" + n + \".prototype;proto.dtype='\" + t + \"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function \" + n + \"_copy() {return new \" + n + \"(this.data,this.offset)};proto.pick=function \" + n + \"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function \" + n + \"_get(){return \" + (o ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\") + \"};proto.set=function \" + n + \"_set(v){return \" + (o ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\") + \"};return function construct_\" + n + \"(a,b,c,d){return new \" + n + \"(a,d)}\";\n        return new Function(\"TrivialArray\", i)(c[t][0]);\n      }\n\n      i = [\"'use strict'\"];\n      var a = r(e),\n          u = a.map(function (t) {\n        return \"i\" + t;\n      }),\n          l = \"this.offset+\" + a.map(function (t) {\n        return \"this.stride[\" + t + \"]*i\" + t;\n      }).join(\"+\"),\n          h = a.map(function (t) {\n        return \"b\" + t;\n      }).join(\",\"),\n          p = a.map(function (t) {\n        return \"c\" + t;\n      }).join(\",\");\n      i.push(\"function \" + n + \"(a,\" + h + \",\" + p + \",d){this.data=a\", \"this.shape=[\" + h + \"]\", \"this.stride=[\" + p + \"]\", \"this.offset=d|0}\", \"var proto=\" + n + \".prototype\", \"proto.dtype='\" + t + \"'\", \"proto.dimension=\" + e), i.push(\"Object.defineProperty(proto,'size',{get:function \" + n + \"_size(){return \" + a.map(function (t) {\n        return \"this.shape[\" + t + \"]\";\n      }).join(\"*\"), \"}})\"), 1 === e ? i.push(\"proto.order=[0]\") : (i.push(\"Object.defineProperty(proto,'order',{get:\"), e < 4 ? (i.push(\"function \" + n + \"_order(){\"), 2 === e ? i.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\") : 3 === e && i.push(\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})\")) : i.push(\"ORDER})\")), i.push(\"proto.set=function \" + n + \"_set(\" + u.join(\",\") + \",v){\"), o ? i.push(\"return this.data.set(\" + l + \",v)}\") : i.push(\"return this.data[\" + l + \"]=v}\"), i.push(\"proto.get=function \" + n + \"_get(\" + u.join(\",\") + \"){\"), o ? i.push(\"return this.data.get(\" + l + \")}\") : i.push(\"return this.data[\" + l + \"]}\"), i.push(\"proto.index=function \" + n + \"_index(\", u.join(), \"){return \" + l + \"}\"), i.push(\"proto.hi=function \" + n + \"_hi(\" + u.join(\",\") + \"){return new \" + n + \"(this.data,\" + a.map(function (t) {\n        return [\"(typeof i\", t, \"!=='number'||i\", t, \"<0)?this.shape[\", t, \"]:i\", t, \"|0\"].join(\"\");\n      }).join(\",\") + \",\" + a.map(function (t) {\n        return \"this.stride[\" + t + \"]\";\n      }).join(\",\") + \",this.offset)}\");\n      var f = a.map(function (t) {\n        return \"a\" + t + \"=this.shape[\" + t + \"]\";\n      }),\n          d = a.map(function (t) {\n        return \"c\" + t + \"=this.stride[\" + t + \"]\";\n      });\n      i.push(\"proto.lo=function \" + n + \"_lo(\" + u.join(\",\") + \"){var b=this.offset,d=0,\" + f.join(\",\") + \",\" + d.join(\",\"));\n\n      for (var m = 0; m < e; ++m) i.push(\"if(typeof i\" + m + \"==='number'&&i\" + m + \">=0){d=i\" + m + \"|0;b+=c\" + m + \"*d;a\" + m + \"-=d}\");\n\n      i.push(\"return new \" + n + \"(this.data,\" + a.map(function (t) {\n        return \"a\" + t;\n      }).join(\",\") + \",\" + a.map(function (t) {\n        return \"c\" + t;\n      }).join(\",\") + \",b)}\"), i.push(\"proto.step=function \" + n + \"_step(\" + u.join(\",\") + \"){var \" + a.map(function (t) {\n        return \"a\" + t + \"=this.shape[\" + t + \"]\";\n      }).join(\",\") + \",\" + a.map(function (t) {\n        return \"b\" + t + \"=this.stride[\" + t + \"]\";\n      }).join(\",\") + \",c=this.offset,d=0,ceil=Math.ceil\");\n\n      for (m = 0; m < e; ++m) i.push(\"if(typeof i\" + m + \"==='number'){d=i\" + m + \"|0;if(d<0){c+=b\" + m + \"*(a\" + m + \"-1);a\" + m + \"=ceil(-a\" + m + \"/d)}else{a\" + m + \"=ceil(a\" + m + \"/d)}b\" + m + \"*=d}\");\n\n      i.push(\"return new \" + n + \"(this.data,\" + a.map(function (t) {\n        return \"a\" + t;\n      }).join(\",\") + \",\" + a.map(function (t) {\n        return \"b\" + t;\n      }).join(\",\") + \",c)}\");\n      var g = new Array(e),\n          v = new Array(e);\n\n      for (m = 0; m < e; ++m) g[m] = \"a[i\" + m + \"]\", v[m] = \"b[i\" + m + \"]\";\n\n      i.push(\"proto.transpose=function \" + n + \"_transpose(\" + u + \"){\" + u.map(function (t, e) {\n        return t + \"=(\" + t + \"===undefined?\" + e + \":\" + t + \"|0)\";\n      }).join(\";\"), \"var a=this.shape,b=this.stride;return new \" + n + \"(this.data,\" + g.join(\",\") + \",\" + v.join(\",\") + \",this.offset)}\"), i.push(\"proto.pick=function \" + n + \"_pick(\" + u + \"){var a=[],b=[],c=this.offset\");\n\n      for (m = 0; m < e; ++m) i.push(\"if(typeof i\" + m + \"==='number'&&i\" + m + \">=0){c=(c+this.stride[\" + m + \"]*i\" + m + \")|0}else{a.push(this.shape[\" + m + \"]);b.push(this.stride[\" + m + \"])}\");\n\n      return i.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\"), i.push(\"return function construct_\" + n + \"(data,shape,stride,offset){return new \" + n + \"(data,\" + a.map(function (t) {\n        return \"shape[\" + t + \"]\";\n      }).join(\",\") + \",\" + a.map(function (t) {\n        return \"stride[\" + t + \"]\";\n      }).join(\",\") + \",offset)}\"), new Function(\"CTOR_LIST\", \"ORDER\", i.join(\"\\n\"))(c[t], s);\n    }\n\n    var c = {\n      float32: [],\n      float64: [],\n      int8: [],\n      int16: [],\n      int32: [],\n      uint8: [],\n      uint16: [],\n      uint32: [],\n      array: [],\n      uint8_clamped: [],\n      buffer: [],\n      generic: []\n    };\n\n    t.exports = function (t, e, n, r) {\n      if (void 0 === t) return (0, c.array[0])([]);\n      \"number\" == typeof t && (t = [t]), void 0 === e && (e = [t.length]);\n      var a = e.length;\n\n      if (void 0 === n) {\n        n = new Array(a);\n\n        for (var s = a - 1, l = 1; s >= 0; --s) n[s] = l, l *= e[s];\n      }\n\n      if (void 0 === r) {\n        r = 0;\n\n        for (s = 0; s < a; ++s) n[s] < 0 && (r -= (e[s] - 1) * n[s]);\n      }\n\n      for (var h = function (t) {\n        if (o(t)) return \"buffer\";\n        if (i) switch (Object.prototype.toString.call(t)) {\n          case \"[object Float64Array]\":\n            return \"float64\";\n\n          case \"[object Float32Array]\":\n            return \"float32\";\n\n          case \"[object Int8Array]\":\n            return \"int8\";\n\n          case \"[object Int16Array]\":\n            return \"int16\";\n\n          case \"[object Int32Array]\":\n            return \"int32\";\n\n          case \"[object Uint8Array]\":\n            return \"uint8\";\n\n          case \"[object Uint16Array]\":\n            return \"uint16\";\n\n          case \"[object Uint32Array]\":\n            return \"uint32\";\n\n          case \"[object Uint8ClampedArray]\":\n            return \"uint8_clamped\";\n        }\n        return Array.isArray(t) ? \"array\" : \"generic\";\n      }(t), p = c[h]; p.length <= a + 1;) p.push(u(h, p.length - 1));\n\n      return (0, p[a + 1])(t, e, n, r);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = {};\n    n.r(r), n.d(r, \"names\", function () {\n      return s;\n    }), n.d(r, \"tokenize\", function () {\n      return h;\n    }), n.d(r, \"props\", function () {\n      return d;\n    }), n.d(r, \"name\", function () {\n      return m;\n    }), n.d(r, \"pc\", function () {\n      return g;\n    }), n.d(r, \"midi\", function () {\n      return v;\n    }), n.d(r, \"midiToFreq\", function () {\n      return y;\n    }), n.d(r, \"freq\", function () {\n      return b;\n    }), n.d(r, \"freqToMidi\", function () {\n      return S;\n    }), n.d(r, \"chroma\", function () {\n      return E;\n    }), n.d(r, \"oct\", function () {\n      return C;\n    }), n.d(r, \"stepToLetter\", function () {\n      return I;\n    }), n.d(r, \"altToAcc\", function () {\n      return k;\n    }), n.d(r, \"from\", function () {\n      return T;\n    }), n.d(r, \"build\", function () {\n      return N;\n    }), n.d(r, \"fromMidi\", function () {\n      return P;\n    }), n.d(r, \"simplify\", function () {\n      return R;\n    }), n.d(r, \"enharmonic\", function () {\n      return _;\n    });\n    var o = {};\n    n.r(o), n.d(o, \"names\", function () {\n      return lt;\n    }), n.d(o, \"props\", function () {\n      return pt;\n    }), n.d(o, \"intervals\", function () {\n      return ft;\n    }), n.d(o, \"notes\", function () {\n      return dt;\n    }), n.d(o, \"exists\", function () {\n      return mt;\n    }), n.d(o, \"supersets\", function () {\n      return gt;\n    }), n.d(o, \"subsets\", function () {\n      return vt;\n    }), n.d(o, \"tokenize\", function () {\n      return bt;\n    });\n\n    var i = n(0),\n        a = \"C C# Db D D# Eb E F F# Gb G G# Ab A A# Bb B\".split(\" \"),\n        s = function (t) {\n      return \"string\" != typeof t ? a.slice() : a.filter(function (e) {\n        var n = e[1] || \" \";\n        return -1 !== t.indexOf(n);\n      });\n    },\n        u = s(\" #\"),\n        c = s(\" b\"),\n        l = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)$/;\n\n    function h(t) {\n      \"string\" != typeof t && (t = \"\");\n      var e = l.exec(t);\n      return [e[1].toUpperCase(), e[2].replace(/x/g, \"##\"), e[3], e[4]];\n    }\n\n    var p = Object.freeze({\n      pc: null,\n      name: null,\n      step: null,\n      alt: null,\n      oct: null,\n      octStr: null,\n      chroma: null,\n      midi: null,\n      freq: null\n    }),\n        f = [0, 2, 4, 5, 7, 9, 11],\n        d = function (t, e) {\n      return void 0 === e && (e = {}), function (n) {\n        return e[n] || (e[n] = t(n));\n      };\n    }(function (t) {\n      var e = h(t);\n      if (\"\" === e[0] || \"\" !== e[3]) return p;\n      var n = e[0],\n          r = e[1],\n          o = e[2],\n          i = {\n        letter: n,\n        acc: r,\n        octStr: o,\n        pc: n + r,\n        name: n + r + o,\n        step: (n.charCodeAt(0) + 3) % 7,\n        alt: \"b\" === r[0] ? -r.length : r.length,\n        oct: o.length ? +o : null,\n        chroma: 0,\n        midi: null,\n        freq: null\n      };\n      return i.chroma = (f[i.step] + i.alt + 120) % 12, i.midi = null !== i.oct ? f[i.step] + i.alt + 12 * (i.oct + 1) : null, i.freq = y(i.midi), Object.freeze(i);\n    }),\n        m = function (t) {\n      return d(t).name;\n    },\n        g = function (t) {\n      return d(t).pc;\n    },\n        v = function (t) {\n      if (\"number\" != typeof t && \"string\" != typeof t) return null;\n      var e,\n          n = d(t).midi,\n          r = n || 0 === n ? n : +t;\n      return (e = r) >= 0 && e <= 127 ? r : null;\n    },\n        y = function (t, e) {\n      return void 0 === e && (e = 440), \"number\" == typeof t ? Math.pow(2, (t - 69) / 12) * e : null;\n    },\n        b = function (t) {\n      return d(t).freq || y(t);\n    },\n        w = Math.log(2),\n        x = Math.log(440),\n        S = function (t) {\n      var e = 12 * (Math.log(t) - x) / w + 69;\n      return Math.round(100 * e) / 100;\n    },\n        E = function (t) {\n      return d(t).chroma;\n    },\n        C = function (t) {\n      return d(t).oct;\n    },\n        I = function (t) {\n      return \"CDEFGAB\"[t];\n    },\n        A = function (t, e) {\n      return Array(e + 1).join(t);\n    },\n        k = function (t) {\n      return function (t, e) {\n        return \"number\" != typeof t ? \"\" : e(t);\n      }(t, function (t) {\n        return t < 0 ? A(\"b\", -t) : A(\"#\", t);\n      });\n    },\n        T = function (t, e) {\n      void 0 === t && (t = {}), void 0 === e && (e = null);\n      var n = e ? Object.assign({}, d(e), t) : t,\n          r = n.step,\n          o = n.alt,\n          i = n.oct;\n      if (\"number\" != typeof r) return null;\n      var a = I(r);\n      if (!a) return null;\n      var s = a + k(o);\n      return i || 0 === i ? s + i : s;\n    },\n        N = T;\n\n    function P(t, e) {\n      return void 0 === e && (e = !1), t = Math.round(t), (!0 === e ? u : c)[t % 12] + (Math.floor(t / 12) - 1);\n    }\n\n    var R = function (t, e) {\n      void 0 === e && (e = !0);\n      var n = d(t),\n          r = n.alt,\n          o = n.chroma,\n          i = n.midi;\n      if (null === o) return null;\n      var a = !1 === e ? r < 0 : r > 0;\n      return null === i ? g(P(o, a)) : P(i, a);\n    },\n        _ = function (t) {\n      return R(t, !1);\n    };\n\n    var M = new RegExp(\"^([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})|(AA|A|P|M|m|d|dd)([-+]?\\\\d+)$\"),\n        O = [0, 2, 4, 5, 7, 9, 11],\n        D = (\"1P 2m 2M 3m 3M 4P 5P 6m 6M 7m 7M 8P\".split(\" \"), Object.freeze({\n      name: null,\n      num: null,\n      q: null,\n      step: null,\n      alt: null,\n      dir: null,\n      type: null,\n      simple: null,\n      semitones: null,\n      chroma: null,\n      oct: null\n    })),\n        F = function (t) {\n      return (Math.abs(t) - 1) % 7;\n    },\n        L = function (t) {\n      var e = function (t) {\n        var e = M.exec(\"\" + t);\n        return null === e ? null : e[1] ? [e[1], e[2]] : [e[4], e[3]];\n      }(t);\n\n      if (null === e) return D;\n      var n,\n          r,\n          o = {\n        num: 0,\n        q: \"d\",\n        name: \"\",\n        type: \"M\",\n        step: 0,\n        dir: -1,\n        simple: 1,\n        alt: 0,\n        oct: 0,\n        semitones: 0,\n        chroma: 0,\n        ic: 0\n      };\n      return o.num = +e[0], o.q = e[1], o.step = F(o.num), o.type = \"PMMPPMM\"[o.step], \"M\" === o.type && \"P\" === o.q ? D : (o.name = \"\" + o.num + o.q, o.dir = o.num < 0 ? -1 : 1, o.simple = 8 === o.num || -8 === o.num ? o.num : o.dir * (o.step + 1), o.alt = (n = o.type, \"M\" === (r = o.q) && \"M\" === n ? 0 : \"P\" === r && \"P\" === n ? 0 : \"m\" === r && \"M\" === n ? -1 : /^A+$/.test(r) ? r.length : /^d+$/.test(r) ? \"P\" === n ? -r.length : -r.length - 1 : null), o.oct = Math.floor((Math.abs(o.num) - 1) / 7), o.semitones = o.dir * (O[o.step] + o.alt + 12 * o.oct), o.chroma = (o.dir * (O[o.step] + o.alt) % 12 + 12) % 12, Object.freeze(o));\n    },\n        B = {};\n\n    function z(t) {\n      return \"string\" != typeof t ? D : B[t] || (B[t] = L(t));\n    }\n\n    \"P m M m M P d P m M m M\".split(\" \");\n    var q = [0, 2, 4, -1, 1, 3, 5],\n        V = q.map(function (t) {\n      return Math.floor(7 * t / 12);\n    }),\n        U = [3, 0, 4, 1, 5, 2, 6];\n\n    var j = function (t, e, n) {\n      var r = U[function (t) {\n        var e = (t + 1) % 7;\n        return e < 0 ? 7 + e : e;\n      }(t)],\n          o = Math.floor((t + 1) / 7);\n\n      return void 0 === e ? {\n        step: r,\n        alt: o,\n        dir: n\n      } : {\n        step: r,\n        alt: o,\n        oct: e + 4 * o + V[r],\n        dir: n\n      };\n    },\n        W = function (t) {\n      return function (t, e) {\n        return void 0 === e && (e = {}), function (n) {\n          return e[n] || (e[n] = t(n));\n        };\n      }(function (e) {\n        var n = t(e);\n        return null === n.name ? null : function (t) {\n          var e = t.step,\n              n = t.alt,\n              r = t.oct,\n              o = t.dir;\n          void 0 === o && (o = 1);\n          var i = q[e] + 7 * n;\n          return null === r ? [o * i] : [o * i, o * (r - V[e] - 4 * n)];\n        }(n);\n      });\n    },\n        G = W(d),\n        H = W(z);\n\n    function $(t, e) {\n      if (1 === arguments.length) return function (e) {\n        return $(t, e);\n      };\n      var n = G(t),\n          r = H(e);\n      if (null === n || null === r) return null;\n      var o = 1 === n.length ? [n[0] + r[0]] : [n[0] + r[0], n[1] + r[1]];\n      return N(j(o[0], o[1]));\n    }\n\n    var K = n(36),\n        Q = n(37),\n        X = function (t) {\n      return E(t) || function (t) {\n        return z(t).chroma;\n      }(t) || 0;\n    },\n        Y = function (t) {\n      return parseInt(J(t), 2);\n    };\n\n    function J(t) {\n      if (tt(t)) return t;\n      if (!Array.isArray(t)) return \"\";\n      var e = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      return t.map(X).forEach(function (t) {\n        e[t] = 1;\n      }), e.join(\"\");\n    }\n\n    var Z = /^[01]{12}$/;\n\n    function tt(t) {\n      return Z.test(t);\n    }\n\n    \"1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M\".split(\" \");\n\n    function et(t, e) {\n      return arguments.length > 1 ? et(t)(e) : (t = Y(t), function (e) {\n        return (e = Y(e)) !== t && (e & t) === e;\n      });\n    }\n\n    function nt(t, e) {\n      return arguments.length > 1 ? nt(t)(e) : (t = Y(t), function (e) {\n        return (e = Y(e)) !== t && (e | t) === e;\n      });\n    }\n\n    var rt,\n        ot,\n        it,\n        at = function (t) {\n      var e = Object.keys(t).sort(),\n          n = [],\n          r = [],\n          o = function (t, e, o) {\n        n[t] = e, r[o] = r[o] || [], r[o].push(t);\n      };\n\n      e.forEach(function (e) {\n        var n = t[e][0].split(\" \"),\n            r = t[e][1],\n            i = J(n);\n        o(e, n, i), r && r.forEach(function (t) {\n          return o(t, n, i);\n        });\n      });\n\n      var i = Object.keys(n).sort(),\n          a = function (t) {\n        return n[t];\n      };\n\n      return a.names = function (t) {\n        return \"string\" == typeof t ? (r[t] || []).slice() : (!0 === t ? i : e).slice();\n      }, a;\n    },\n        st = at(K),\n        ut = at(Q),\n        ct = (rt = st, ot = ut, (it = function (t) {\n      return rt(t) || ot(t);\n    }).names = function (t) {\n      return rt.names(t).concat(ot.names(t));\n    }, Object.freeze({\n      name: null,\n      intervals: [],\n      names: [],\n      chroma: null,\n      setnum: null\n    }));\n\n    st.names;\n\n    var lt = ut.names,\n        ht = Object.freeze({\n      name: null,\n      names: [],\n      intervals: [],\n      chroma: null,\n      setnum: null\n    }),\n        pt = function (t, e) {\n      return void 0 === e && (e = {}), function (n) {\n        return e[n] || (e[n] = t(n));\n      };\n    }(function (t) {\n      var e = ut(t);\n      if (!e) return ht;\n      var n = {\n        intervals: e,\n        name: t\n      };\n      return n.chroma = J(e), n.setnum = parseInt(n.chroma, 2), n.names = ut.names(n.chroma), n;\n    }),\n        ft = function (t) {\n      return pt(bt(t)[1]).intervals;\n    };\n\n    function dt(t, e) {\n      if (e) return pt(e).intervals.map($(t));\n      var n = bt(t),\n          r = n[0],\n          o = n[1];\n      return pt(o).intervals.map($(r));\n    }\n\n    var mt = function (t) {\n      return void 0 !== ut(bt(t)[1]);\n    },\n        gt = function (t) {\n      if (!ft(t).length) return [];\n      var e = nt(ft(t));\n      return ut.names().filter(function (t) {\n        return e(ut(t));\n      });\n    },\n        vt = function (t) {\n      var e = et(ft(t));\n      return ut.names().filter(function (t) {\n        return e(ut(t));\n      });\n    },\n        yt = /^(6|64|7|9|11|13)$/;\n\n    function bt(t) {\n      var e = h(t);\n      return \"\" === e[0] ? [\"\", t] : \"A\" === e[0] && \"ug\" === e[3] ? [\"\", \"aug\"] : yt.test(e[2]) ? [e[0] + e[1], e[2] + e[3]] : [e[0] + e[1] + e[2], e[3]];\n    }\n\n    var wt = n(1);\n    n.d(e, \"ChordQuality\", function () {\n      return St;\n    }), n.d(e, \"ChordSymbolException\", function () {\n      return Et;\n    }), n.d(e, \"ChordEncodingException\", function () {\n      return Ct;\n    }), n.d(e, \"ChordSymbols\", function () {\n      return It;\n    }), n.d(e, \"ChordEncoder\", function () {\n      return At;\n    }), n.d(e, \"chordEncoderFromType\", function () {\n      return kt;\n    }), n.d(e, \"MajorMinorChordEncoder\", function () {\n      return Tt;\n    }), n.d(e, \"TriadChordEncoder\", function () {\n      return Nt;\n    }), n.d(e, \"PitchChordEncoder\", function () {\n      return Pt;\n    });\n    const xt = [[\"1P\", \"3M\", \"5P\"], [\"1P\", \"3m\", \"5P\"], [\"1P\", \"3M\", \"5A\"], [\"1P\", \"3m\", \"5d\"]];\n    var St;\n    !function (t) {\n      t[t.Major = 0] = \"Major\", t[t.Minor = 1] = \"Minor\", t[t.Augmented = 2] = \"Augmented\", t[t.Diminished = 3] = \"Diminished\", t[t.Other = 4] = \"Other\";\n    }(St || (St = {}));\n\n    class Et extends Error {\n      constructor(t) {\n        super(t), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class Ct extends Error {\n      constructor(t) {\n        super(t), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    class It {\n      static pitches(t) {\n        if (!o.tokenize(t)[0] || !o.exists(t)) throw new Et(\"Unrecognized chord symbol: \".concat(t));\n        return o.notes(t).map(r.chroma);\n      }\n\n      static root(t) {\n        const e = o.tokenize(t)[0];\n        if (!e) throw new Et(\"Chord symbol has unknown root: \".concat(t));\n        return r.chroma(e);\n      }\n\n      static quality(t) {\n        if (!o.exists(t)) throw new Et(\"Unrecognized chord symbol: \".concat(t));\n        const e = o.intervals(t),\n              n = xt.map(t => t.every(t => e.includes(t))),\n              r = n.indexOf(!0),\n              i = n.lastIndexOf(!0);\n        return r >= 0 && r === i ? r : St.Other;\n      }\n\n    }\n\n    class At {\n      encodeProgression(t, e) {\n        const n = t.map(t => this.encode(t)),\n              r = Array.from(Array(e).keys()).map(t => Math.floor(t * n.length / e));\n        return i.stack(r.map(t => n[t]));\n      }\n\n    }\n\n    function kt(t) {\n      switch (t) {\n        case \"MajorMinorChordEncoder\":\n          return new Tt();\n\n        case \"TriadChordEncoder\":\n          return new Nt();\n\n        case \"PitchChordEncoder\":\n          return new Pt();\n\n        default:\n          throw new Error(\"Unknown chord encoder type: \".concat(t));\n      }\n    }\n\n    class Tt extends At {\n      constructor() {\n        super(...arguments), this.depth = 1 + 2 * wt.NUM_PITCH_CLASSES;\n      }\n\n      index(t) {\n        if (t === wt.NO_CHORD) return 0;\n        const e = It.root(t),\n              n = 1 + It.quality(t) * wt.NUM_PITCH_CLASSES + e;\n        if (n >= this.depth) throw new Ct(\"Chord is neither major nor minor: \".concat(t));\n        return n;\n      }\n\n      encode(t) {\n        return i.tidy(() => i.oneHot(i.tensor1d([this.index(t)], \"int32\"), this.depth).as1D());\n      }\n\n    }\n\n    class Nt extends At {\n      constructor() {\n        super(...arguments), this.depth = 1 + 4 * wt.NUM_PITCH_CLASSES;\n      }\n\n      index(t) {\n        if (t === wt.NO_CHORD) return 0;\n        const e = It.root(t),\n              n = 1 + It.quality(t) * wt.NUM_PITCH_CLASSES + e;\n        if (n >= this.depth) throw new Ct(\"Chord is not a standard triad: \".concat(t));\n        return n;\n      }\n\n      encode(t) {\n        return i.tidy(() => i.oneHot(i.tensor1d([this.index(t)], \"int32\"), this.depth).as1D());\n      }\n\n    }\n\n    class Pt extends At {\n      constructor() {\n        super(...arguments), this.depth = 1 + 3 * wt.NUM_PITCH_CLASSES;\n      }\n\n      encode(t) {\n        return i.tidy(() => {\n          if (t === wt.NO_CHORD) return i.oneHot(i.tensor1d([0], \"int32\"), this.depth).as1D();\n          const e = It.root(t),\n                n = i.oneHot(i.tensor1d([e], \"int32\"), wt.NUM_PITCH_CLASSES).as1D(),\n                r = i.buffer([wt.NUM_PITCH_CLASSES]);\n          It.pitches(t).forEach(t => r.set(1, t));\n          const o = r.toTensor().as1D(),\n                a = n;\n          return i.concat1d([i.tensor1d([0]), n, o, a]);\n        });\n      }\n\n    }\n  }, function (t, e, n) {\n    (function (t) {\n      var n = {};\n      !function (t) {\n        var e = t.DEFAULT_VOLUME = 90,\n            n = (t.DEFAULT_DURATION = 128, t.DEFAULT_CHANNEL = 0, {\n          midi_letter_pitches: {\n            a: 21,\n            b: 23,\n            c: 12,\n            d: 14,\n            e: 16,\n            f: 17,\n            g: 19\n          },\n          midiPitchFromNote: function (t) {\n            var e = /([a-g])(#+|b+)?([0-9]+)$/i.exec(t),\n                r = e[1].toLowerCase(),\n                o = e[2] || \"\";\n            return 12 * parseInt(e[3], 10) + n.midi_letter_pitches[r] + (\"#\" == o.substr(0, 1) ? 1 : -1) * o.length;\n          },\n          ensureMidiPitch: function (t) {\n            return \"number\" != typeof t && /[^0-9]/.test(t) ? n.midiPitchFromNote(t) : parseInt(t, 10);\n          },\n          midi_pitches_letter: {\n            12: \"c\",\n            13: \"c#\",\n            14: \"d\",\n            15: \"d#\",\n            16: \"e\",\n            17: \"f\",\n            18: \"f#\",\n            19: \"g\",\n            20: \"g#\",\n            21: \"a\",\n            22: \"a#\",\n            23: \"b\"\n          },\n          midi_flattened_notes: {\n            \"a#\": \"bb\",\n            \"c#\": \"db\",\n            \"d#\": \"eb\",\n            \"f#\": \"gb\",\n            \"g#\": \"ab\"\n          },\n          noteFromMidiPitch: function (t, e) {\n            var r,\n                o = 0,\n                i = t;\n            e = e || !1;\n            return t > 23 && (i = t - 12 * (o = Math.floor(t / 12) - 1)), r = n.midi_pitches_letter[i], e && r.indexOf(\"#\") > 0 && (r = n.midi_flattened_notes[r]), r + o;\n          },\n          mpqnFromBpm: function (t) {\n            var e = Math.floor(6e7 / t),\n                n = [];\n\n            do {\n              n.unshift(255 & e), e >>= 8;\n            } while (e);\n\n            for (; n.length < 3;) n.push(0);\n\n            return n;\n          },\n          bpmFromMpqn: function (t) {\n            if (void 0 !== t[0]) {\n              0;\n\n              for (var e = 0, n = t.length - 1; n >= 0; ++e, --n) t[e] << n;\n            }\n\n            return Math.floor(6e7 / t);\n          },\n          codes2Str: function (t) {\n            return String.fromCharCode.apply(null, t);\n          },\n          str2Bytes: function (t, e) {\n            if (e) for (; t.length / 2 < e;) t = \"0\" + t;\n\n            for (var n = [], r = t.length - 1; r >= 0; r -= 2) {\n              var o = 0 === r ? t[r] : t[r - 1] + t[r];\n              n.unshift(parseInt(o, 16));\n            }\n\n            return n;\n          },\n          translateTickTime: function (t) {\n            for (var e = 127 & t; t >>= 7;) e <<= 8, e |= 127 & t | 128;\n\n            for (var n = []; n.push(255 & e), 128 & e;) e >>= 8;\n\n            return n;\n          }\n        }),\n            r = function (t) {\n          if (!this) return new r(t);\n          !t || null === t.type && void 0 === t.type || null === t.channel && void 0 === t.channel || null === t.param1 && void 0 === t.param1 || (this.setTime(t.time), this.setType(t.type), this.setChannel(t.channel), this.setParam1(t.param1), this.setParam2(t.param2));\n        };\n\n        r.NOTE_OFF = 128, r.NOTE_ON = 144, r.AFTER_TOUCH = 160, r.CONTROLLER = 176, r.PROGRAM_CHANGE = 192, r.CHANNEL_AFTERTOUCH = 208, r.PITCH_BEND = 224, r.prototype.setTime = function (t) {\n          this.time = n.translateTickTime(t || 0);\n        }, r.prototype.setType = function (t) {\n          if (t < r.NOTE_OFF || t > r.PITCH_BEND) throw new Error(\"Trying to set an unknown event: \" + t);\n          this.type = t;\n        }, r.prototype.setChannel = function (t) {\n          if (t < 0 || t > 15) throw new Error(\"Channel is out of bounds.\");\n          this.channel = t;\n        }, r.prototype.setParam1 = function (t) {\n          this.param1 = t;\n        }, r.prototype.setParam2 = function (t) {\n          this.param2 = t;\n        }, r.prototype.toBytes = function () {\n          var t = [],\n              e = this.type | 15 & this.channel;\n          return t.push.apply(t, this.time), t.push(e), t.push(this.param1), void 0 !== this.param2 && null !== this.param2 && t.push(this.param2), t;\n        };\n\n        var o = function (t) {\n          if (!this) return new o(t);\n          this.setTime(t.time), this.setType(t.type), this.setData(t.data);\n        };\n\n        o.SEQUENCE = 0, o.TEXT = 1, o.COPYRIGHT = 2, o.TRACK_NAME = 3, o.INSTRUMENT = 4, o.LYRIC = 5, o.MARKER = 6, o.CUE_POINT = 7, o.CHANNEL_PREFIX = 32, o.END_OF_TRACK = 47, o.TEMPO = 81, o.SMPTE = 84, o.TIME_SIG = 88, o.KEY_SIG = 89, o.SEQ_EVENT = 127, o.prototype.setTime = function (t) {\n          this.time = n.translateTickTime(t || 0);\n        }, o.prototype.setType = function (t) {\n          this.type = t;\n        }, o.prototype.setData = function (t) {\n          this.data = t;\n        }, o.prototype.toBytes = function () {\n          if (!this.type) throw new Error(\"Type for meta-event not specified.\");\n          var t = [];\n          if (t.push.apply(t, this.time), t.push(255, this.type), Array.isArray(this.data)) t.push(this.data.length), t.push.apply(t, this.data);else if (\"number\" == typeof this.data) t.push(1, this.data);else if (null !== this.data && void 0 !== this.data) {\n            t.push(this.data.length);\n            var e = this.data.split(\"\").map(function (t) {\n              return t.charCodeAt(0);\n            });\n            t.push.apply(t, e);\n          } else t.push(0);\n          return t;\n        };\n\n        var i = function (t) {\n          if (!this) return new i(t);\n          var e = t || {};\n          this.events = e.events || [];\n        };\n\n        i.START_BYTES = [77, 84, 114, 107], i.END_BYTES = [0, 255, 47, 0], i.prototype.addEvent = function (t) {\n          return this.events.push(t), this;\n        }, i.prototype.addNoteOn = i.prototype.noteOn = function (t, o, i, a) {\n          return this.events.push(new r({\n            type: r.NOTE_ON,\n            channel: t,\n            param1: n.ensureMidiPitch(o),\n            param2: a || e,\n            time: i || 0\n          })), this;\n        }, i.prototype.addNoteOff = i.prototype.noteOff = function (t, o, i, a) {\n          return this.events.push(new r({\n            type: r.NOTE_OFF,\n            channel: t,\n            param1: n.ensureMidiPitch(o),\n            param2: a || e,\n            time: i || 0\n          })), this;\n        }, i.prototype.addNote = i.prototype.note = function (t, e, n, r, o) {\n          return this.noteOn(t, e, r, o), n && this.noteOff(t, e, n, o), this;\n        }, i.prototype.addChord = i.prototype.chord = function (t, e, n, r) {\n          if (!Array.isArray(e) && !e.length) throw new Error(\"Chord must be an array of pitches\");\n          return e.forEach(function (e) {\n            this.noteOn(t, e, 0, r);\n          }, this), e.forEach(function (e, r) {\n            0 === r ? this.noteOff(t, e, n) : this.noteOff(t, e);\n          }, this), this;\n        }, i.prototype.setInstrument = i.prototype.instrument = function (t, e, n) {\n          return this.events.push(new r({\n            type: r.PROGRAM_CHANGE,\n            channel: t,\n            param1: e,\n            time: n || 0\n          })), this;\n        }, i.prototype.setTempo = i.prototype.tempo = function (t, e) {\n          return this.events.push(new o({\n            type: o.TEMPO,\n            data: n.mpqnFromBpm(t),\n            time: e || 0\n          })), this;\n        }, i.prototype.toBytes = function () {\n          var t = 0,\n              e = [],\n              r = i.START_BYTES,\n              o = i.END_BYTES;\n          this.events.forEach(function (n) {\n            var r = n.toBytes();\n            t += r.length, e.push.apply(e, r);\n          }), t += o.length;\n          var a = n.str2Bytes(t.toString(16), 4);\n          return r.concat(a, e, o);\n        };\n\n        var a = function (t) {\n          if (!this) return new a(t);\n          var e = t || {};\n\n          if (e.ticks) {\n            if (\"number\" != typeof e.ticks) throw new Error(\"Ticks per beat must be a number!\");\n            if (e.ticks <= 0 || e.ticks >= 32768 || e.ticks % 1 != 0) throw new Error(\"Ticks per beat must be an integer between 1 and 32767!\");\n          }\n\n          this.ticks = e.ticks || 128, this.tracks = e.tracks || [];\n        };\n\n        a.HDR_CHUNKID = \"MThd\", a.HDR_CHUNK_SIZE = \"\\0\\0\\0\u0006\", a.HDR_TYPE0 = \"\\0\\0\", a.HDR_TYPE1 = \"\\0\u0001\", a.prototype.addTrack = function (t) {\n          return t ? (this.tracks.push(t), this) : (t = new i(), this.tracks.push(t), t);\n        }, a.prototype.toBytes = function () {\n          var t = this.tracks.length.toString(16),\n              e = a.HDR_CHUNKID + a.HDR_CHUNK_SIZE;\n          return parseInt(t, 16) > 1 ? e += a.HDR_TYPE1 : e += a.HDR_TYPE0, e += n.codes2Str(n.str2Bytes(t, 2)), e += String.fromCharCode(this.ticks / 256, this.ticks % 256), this.tracks.forEach(function (t) {\n            e += n.codes2Str(t.toBytes());\n          }), e;\n        }, t.Util = n, t.File = a, t.Track = i, t.Event = r, t.MetaEvent = o;\n      }(n), null !== t ? t.exports = n : null !== e ? e = n : this.Midi = n;\n    }).call(this, n(74)(t));\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      if (this.size = 0 | t, this.size <= 1 || 0 != (this.size & this.size - 1)) throw new Error(\"FFT size must be a power of two and bigger than 1\");\n      this._csize = t << 1;\n\n      for (var e = new Array(2 * this.size), n = 0; n < e.length; n += 2) {\n        const t = Math.PI * n / this.size;\n        e[n] = Math.cos(t), e[n + 1] = -Math.sin(t);\n      }\n\n      this.table = e;\n\n      for (var r = 0, o = 1; this.size > o; o <<= 1) r++;\n\n      this._width = r % 2 == 0 ? r - 1 : r, this._bitrev = new Array(1 << this._width);\n\n      for (var i = 0; i < this._bitrev.length; i++) {\n        this._bitrev[i] = 0;\n\n        for (var a = 0; a < this._width; a += 2) {\n          var s = this._width - a - 2;\n          this._bitrev[i] |= (i >>> a & 3) << s;\n        }\n      }\n\n      this._out = null, this._data = null, this._inv = 0;\n    }\n\n    t.exports = r, r.prototype.fromComplexArray = function (t, e) {\n      for (var n = e || new Array(t.length >>> 1), r = 0; r < t.length; r += 2) n[r >>> 1] = t[r];\n\n      return n;\n    }, r.prototype.createComplexArray = function () {\n      const t = new Array(this._csize);\n\n      for (var e = 0; e < t.length; e++) t[e] = 0;\n\n      return t;\n    }, r.prototype.toComplexArray = function (t, e) {\n      for (var n = e || this.createComplexArray(), r = 0; r < n.length; r += 2) n[r] = t[r >>> 1], n[r + 1] = 0;\n\n      return n;\n    }, r.prototype.completeSpectrum = function (t) {\n      for (var e = this._csize, n = e >>> 1, r = 2; r < n; r += 2) t[e - r] = t[r], t[e - r + 1] = -t[r + 1];\n    }, r.prototype.transform = function (t, e) {\n      if (t === e) throw new Error(\"Input and output buffers must be different\");\n      this._out = t, this._data = e, this._inv = 0, this._transform4(), this._out = null, this._data = null;\n    }, r.prototype.realTransform = function (t, e) {\n      if (t === e) throw new Error(\"Input and output buffers must be different\");\n      this._out = t, this._data = e, this._inv = 0, this._realTransform4(), this._out = null, this._data = null;\n    }, r.prototype.inverseTransform = function (t, e) {\n      if (t === e) throw new Error(\"Input and output buffers must be different\");\n      this._out = t, this._data = e, this._inv = 1, this._transform4();\n\n      for (var n = 0; n < t.length; n++) t[n] /= this.size;\n\n      this._out = null, this._data = null;\n    }, r.prototype._transform4 = function () {\n      var t,\n          e,\n          n = this._out,\n          r = this._csize,\n          o = 1 << this._width,\n          i = r / o << 1,\n          a = this._bitrev;\n      if (4 === i) for (t = 0, e = 0; t < r; t += i, e++) {\n        const n = a[e];\n\n        this._singleTransform2(t, n, o);\n      } else for (t = 0, e = 0; t < r; t += i, e++) {\n        const n = a[e];\n\n        this._singleTransform4(t, n, o);\n      }\n      var s = this._inv ? -1 : 1,\n          u = this.table;\n\n      for (o >>= 2; o >= 2; o >>= 2) {\n        var c = (i = r / o << 1) >>> 2;\n\n        for (t = 0; t < r; t += i) for (var l = t + c, h = t, p = 0; h < l; h += 2, p += o) {\n          const t = h,\n                e = t + c,\n                r = e + c,\n                o = r + c,\n                i = n[t],\n                a = n[t + 1],\n                l = n[e],\n                f = n[e + 1],\n                d = n[r],\n                m = n[r + 1],\n                g = n[o],\n                v = n[o + 1],\n                y = i,\n                b = a,\n                w = u[p],\n                x = s * u[p + 1],\n                S = l * w - f * x,\n                E = l * x + f * w,\n                C = u[2 * p],\n                I = s * u[2 * p + 1],\n                A = d * C - m * I,\n                k = d * I + m * C,\n                T = u[3 * p],\n                N = s * u[3 * p + 1],\n                P = g * T - v * N,\n                R = g * N + v * T,\n                _ = y + A,\n                M = b + k,\n                O = y - A,\n                D = b - k,\n                F = S + P,\n                L = E + R,\n                B = s * (S - P),\n                z = s * (E - R),\n                q = _ + F,\n                V = M + L,\n                U = _ - F,\n                j = M - L,\n                W = O + z,\n                G = D - B,\n                H = O - z,\n                $ = D + B;\n\n          n[t] = q, n[t + 1] = V, n[e] = W, n[e + 1] = G, n[r] = U, n[r + 1] = j, n[o] = H, n[o + 1] = $;\n        }\n      }\n    }, r.prototype._singleTransform2 = function (t, e, n) {\n      const r = this._out,\n            o = this._data,\n            i = o[e],\n            a = o[e + 1],\n            s = o[e + n],\n            u = o[e + n + 1],\n            c = i + s,\n            l = a + u,\n            h = i - s,\n            p = a - u;\n      r[t] = c, r[t + 1] = l, r[t + 2] = h, r[t + 3] = p;\n    }, r.prototype._singleTransform4 = function (t, e, n) {\n      const r = this._out,\n            o = this._data,\n            i = this._inv ? -1 : 1,\n            a = 2 * n,\n            s = 3 * n,\n            u = o[e],\n            c = o[e + 1],\n            l = o[e + n],\n            h = o[e + n + 1],\n            p = o[e + a],\n            f = o[e + a + 1],\n            d = o[e + s],\n            m = o[e + s + 1],\n            g = u + p,\n            v = c + f,\n            y = u - p,\n            b = c - f,\n            w = l + d,\n            x = h + m,\n            S = i * (l - d),\n            E = i * (h - m),\n            C = g + w,\n            I = v + x,\n            A = y + E,\n            k = b - S,\n            T = g - w,\n            N = v - x,\n            P = y - E,\n            R = b + S;\n      r[t] = C, r[t + 1] = I, r[t + 2] = A, r[t + 3] = k, r[t + 4] = T, r[t + 5] = N, r[t + 6] = P, r[t + 7] = R;\n    }, r.prototype._realTransform4 = function () {\n      var t,\n          e,\n          n = this._out,\n          r = this._csize,\n          o = 1 << this._width,\n          i = r / o << 1,\n          a = this._bitrev;\n      if (4 === i) for (t = 0, e = 0; t < r; t += i, e++) {\n        const n = a[e];\n\n        this._singleRealTransform2(t, n >>> 1, o >>> 1);\n      } else for (t = 0, e = 0; t < r; t += i, e++) {\n        const n = a[e];\n\n        this._singleRealTransform4(t, n >>> 1, o >>> 1);\n      }\n      var s = this._inv ? -1 : 1,\n          u = this.table;\n\n      for (o >>= 2; o >= 2; o >>= 2) {\n        var c = (i = r / o << 1) >>> 1,\n            l = c >>> 1,\n            h = l >>> 1;\n\n        for (t = 0; t < r; t += i) for (var p = 0, f = 0; p <= h; p += 2, f += o) {\n          var d = t + p,\n              m = d + l,\n              g = m + l,\n              v = g + l,\n              y = n[d],\n              b = n[d + 1],\n              w = n[m],\n              x = n[m + 1],\n              S = n[g],\n              E = n[g + 1],\n              C = n[v],\n              I = n[v + 1],\n              A = y,\n              k = b,\n              T = u[f],\n              N = s * u[f + 1],\n              P = w * T - x * N,\n              R = w * N + x * T,\n              _ = u[2 * f],\n              M = s * u[2 * f + 1],\n              O = S * _ - E * M,\n              D = S * M + E * _,\n              F = u[3 * f],\n              L = s * u[3 * f + 1],\n              B = C * F - I * L,\n              z = C * L + I * F,\n              q = A + O,\n              V = k + D,\n              U = A - O,\n              j = k - D,\n              W = P + B,\n              G = R + z,\n              H = s * (P - B),\n              $ = s * (R - z),\n              K = q + W,\n              Q = V + G,\n              X = U + $,\n              Y = j - H;\n\n          if (n[d] = K, n[d + 1] = Q, n[m] = X, n[m + 1] = Y, 0 !== p) {\n            if (p !== h) {\n              var J = U + -s * $,\n                  Z = -j + -s * H,\n                  tt = q + -s * W,\n                  et = -V - -s * G,\n                  nt = t + l - p,\n                  rt = t + c - p;\n              n[nt] = J, n[nt + 1] = Z, n[rt] = tt, n[rt + 1] = et;\n            }\n          } else {\n            var ot = q - W,\n                it = V - G;\n            n[g] = ot, n[g + 1] = it;\n          }\n        }\n      }\n    }, r.prototype._singleRealTransform2 = function (t, e, n) {\n      const r = this._out,\n            o = this._data,\n            i = o[e],\n            a = o[e + n],\n            s = i + a,\n            u = i - a;\n      r[t] = s, r[t + 1] = 0, r[t + 2] = u, r[t + 3] = 0;\n    }, r.prototype._singleRealTransform4 = function (t, e, n) {\n      const r = this._out,\n            o = this._data,\n            i = this._inv ? -1 : 1,\n            a = 2 * n,\n            s = 3 * n,\n            u = o[e],\n            c = o[e + n],\n            l = o[e + a],\n            h = o[e + s],\n            p = u + l,\n            f = u - l,\n            d = c + h,\n            m = i * (c - h),\n            g = p + d,\n            v = f,\n            y = -m,\n            b = p - d,\n            w = f,\n            x = m;\n      r[t] = g, r[t + 1] = 0, r[t + 2] = v, r[t + 3] = y, r[t + 4] = b, r[t + 5] = 0, r[t + 6] = w, r[t + 7] = x;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = n(20);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = e;\n\n    function o() {\n      r.Reader._configure(r.BufferReader), r.util._configure();\n    }\n\n    r.build = \"minimal\", r.Writer = n(12), r.BufferWriter = n(29), r.Reader = n(13), r.BufferReader = n(30), r.util = n(7), r.rpc = n(31), r.roots = n(33), r.configure = o, r.Writer._configure(r.BufferWriter), o();\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = function (t, e) {\n      var n = new Array(arguments.length - 1),\n          r = 0,\n          o = 2,\n          i = !0;\n\n      for (; o < arguments.length;) n[r++] = arguments[o++];\n\n      return new Promise(function (o, a) {\n        n[r] = function (t) {\n          if (i) if (i = !1, t) a(t);else {\n            for (var e = new Array(arguments.length - 1), n = 0; n < e.length;) e[n++] = arguments[n];\n\n            o.apply(null, e);\n          }\n        };\n\n        try {\n          t.apply(e || null, n);\n        } catch (t) {\n          i && (i = !1, a(t));\n        }\n      });\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = e;\n\n    r.length = function (t) {\n      var e = t.length;\n      if (!e) return 0;\n\n      for (var n = 0; --e % 4 > 1 && \"=\" === t.charAt(e);) ++n;\n\n      return Math.ceil(3 * t.length) / 4 - n;\n    };\n\n    for (var o = new Array(64), i = new Array(123), a = 0; a < 64;) i[o[a] = a < 26 ? a + 65 : a < 52 ? a + 71 : a < 62 ? a - 4 : a - 59 | 43] = a++;\n\n    r.encode = function (t, e, n) {\n      for (var r, i = null, a = [], s = 0, u = 0; e < n;) {\n        var c = t[e++];\n\n        switch (u) {\n          case 0:\n            a[s++] = o[c >> 2], r = (3 & c) << 4, u = 1;\n            break;\n\n          case 1:\n            a[s++] = o[r | c >> 4], r = (15 & c) << 2, u = 2;\n            break;\n\n          case 2:\n            a[s++] = o[r | c >> 6], a[s++] = o[63 & c], u = 0;\n        }\n\n        s > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, a)), s = 0);\n      }\n\n      return u && (a[s++] = o[r], a[s++] = 61, 1 === u && (a[s++] = 61)), i ? (s && i.push(String.fromCharCode.apply(String, a.slice(0, s))), i.join(\"\")) : String.fromCharCode.apply(String, a.slice(0, s));\n    };\n\n    r.decode = function (t, e, n) {\n      for (var r, o = n, a = 0, s = 0; s < t.length;) {\n        var u = t.charCodeAt(s++);\n        if (61 === u && a > 1) break;\n        if (void 0 === (u = i[u])) throw Error(\"invalid encoding\");\n\n        switch (a) {\n          case 0:\n            r = u, a = 1;\n            break;\n\n          case 1:\n            e[n++] = r << 2 | (48 & u) >> 4, r = u, a = 2;\n            break;\n\n          case 2:\n            e[n++] = (15 & r) << 4 | (60 & u) >> 2, r = u, a = 3;\n            break;\n\n          case 3:\n            e[n++] = (3 & r) << 6 | u, a = 0;\n        }\n      }\n\n      if (1 === a) throw Error(\"invalid encoding\");\n      return n - o;\n    }, r.test = function (t) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r() {\n      this._listeners = {};\n    }\n\n    t.exports = r, r.prototype.on = function (t, e, n) {\n      return (this._listeners[t] || (this._listeners[t] = [])).push({\n        fn: e,\n        ctx: n || this\n      }), this;\n    }, r.prototype.off = function (t, e) {\n      if (void 0 === t) this._listeners = {};else if (void 0 === e) this._listeners[t] = [];else for (var n = this._listeners[t], r = 0; r < n.length;) n[r].fn === e ? n.splice(r, 1) : ++r;\n      return this;\n    }, r.prototype.emit = function (t) {\n      var e = this._listeners[t];\n\n      if (e) {\n        for (var n = [], r = 1; r < arguments.length;) n.push(arguments[r++]);\n\n        for (r = 0; r < e.length;) e[r].fn.apply(e[r++].ctx, n);\n      }\n\n      return this;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      return \"undefined\" != typeof Float32Array ? function () {\n        var e = new Float32Array([-0]),\n            n = new Uint8Array(e.buffer),\n            r = 128 === n[3];\n\n        function o(t, r, o) {\n          e[0] = t, r[o] = n[0], r[o + 1] = n[1], r[o + 2] = n[2], r[o + 3] = n[3];\n        }\n\n        function i(t, r, o) {\n          e[0] = t, r[o] = n[3], r[o + 1] = n[2], r[o + 2] = n[1], r[o + 3] = n[0];\n        }\n\n        function a(t, r) {\n          return n[0] = t[r], n[1] = t[r + 1], n[2] = t[r + 2], n[3] = t[r + 3], e[0];\n        }\n\n        function s(t, r) {\n          return n[3] = t[r], n[2] = t[r + 1], n[1] = t[r + 2], n[0] = t[r + 3], e[0];\n        }\n\n        t.writeFloatLE = r ? o : i, t.writeFloatBE = r ? i : o, t.readFloatLE = r ? a : s, t.readFloatBE = r ? s : a;\n      }() : function () {\n        function e(t, e, n, r) {\n          var o = e < 0 ? 1 : 0;\n          if (o && (e = -e), 0 === e) t(1 / e > 0 ? 0 : 2147483648, n, r);else if (isNaN(e)) t(2143289344, n, r);else if (e > 34028234663852886e22) t((o << 31 | 2139095040) >>> 0, n, r);else if (e < 11754943508222875e-54) t((o << 31 | Math.round(e / 1401298464324817e-60)) >>> 0, n, r);else {\n            var i = Math.floor(Math.log(e) / Math.LN2);\n            t((o << 31 | i + 127 << 23 | 8388607 & Math.round(e * Math.pow(2, -i) * 8388608)) >>> 0, n, r);\n          }\n        }\n\n        function n(t, e, n) {\n          var r = t(e, n),\n              o = 2 * (r >> 31) + 1,\n              i = r >>> 23 & 255,\n              a = 8388607 & r;\n          return 255 === i ? a ? NaN : o * (1 / 0) : 0 === i ? 1401298464324817e-60 * o * a : o * Math.pow(2, i - 150) * (a + 8388608);\n        }\n\n        t.writeFloatLE = e.bind(null, o), t.writeFloatBE = e.bind(null, i), t.readFloatLE = n.bind(null, a), t.readFloatBE = n.bind(null, s);\n      }(), \"undefined\" != typeof Float64Array ? function () {\n        var e = new Float64Array([-0]),\n            n = new Uint8Array(e.buffer),\n            r = 128 === n[7];\n\n        function o(t, r, o) {\n          e[0] = t, r[o] = n[0], r[o + 1] = n[1], r[o + 2] = n[2], r[o + 3] = n[3], r[o + 4] = n[4], r[o + 5] = n[5], r[o + 6] = n[6], r[o + 7] = n[7];\n        }\n\n        function i(t, r, o) {\n          e[0] = t, r[o] = n[7], r[o + 1] = n[6], r[o + 2] = n[5], r[o + 3] = n[4], r[o + 4] = n[3], r[o + 5] = n[2], r[o + 6] = n[1], r[o + 7] = n[0];\n        }\n\n        function a(t, r) {\n          return n[0] = t[r], n[1] = t[r + 1], n[2] = t[r + 2], n[3] = t[r + 3], n[4] = t[r + 4], n[5] = t[r + 5], n[6] = t[r + 6], n[7] = t[r + 7], e[0];\n        }\n\n        function s(t, r) {\n          return n[7] = t[r], n[6] = t[r + 1], n[5] = t[r + 2], n[4] = t[r + 3], n[3] = t[r + 4], n[2] = t[r + 5], n[1] = t[r + 6], n[0] = t[r + 7], e[0];\n        }\n\n        t.writeDoubleLE = r ? o : i, t.writeDoubleBE = r ? i : o, t.readDoubleLE = r ? a : s, t.readDoubleBE = r ? s : a;\n      }() : function () {\n        function e(t, e, n, r, o, i) {\n          var a = r < 0 ? 1 : 0;\n          if (a && (r = -r), 0 === r) t(0, o, i + e), t(1 / r > 0 ? 0 : 2147483648, o, i + n);else if (isNaN(r)) t(0, o, i + e), t(2146959360, o, i + n);else if (r > 17976931348623157e292) t(0, o, i + e), t((a << 31 | 2146435072) >>> 0, o, i + n);else {\n            var s;\n            if (r < 22250738585072014e-324) t((s = r / 5e-324) >>> 0, o, i + e), t((a << 31 | s / 4294967296) >>> 0, o, i + n);else {\n              var u = Math.floor(Math.log(r) / Math.LN2);\n              1024 === u && (u = 1023), t(4503599627370496 * (s = r * Math.pow(2, -u)) >>> 0, o, i + e), t((a << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, o, i + n);\n            }\n          }\n        }\n\n        function n(t, e, n, r, o) {\n          var i = t(r, o + e),\n              a = t(r, o + n),\n              s = 2 * (a >> 31) + 1,\n              u = a >>> 20 & 2047,\n              c = 4294967296 * (1048575 & a) + i;\n          return 2047 === u ? c ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * c : s * Math.pow(2, u - 1075) * (c + 4503599627370496);\n        }\n\n        t.writeDoubleLE = e.bind(null, o, 0, 4), t.writeDoubleBE = e.bind(null, i, 4, 0), t.readDoubleLE = n.bind(null, a, 0, 4), t.readDoubleBE = n.bind(null, s, 4, 0);\n      }(), t;\n    }\n\n    function o(t, e, n) {\n      e[n] = 255 & t, e[n + 1] = t >>> 8 & 255, e[n + 2] = t >>> 16 & 255, e[n + 3] = t >>> 24;\n    }\n\n    function i(t, e, n) {\n      e[n] = t >>> 24, e[n + 1] = t >>> 16 & 255, e[n + 2] = t >>> 8 & 255, e[n + 3] = 255 & t;\n    }\n\n    function a(t, e) {\n      return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0;\n    }\n\n    function s(t, e) {\n      return (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;\n    }\n\n    t.exports = r(r);\n  }, function (module, exports, __webpack_require__) {\n    \"use strict\";\n\n    function inquire(moduleName) {\n      try {\n        var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n        if (mod && (mod.length || Object.keys(mod).length)) return mod;\n      } catch (t) {}\n\n      return null;\n    }\n\n    module.exports = inquire;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = e;\n    r.length = function (t) {\n      for (var e = 0, n = 0, r = 0; r < t.length; ++r) (n = t.charCodeAt(r)) < 128 ? e += 1 : n < 2048 ? e += 2 : 55296 == (64512 & n) && 56320 == (64512 & t.charCodeAt(r + 1)) ? (++r, e += 4) : e += 3;\n\n      return e;\n    }, r.read = function (t, e, n) {\n      if (n - e < 1) return \"\";\n\n      for (var r, o = null, i = [], a = 0; e < n;) (r = t[e++]) < 128 ? i[a++] = r : r > 191 && r < 224 ? i[a++] = (31 & r) << 6 | 63 & t[e++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & t[e++]) << 12 | (63 & t[e++]) << 6 | 63 & t[e++]) - 65536, i[a++] = 55296 + (r >> 10), i[a++] = 56320 + (1023 & r)) : i[a++] = (15 & r) << 12 | (63 & t[e++]) << 6 | 63 & t[e++], a > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), a = 0);\n\n      return o ? (a && o.push(String.fromCharCode.apply(String, i.slice(0, a))), o.join(\"\")) : String.fromCharCode.apply(String, i.slice(0, a));\n    }, r.write = function (t, e, n) {\n      for (var r, o, i = n, a = 0; a < t.length; ++a) (r = t.charCodeAt(a)) < 128 ? e[n++] = r : r < 2048 ? (e[n++] = r >> 6 | 192, e[n++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (o = t.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & o), ++a, e[n++] = r >> 18 | 240, e[n++] = r >> 12 & 63 | 128, e[n++] = r >> 6 & 63 | 128, e[n++] = 63 & r | 128) : (e[n++] = r >> 12 | 224, e[n++] = r >> 6 & 63 | 128, e[n++] = 63 & r | 128);\n\n      return n - i;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = function (t, e, n) {\n      var r = n || 8192,\n          o = r >>> 1,\n          i = null,\n          a = r;\n      return function (n) {\n        if (n < 1 || n > o) return t(n);\n        a + n > r && (i = t(r), a = 0);\n        var s = e.call(i, a, a += n);\n        return 7 & a && (a = 1 + (7 | a)), s;\n      };\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = o;\n    var r = n(7);\n\n    function o(t, e) {\n      this.lo = t >>> 0, this.hi = e >>> 0;\n    }\n\n    var i = o.zero = new o(0, 0);\n    i.toNumber = function () {\n      return 0;\n    }, i.zzEncode = i.zzDecode = function () {\n      return this;\n    }, i.length = function () {\n      return 1;\n    };\n    var a = o.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n    o.fromNumber = function (t) {\n      if (0 === t) return i;\n      var e = t < 0;\n      e && (t = -t);\n      var n = t >>> 0,\n          r = (t - n) / 4294967296 >>> 0;\n      return e && (r = ~r >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++r > 4294967295 && (r = 0))), new o(n, r);\n    }, o.from = function (t) {\n      if (\"number\" == typeof t) return o.fromNumber(t);\n\n      if (r.isString(t)) {\n        if (!r.Long) return o.fromNumber(parseInt(t, 10));\n        t = r.Long.fromString(t);\n      }\n\n      return t.low || t.high ? new o(t.low >>> 0, t.high >>> 0) : i;\n    }, o.prototype.toNumber = function (t) {\n      if (!t && this.hi >>> 31) {\n        var e = 1 + ~this.lo >>> 0,\n            n = ~this.hi >>> 0;\n        return e || (n = n + 1 >>> 0), -(e + 4294967296 * n);\n      }\n\n      return this.lo + 4294967296 * this.hi;\n    }, o.prototype.toLong = function (t) {\n      return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(t)) : {\n        low: 0 | this.lo,\n        high: 0 | this.hi,\n        unsigned: Boolean(t)\n      };\n    };\n    var s = String.prototype.charCodeAt;\n    o.fromHash = function (t) {\n      return t === a ? i : new o((s.call(t, 0) | s.call(t, 1) << 8 | s.call(t, 2) << 16 | s.call(t, 3) << 24) >>> 0, (s.call(t, 4) | s.call(t, 5) << 8 | s.call(t, 6) << 16 | s.call(t, 7) << 24) >>> 0);\n    }, o.prototype.toHash = function () {\n      return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n    }, o.prototype.zzEncode = function () {\n      var t = this.hi >> 31;\n      return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t) >>> 0, this.lo = (this.lo << 1 ^ t) >>> 0, this;\n    }, o.prototype.zzDecode = function () {\n      var t = -(1 & this.lo);\n      return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t) >>> 0, this.hi = (this.hi >>> 1 ^ t) >>> 0, this;\n    }, o.prototype.length = function () {\n      var t = this.lo,\n          e = (this.lo >>> 28 | this.hi << 4) >>> 0,\n          n = this.hi >>> 24;\n      return 0 === n ? 0 === e ? t < 16384 ? t < 128 ? 1 : 2 : t < 2097152 ? 3 : 4 : e < 16384 ? e < 128 ? 5 : 6 : e < 2097152 ? 7 : 8 : n < 128 ? 9 : 10;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = a;\n    var r = n(12);\n    (a.prototype = Object.create(r.prototype)).constructor = a;\n    var o = n(7),\n        i = o.Buffer;\n\n    function a() {\n      r.call(this);\n    }\n\n    a.alloc = function (t) {\n      return (a.alloc = o._Buffer_allocUnsafe)(t);\n    };\n\n    var s = i && i.prototype instanceof Uint8Array && \"set\" === i.prototype.set.name ? function (t, e, n) {\n      e.set(t, n);\n    } : function (t, e, n) {\n      if (t.copy) t.copy(e, n, 0, t.length);else for (var r = 0; r < t.length;) e[n++] = t[r++];\n    };\n\n    function u(t, e, n) {\n      t.length < 40 ? o.utf8.write(t, e, n) : e.utf8Write(t, n);\n    }\n\n    a.prototype.bytes = function (t) {\n      o.isString(t) && (t = o._Buffer_from(t, \"base64\"));\n      var e = t.length >>> 0;\n      return this.uint32(e), e && this._push(s, e, t), this;\n    }, a.prototype.string = function (t) {\n      var e = i.byteLength(t);\n      return this.uint32(e), e && this._push(u, e, t), this;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = i;\n    var r = n(13);\n    (i.prototype = Object.create(r.prototype)).constructor = i;\n    var o = n(7);\n\n    function i(t) {\n      r.call(this, t);\n    }\n\n    o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice), i.prototype.string = function () {\n      var t = this.uint32();\n      return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t, this.len));\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    e.Service = n(32);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = o;\n    var r = n(7);\n\n    function o(t, e, n) {\n      if (\"function\" != typeof t) throw TypeError(\"rpcImpl must be a function\");\n      r.EventEmitter.call(this), this.rpcImpl = t, this.requestDelimited = Boolean(e), this.responseDelimited = Boolean(n);\n    }\n\n    (o.prototype = Object.create(r.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function t(e, n, o, i, a) {\n      if (!i) throw TypeError(\"request must be specified\");\n      var s = this;\n      if (!a) return r.asPromise(t, s, e, n, o, i);\n      if (s.rpcImpl) try {\n        return s.rpcImpl(e, n[s.requestDelimited ? \"encodeDelimited\" : \"encode\"](i).finish(), function (t, n) {\n          if (t) return s.emit(\"error\", t, e), a(t);\n\n          if (null !== n) {\n            if (!(n instanceof o)) try {\n              n = o[s.responseDelimited ? \"decodeDelimited\" : \"decode\"](n);\n            } catch (t) {\n              return s.emit(\"error\", t, e), a(t);\n            }\n            return s.emit(\"data\", n, e), a(null, n);\n          }\n\n          s.end(!0);\n        });\n      } catch (t) {\n        return s.emit(\"error\", t, e), void setTimeout(function () {\n          a(t);\n        }, 0);\n      } else setTimeout(function () {\n        a(Error(\"already ended\"));\n      }, 0);\n    }, o.prototype.end = function (t) {\n      return this.rpcImpl && (t || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = {};\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(39),\n        o = {\n      body: \"\",\n      args: [],\n      thisVars: [],\n      localVars: []\n    };\n\n    function i(t) {\n      if (!t) return o;\n\n      for (var e = 0; e < t.args.length; ++e) {\n        var n = t.args[e];\n        t.args[e] = 0 === e ? {\n          name: n,\n          lvalue: !0,\n          rvalue: !!t.rvalue,\n          count: t.count || 1\n        } : {\n          name: n,\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        };\n      }\n\n      return t.thisVars || (t.thisVars = []), t.localVars || (t.localVars = []), t;\n    }\n\n    function a(t) {\n      for (var e = [], n = 0; n < t.args.length; ++n) e.push(\"a\" + n);\n\n      return new Function(\"P\", [\"return function \", t.funcName, \"_ndarrayops(\", e.join(\",\"), \") {P(\", e.join(\",\"), \");return a0}\"].join(\"\"))(function (t) {\n        return r({\n          args: t.args,\n          pre: i(t.pre),\n          body: i(t.body),\n          post: i(t.proc),\n          funcName: t.funcName\n        });\n      }(t));\n    }\n\n    var s = {\n      add: \"+\",\n      sub: \"-\",\n      mul: \"*\",\n      div: \"/\",\n      mod: \"%\",\n      band: \"&\",\n      bor: \"|\",\n      bxor: \"^\",\n      lshift: \"<<\",\n      rshift: \">>\",\n      rrshift: \">>>\"\n    };\n    !function () {\n      for (var t in s) {\n        var n = s[t];\n        e[t] = a({\n          args: [\"array\", \"array\", \"array\"],\n          body: {\n            args: [\"a\", \"b\", \"c\"],\n            body: \"a=b\" + n + \"c\"\n          },\n          funcName: t\n        }), e[t + \"eq\"] = a({\n          args: [\"array\", \"array\"],\n          body: {\n            args: [\"a\", \"b\"],\n            body: \"a\" + n + \"=b\"\n          },\n          rvalue: !0,\n          funcName: t + \"eq\"\n        }), e[t + \"s\"] = a({\n          args: [\"array\", \"array\", \"scalar\"],\n          body: {\n            args: [\"a\", \"b\", \"s\"],\n            body: \"a=b\" + n + \"s\"\n          },\n          funcName: t + \"s\"\n        }), e[t + \"seq\"] = a({\n          args: [\"array\", \"scalar\"],\n          body: {\n            args: [\"a\", \"s\"],\n            body: \"a\" + n + \"=s\"\n          },\n          rvalue: !0,\n          funcName: t + \"seq\"\n        });\n      }\n    }();\n    var u = {\n      not: \"!\",\n      bnot: \"~\",\n      neg: \"-\",\n      recip: \"1.0/\"\n    };\n    !function () {\n      for (var t in u) {\n        var n = u[t];\n        e[t] = a({\n          args: [\"array\", \"array\"],\n          body: {\n            args: [\"a\", \"b\"],\n            body: \"a=\" + n + \"b\"\n          },\n          funcName: t\n        }), e[t + \"eq\"] = a({\n          args: [\"array\"],\n          body: {\n            args: [\"a\"],\n            body: \"a=\" + n + \"a\"\n          },\n          rvalue: !0,\n          count: 2,\n          funcName: t + \"eq\"\n        });\n      }\n    }();\n    var c = {\n      and: \"&&\",\n      or: \"||\",\n      eq: \"===\",\n      neq: \"!==\",\n      lt: \"<\",\n      gt: \">\",\n      leq: \"<=\",\n      geq: \">=\"\n    };\n    !function () {\n      for (var t in c) {\n        var n = c[t];\n        e[t] = a({\n          args: [\"array\", \"array\", \"array\"],\n          body: {\n            args: [\"a\", \"b\", \"c\"],\n            body: \"a=b\" + n + \"c\"\n          },\n          funcName: t\n        }), e[t + \"s\"] = a({\n          args: [\"array\", \"array\", \"scalar\"],\n          body: {\n            args: [\"a\", \"b\", \"s\"],\n            body: \"a=b\" + n + \"s\"\n          },\n          funcName: t + \"s\"\n        }), e[t + \"eq\"] = a({\n          args: [\"array\", \"array\"],\n          body: {\n            args: [\"a\", \"b\"],\n            body: \"a=a\" + n + \"b\"\n          },\n          rvalue: !0,\n          count: 2,\n          funcName: t + \"eq\"\n        }), e[t + \"seq\"] = a({\n          args: [\"array\", \"scalar\"],\n          body: {\n            args: [\"a\", \"s\"],\n            body: \"a=a\" + n + \"s\"\n          },\n          rvalue: !0,\n          count: 2,\n          funcName: t + \"seq\"\n        });\n      }\n    }();\n    var l = [\"abs\", \"acos\", \"asin\", \"atan\", \"ceil\", \"cos\", \"exp\", \"floor\", \"log\", \"round\", \"sin\", \"sqrt\", \"tan\"];\n    !function () {\n      for (var t = 0; t < l.length; ++t) {\n        var n = l[t];\n        e[n] = a({\n          args: [\"array\", \"array\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\"],\n            body: \"a=this_f(b)\",\n            thisVars: [\"this_f\"]\n          },\n          funcName: n\n        }), e[n + \"eq\"] = a({\n          args: [\"array\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\"],\n            body: \"a=this_f(a)\",\n            thisVars: [\"this_f\"]\n          },\n          rvalue: !0,\n          count: 2,\n          funcName: n + \"eq\"\n        });\n      }\n    }();\n    var h = [\"max\", \"min\", \"atan2\", \"pow\"];\n    !function () {\n      for (var t = 0; t < h.length; ++t) {\n        var n = h[t];\n        e[n] = a({\n          args: [\"array\", \"array\", \"array\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\", \"c\"],\n            body: \"a=this_f(b,c)\",\n            thisVars: [\"this_f\"]\n          },\n          funcName: n\n        }), e[n + \"s\"] = a({\n          args: [\"array\", \"array\", \"scalar\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\", \"c\"],\n            body: \"a=this_f(b,c)\",\n            thisVars: [\"this_f\"]\n          },\n          funcName: n + \"s\"\n        }), e[n + \"eq\"] = a({\n          args: [\"array\", \"array\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\"],\n            body: \"a=this_f(a,b)\",\n            thisVars: [\"this_f\"]\n          },\n          rvalue: !0,\n          count: 2,\n          funcName: n + \"eq\"\n        }), e[n + \"seq\"] = a({\n          args: [\"array\", \"scalar\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\"],\n            body: \"a=this_f(a,b)\",\n            thisVars: [\"this_f\"]\n          },\n          rvalue: !0,\n          count: 2,\n          funcName: n + \"seq\"\n        });\n      }\n    }();\n    var p = [\"atan2\", \"pow\"];\n    !function () {\n      for (var t = 0; t < p.length; ++t) {\n        var n = p[t];\n        e[n + \"op\"] = a({\n          args: [\"array\", \"array\", \"array\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\", \"c\"],\n            body: \"a=this_f(c,b)\",\n            thisVars: [\"this_f\"]\n          },\n          funcName: n + \"op\"\n        }), e[n + \"ops\"] = a({\n          args: [\"array\", \"array\", \"scalar\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\", \"c\"],\n            body: \"a=this_f(c,b)\",\n            thisVars: [\"this_f\"]\n          },\n          funcName: n + \"ops\"\n        }), e[n + \"opeq\"] = a({\n          args: [\"array\", \"array\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\"],\n            body: \"a=this_f(b,a)\",\n            thisVars: [\"this_f\"]\n          },\n          rvalue: !0,\n          count: 2,\n          funcName: n + \"opeq\"\n        }), e[n + \"opseq\"] = a({\n          args: [\"array\", \"scalar\"],\n          pre: {\n            args: [],\n            body: \"this_f=Math.\" + n,\n            thisVars: [\"this_f\"]\n          },\n          body: {\n            args: [\"a\", \"b\"],\n            body: \"a=this_f(b,a)\",\n            thisVars: [\"this_f\"]\n          },\n          rvalue: !0,\n          count: 2,\n          funcName: n + \"opseq\"\n        });\n      }\n    }(), e.any = r({\n      args: [\"array\"],\n      pre: o,\n      body: {\n        args: [{\n          name: \"a\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        }],\n        body: \"if(a){return true}\",\n        localVars: [],\n        thisVars: []\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [],\n        body: \"return false\"\n      },\n      funcName: \"any\"\n    }), e.all = r({\n      args: [\"array\"],\n      pre: o,\n      body: {\n        args: [{\n          name: \"x\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        }],\n        body: \"if(!x){return false}\",\n        localVars: [],\n        thisVars: []\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [],\n        body: \"return true\"\n      },\n      funcName: \"all\"\n    }), e.sum = r({\n      args: [\"array\"],\n      pre: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"this_s=0\"\n      },\n      body: {\n        args: [{\n          name: \"a\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        }],\n        body: \"this_s+=a\",\n        localVars: [],\n        thisVars: [\"this_s\"]\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"return this_s\"\n      },\n      funcName: \"sum\"\n    }), e.prod = r({\n      args: [\"array\"],\n      pre: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"this_s=1\"\n      },\n      body: {\n        args: [{\n          name: \"a\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        }],\n        body: \"this_s*=a\",\n        localVars: [],\n        thisVars: [\"this_s\"]\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"return this_s\"\n      },\n      funcName: \"prod\"\n    }), e.norm2squared = r({\n      args: [\"array\"],\n      pre: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"this_s=0\"\n      },\n      body: {\n        args: [{\n          name: \"a\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 2\n        }],\n        body: \"this_s+=a*a\",\n        localVars: [],\n        thisVars: [\"this_s\"]\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"return this_s\"\n      },\n      funcName: \"norm2squared\"\n    }), e.norm2 = r({\n      args: [\"array\"],\n      pre: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"this_s=0\"\n      },\n      body: {\n        args: [{\n          name: \"a\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 2\n        }],\n        body: \"this_s+=a*a\",\n        localVars: [],\n        thisVars: [\"this_s\"]\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"return Math.sqrt(this_s)\"\n      },\n      funcName: \"norm2\"\n    }), e.norminf = r({\n      args: [\"array\"],\n      pre: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"this_s=0\"\n      },\n      body: {\n        args: [{\n          name: \"a\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 4\n        }],\n        body: \"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}\",\n        localVars: [],\n        thisVars: [\"this_s\"]\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"return this_s\"\n      },\n      funcName: \"norminf\"\n    }), e.norm1 = r({\n      args: [\"array\"],\n      pre: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"this_s=0\"\n      },\n      body: {\n        args: [{\n          name: \"a\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 3\n        }],\n        body: \"this_s+=a<0?-a:a\",\n        localVars: [],\n        thisVars: [\"this_s\"]\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [\"this_s\"],\n        body: \"return this_s\"\n      },\n      funcName: \"norm1\"\n    }), e.sup = r({\n      args: [\"array\"],\n      pre: {\n        body: \"this_h=-Infinity\",\n        args: [],\n        thisVars: [\"this_h\"],\n        localVars: []\n      },\n      body: {\n        body: \"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_\",\n        args: [{\n          name: \"_inline_1_arg0_\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 2\n        }],\n        thisVars: [\"this_h\"],\n        localVars: []\n      },\n      post: {\n        body: \"return this_h\",\n        args: [],\n        thisVars: [\"this_h\"],\n        localVars: []\n      }\n    }), e.inf = r({\n      args: [\"array\"],\n      pre: {\n        body: \"this_h=Infinity\",\n        args: [],\n        thisVars: [\"this_h\"],\n        localVars: []\n      },\n      body: {\n        body: \"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_\",\n        args: [{\n          name: \"_inline_1_arg0_\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 2\n        }],\n        thisVars: [\"this_h\"],\n        localVars: []\n      },\n      post: {\n        body: \"return this_h\",\n        args: [],\n        thisVars: [\"this_h\"],\n        localVars: []\n      }\n    }), e.argmin = r({\n      args: [\"index\", \"array\", \"shape\"],\n      pre: {\n        body: \"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n        args: [{\n          name: \"_inline_0_arg0_\",\n          lvalue: !1,\n          rvalue: !1,\n          count: 0\n        }, {\n          name: \"_inline_0_arg1_\",\n          lvalue: !1,\n          rvalue: !1,\n          count: 0\n        }, {\n          name: \"_inline_0_arg2_\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        }],\n        thisVars: [\"this_i\", \"this_v\"],\n        localVars: []\n      },\n      body: {\n        body: \"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n        args: [{\n          name: \"_inline_1_arg0_\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 2\n        }, {\n          name: \"_inline_1_arg1_\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 2\n        }],\n        thisVars: [\"this_i\", \"this_v\"],\n        localVars: [\"_inline_1_k\"]\n      },\n      post: {\n        body: \"{return this_i}\",\n        args: [],\n        thisVars: [\"this_i\"],\n        localVars: []\n      }\n    }), e.argmax = r({\n      args: [\"index\", \"array\", \"shape\"],\n      pre: {\n        body: \"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}\",\n        args: [{\n          name: \"_inline_0_arg0_\",\n          lvalue: !1,\n          rvalue: !1,\n          count: 0\n        }, {\n          name: \"_inline_0_arg1_\",\n          lvalue: !1,\n          rvalue: !1,\n          count: 0\n        }, {\n          name: \"_inline_0_arg2_\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        }],\n        thisVars: [\"this_i\", \"this_v\"],\n        localVars: []\n      },\n      body: {\n        body: \"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}\",\n        args: [{\n          name: \"_inline_1_arg0_\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 2\n        }, {\n          name: \"_inline_1_arg1_\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 2\n        }],\n        thisVars: [\"this_i\", \"this_v\"],\n        localVars: [\"_inline_1_k\"]\n      },\n      post: {\n        body: \"{return this_i}\",\n        args: [],\n        thisVars: [\"this_i\"],\n        localVars: []\n      }\n    }), e.random = a({\n      args: [\"array\"],\n      pre: {\n        args: [],\n        body: \"this_f=Math.random\",\n        thisVars: [\"this_f\"]\n      },\n      body: {\n        args: [\"a\"],\n        body: \"a=this_f()\",\n        thisVars: [\"this_f\"]\n      },\n      funcName: \"random\"\n    }), e.assign = a({\n      args: [\"array\", \"array\"],\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=b\"\n      },\n      funcName: \"assign\"\n    }), e.assigns = a({\n      args: [\"array\", \"scalar\"],\n      body: {\n        args: [\"a\", \"b\"],\n        body: \"a=b\"\n      },\n      funcName: \"assigns\"\n    }), e.equals = r({\n      args: [\"array\", \"array\"],\n      pre: o,\n      body: {\n        args: [{\n          name: \"x\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        }, {\n          name: \"y\",\n          lvalue: !1,\n          rvalue: !0,\n          count: 1\n        }],\n        body: \"if(x!==y){return false}\",\n        localVars: [],\n        thisVars: []\n      },\n      post: {\n        args: [],\n        localVars: [],\n        thisVars: [],\n        body: \"return true\"\n      },\n      funcName: \"equals\"\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e), n.d(e, \"auxiliaryInputFromSpec\", function () {\n      return o;\n    }), n.d(e, \"AuxiliaryInput\", function () {\n      return i;\n    }), n.d(e, \"BinaryCounter\", function () {\n      return a;\n    });\n    var r = n(0);\n\n    function o(t) {\n      switch (t.type) {\n        case \"BinaryCounter\":\n          return new a(t.args);\n\n        default:\n          throw new Error(\"Unknown auxiliary input: \".concat(t));\n      }\n    }\n\n    class i {\n      constructor(t) {\n        this.depth = t;\n      }\n\n    }\n\n    class a extends i {\n      constructor(t) {\n        super(t.numBits);\n      }\n\n      getTensors(t) {\n        const e = r.buffer([t, this.depth]);\n\n        for (let n = 0; n < t; ++n) for (let t = 0; t < this.depth; ++t) e.set(Math.floor((n + 1) / Math.pow(2, t)) % 2 ? 1 : -1, n, t);\n\n        return e.toTensor().as2D(t, this.depth);\n      }\n\n    }\n  }, function (t) {\n    t.exports = JSON.parse('{\"chromatic\":[\"1P 2m 2M 3m 3M 4P 4A 5P 6m 6M 7m 7M\"],\"lydian\":[\"1P 2M 3M 4A 5P 6M 7M\"],\"major\":[\"1P 2M 3M 4P 5P 6M 7M\",[\"ionian\"]],\"mixolydian\":[\"1P 2M 3M 4P 5P 6M 7m\",[\"dominant\"]],\"dorian\":[\"1P 2M 3m 4P 5P 6M 7m\"],\"aeolian\":[\"1P 2M 3m 4P 5P 6m 7m\",[\"minor\"]],\"phrygian\":[\"1P 2m 3m 4P 5P 6m 7m\"],\"locrian\":[\"1P 2m 3m 4P 5d 6m 7m\"],\"melodic minor\":[\"1P 2M 3m 4P 5P 6M 7M\"],\"melodic minor second mode\":[\"1P 2m 3m 4P 5P 6M 7m\"],\"lydian augmented\":[\"1P 2M 3M 4A 5A 6M 7M\"],\"lydian dominant\":[\"1P 2M 3M 4A 5P 6M 7m\",[\"lydian b7\"]],\"melodic minor fifth mode\":[\"1P 2M 3M 4P 5P 6m 7m\",[\"hindu\",\"mixolydian b6M\"]],\"locrian #2\":[\"1P 2M 3m 4P 5d 6m 7m\",[\"half-diminished\"]],\"altered\":[\"1P 2m 3m 3M 5d 6m 7m\",[\"super locrian\",\"diminished whole tone\",\"pomeroy\"]],\"harmonic minor\":[\"1P 2M 3m 4P 5P 6m 7M\"],\"phrygian dominant\":[\"1P 2m 3M 4P 5P 6m 7m\",[\"spanish\",\"phrygian major\"]],\"half-whole diminished\":[\"1P 2m 3m 3M 4A 5P 6M 7m\",[\"dominant diminished\"]],\"diminished\":[\"1P 2M 3m 4P 5d 6m 6M 7M\",[\"whole-half diminished\"]],\"major pentatonic\":[\"1P 2M 3M 5P 6M\",[\"pentatonic\"]],\"lydian pentatonic\":[\"1P 3M 4A 5P 7M\",[\"chinese\"]],\"mixolydian pentatonic\":[\"1P 3M 4P 5P 7m\",[\"indian\"]],\"locrian pentatonic\":[\"1P 3m 4P 5d 7m\",[\"minor seven flat five pentatonic\"]],\"minor pentatonic\":[\"1P 3m 4P 5P 7m\"],\"minor six pentatonic\":[\"1P 3m 4P 5P 6M\"],\"minor hexatonic\":[\"1P 2M 3m 4P 5P 7M\"],\"flat three pentatonic\":[\"1P 2M 3m 5P 6M\",[\"kumoi\"]],\"flat six pentatonic\":[\"1P 2M 3M 5P 6m\"],\"major flat two pentatonic\":[\"1P 2m 3M 5P 6M\"],\"whole tone pentatonic\":[\"1P 3M 5d 6m 7m\"],\"ionian pentatonic\":[\"1P 3M 4P 5P 7M\"],\"lydian #5P pentatonic\":[\"1P 3M 4A 5A 7M\"],\"lydian dominant pentatonic\":[\"1P 3M 4A 5P 7m\"],\"minor #7M pentatonic\":[\"1P 3m 4P 5P 7M\"],\"super locrian pentatonic\":[\"1P 3m 4d 5d 7m\"],\"in-sen\":[\"1P 2m 4P 5P 7m\"],\"iwato\":[\"1P 2m 4P 5d 7m\"],\"hirajoshi\":[\"1P 2M 3m 5P 6m\"],\"kumoijoshi\":[\"1P 2m 4P 5P 6m\"],\"pelog\":[\"1P 2m 3m 5P 6m\"],\"vietnamese 1\":[\"1P 3m 4P 5P 6m\"],\"vietnamese 2\":[\"1P 3m 4P 5P 7m\"],\"prometheus\":[\"1P 2M 3M 4A 6M 7m\"],\"prometheus neopolitan\":[\"1P 2m 3M 4A 6M 7m\"],\"ritusen\":[\"1P 2M 4P 5P 6M\"],\"scriabin\":[\"1P 2m 3M 5P 6M\"],\"piongio\":[\"1P 2M 4P 5P 6M 7m\"],\"major blues\":[\"1P 2M 3m 3M 5P 6M\"],\"minor blues\":[\"1P 3m 4P 5d 5P 7m\",[\"blues\"]],\"composite blues\":[\"1P 2M 3m 3M 4P 5d 5P 6M 7m\"],\"augmented\":[\"1P 2A 3M 5P 5A 7M\"],\"augmented heptatonic\":[\"1P 2A 3M 4P 5P 5A 7M\"],\"dorian #4\":[\"1P 2M 3m 4A 5P 6M 7m\"],\"lydian diminished\":[\"1P 2M 3m 4A 5P 6M 7M\"],\"whole tone\":[\"1P 2M 3M 4A 5A 7m\"],\"leading whole tone\":[\"1P 2M 3M 4A 5A 7m 7M\"],\"lydian minor\":[\"1P 2M 3M 4A 5P 6m 7m\"],\"locrian major\":[\"1P 2M 3M 4P 5d 6m 7m\",[\"arabian\"]],\"neopolitan\":[\"1P 2m 3m 4P 5P 6m 7M\"],\"neopolitan minor\":[\"1P 2m 3m 4P 5P 6m 7M\"],\"neopolitan major\":[\"1P 2m 3m 4P 5P 6M 7M\",[\"dorian b2\"]],\"neopolitan major pentatonic\":[\"1P 3M 4P 5d 7m\"],\"romanian minor\":[\"1P 2M 3m 5d 5P 6M 7m\"],\"double harmonic lydian\":[\"1P 2m 3M 4A 5P 6m 7M\"],\"harmonic major\":[\"1P 2M 3M 4P 5P 6m 7M\"],\"double harmonic major\":[\"1P 2m 3M 4P 5P 6m 7M\",[\"gypsy\"]],\"egyptian\":[\"1P 2M 4P 5P 7m\"],\"hungarian minor\":[\"1P 2M 3m 4A 5P 6m 7M\"],\"hungarian major\":[\"1P 2A 3M 4A 5P 6M 7m\"],\"oriental\":[\"1P 2m 3M 4P 5d 6M 7m\"],\"spanish heptatonic\":[\"1P 2m 3m 3M 4P 5P 6m 7m\"],\"flamenco\":[\"1P 2m 3m 3M 4A 5P 7m\"],\"balinese\":[\"1P 2m 3m 4P 5P 6m 7M\"],\"todi raga\":[\"1P 2m 3m 4A 5P 6m 7M\"],\"malkos raga\":[\"1P 3m 4P 6m 7m\"],\"kafi raga\":[\"1P 3m 3M 4P 5P 6M 7m 7M\"],\"purvi raga\":[\"1P 2m 3M 4P 4A 5P 6m 7M\"],\"persian\":[\"1P 2m 3M 4P 5d 6m 7M\"],\"bebop\":[\"1P 2M 3M 4P 5P 6M 7m 7M\"],\"bebop dominant\":[\"1P 2M 3M 4P 5P 6M 7m 7M\"],\"bebop minor\":[\"1P 2M 3m 3M 4P 5P 6M 7m\"],\"bebop major\":[\"1P 2M 3M 4P 5P 5A 6M 7M\"],\"bebop locrian\":[\"1P 2m 3m 4P 5d 5P 6m 7m\"],\"minor bebop\":[\"1P 2M 3m 4P 5P 6m 7m 7M\"],\"mystery #1\":[\"1P 2m 3M 5d 6m 7m\"],\"enigmatic\":[\"1P 2m 3M 5d 6m 7m 7M\"],\"minor six diminished\":[\"1P 2M 3m 4P 5P 6m 6M 7M\"],\"ionian augmented\":[\"1P 2M 3M 4P 5A 6M 7M\"],\"lydian #9\":[\"1P 2m 3M 4A 5P 6M 7M\"],\"ichikosucho\":[\"1P 2M 3M 4P 5d 5P 6M 7M\"],\"six tone symmetric\":[\"1P 2m 3M 4P 5A 6M\"]}');\n  }, function (t) {\n    t.exports = JSON.parse('{\"4\":[\"1P 4P 7m 10m\",[\"quartal\"]],\"5\":[\"1P 5P\"],\"7\":[\"1P 3M 5P 7m\",[\"Dominant\",\"Dom\"]],\"9\":[\"1P 3M 5P 7m 9M\",[\"79\"]],\"11\":[\"1P 5P 7m 9M 11P\"],\"13\":[\"1P 3M 5P 7m 9M 13M\",[\"13_\"]],\"64\":[\"5P 8P 10M\"],\"M\":[\"1P 3M 5P\",[\"Major\",\"\"]],\"M#5\":[\"1P 3M 5A\",[\"augmented\",\"maj#5\",\"Maj#5\",\"+\",\"aug\"]],\"M#5add9\":[\"1P 3M 5A 9M\",[\"+add9\"]],\"M13\":[\"1P 3M 5P 7M 9M 13M\",[\"maj13\",\"Maj13\"]],\"M13#11\":[\"1P 3M 5P 7M 9M 11A 13M\",[\"maj13#11\",\"Maj13#11\",\"M13+4\",\"M13#4\"]],\"M6\":[\"1P 3M 5P 13M\",[\"6\"]],\"M6#11\":[\"1P 3M 5P 6M 11A\",[\"M6b5\",\"6#11\",\"6b5\"]],\"M69\":[\"1P 3M 5P 6M 9M\",[\"69\"]],\"M69#11\":[\"1P 3M 5P 6M 9M 11A\"],\"M7#11\":[\"1P 3M 5P 7M 11A\",[\"maj7#11\",\"Maj7#11\",\"M7+4\",\"M7#4\"]],\"M7#5\":[\"1P 3M 5A 7M\",[\"maj7#5\",\"Maj7#5\",\"maj9#5\",\"M7+\"]],\"M7#5sus4\":[\"1P 4P 5A 7M\"],\"M7#9#11\":[\"1P 3M 5P 7M 9A 11A\"],\"M7add13\":[\"1P 3M 5P 6M 7M 9M\"],\"M7b5\":[\"1P 3M 5d 7M\"],\"M7b6\":[\"1P 3M 6m 7M\"],\"M7b9\":[\"1P 3M 5P 7M 9m\"],\"M7sus4\":[\"1P 4P 5P 7M\"],\"M9\":[\"1P 3M 5P 7M 9M\",[\"maj9\",\"Maj9\"]],\"M9#11\":[\"1P 3M 5P 7M 9M 11A\",[\"maj9#11\",\"Maj9#11\",\"M9+4\",\"M9#4\"]],\"M9#5\":[\"1P 3M 5A 7M 9M\",[\"Maj9#5\"]],\"M9#5sus4\":[\"1P 4P 5A 7M 9M\"],\"M9b5\":[\"1P 3M 5d 7M 9M\"],\"M9sus4\":[\"1P 4P 5P 7M 9M\"],\"Madd9\":[\"1P 3M 5P 9M\",[\"2\",\"add9\",\"add2\"]],\"Maj7\":[\"1P 3M 5P 7M\",[\"maj7\",\"M7\"]],\"Mb5\":[\"1P 3M 5d\"],\"Mb6\":[\"1P 3M 13m\"],\"Msus2\":[\"1P 2M 5P\",[\"add9no3\",\"sus2\"]],\"Msus4\":[\"1P 4P 5P\",[\"sus\",\"sus4\"]],\"Maddb9\":[\"1P 3M 5P 9m\"],\"11b9\":[\"1P 5P 7m 9m 11P\"],\"13#11\":[\"1P 3M 5P 7m 9M 11A 13M\",[\"13+4\",\"13#4\"]],\"13#9\":[\"1P 3M 5P 7m 9A 13M\",[\"13#9_\"]],\"13#9#11\":[\"1P 3M 5P 7m 9A 11A 13M\"],\"13b5\":[\"1P 3M 5d 6M 7m 9M\"],\"13b9\":[\"1P 3M 5P 7m 9m 13M\"],\"13b9#11\":[\"1P 3M 5P 7m 9m 11A 13M\"],\"13no5\":[\"1P 3M 7m 9M 13M\"],\"13sus4\":[\"1P 4P 5P 7m 9M 13M\",[\"13sus\"]],\"69#11\":[\"1P 3M 5P 6M 9M 11A\"],\"7#11\":[\"1P 3M 5P 7m 11A\",[\"7+4\",\"7#4\",\"7#11_\",\"7#4_\"]],\"7#11b13\":[\"1P 3M 5P 7m 11A 13m\",[\"7b5b13\"]],\"7#5\":[\"1P 3M 5A 7m\",[\"+7\",\"7aug\",\"aug7\"]],\"7#5#9\":[\"1P 3M 5A 7m 9A\",[\"7alt\",\"7#5#9_\",\"7#9b13_\"]],\"7#5b9\":[\"1P 3M 5A 7m 9m\"],\"7#5b9#11\":[\"1P 3M 5A 7m 9m 11A\"],\"7#5sus4\":[\"1P 4P 5A 7m\"],\"7#9\":[\"1P 3M 5P 7m 9A\",[\"7#9_\"]],\"7#9#11\":[\"1P 3M 5P 7m 9A 11A\",[\"7b5#9\"]],\"7#9#11b13\":[\"1P 3M 5P 7m 9A 11A 13m\"],\"7#9b13\":[\"1P 3M 5P 7m 9A 13m\"],\"7add6\":[\"1P 3M 5P 7m 13M\",[\"67\",\"7add13\"]],\"7b13\":[\"1P 3M 7m 13m\"],\"7b5\":[\"1P 3M 5d 7m\"],\"7b6\":[\"1P 3M 5P 6m 7m\"],\"7b9\":[\"1P 3M 5P 7m 9m\"],\"7b9#11\":[\"1P 3M 5P 7m 9m 11A\",[\"7b5b9\"]],\"7b9#9\":[\"1P 3M 5P 7m 9m 9A\"],\"7b9b13\":[\"1P 3M 5P 7m 9m 13m\"],\"7b9b13#11\":[\"1P 3M 5P 7m 9m 11A 13m\",[\"7b9#11b13\",\"7b5b9b13\"]],\"7no5\":[\"1P 3M 7m\"],\"7sus4\":[\"1P 4P 5P 7m\",[\"7sus\"]],\"7sus4b9\":[\"1P 4P 5P 7m 9m\",[\"susb9\",\"7susb9\",\"7b9sus\",\"7b9sus4\",\"phryg\"]],\"7sus4b9b13\":[\"1P 4P 5P 7m 9m 13m\",[\"7b9b13sus4\"]],\"9#11\":[\"1P 3M 5P 7m 9M 11A\",[\"9+4\",\"9#4\",\"9#11_\",\"9#4_\"]],\"9#11b13\":[\"1P 3M 5P 7m 9M 11A 13m\",[\"9b5b13\"]],\"9#5\":[\"1P 3M 5A 7m 9M\",[\"9+\"]],\"9#5#11\":[\"1P 3M 5A 7m 9M 11A\"],\"9b13\":[\"1P 3M 7m 9M 13m\"],\"9b5\":[\"1P 3M 5d 7m 9M\"],\"9no5\":[\"1P 3M 7m 9M\"],\"9sus4\":[\"1P 4P 5P 7m 9M\",[\"9sus\"]],\"m\":[\"1P 3m 5P\"],\"m#5\":[\"1P 3m 5A\",[\"m+\",\"mb6\"]],\"m11\":[\"1P 3m 5P 7m 9M 11P\",[\"_11\"]],\"m11A 5\":[\"1P 3m 6m 7m 9M 11P\"],\"m11b5\":[\"1P 3m 7m 12d 2M 4P\",[\"h11\",\"_11b5\"]],\"m13\":[\"1P 3m 5P 7m 9M 11P 13M\",[\"_13\"]],\"m6\":[\"1P 3m 4P 5P 13M\",[\"_6\"]],\"m69\":[\"1P 3m 5P 6M 9M\",[\"_69\"]],\"m7\":[\"1P 3m 5P 7m\",[\"minor7\",\"_\",\"_7\"]],\"m7#5\":[\"1P 3m 6m 7m\"],\"m7add11\":[\"1P 3m 5P 7m 11P\",[\"m7add4\"]],\"m7b5\":[\"1P 3m 5d 7m\",[\"half-diminished\",\"h7\",\"_7b5\"]],\"m9\":[\"1P 3m 5P 7m 9M\",[\"_9\"]],\"m9#5\":[\"1P 3m 6m 7m 9M\"],\"m9b5\":[\"1P 3m 7m 12d 2M\",[\"h9\",\"-9b5\"]],\"mMaj7\":[\"1P 3m 5P 7M\",[\"mM7\",\"_M7\"]],\"mMaj7b6\":[\"1P 3m 5P 6m 7M\",[\"mM7b6\"]],\"mM9\":[\"1P 3m 5P 7M 9M\",[\"mMaj9\",\"-M9\"]],\"mM9b6\":[\"1P 3m 5P 6m 7M 9M\",[\"mMaj9b6\"]],\"mb6M7\":[\"1P 3m 6m 7M\"],\"mb6b9\":[\"1P 3m 6m 9m\"],\"o\":[\"1P 3m 5d\",[\"mb5\",\"dim\"]],\"o7\":[\"1P 3m 5d 13M\",[\"diminished\",\"m6b5\",\"dim7\"]],\"o7M7\":[\"1P 3m 5d 6M 7M\"],\"oM7\":[\"1P 3m 5d 7M\"],\"sus24\":[\"1P 2M 4P 5P\",[\"sus4add9\"]],\"+add#9\":[\"1P 3M 5A 9A\"],\"madd4\":[\"1P 3m 4P 5P\"],\"madd9\":[\"1P 3m 5P 9M\"]}');\n  }, function (t, e, n) {\n    \"use strict\";\n\n    (function (t) {\n      /*!\n       * The buffer module from node.js, for the browser.\n       *\n       * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n       * @license  MIT\n       */\n      var r = n(44),\n          o = n(45),\n          i = n(46);\n\n      function a() {\n        return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;\n      }\n\n      function s(t, e) {\n        if (a() < e) throw new RangeError(\"Invalid typed array length\");\n        return u.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = u.prototype : (null === t && (t = new u(e)), t.length = e), t;\n      }\n\n      function u(t, e, n) {\n        if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u)) return new u(t, e, n);\n\n        if (\"number\" == typeof t) {\n          if (\"string\" == typeof e) throw new Error(\"If encoding is specified then the first argument must be a string\");\n          return h(this, t);\n        }\n\n        return c(this, t, e, n);\n      }\n\n      function c(t, e, n, r) {\n        if (\"number\" == typeof e) throw new TypeError('\"value\" argument must not be a number');\n        return \"undefined\" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, n, r) {\n          if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError(\"'offset' is out of bounds\");\n          if (e.byteLength < n + (r || 0)) throw new RangeError(\"'length' is out of bounds\");\n          e = void 0 === n && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, n) : new Uint8Array(e, n, r);\n          u.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = u.prototype : t = p(t, e);\n          return t;\n        }(t, e, n, r) : \"string\" == typeof e ? function (t, e, n) {\n          \"string\" == typeof n && \"\" !== n || (n = \"utf8\");\n          if (!u.isEncoding(n)) throw new TypeError('\"encoding\" must be a valid string encoding');\n          var r = 0 | d(e, n),\n              o = (t = s(t, r)).write(e, n);\n          o !== r && (t = t.slice(0, o));\n          return t;\n        }(t, e, n) : function (t, e) {\n          if (u.isBuffer(e)) {\n            var n = 0 | f(e.length);\n            return 0 === (t = s(t, n)).length ? t : (e.copy(t, 0, 0, n), t);\n          }\n\n          if (e) {\n            if (\"undefined\" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || \"length\" in e) return \"number\" != typeof e.length || (r = e.length) != r ? s(t, 0) : p(t, e);\n            if (\"Buffer\" === e.type && i(e.data)) return p(t, e.data);\n          }\n\n          var r;\n          throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n        }(t, e);\n      }\n\n      function l(t) {\n        if (\"number\" != typeof t) throw new TypeError('\"size\" argument must be a number');\n        if (t < 0) throw new RangeError('\"size\" argument must not be negative');\n      }\n\n      function h(t, e) {\n        if (l(e), t = s(t, e < 0 ? 0 : 0 | f(e)), !u.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n) t[n] = 0;\n        return t;\n      }\n\n      function p(t, e) {\n        var n = e.length < 0 ? 0 : 0 | f(e.length);\n        t = s(t, n);\n\n        for (var r = 0; r < n; r += 1) t[r] = 255 & e[r];\n\n        return t;\n      }\n\n      function f(t) {\n        if (t >= a()) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + a().toString(16) + \" bytes\");\n        return 0 | t;\n      }\n\n      function d(t, e) {\n        if (u.isBuffer(t)) return t.length;\n        if (\"undefined\" != typeof ArrayBuffer && \"function\" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;\n        \"string\" != typeof t && (t = \"\" + t);\n        var n = t.length;\n        if (0 === n) return 0;\n\n        for (var r = !1;;) switch (e) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return n;\n\n          case \"utf8\":\n          case \"utf-8\":\n          case void 0:\n            return V(t).length;\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return 2 * n;\n\n          case \"hex\":\n            return n >>> 1;\n\n          case \"base64\":\n            return U(t).length;\n\n          default:\n            if (r) return V(t).length;\n            e = (\"\" + e).toLowerCase(), r = !0;\n        }\n      }\n\n      function m(t, e, n) {\n        var r = !1;\n        if ((void 0 === e || e < 0) && (e = 0), e > this.length) return \"\";\n        if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return \"\";\n        if ((n >>>= 0) <= (e >>>= 0)) return \"\";\n\n        for (t || (t = \"utf8\");;) switch (t) {\n          case \"hex\":\n            return P(this, e, n);\n\n          case \"utf8\":\n          case \"utf-8\":\n            return A(this, e, n);\n\n          case \"ascii\":\n            return T(this, e, n);\n\n          case \"latin1\":\n          case \"binary\":\n            return N(this, e, n);\n\n          case \"base64\":\n            return I(this, e, n);\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return R(this, e, n);\n\n          default:\n            if (r) throw new TypeError(\"Unknown encoding: \" + t);\n            t = (t + \"\").toLowerCase(), r = !0;\n        }\n      }\n\n      function g(t, e, n) {\n        var r = t[e];\n        t[e] = t[n], t[n] = r;\n      }\n\n      function v(t, e, n, r, o) {\n        if (0 === t.length) return -1;\n\n        if (\"string\" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) {\n          if (o) return -1;\n          n = t.length - 1;\n        } else if (n < 0) {\n          if (!o) return -1;\n          n = 0;\n        }\n\n        if (\"string\" == typeof e && (e = u.from(e, r)), u.isBuffer(e)) return 0 === e.length ? -1 : y(t, e, n, r, o);\n        if (\"number\" == typeof e) return e &= 255, u.TYPED_ARRAY_SUPPORT && \"function\" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : y(t, [e], n, r, o);\n        throw new TypeError(\"val must be string, number or Buffer\");\n      }\n\n      function y(t, e, n, r, o) {\n        var i,\n            a = 1,\n            s = t.length,\n            u = e.length;\n\n        if (void 0 !== r && (\"ucs2\" === (r = String(r).toLowerCase()) || \"ucs-2\" === r || \"utf16le\" === r || \"utf-16le\" === r)) {\n          if (t.length < 2 || e.length < 2) return -1;\n          a = 2, s /= 2, u /= 2, n /= 2;\n        }\n\n        function c(t, e) {\n          return 1 === a ? t[e] : t.readUInt16BE(e * a);\n        }\n\n        if (o) {\n          var l = -1;\n\n          for (i = n; i < s; i++) if (c(t, i) === c(e, -1 === l ? 0 : i - l)) {\n            if (-1 === l && (l = i), i - l + 1 === u) return l * a;\n          } else -1 !== l && (i -= i - l), l = -1;\n        } else for (n + u > s && (n = s - u), i = n; i >= 0; i--) {\n          for (var h = !0, p = 0; p < u; p++) if (c(t, i + p) !== c(e, p)) {\n            h = !1;\n            break;\n          }\n\n          if (h) return i;\n        }\n\n        return -1;\n      }\n\n      function b(t, e, n, r) {\n        n = Number(n) || 0;\n        var o = t.length - n;\n        r ? (r = Number(r)) > o && (r = o) : r = o;\n        var i = e.length;\n        if (i % 2 != 0) throw new TypeError(\"Invalid hex string\");\n        r > i / 2 && (r = i / 2);\n\n        for (var a = 0; a < r; ++a) {\n          var s = parseInt(e.substr(2 * a, 2), 16);\n          if (isNaN(s)) return a;\n          t[n + a] = s;\n        }\n\n        return a;\n      }\n\n      function w(t, e, n, r) {\n        return j(V(e, t.length - n), t, n, r);\n      }\n\n      function x(t, e, n, r) {\n        return j(function (t) {\n          for (var e = [], n = 0; n < t.length; ++n) e.push(255 & t.charCodeAt(n));\n\n          return e;\n        }(e), t, n, r);\n      }\n\n      function S(t, e, n, r) {\n        return x(t, e, n, r);\n      }\n\n      function E(t, e, n, r) {\n        return j(U(e), t, n, r);\n      }\n\n      function C(t, e, n, r) {\n        return j(function (t, e) {\n          for (var n, r, o, i = [], a = 0; a < t.length && !((e -= 2) < 0); ++a) n = t.charCodeAt(a), r = n >> 8, o = n % 256, i.push(o), i.push(r);\n\n          return i;\n        }(e, t.length - n), t, n, r);\n      }\n\n      function I(t, e, n) {\n        return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n));\n      }\n\n      function A(t, e, n) {\n        n = Math.min(t.length, n);\n\n        for (var r = [], o = e; o < n;) {\n          var i,\n              a,\n              s,\n              u,\n              c = t[o],\n              l = null,\n              h = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;\n          if (o + h <= n) switch (h) {\n            case 1:\n              c < 128 && (l = c);\n              break;\n\n            case 2:\n              128 == (192 & (i = t[o + 1])) && (u = (31 & c) << 6 | 63 & i) > 127 && (l = u);\n              break;\n\n            case 3:\n              i = t[o + 1], a = t[o + 2], 128 == (192 & i) && 128 == (192 & a) && (u = (15 & c) << 12 | (63 & i) << 6 | 63 & a) > 2047 && (u < 55296 || u > 57343) && (l = u);\n              break;\n\n            case 4:\n              i = t[o + 1], a = t[o + 2], s = t[o + 3], 128 == (192 & i) && 128 == (192 & a) && 128 == (192 & s) && (u = (15 & c) << 18 | (63 & i) << 12 | (63 & a) << 6 | 63 & s) > 65535 && u < 1114112 && (l = u);\n          }\n          null === l ? (l = 65533, h = 1) : l > 65535 && (l -= 65536, r.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), r.push(l), o += h;\n        }\n\n        return function (t) {\n          var e = t.length;\n          if (e <= k) return String.fromCharCode.apply(String, t);\n          var n = \"\",\n              r = 0;\n\n          for (; r < e;) n += String.fromCharCode.apply(String, t.slice(r, r += k));\n\n          return n;\n        }(r);\n      }\n\n      e.Buffer = u, e.SlowBuffer = function (t) {\n        +t != t && (t = 0);\n        return u.alloc(+t);\n      }, e.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : function () {\n        try {\n          var t = new Uint8Array(1);\n          return t.__proto__ = {\n            __proto__: Uint8Array.prototype,\n            foo: function () {\n              return 42;\n            }\n          }, 42 === t.foo() && \"function\" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength;\n        } catch (t) {\n          return !1;\n        }\n      }(), e.kMaxLength = a(), u.poolSize = 8192, u._augment = function (t) {\n        return t.__proto__ = u.prototype, t;\n      }, u.from = function (t, e, n) {\n        return c(null, t, e, n);\n      }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, \"undefined\" != typeof Symbol && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, {\n        value: null,\n        configurable: !0\n      })), u.alloc = function (t, e, n) {\n        return function (t, e, n, r) {\n          return l(e), e <= 0 ? s(t, e) : void 0 !== n ? \"string\" == typeof r ? s(t, e).fill(n, r) : s(t, e).fill(n) : s(t, e);\n        }(null, t, e, n);\n      }, u.allocUnsafe = function (t) {\n        return h(null, t);\n      }, u.allocUnsafeSlow = function (t) {\n        return h(null, t);\n      }, u.isBuffer = function (t) {\n        return !(null == t || !t._isBuffer);\n      }, u.compare = function (t, e) {\n        if (!u.isBuffer(t) || !u.isBuffer(e)) throw new TypeError(\"Arguments must be Buffers\");\n        if (t === e) return 0;\n\n        for (var n = t.length, r = e.length, o = 0, i = Math.min(n, r); o < i; ++o) if (t[o] !== e[o]) {\n          n = t[o], r = e[o];\n          break;\n        }\n\n        return n < r ? -1 : r < n ? 1 : 0;\n      }, u.isEncoding = function (t) {\n        switch (String(t).toLowerCase()) {\n          case \"hex\":\n          case \"utf8\":\n          case \"utf-8\":\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n          case \"base64\":\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return !0;\n\n          default:\n            return !1;\n        }\n      }, u.concat = function (t, e) {\n        if (!i(t)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        if (0 === t.length) return u.alloc(0);\n        var n;\n        if (void 0 === e) for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;\n        var r = u.allocUnsafe(e),\n            o = 0;\n\n        for (n = 0; n < t.length; ++n) {\n          var a = t[n];\n          if (!u.isBuffer(a)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n          a.copy(r, o), o += a.length;\n        }\n\n        return r;\n      }, u.byteLength = d, u.prototype._isBuffer = !0, u.prototype.swap16 = function () {\n        var t = this.length;\n        if (t % 2 != 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n\n        for (var e = 0; e < t; e += 2) g(this, e, e + 1);\n\n        return this;\n      }, u.prototype.swap32 = function () {\n        var t = this.length;\n        if (t % 4 != 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n\n        for (var e = 0; e < t; e += 4) g(this, e, e + 3), g(this, e + 1, e + 2);\n\n        return this;\n      }, u.prototype.swap64 = function () {\n        var t = this.length;\n        if (t % 8 != 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n\n        for (var e = 0; e < t; e += 8) g(this, e, e + 7), g(this, e + 1, e + 6), g(this, e + 2, e + 5), g(this, e + 3, e + 4);\n\n        return this;\n      }, u.prototype.toString = function () {\n        var t = 0 | this.length;\n        return 0 === t ? \"\" : 0 === arguments.length ? A(this, 0, t) : m.apply(this, arguments);\n      }, u.prototype.equals = function (t) {\n        if (!u.isBuffer(t)) throw new TypeError(\"Argument must be a Buffer\");\n        return this === t || 0 === u.compare(this, t);\n      }, u.prototype.inspect = function () {\n        var t = \"\",\n            n = e.INSPECT_MAX_BYTES;\n        return this.length > 0 && (t = this.toString(\"hex\", 0, n).match(/.{2}/g).join(\" \"), this.length > n && (t += \" ... \")), \"<Buffer \" + t + \">\";\n      }, u.prototype.compare = function (t, e, n, r, o) {\n        if (!u.isBuffer(t)) throw new TypeError(\"Argument must be a Buffer\");\n        if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), e < 0 || n > t.length || r < 0 || o > this.length) throw new RangeError(\"out of range index\");\n        if (r >= o && e >= n) return 0;\n        if (r >= o) return -1;\n        if (e >= n) return 1;\n        if (this === t) return 0;\n\n        for (var i = (o >>>= 0) - (r >>>= 0), a = (n >>>= 0) - (e >>>= 0), s = Math.min(i, a), c = this.slice(r, o), l = t.slice(e, n), h = 0; h < s; ++h) if (c[h] !== l[h]) {\n          i = c[h], a = l[h];\n          break;\n        }\n\n        return i < a ? -1 : a < i ? 1 : 0;\n      }, u.prototype.includes = function (t, e, n) {\n        return -1 !== this.indexOf(t, e, n);\n      }, u.prototype.indexOf = function (t, e, n) {\n        return v(this, t, e, n, !0);\n      }, u.prototype.lastIndexOf = function (t, e, n) {\n        return v(this, t, e, n, !1);\n      }, u.prototype.write = function (t, e, n, r) {\n        if (void 0 === e) r = \"utf8\", n = this.length, e = 0;else if (void 0 === n && \"string\" == typeof e) r = e, n = this.length, e = 0;else {\n          if (!isFinite(e)) throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n          e |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = \"utf8\")) : (r = n, n = void 0);\n        }\n        var o = this.length - e;\n        if ((void 0 === n || n > o) && (n = o), t.length > 0 && (n < 0 || e < 0) || e > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n        r || (r = \"utf8\");\n\n        for (var i = !1;;) switch (r) {\n          case \"hex\":\n            return b(this, t, e, n);\n\n          case \"utf8\":\n          case \"utf-8\":\n            return w(this, t, e, n);\n\n          case \"ascii\":\n            return x(this, t, e, n);\n\n          case \"latin1\":\n          case \"binary\":\n            return S(this, t, e, n);\n\n          case \"base64\":\n            return E(this, t, e, n);\n\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return C(this, t, e, n);\n\n          default:\n            if (i) throw new TypeError(\"Unknown encoding: \" + r);\n            r = (\"\" + r).toLowerCase(), i = !0;\n        }\n      }, u.prototype.toJSON = function () {\n        return {\n          type: \"Buffer\",\n          data: Array.prototype.slice.call(this._arr || this, 0)\n        };\n      };\n      var k = 4096;\n\n      function T(t, e, n) {\n        var r = \"\";\n        n = Math.min(t.length, n);\n\n        for (var o = e; o < n; ++o) r += String.fromCharCode(127 & t[o]);\n\n        return r;\n      }\n\n      function N(t, e, n) {\n        var r = \"\";\n        n = Math.min(t.length, n);\n\n        for (var o = e; o < n; ++o) r += String.fromCharCode(t[o]);\n\n        return r;\n      }\n\n      function P(t, e, n) {\n        var r = t.length;\n        (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);\n\n        for (var o = \"\", i = e; i < n; ++i) o += q(t[i]);\n\n        return o;\n      }\n\n      function R(t, e, n) {\n        for (var r = t.slice(e, n), o = \"\", i = 0; i < r.length; i += 2) o += String.fromCharCode(r[i] + 256 * r[i + 1]);\n\n        return o;\n      }\n\n      function _(t, e, n) {\n        if (t % 1 != 0 || t < 0) throw new RangeError(\"offset is not uint\");\n        if (t + e > n) throw new RangeError(\"Trying to access beyond buffer length\");\n      }\n\n      function M(t, e, n, r, o, i) {\n        if (!u.isBuffer(t)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n        if (e > o || e < i) throw new RangeError('\"value\" argument is out of bounds');\n        if (n + r > t.length) throw new RangeError(\"Index out of range\");\n      }\n\n      function O(t, e, n, r) {\n        e < 0 && (e = 65535 + e + 1);\n\n        for (var o = 0, i = Math.min(t.length - n, 2); o < i; ++o) t[n + o] = (e & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o);\n      }\n\n      function D(t, e, n, r) {\n        e < 0 && (e = 4294967295 + e + 1);\n\n        for (var o = 0, i = Math.min(t.length - n, 4); o < i; ++o) t[n + o] = e >>> 8 * (r ? o : 3 - o) & 255;\n      }\n\n      function F(t, e, n, r, o, i) {\n        if (n + r > t.length) throw new RangeError(\"Index out of range\");\n        if (n < 0) throw new RangeError(\"Index out of range\");\n      }\n\n      function L(t, e, n, r, i) {\n        return i || F(t, 0, n, 4), o.write(t, e, n, r, 23, 4), n + 4;\n      }\n\n      function B(t, e, n, r, i) {\n        return i || F(t, 0, n, 8), o.write(t, e, n, r, 52, 8), n + 8;\n      }\n\n      u.prototype.slice = function (t, e) {\n        var n,\n            r = this.length;\n        if ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), e < t && (e = t), u.TYPED_ARRAY_SUPPORT) (n = this.subarray(t, e)).__proto__ = u.prototype;else {\n          var o = e - t;\n          n = new u(o, void 0);\n\n          for (var i = 0; i < o; ++i) n[i] = this[i + t];\n        }\n        return n;\n      }, u.prototype.readUIntLE = function (t, e, n) {\n        t |= 0, e |= 0, n || _(t, e, this.length);\n\n        for (var r = this[t], o = 1, i = 0; ++i < e && (o *= 256);) r += this[t + i] * o;\n\n        return r;\n      }, u.prototype.readUIntBE = function (t, e, n) {\n        t |= 0, e |= 0, n || _(t, e, this.length);\n\n        for (var r = this[t + --e], o = 1; e > 0 && (o *= 256);) r += this[t + --e] * o;\n\n        return r;\n      }, u.prototype.readUInt8 = function (t, e) {\n        return e || _(t, 1, this.length), this[t];\n      }, u.prototype.readUInt16LE = function (t, e) {\n        return e || _(t, 2, this.length), this[t] | this[t + 1] << 8;\n      }, u.prototype.readUInt16BE = function (t, e) {\n        return e || _(t, 2, this.length), this[t] << 8 | this[t + 1];\n      }, u.prototype.readUInt32LE = function (t, e) {\n        return e || _(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];\n      }, u.prototype.readUInt32BE = function (t, e) {\n        return e || _(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);\n      }, u.prototype.readIntLE = function (t, e, n) {\n        t |= 0, e |= 0, n || _(t, e, this.length);\n\n        for (var r = this[t], o = 1, i = 0; ++i < e && (o *= 256);) r += this[t + i] * o;\n\n        return r >= (o *= 128) && (r -= Math.pow(2, 8 * e)), r;\n      }, u.prototype.readIntBE = function (t, e, n) {\n        t |= 0, e |= 0, n || _(t, e, this.length);\n\n        for (var r = e, o = 1, i = this[t + --r]; r > 0 && (o *= 256);) i += this[t + --r] * o;\n\n        return i >= (o *= 128) && (i -= Math.pow(2, 8 * e)), i;\n      }, u.prototype.readInt8 = function (t, e) {\n        return e || _(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];\n      }, u.prototype.readInt16LE = function (t, e) {\n        e || _(t, 2, this.length);\n        var n = this[t] | this[t + 1] << 8;\n        return 32768 & n ? 4294901760 | n : n;\n      }, u.prototype.readInt16BE = function (t, e) {\n        e || _(t, 2, this.length);\n        var n = this[t + 1] | this[t] << 8;\n        return 32768 & n ? 4294901760 | n : n;\n      }, u.prototype.readInt32LE = function (t, e) {\n        return e || _(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;\n      }, u.prototype.readInt32BE = function (t, e) {\n        return e || _(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];\n      }, u.prototype.readFloatLE = function (t, e) {\n        return e || _(t, 4, this.length), o.read(this, t, !0, 23, 4);\n      }, u.prototype.readFloatBE = function (t, e) {\n        return e || _(t, 4, this.length), o.read(this, t, !1, 23, 4);\n      }, u.prototype.readDoubleLE = function (t, e) {\n        return e || _(t, 8, this.length), o.read(this, t, !0, 52, 8);\n      }, u.prototype.readDoubleBE = function (t, e) {\n        return e || _(t, 8, this.length), o.read(this, t, !1, 52, 8);\n      }, u.prototype.writeUIntLE = function (t, e, n, r) {\n        (t = +t, e |= 0, n |= 0, r) || M(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);\n        var o = 1,\n            i = 0;\n\n        for (this[e] = 255 & t; ++i < n && (o *= 256);) this[e + i] = t / o & 255;\n\n        return e + n;\n      }, u.prototype.writeUIntBE = function (t, e, n, r) {\n        (t = +t, e |= 0, n |= 0, r) || M(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);\n        var o = n - 1,\n            i = 1;\n\n        for (this[e + o] = 255 & t; --o >= 0 && (i *= 256);) this[e + o] = t / i & 255;\n\n        return e + n;\n      }, u.prototype.writeUInt8 = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1;\n      }, u.prototype.writeUInt16LE = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : O(this, t, e, !0), e + 2;\n      }, u.prototype.writeUInt16BE = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : O(this, t, e, !1), e + 2;\n      }, u.prototype.writeUInt32LE = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : D(this, t, e, !0), e + 4;\n      }, u.prototype.writeUInt32BE = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : D(this, t, e, !1), e + 4;\n      }, u.prototype.writeIntLE = function (t, e, n, r) {\n        if (t = +t, e |= 0, !r) {\n          var o = Math.pow(2, 8 * n - 1);\n          M(this, t, e, n, o - 1, -o);\n        }\n\n        var i = 0,\n            a = 1,\n            s = 0;\n\n        for (this[e] = 255 & t; ++i < n && (a *= 256);) t < 0 && 0 === s && 0 !== this[e + i - 1] && (s = 1), this[e + i] = (t / a >> 0) - s & 255;\n\n        return e + n;\n      }, u.prototype.writeIntBE = function (t, e, n, r) {\n        if (t = +t, e |= 0, !r) {\n          var o = Math.pow(2, 8 * n - 1);\n          M(this, t, e, n, o - 1, -o);\n        }\n\n        var i = n - 1,\n            a = 1,\n            s = 0;\n\n        for (this[e + i] = 255 & t; --i >= 0 && (a *= 256);) t < 0 && 0 === s && 0 !== this[e + i + 1] && (s = 1), this[e + i] = (t / a >> 0) - s & 255;\n\n        return e + n;\n      }, u.prototype.writeInt8 = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1;\n      }, u.prototype.writeInt16LE = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : O(this, t, e, !0), e + 2;\n      }, u.prototype.writeInt16BE = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : O(this, t, e, !1), e + 2;\n      }, u.prototype.writeInt32LE = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : D(this, t, e, !0), e + 4;\n      }, u.prototype.writeInt32BE = function (t, e, n) {\n        return t = +t, e |= 0, n || M(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), u.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : D(this, t, e, !1), e + 4;\n      }, u.prototype.writeFloatLE = function (t, e, n) {\n        return L(this, t, e, !0, n);\n      }, u.prototype.writeFloatBE = function (t, e, n) {\n        return L(this, t, e, !1, n);\n      }, u.prototype.writeDoubleLE = function (t, e, n) {\n        return B(this, t, e, !0, n);\n      }, u.prototype.writeDoubleBE = function (t, e, n) {\n        return B(this, t, e, !1, n);\n      }, u.prototype.copy = function (t, e, n, r) {\n        if (n || (n = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), r > 0 && r < n && (r = n), r === n) return 0;\n        if (0 === t.length || 0 === this.length) return 0;\n        if (e < 0) throw new RangeError(\"targetStart out of bounds\");\n        if (n < 0 || n >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n        if (r < 0) throw new RangeError(\"sourceEnd out of bounds\");\n        r > this.length && (r = this.length), t.length - e < r - n && (r = t.length - e + n);\n        var o,\n            i = r - n;\n        if (this === t && n < e && e < r) for (o = i - 1; o >= 0; --o) t[o + e] = this[o + n];else if (i < 1e3 || !u.TYPED_ARRAY_SUPPORT) for (o = 0; o < i; ++o) t[o + e] = this[o + n];else Uint8Array.prototype.set.call(t, this.subarray(n, n + i), e);\n        return i;\n      }, u.prototype.fill = function (t, e, n, r) {\n        if (\"string\" == typeof t) {\n          if (\"string\" == typeof e ? (r = e, e = 0, n = this.length) : \"string\" == typeof n && (r = n, n = this.length), 1 === t.length) {\n            var o = t.charCodeAt(0);\n            o < 256 && (t = o);\n          }\n\n          if (void 0 !== r && \"string\" != typeof r) throw new TypeError(\"encoding must be a string\");\n          if (\"string\" == typeof r && !u.isEncoding(r)) throw new TypeError(\"Unknown encoding: \" + r);\n        } else \"number\" == typeof t && (t &= 255);\n\n        if (e < 0 || this.length < e || this.length < n) throw new RangeError(\"Out of range index\");\n        if (n <= e) return this;\n        var i;\n        if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), \"number\" == typeof t) for (i = e; i < n; ++i) this[i] = t;else {\n          var a = u.isBuffer(t) ? t : V(new u(t, r).toString()),\n              s = a.length;\n\n          for (i = 0; i < n - e; ++i) this[i + e] = a[i % s];\n        }\n        return this;\n      };\n      var z = /[^+\\/0-9A-Za-z-_]/g;\n\n      function q(t) {\n        return t < 16 ? \"0\" + t.toString(16) : t.toString(16);\n      }\n\n      function V(t, e) {\n        var n;\n        e = e || 1 / 0;\n\n        for (var r = t.length, o = null, i = [], a = 0; a < r; ++a) {\n          if ((n = t.charCodeAt(a)) > 55295 && n < 57344) {\n            if (!o) {\n              if (n > 56319) {\n                (e -= 3) > -1 && i.push(239, 191, 189);\n                continue;\n              }\n\n              if (a + 1 === r) {\n                (e -= 3) > -1 && i.push(239, 191, 189);\n                continue;\n              }\n\n              o = n;\n              continue;\n            }\n\n            if (n < 56320) {\n              (e -= 3) > -1 && i.push(239, 191, 189), o = n;\n              continue;\n            }\n\n            n = 65536 + (o - 55296 << 10 | n - 56320);\n          } else o && (e -= 3) > -1 && i.push(239, 191, 189);\n\n          if (o = null, n < 128) {\n            if ((e -= 1) < 0) break;\n            i.push(n);\n          } else if (n < 2048) {\n            if ((e -= 2) < 0) break;\n            i.push(n >> 6 | 192, 63 & n | 128);\n          } else if (n < 65536) {\n            if ((e -= 3) < 0) break;\n            i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);\n          } else {\n            if (!(n < 1114112)) throw new Error(\"Invalid code point\");\n            if ((e -= 4) < 0) break;\n            i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);\n          }\n        }\n\n        return i;\n      }\n\n      function U(t) {\n        return r.toByteArray(function (t) {\n          if ((t = function (t) {\n            return t.trim ? t.trim() : t.replace(/^\\s+|\\s+$/g, \"\");\n          }(t).replace(z, \"\")).length < 2) return \"\";\n\n          for (; t.length % 4 != 0;) t += \"=\";\n\n          return t;\n        }(t));\n      }\n\n      function j(t, e, n, r) {\n        for (var o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o) e[o + n] = t[o];\n\n        return o;\n      }\n    }).call(this, n(8));\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(53);\n\n    function o() {\n      this.argTypes = [], this.shimArgs = [], this.arrayArgs = [], this.arrayBlockIndices = [], this.scalarArgs = [], this.offsetArgs = [], this.offsetArgIndex = [], this.indexArgs = [], this.shapeArgs = [], this.funcName = \"\", this.pre = null, this.body = null, this.post = null, this.debug = !1;\n    }\n\n    t.exports = function (t) {\n      var e = new o();\n      e.pre = t.pre, e.body = t.body, e.post = t.post;\n      var n = t.args.slice(0);\n      e.argTypes = n;\n\n      for (var i = 0; i < n.length; ++i) {\n        var a = n[i];\n\n        if (\"array\" === a || \"object\" == typeof a && a.blockIndices) {\n          if (e.argTypes[i] = \"array\", e.arrayArgs.push(i), e.arrayBlockIndices.push(a.blockIndices ? a.blockIndices : 0), e.shimArgs.push(\"array\" + i), i < e.pre.args.length && e.pre.args[i].count > 0) throw new Error(\"cwise: pre() block may not reference array args\");\n          if (i < e.post.args.length && e.post.args[i].count > 0) throw new Error(\"cwise: post() block may not reference array args\");\n        } else if (\"scalar\" === a) e.scalarArgs.push(i), e.shimArgs.push(\"scalar\" + i);else if (\"index\" === a) {\n          if (e.indexArgs.push(i), i < e.pre.args.length && e.pre.args[i].count > 0) throw new Error(\"cwise: pre() block may not reference array index\");\n          if (i < e.body.args.length && e.body.args[i].lvalue) throw new Error(\"cwise: body() block may not write to array index\");\n          if (i < e.post.args.length && e.post.args[i].count > 0) throw new Error(\"cwise: post() block may not reference array index\");\n        } else if (\"shape\" === a) {\n          if (e.shapeArgs.push(i), i < e.pre.args.length && e.pre.args[i].lvalue) throw new Error(\"cwise: pre() block may not write to array shape\");\n          if (i < e.body.args.length && e.body.args[i].lvalue) throw new Error(\"cwise: body() block may not write to array shape\");\n          if (i < e.post.args.length && e.post.args[i].lvalue) throw new Error(\"cwise: post() block may not write to array shape\");\n        } else {\n          if (\"object\" != typeof a || !a.offset) throw new Error(\"cwise: Unknown argument type \" + n[i]);\n          e.argTypes[i] = \"offset\", e.offsetArgs.push({\n            array: a.array,\n            offset: a.offset\n          }), e.offsetArgIndex.push(i);\n        }\n      }\n\n      if (e.arrayArgs.length <= 0) throw new Error(\"cwise: No array arguments specified\");\n      if (e.pre.args.length > n.length) throw new Error(\"cwise: Too many arguments in pre() block\");\n      if (e.body.args.length > n.length) throw new Error(\"cwise: Too many arguments in body() block\");\n      if (e.post.args.length > n.length) throw new Error(\"cwise: Too many arguments in post() block\");\n      return e.debug = !!t.printCode || !!t.debug, e.funcName = t.funcName || \"cwise\", e.blockSize = t.blockSize || 64, r(e);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = function (t, e, n) {\n      return 0 === t.length ? t : e ? (n || t.sort(e), function (t, e) {\n        for (var n = 1, r = t.length, o = t[0], i = t[0], a = 1; a < r; ++a) if (i = o, e(o = t[a], i)) {\n          if (a === n) {\n            n++;\n            continue;\n          }\n\n          t[n++] = o;\n        }\n\n        return t.length = n, t;\n      }(t, e)) : (n || t.sort(), function (t) {\n        for (var e = 1, n = t.length, r = t[0], o = t[0], i = 1; i < n; ++i, o = r) if (o = r, (r = t[i]) !== o) {\n          if (i === e) {\n            e++;\n            continue;\n          }\n\n          t[e++] = r;\n        }\n\n        return t.length = e, t;\n      }(t));\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    (function (t, r) {\n      var o = n(42),\n          i = n(55);\n      t.__TYPEDARRAY_POOL || (t.__TYPEDARRAY_POOL = {\n        UINT8: i([32, 0]),\n        UINT16: i([32, 0]),\n        UINT32: i([32, 0]),\n        INT8: i([32, 0]),\n        INT16: i([32, 0]),\n        INT32: i([32, 0]),\n        FLOAT: i([32, 0]),\n        DOUBLE: i([32, 0]),\n        DATA: i([32, 0]),\n        UINT8C: i([32, 0]),\n        BUFFER: i([32, 0])\n      });\n      var a = \"undefined\" != typeof Uint8ClampedArray,\n          s = t.__TYPEDARRAY_POOL;\n      s.UINT8C || (s.UINT8C = i([32, 0])), s.BUFFER || (s.BUFFER = i([32, 0]));\n      var u = s.DATA,\n          c = s.BUFFER;\n\n      function l(t) {\n        if (t) {\n          var e = t.length || t.byteLength,\n              n = o.log2(e);\n          u[n].push(t);\n        }\n      }\n\n      function h(t) {\n        t = o.nextPow2(t);\n        var e = o.log2(t),\n            n = u[e];\n        return n.length > 0 ? n.pop() : new ArrayBuffer(t);\n      }\n\n      function p(t) {\n        return new Uint8Array(h(t), 0, t);\n      }\n\n      function f(t) {\n        return new Uint16Array(h(2 * t), 0, t);\n      }\n\n      function d(t) {\n        return new Uint32Array(h(4 * t), 0, t);\n      }\n\n      function m(t) {\n        return new Int8Array(h(t), 0, t);\n      }\n\n      function g(t) {\n        return new Int16Array(h(2 * t), 0, t);\n      }\n\n      function v(t) {\n        return new Int32Array(h(4 * t), 0, t);\n      }\n\n      function y(t) {\n        return new Float32Array(h(4 * t), 0, t);\n      }\n\n      function b(t) {\n        return new Float64Array(h(8 * t), 0, t);\n      }\n\n      function w(t) {\n        return a ? new Uint8ClampedArray(h(t), 0, t) : p(t);\n      }\n\n      function x(t) {\n        return new DataView(h(t), 0, t);\n      }\n\n      function S(t) {\n        t = o.nextPow2(t);\n        var e = o.log2(t),\n            n = c[e];\n        return n.length > 0 ? n.pop() : new r(t);\n      }\n\n      e.free = function (t) {\n        if (r.isBuffer(t)) c[o.log2(t.length)].push(t);else {\n          if (\"[object ArrayBuffer]\" !== Object.prototype.toString.call(t) && (t = t.buffer), !t) return;\n          var e = t.length || t.byteLength,\n              n = 0 | o.log2(e);\n          u[n].push(t);\n        }\n      }, e.freeUint8 = e.freeUint16 = e.freeUint32 = e.freeInt8 = e.freeInt16 = e.freeInt32 = e.freeFloat32 = e.freeFloat = e.freeFloat64 = e.freeDouble = e.freeUint8Clamped = e.freeDataView = function (t) {\n        l(t.buffer);\n      }, e.freeArrayBuffer = l, e.freeBuffer = function (t) {\n        c[o.log2(t.length)].push(t);\n      }, e.malloc = function (t, e) {\n        if (void 0 === e || \"arraybuffer\" === e) return h(t);\n\n        switch (e) {\n          case \"uint8\":\n            return p(t);\n\n          case \"uint16\":\n            return f(t);\n\n          case \"uint32\":\n            return d(t);\n\n          case \"int8\":\n            return m(t);\n\n          case \"int16\":\n            return g(t);\n\n          case \"int32\":\n            return v(t);\n\n          case \"float\":\n          case \"float32\":\n            return y(t);\n\n          case \"double\":\n          case \"float64\":\n            return b(t);\n\n          case \"uint8_clamped\":\n            return w(t);\n\n          case \"buffer\":\n            return S(t);\n\n          case \"data\":\n          case \"dataview\":\n            return x(t);\n\n          default:\n            return null;\n        }\n\n        return null;\n      }, e.mallocArrayBuffer = h, e.mallocUint8 = p, e.mallocUint16 = f, e.mallocUint32 = d, e.mallocInt8 = m, e.mallocInt16 = g, e.mallocInt32 = v, e.mallocFloat32 = e.mallocFloat = y, e.mallocFloat64 = e.mallocDouble = b, e.mallocUint8Clamped = w, e.mallocDataView = x, e.mallocBuffer = S, e.clearCache = function () {\n        for (var t = 0; t < 32; ++t) s.UINT8[t].length = 0, s.UINT16[t].length = 0, s.UINT32[t].length = 0, s.INT8[t].length = 0, s.INT16[t].length = 0, s.INT32[t].length = 0, s.FLOAT[t].length = 0, s.DOUBLE[t].length = 0, s.UINT8C[t].length = 0, u[t].length = 0, c[t].length = 0;\n      };\n    }).call(this, n(8), n(38).Buffer);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function r(t) {\n      var e = 32;\n      return (t &= -t) && e--, 65535 & t && (e -= 16), 16711935 & t && (e -= 8), 252645135 & t && (e -= 4), 858993459 & t && (e -= 2), 1431655765 & t && (e -= 1), e;\n    }\n\n    e.INT_BITS = 32, e.INT_MAX = 2147483647, e.INT_MIN = -1 << 31, e.sign = function (t) {\n      return (t > 0) - (t < 0);\n    }, e.abs = function (t) {\n      var e = t >> 31;\n      return (t ^ e) - e;\n    }, e.min = function (t, e) {\n      return e ^ (t ^ e) & -(t < e);\n    }, e.max = function (t, e) {\n      return t ^ (t ^ e) & -(t < e);\n    }, e.isPow2 = function (t) {\n      return !(t & t - 1 || !t);\n    }, e.log2 = function (t) {\n      var e, n;\n      return e = (t > 65535) << 4, e |= n = ((t >>>= e) > 255) << 3, e |= n = ((t >>>= n) > 15) << 2, (e |= n = ((t >>>= n) > 3) << 1) | (t >>>= n) >> 1;\n    }, e.log10 = function (t) {\n      return t >= 1e9 ? 9 : t >= 1e8 ? 8 : t >= 1e7 ? 7 : t >= 1e6 ? 6 : t >= 1e5 ? 5 : t >= 1e4 ? 4 : t >= 1e3 ? 3 : t >= 100 ? 2 : t >= 10 ? 1 : 0;\n    }, e.popCount = function (t) {\n      return 16843009 * ((t = (858993459 & (t -= t >>> 1 & 1431655765)) + (t >>> 2 & 858993459)) + (t >>> 4) & 252645135) >>> 24;\n    }, e.countTrailingZeros = r, e.nextPow2 = function (t) {\n      return t += 0 === t, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, (t |= t >>> 16) + 1;\n    }, e.prevPow2 = function (t) {\n      return t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, (t |= t >>> 16) - (t >>> 1);\n    }, e.parity = function (t) {\n      return t ^= t >>> 16, t ^= t >>> 8, t ^= t >>> 4, 27030 >>> (t &= 15) & 1;\n    };\n    var o = new Array(256);\n    !function (t) {\n      for (var e = 0; e < 256; ++e) {\n        var n = e,\n            r = e,\n            o = 7;\n\n        for (n >>>= 1; n; n >>>= 1) r <<= 1, r |= 1 & n, --o;\n\n        t[e] = r << o & 255;\n      }\n    }(o), e.reverse = function (t) {\n      return o[255 & t] << 24 | o[t >>> 8 & 255] << 16 | o[t >>> 16 & 255] << 8 | o[t >>> 24 & 255];\n    }, e.interleave2 = function (t, e) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t &= 65535) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e &= 65535) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }, e.deinterleave2 = function (t, e) {\n      return (t = 65535 & ((t = 16711935 & ((t = 252645135 & ((t = 858993459 & ((t = t >>> e & 1431655765) | t >>> 1)) | t >>> 2)) | t >>> 4)) | t >>> 16)) << 16 >> 16;\n    }, e.interleave3 = function (t, e, n) {\n      return t = 1227133513 & ((t = 3272356035 & ((t = 251719695 & ((t = 4278190335 & ((t &= 1023) | t << 16)) | t << 8)) | t << 4)) | t << 2), (t |= (e = 1227133513 & ((e = 3272356035 & ((e = 251719695 & ((e = 4278190335 & ((e &= 1023) | e << 16)) | e << 8)) | e << 4)) | e << 2)) << 1) | (n = 1227133513 & ((n = 3272356035 & ((n = 251719695 & ((n = 4278190335 & ((n &= 1023) | n << 16)) | n << 8)) | n << 4)) | n << 2)) << 2;\n    }, e.deinterleave3 = function (t, e) {\n      return (t = 1023 & ((t = 4278190335 & ((t = 251719695 & ((t = 3272356035 & ((t = t >>> e & 1227133513) | t >>> 2)) | t >>> 4)) | t >>> 8)) | t >>> 16)) << 22 >> 22;\n    }, e.nextCombination = function (t) {\n      var e = t | t - 1;\n      return e + 1 | (~e & -~e) - 1 >>> r(t) + 1;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(52),\n        o = n(57),\n        i = n(34),\n        a = n(58)({\n      args: [\"array\", \"array\", \"scalar\", \"scalar\", \"scalar\"],\n      body: function (t, e, n, r, o) {\n        var i = e * n;\n        i < r && (i = r), i > o && (i = o);\n      }\n    });\n\n    t.exports = function (t, e, n, s) {\n      void 0 === n && (n = -1 / 0), void 0 === s && (s = 1 / 0);\n      var u = e.shape,\n          c = t.shape;\n      if (e.shape.length !== t.shape.length) throw new Error(\"ndarray-resample: input and output arrays should have the same dimensions\");\n      var l,\n          h = u.map(function () {\n        return 0;\n      });\n      if (1 === t.size) return (l = i.sum(e) / e.size) < n && (l = n), l > s && (l = s), void t.set.apply(t, h.concat(l));\n      if (1 === e.size) return (l = e.get.apply(e, h)) < n && (l = n), l > s && (l = s), void i.assigns(t, l);\n\n      for (var p = u.length, f = new Array(p), d = !1, m = 0; m < p; m++) f[m] = Math.min(c[m], u[m]), c[m] > u[m] && (d = !0);\n\n      var g = o.malloc(u),\n          v = o.malloc(u);\n      i.assign(g, e), i.assigns(v, 0), r(1, g, v);\n      var y = g.lo,\n          b = g.hi,\n          w = o.malloc(c),\n          x = o.malloc(c);\n      d && (i.assigns(w, 0), i.assigns(x, 0));\n      var S = new Array(p),\n          E = new Array(p),\n          C = new Array(p),\n          I = new Array(p);\n\n      for (m = 0; m < 1 << p; ++m) {\n        for (var A = 0; A < p; ++A) if (m & 1 << A) {\n          if (S[A] = f[A] - (f[A] + 1 >>> 1), 0 === S[A]) continue;\n          E[A] = c[A] - S[A], C[A] = u[A] - S[A], I[A] = 1 & f[A] ? 0 : 1;\n        } else S[A] = f[A] + 1 >>> 1, E[A] = 0, C[A] = 0, I[A] = 0;\n\n        i.assign(b.apply(y.apply(w, E), S), b.apply(y.apply(g, C), S)), i.assign(y.apply(b.apply(y.apply(x, E), S), I), y.apply(b.apply(y.apply(v, C), S), I)), i.assigns(b.apply(b.apply(y.apply(x, E), S), I), 0);\n      }\n\n      r(-1, w, x), a(t, w, t.size / e.size, n, s), o.free(g), o.free(v), o.free(w), o.free(x);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    e.byteLength = function (t) {\n      var e = c(t),\n          n = e[0],\n          r = e[1];\n      return 3 * (n + r) / 4 - r;\n    }, e.toByteArray = function (t) {\n      var e,\n          n,\n          r = c(t),\n          a = r[0],\n          s = r[1],\n          u = new i(function (t, e, n) {\n        return 3 * (e + n) / 4 - n;\n      }(0, a, s)),\n          l = 0,\n          h = s > 0 ? a - 4 : a;\n\n      for (n = 0; n < h; n += 4) e = o[t.charCodeAt(n)] << 18 | o[t.charCodeAt(n + 1)] << 12 | o[t.charCodeAt(n + 2)] << 6 | o[t.charCodeAt(n + 3)], u[l++] = e >> 16 & 255, u[l++] = e >> 8 & 255, u[l++] = 255 & e;\n\n      2 === s && (e = o[t.charCodeAt(n)] << 2 | o[t.charCodeAt(n + 1)] >> 4, u[l++] = 255 & e);\n      1 === s && (e = o[t.charCodeAt(n)] << 10 | o[t.charCodeAt(n + 1)] << 4 | o[t.charCodeAt(n + 2)] >> 2, u[l++] = e >> 8 & 255, u[l++] = 255 & e);\n      return u;\n    }, e.fromByteArray = function (t) {\n      for (var e, n = t.length, o = n % 3, i = [], a = 0, s = n - o; a < s; a += 16383) i.push(l(t, a, a + 16383 > s ? s : a + 16383));\n\n      1 === o ? (e = t[n - 1], i.push(r[e >> 2] + r[e << 4 & 63] + \"==\")) : 2 === o && (e = (t[n - 2] << 8) + t[n - 1], i.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + \"=\"));\n      return i.join(\"\");\n    };\n\n    for (var r = [], o = [], i = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, a = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", s = 0, u = a.length; s < u; ++s) r[s] = a[s], o[a.charCodeAt(s)] = s;\n\n    function c(t) {\n      var e = t.length;\n      if (e % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      var n = t.indexOf(\"=\");\n      return -1 === n && (n = e), [n, n === e ? 0 : 4 - n % 4];\n    }\n\n    function l(t, e, n) {\n      for (var o, i, a = [], s = e; s < n; s += 3) o = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (255 & t[s + 2]), a.push(r[(i = o) >> 18 & 63] + r[i >> 12 & 63] + r[i >> 6 & 63] + r[63 & i]);\n\n      return a.join(\"\");\n    }\n\n    o[\"-\".charCodeAt(0)] = 62, o[\"_\".charCodeAt(0)] = 63;\n  }, function (t, e) {\n    e.read = function (t, e, n, r, o) {\n      var i,\n          a,\n          s = 8 * o - r - 1,\n          u = (1 << s) - 1,\n          c = u >> 1,\n          l = -7,\n          h = n ? o - 1 : 0,\n          p = n ? -1 : 1,\n          f = t[e + h];\n\n      for (h += p, i = f & (1 << -l) - 1, f >>= -l, l += s; l > 0; i = 256 * i + t[e + h], h += p, l -= 8);\n\n      for (a = i & (1 << -l) - 1, i >>= -l, l += r; l > 0; a = 256 * a + t[e + h], h += p, l -= 8);\n\n      if (0 === i) i = 1 - c;else {\n        if (i === u) return a ? NaN : 1 / 0 * (f ? -1 : 1);\n        a += Math.pow(2, r), i -= c;\n      }\n      return (f ? -1 : 1) * a * Math.pow(2, i - r);\n    }, e.write = function (t, e, n, r, o, i) {\n      var a,\n          s,\n          u,\n          c = 8 * i - o - 1,\n          l = (1 << c) - 1,\n          h = l >> 1,\n          p = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          f = r ? 0 : i - 1,\n          d = r ? 1 : -1,\n          m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n\n      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, a = l) : (a = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), (e += a + h >= 1 ? p / u : p * Math.pow(2, 1 - h)) * u >= 2 && (a++, u /= 2), a + h >= l ? (s = 0, a = l) : a + h >= 1 ? (s = (e * u - 1) * Math.pow(2, o), a += h) : (s = e * Math.pow(2, h - 1) * Math.pow(2, o), a = 0)); o >= 8; t[n + f] = 255 & s, f += d, s /= 256, o -= 8);\n\n      for (a = a << o | s, c += o; c > 0; t[n + f] = 255 & a, f += d, a /= 256, c -= 8);\n\n      t[n + f - d] |= 128 * m;\n    };\n  }, function (t, e) {\n    var n = {}.toString;\n\n    t.exports = Array.isArray || function (t) {\n      return \"[object Array]\" == n.call(t);\n    };\n  }, function (t, e) {\n    var n,\n        r,\n        o = t.exports = {};\n\n    function i() {\n      throw new Error(\"setTimeout has not been defined\");\n    }\n\n    function a() {\n      throw new Error(\"clearTimeout has not been defined\");\n    }\n\n    function s(t) {\n      if (n === setTimeout) return setTimeout(t, 0);\n      if ((n === i || !n) && setTimeout) return n = setTimeout, setTimeout(t, 0);\n\n      try {\n        return n(t, 0);\n      } catch (e) {\n        try {\n          return n.call(null, t, 0);\n        } catch (e) {\n          return n.call(this, t, 0);\n        }\n      }\n    }\n\n    !function () {\n      try {\n        n = \"function\" == typeof setTimeout ? setTimeout : i;\n      } catch (t) {\n        n = i;\n      }\n\n      try {\n        r = \"function\" == typeof clearTimeout ? clearTimeout : a;\n      } catch (t) {\n        r = a;\n      }\n    }();\n    var u,\n        c = [],\n        l = !1,\n        h = -1;\n\n    function p() {\n      l && u && (l = !1, u.length ? c = u.concat(c) : h = -1, c.length && f());\n    }\n\n    function f() {\n      if (!l) {\n        var t = s(p);\n        l = !0;\n\n        for (var e = c.length; e;) {\n          for (u = c, c = []; ++h < e;) u && u[h].run();\n\n          h = -1, e = c.length;\n        }\n\n        u = null, l = !1, function (t) {\n          if (r === clearTimeout) return clearTimeout(t);\n          if ((r === a || !r) && clearTimeout) return r = clearTimeout, clearTimeout(t);\n\n          try {\n            r(t);\n          } catch (e) {\n            try {\n              return r.call(null, t);\n            } catch (e) {\n              return r.call(this, t);\n            }\n          }\n        }(t);\n      }\n    }\n\n    function d(t, e) {\n      this.fun = t, this.array = e;\n    }\n\n    function m() {}\n\n    o.nextTick = function (t) {\n      var e = new Array(arguments.length - 1);\n      if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];\n      c.push(new d(t, e)), 1 !== c.length || l || s(f);\n    }, d.prototype.run = function () {\n      this.fun.apply(null, this.array);\n    }, o.title = \"browser\", o.browser = !0, o.env = {}, o.argv = [], o.version = \"\", o.versions = {}, o.on = m, o.addListener = m, o.once = m, o.off = m, o.removeListener = m, o.removeAllListeners = m, o.emit = m, o.prependListener = m, o.prependOnceListener = m, o.listeners = function (t) {\n      return [];\n    }, o.binding = function (t) {\n      throw new Error(\"process.binding is not supported\");\n    }, o.cwd = function () {\n      return \"/\";\n    }, o.chdir = function (t) {\n      throw new Error(\"process.chdir is not supported\");\n    }, o.umask = function () {\n      return 0;\n    };\n  }, function (t, e) {\n    function n(t) {\n      var e = 0;\n\n      function n(n) {\n        var r = t.charCodeAt(e);\n        return n && r > 127 && (r -= 256), e += 1, r;\n      }\n\n      return {\n        eof: function () {\n          return e >= t.length;\n        },\n        read: function (n) {\n          var r = t.substr(e, n);\n          return e += n, r;\n        },\n        readInt32: function () {\n          var n = (t.charCodeAt(e) << 24) + (t.charCodeAt(e + 1) << 16) + (t.charCodeAt(e + 2) << 8) + t.charCodeAt(e + 3);\n          return e += 4, n;\n        },\n        readInt16: function () {\n          var n = (t.charCodeAt(e) << 8) + t.charCodeAt(e + 1);\n          return e += 2, n;\n        },\n        readInt8: n,\n        readVarInt: function () {\n          for (var t = 0;;) {\n            var e = n();\n            if (!(128 & e)) return t + e;\n            t += 127 & e, t <<= 7;\n          }\n        }\n      };\n    }\n\n    t.exports = function (t) {\n      return function (t) {\n        function e(t) {\n          var e = t.read(4),\n              n = t.readInt32();\n          return {\n            id: e,\n            length: n,\n            data: t.read(n)\n          };\n        }\n\n        var r;\n\n        function o(t) {\n          var e = {};\n          e.deltaTime = t.readVarInt();\n          var n,\n              o = t.readInt8();\n\n          if (240 == (240 & o)) {\n            if (255 == o) {\n              e.type = \"meta\";\n              var i = t.readInt8(),\n                  a = t.readVarInt();\n\n              switch (i) {\n                case 0:\n                  if (e.subtype = \"sequenceNumber\", 2 != a) throw \"Expected length for sequenceNumber event is 2, got \" + a;\n                  return e.number = t.readInt16(), e;\n\n                case 1:\n                  return e.subtype = \"text\", e.text = t.read(a), e;\n\n                case 2:\n                  return e.subtype = \"copyrightNotice\", e.text = t.read(a), e;\n\n                case 3:\n                  return e.subtype = \"trackName\", e.text = t.read(a), e;\n\n                case 4:\n                  return e.subtype = \"instrumentName\", e.text = t.read(a), e;\n\n                case 5:\n                  return e.subtype = \"lyrics\", e.text = t.read(a), e;\n\n                case 6:\n                  return e.subtype = \"marker\", e.text = t.read(a), e;\n\n                case 7:\n                  return e.subtype = \"cuePoint\", e.text = t.read(a), e;\n\n                case 32:\n                  if (e.subtype = \"midiChannelPrefix\", 1 != a) throw \"Expected length for midiChannelPrefix event is 1, got \" + a;\n                  return e.channel = t.readInt8(), e;\n\n                case 47:\n                  if (e.subtype = \"endOfTrack\", 0 != a) throw \"Expected length for endOfTrack event is 0, got \" + a;\n                  return e;\n\n                case 81:\n                  if (e.subtype = \"setTempo\", 3 != a) throw \"Expected length for setTempo event is 3, got \" + a;\n                  return e.microsecondsPerBeat = (t.readInt8() << 16) + (t.readInt8() << 8) + t.readInt8(), e;\n\n                case 84:\n                  if (e.subtype = \"smpteOffset\", 5 != a) throw \"Expected length for smpteOffset event is 5, got \" + a;\n                  var s = t.readInt8();\n                  return e.frameRate = {\n                    0: 24,\n                    32: 25,\n                    64: 29,\n                    96: 30\n                  }[96 & s], e.hour = 31 & s, e.min = t.readInt8(), e.sec = t.readInt8(), e.frame = t.readInt8(), e.subframe = t.readInt8(), e;\n\n                case 88:\n                  if (e.subtype = \"timeSignature\", 4 != a) throw \"Expected length for timeSignature event is 4, got \" + a;\n                  return e.numerator = t.readInt8(), e.denominator = Math.pow(2, t.readInt8()), e.metronome = t.readInt8(), e.thirtyseconds = t.readInt8(), e;\n\n                case 89:\n                  if (e.subtype = \"keySignature\", 2 != a) throw \"Expected length for keySignature event is 2, got \" + a;\n                  return e.key = t.readInt8(!0), e.scale = t.readInt8(), e;\n\n                case 127:\n                  return e.subtype = \"sequencerSpecific\", e.data = t.read(a), e;\n\n                default:\n                  return e.subtype = \"unknown\", e.data = t.read(a), e;\n              }\n\n              return e.data = t.read(a), e;\n            }\n\n            if (240 == o) {\n              e.type = \"sysEx\";\n              a = t.readVarInt();\n              return e.data = t.read(a), e;\n            }\n\n            if (247 == o) {\n              e.type = \"dividedSysEx\";\n              a = t.readVarInt();\n              return e.data = t.read(a), e;\n            }\n\n            throw \"Unrecognised MIDI event type byte: \" + o;\n          }\n\n          0 == (128 & o) ? (n = o, o = r) : (n = t.readInt8(), r = o);\n          var u = o >> 4;\n\n          switch (e.channel = 15 & o, e.type = \"channel\", u) {\n            case 8:\n              return e.subtype = \"noteOff\", e.noteNumber = n, e.velocity = t.readInt8(), e;\n\n            case 9:\n              return e.noteNumber = n, e.velocity = t.readInt8(), 0 == e.velocity ? e.subtype = \"noteOff\" : e.subtype = \"noteOn\", e;\n\n            case 10:\n              return e.subtype = \"noteAftertouch\", e.noteNumber = n, e.amount = t.readInt8(), e;\n\n            case 11:\n              return e.subtype = \"controller\", e.controllerType = n, e.value = t.readInt8(), e;\n\n            case 12:\n              return e.subtype = \"programChange\", e.programNumber = n, e;\n\n            case 13:\n              return e.subtype = \"channelAftertouch\", e.amount = n, e;\n\n            case 14:\n              return e.subtype = \"pitchBend\", e.value = n + (t.readInt8() << 7), e;\n\n            default:\n              throw \"Unrecognised MIDI event type: \" + u;\n          }\n        }\n\n        stream = n(t);\n        var i = e(stream);\n        if (\"MThd\" != i.id || 6 != i.length) throw \"Bad .mid file - header not found\";\n        var a = n(i.data),\n            s = a.readInt16(),\n            u = a.readInt16(),\n            c = a.readInt16();\n        if (32768 & c) throw \"Expressing time division in SMTPE frames is not supported yet\";\n        ticksPerBeat = c;\n\n        for (var l = {\n          formatType: s,\n          trackCount: u,\n          ticksPerBeat\n        }, h = [], p = 0; p < l.trackCount; p++) {\n          h[p] = [];\n          var f = e(stream);\n          if (\"MTrk\" != f.id) throw \"Unexpected chunk - expected MTrk, got \" + f.id;\n\n          for (var d = n(f.data); !d.eof();) {\n            var m = o(d);\n            h[p].push(m);\n          }\n        }\n\n        return {\n          header: l,\n          tracks: h\n        };\n      }(t);\n    };\n  }, function (t, e, n) {\n    self, t.exports = function (t) {\n      var e = {};\n\n      function n(r) {\n        if (e[r]) return e[r].exports;\n        var o = e[r] = {\n          i: r,\n          l: !1,\n          exports: {}\n        };\n        return t[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n      }\n\n      return n.m = t, n.c = e, n.d = function (t, e, r) {\n        n.o(t, e) || Object.defineProperty(t, e, {\n          enumerable: !0,\n          get: r\n        });\n      }, n.r = function (t) {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n          value: \"Module\"\n        }), Object.defineProperty(t, \"__esModule\", {\n          value: !0\n        });\n      }, n.t = function (t, e) {\n        if (1 & e && (t = n(t)), 8 & e) return t;\n        if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n        var r = Object.create(null);\n        if (n.r(r), Object.defineProperty(r, \"default\", {\n          enumerable: !0,\n          value: t\n        }), 2 & e && \"string\" != typeof t) for (var o in t) n.d(r, o, function (e) {\n          return t[e];\n        }.bind(null, o));\n        return r;\n      }, n.n = function (t) {\n        var e = t && t.__esModule ? function () {\n          return t.default;\n        } : function () {\n          return t;\n        };\n        return n.d(e, \"a\", e), e;\n      }, n.o = function (t, e) {\n        return Object.prototype.hasOwnProperty.call(t, e);\n      }, n.p = \"\", n(n.s = 4);\n    }([function (t, e, n) {\n      \"use strict\";\n\n      n.r(e), n.d(e, \"SVGNS\", function () {\n        return r;\n      }), n.d(e, \"drawSVGPath\", function () {\n        return o;\n      }), n.d(e, \"drawSVGText\", function () {\n        return i;\n      }), n.d(e, \"createSVGGroupChild\", function () {\n        return a;\n      }), n.d(e, \"setFade\", function () {\n        return s;\n      });\n      const r = \"http://www.w3.org/2000/svg\";\n\n      function o(t, e, n, o, i, a, s = 1) {\n        const u = document.createElementNS(r, \"path\");\n        return u.setAttributeNS(null, \"d\", e), u.setAttributeNS(null, \"transform\", \"translate(\".concat(n, \", \").concat(o, \") scale(\").concat(i, \", \").concat(a, \")\")), u.setAttributeNS(null, \"opacity\", \"\".concat(s)), t.appendChild(u), u;\n      }\n\n      function i(t, e, n, o, i, a = !1, s = 1, u = 1) {\n        const c = document.createElementNS(r, \"text\");\n        c.setAttributeNS(null, \"font-family\", \"Times\"), c.setAttributeNS(null, \"font-size\", i), a && c.setAttributeNS(null, \"font-weight\", \"bold\"), c.setAttributeNS(null, \"transform\", \"translate(\".concat(n, \", \").concat(o, \") scale(\").concat(s, \", \").concat(u, \")\"));\n        const l = document.createTextNode(e);\n        return c.appendChild(l), t.appendChild(c), c;\n      }\n\n      function a(t, e) {\n        const n = document.createElementNS(r, \"g\");\n        return n.setAttribute(\"data-id\", e), t.appendChild(n), n;\n      }\n\n      function s(t, e = !1, n = 1, o = 0) {\n        let i = t.querySelector(\"animate\");\n\n        if (!i) {\n          (i = document.createElementNS(r, \"animate\")).setAttributeNS(null, \"attributeName\", \"opacity\"), i.setAttributeNS(null, \"dur\", \"4s\"), i.setAttributeNS(null, \"fill\", \"freeze\"), i.setAttributeNS(null, \"keyTimes\", \"0; 0.25; 0.5; 0.75; 1\");\n          const t = (n + 3 * o) / 4;\n          i.setAttributeNS(null, \"values\", \"\".concat(n, \"; \").concat(t, \"; \").concat(o, \"; \").concat(t, \"; \").concat(n));\n        }\n\n        return e ? i.setAttributeNS(null, \"repeatCount\", \"indefinite\") : i.setAttributeNS(null, \"repeatCount\", \"1\"), t.appendChild(i), t;\n      }\n    }, function (t, e, n) {\n      \"use strict\";\n\n      n.r(e), n.d(e, \"PATH_SCALE\", function () {\n        return r;\n      }), n.d(e, \"staffLinePath\", function () {\n        return i;\n      }), n.d(e, \"extraLinePath\", function () {\n        return a;\n      }), n.d(e, \"barPath\", function () {\n        return s;\n      }), n.d(e, \"stemPath\", function () {\n        return u;\n      }), n.d(e, \"singleFlagPath\", function () {\n        return c;\n      }), n.d(e, \"multiFlagPath\", function () {\n        return l;\n      }), n.d(e, \"tiePath\", function () {\n        return h;\n      }), n.d(e, \"dotPath\", function () {\n        return p;\n      }), n.d(e, \"NOTE_PATHS\", function () {\n        return f;\n      }), n.d(e, \"REST_PATHS\", function () {\n        return d;\n      }), n.d(e, \"CLEF_PATHS\", function () {\n        return m;\n      }), n.d(e, \"ACCIDENTAL_PATHS\", function () {\n        return g;\n      });\n      const r = 100,\n            o = \"M 0,10 C 0,-15 35,-50 80,-50 110,-50 125,-35 125,-10 \\n125,15 90,50 45,50 15,50 0,35 0,10 Z\",\n            i = \"m 0,0 h 100\",\n            a = \"m -25,0 h 175\",\n            s = \"m 0,-200 v 400\",\n            u = \"m 0,0 v 100 h 15 v -100 z\",\n            c = \"M0,0 h 12 c 7,100 175,156 62,314 79,-177 -49,\\n-193 -61,-200 l -13,-5 z\",\n            l = \"m 0,0 h 10 c 6,72 173,64 84,227 44,-120 -44,\\n-123 -94,-167 z\",\n            h = \"M 0,25 C 10,46 30,67 50,67 69,67 90,47 100,25 94,\\n65 73,89 50,89 26,89 5,63 0,25 Z\",\n            p = \"M 5 -20 a 20 20 0 1 0 0.00001 0 z\",\n            f = {\n        4: {\n          path: \"m 0,0 c 0,-37 49,-51 79,-51 31,0 83,13 83,51 0,39 \\n-55,51 -84,51 C 49,51 0,37 0,0 Z m 111,31 c 13,-19 0,-58 -22,-68 -33,-15 \\n-53,10 -39,49 9,27 48,39 61,19 z\",\n          width: 150,\n          stemVSteps: 0,\n          stemAnchor: 0,\n          flags: 0\n        },\n        2: {\n          path: \"m 0,10 c 0,-25 35,-60 80,-60 15,0 45,4 45,40 C 125,16 \\n89,50 45,50 17,50 0,36 0,10 Z m 71,7 c 17,-11 45,-34 38,-45 -7,-10 -39,1 \\n-57,12 -19,11 -42,31 -36,42 6,10 37,2 55,-9 z\",\n          width: 125,\n          stemVSteps: 7,\n          stemAnchor: -10,\n          flags: 0\n        },\n        1: {\n          path: o,\n          width: 125,\n          stemVSteps: 7,\n          stemAnchor: -10,\n          flags: 0\n        },\n        .5: {\n          path: o,\n          width: 125,\n          stemVSteps: 7,\n          stemAnchor: -10,\n          flags: 1\n        },\n        .25: {\n          path: o,\n          width: 125,\n          stemVSteps: 9,\n          stemAnchor: -10,\n          flags: 2\n        },\n        .125: {\n          path: o,\n          width: 125,\n          stemVSteps: 11,\n          stemAnchor: -10,\n          flags: 3\n        },\n        .0625: {\n          path: o,\n          width: 125,\n          stemVSteps: 13,\n          stemAnchor: -10,\n          flags: 4\n        }\n      },\n            d = {\n        4: \"m 0,-50 h 125 v -50 H 0 Z\",\n        2: \"M 0,0 H 125 V -50 H 0 Z\",\n        1: \"m 0,-25 c 39,-39 37,-75 8,-120 l 6,-5 61,103 C \\n40,-13 31,4 73,71 l -5,5 C 14,52 16,125 67,144 l -4,6 C -37,102 -1,22 59,60 Z\",\n        .5: \"m 52,-47 c 26,-2 42,-21 48,-42 l 12,4 L 64,83 52,79 \\n88,-49 c 0,0 -17,22 -57,22 -16,0 -31,-13 -31,-27 0,-18 10,-31 27,-31 17,0 \\n33,15 25,38 z\",\n        .25: \"m 129,-191 c -6,21 -22,40 -48,42 8,-23 -8,-38 \\n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -20,69 \\nc -7,18 -22,33 -45,35 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 15,27 \\n31,27 40,0 57,-22 57,-22 l -36,128 12,4 77,-270 z\",\n        .125: \"m 129,-191 c -6,21 -22,40 -48,42 8,-23 -8,-38 \\n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -20,69 \\nc -7,18 -22,33 -45,35 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 15,27 \\n31,27 40,0 57,-22 57,-22 L 68,20 C 61,37 46,51 24,52 32,29 16,14 -1,14 c \\n-17,0 -27,13 -27,31 0,14 15,27 31,27 38,0 55,-20 57,-22 l -36,128 12,4 \\n105,-369 z\",\n        .0625: \"m 158,-292 c -6,21 -22,40 -48,42 8,-23 -8,-38 \\n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 l -17,61 \\nv 0 c -6,21 -22,40 -48,42 8,-23 -8,-38 -25,-38 -17,0 -27,13 -27,31 0,14 \\n15,27 31,27 40,0 57,-22 57,-22 l -20,69 c -7,18 -22,33 -45,35 8,-23 -8,-38 \\n-25,-38 -17,0 -27,13 -27,31 0,14 15,27 31,27 40,0 57,-22 57,-22 L 68,20 C \\n61,37 46,51 24,52 32,29 16,14 -1,14 c -17,0 -27,13 -27,31 0,14 15,27 31,27 \\n38,0 55,-20 57,-22 l -36,128 12,4 134,-469 z\"\n      },\n            m = {\n        50: {\n          path: \"m 101,-199 c -49,0 -100,28 -100,83 0,39 58,57 82,26 15,-20 \\n-4,-47 -32,-47 -23,1 -25,0 -25,-8 0,-22 40,-46 71,-41 91,16 67,208 -105,302 \\n75,-27 198,-94 211,-201 6,-66 -42,-114 -102,-114 z m 143,33 c -13,0 -23,11 \\n-23,24 0,14 10,24 23,24 13,0 23,-11 23,-24 0,-13 -10,-24 -23,-24 z m 2,83 c \\n-13,0 -23,11 -23,24 0,14 10,24 23,24 13,0 23,-11 23,-24 0,-13 -10,-24 -23,-24 \\nz\",\n          upper: -4,\n          lower: 3\n        },\n        71: {\n          path: \"M 139,48 C 102,57 76,120 131,151 41,128 64,24 129,2 L \\n117,-57 C -32,47 26,217 166,182 Z m 12,-1 27,131 C 242,153 216,46 151,47 \\nZ m -35,-177 c 34,-23 82,-117 50,-140 -23,-17 -71,33 -50,140 z m -10,10 c \\n-23,-77 -20,-200 48,-213 19,-4 89,171 -26,266 l 13,66 c 120,-6 137,155 \\n39,191 l 12,58 c 30,131 -137,145 -138,47 0,-29 37,-59 63,-37 21,18 25,71 \\n-25,70 32,42 103,0 91,-65 L 167,193 C 56,232 -112,63 106,-120 Z\",\n          upper: -7,\n          lower: 8\n        }\n      },\n            g = [null, \"m -49,-121 v 52 l -29,9 v -48 h -8 v 51 l -20,6 v 29 l \\n20,-6 v 70 l -20,6 v 30 l 20,-6 v 51 h 8 V 69 l 30,-8 v 50 h 8 V 58 l 20,-6 \\nV 23 l -20,6 v -71 l 20,-6 v -29 l -20,6 v -50 z m 1,82 v 71 l -29,9 v -71 z\", \"M -106,-166 V 67 c 52,-42 85,-56 85,-94 0,-47 -46,-51 \\n-73,-22 v -117 z m 31,120 c 20,0 42,46 -20,91 V -7 c 0,-28 10,-39 20,-39 z\", \"m -81,-58 v -48 H -92 V 73 l 60,-13 v 50 h 11 V -72 Z m \\n50,24 v 58 l -50,11 v -58 z\"];\n    }, function (t, e, n) {\n      \"use strict\";\n\n      n.r(e), n.d(e, \"MIN_RESOLUTION\", function () {\n        return r;\n      }), n.d(e, \"STEM_WIDTH\", function () {\n        return o;\n      }), n.d(e, \"LINE_STROKE\", function () {\n        return i;\n      }), n.d(e, \"COMPACT_SPACING\", function () {\n        return a;\n      });\n      const r = .0625,\n            o = 15,\n            i = 1,\n            a = 150;\n    }, function (t, e, n) {\n      \"use strict\";\n\n      n.r(e), n.d(e, \"MAX_QUARTER_DIVISION\", function () {\n        return u;\n      }), n.d(e, \"ScrollType\", function () {\n        return c;\n      }), n.d(e, \"StaffSVGRender\", function () {\n        return l;\n      });\n      var r = n(2),\n          o = n(0),\n          i = n(1);\n      const a = [{\n        steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6],\n        accidental: [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0]\n      }, {\n        steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6],\n        accidental: [0, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 3]\n      }, {\n        steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6],\n        accidental: [3, 0, 0, 1, 0, 3, 0, 0, 1, 0, 1, 0]\n      }, {\n        steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6],\n        accidental: [0, 2, 0, 0, 3, 0, 2, 0, 0, 3, 0, 3]\n      }, {\n        steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6],\n        accidental: [3, 0, 3, 0, 0, 3, 0, 3, 0, 0, 1, 0]\n      }, {\n        steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6],\n        accidental: [0, 2, 0, 2, 0, 0, 2, 0, 2, 0, 0, 3]\n      }, {\n        steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -7],\n        accidental: [3, 0, 3, 0, 3, 0, 0, 3, 0, 3, 0, 0]\n      }, {\n        steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6],\n        accidental: [0, 1, 0, 1, 0, 3, 0, 0, 1, 0, 1, 0]\n      }, {\n        steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6],\n        accidental: [0, 0, 3, 0, 3, 0, 2, 0, 0, 3, 0, 3]\n      }, {\n        steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6],\n        accidental: [3, 0, 0, 1, 0, 3, 0, 3, 0, 0, 1, 0]\n      }, {\n        steps: [0, -1, -1, -2, -2, -3, -4, -4, -5, -5, -6, -6],\n        accidental: [0, 2, 0, 0, 3, 0, 2, 0, 2, 0, 0, 3]\n      }, {\n        steps: [0, 0, -1, -1, -2, -3, -3, -4, -4, -5, -5, -6],\n        accidental: [3, 0, 3, 0, 0, 3, 0, 3, 0, 3, 0, 0]\n      }],\n            s = [{\n        accidental: 1,\n        pitches: []\n      }, {\n        accidental: 2,\n        pitches: [70, 75, 68, 73, 66]\n      }, {\n        accidental: 1,\n        pitches: [78, 73]\n      }, {\n        accidental: 2,\n        pitches: [70, 75, 68]\n      }, {\n        accidental: 1,\n        pitches: [78, 73, 80, 75]\n      }, {\n        accidental: 2,\n        pitches: [70]\n      }, {\n        accidental: 2,\n        pitches: [70, 75, 68, 73, 66, 71]\n      }, {\n        accidental: 1,\n        pitches: [78]\n      }, {\n        accidental: 2,\n        pitches: [70, 75, 68, 73]\n      }, {\n        accidental: 1,\n        pitches: [78, 73, 80]\n      }, {\n        accidental: 2,\n        pitches: [70, 75]\n      }, {\n        accidental: 1,\n        pitches: [78, 73, 80, 75, 70]\n      }],\n            u = 16;\n      var c;\n      !function (t) {\n        t[t.PAGE = 0] = \"PAGE\", t[t.NOTE = 1] = \"NOTE\", t[t.BAR = 2] = \"BAR\";\n      }(c || (c = {}));\n\n      class l {\n        constructor(t, e, n) {\n          this.handleScrollEvent = t => {\n            this.lastKnownScrollLeft = this.parentElement.scrollLeft, this.ticking || window.requestAnimationFrame(() => {\n              this.changeAndDrawSignaturesIfNeeded(this.lastKnownScrollLeft), this.ticking = !1;\n            }), this.ticking = !0;\n          }, this.scoreInfo = t, this.config = {\n            noteHeight: e.noteHeight || 6,\n            noteSpacing: e.noteSpacing || 1,\n            pixelsPerTimeStep: e.pixelsPerTimeStep || 30,\n            noteRGB: e.noteRGB || \"8, 41, 64\",\n            activeNoteRGB: e.activeNoteRGB || \"240, 84, 119\"\n          }, this.div = n, this.timeSignatureNumerator = 4, this.timeSignatureDenominator = 4, this.key = e.defaultKey || 0, this.scrollType = e.scrollType || c.PAGE, this.scale = this.config.noteHeight / i.PATH_SCALE, (void 0 === e.pixelsPerTimeStep || e.pixelsPerTimeStep <= 0) && (this.config.pixelsPerTimeStep = 0, this.config.noteSpacing = r.COMPACT_SPACING * this.scale), this.clear(), this.redraw();\n        }\n\n        clear() {\n          for (; this.div.lastChild;) this.div.removeChild(this.div.lastChild);\n\n          this.div.style.overflow = \"visible\", this.div.style.position = \"relative\", this.overlaySVG = document.createElementNS(o.SVGNS, \"svg\"), this.overlaySVG.style.position = \"absolute\", this.div.appendChild(this.overlaySVG), this.overlayG = Object(o.createSVGGroupChild)(this.overlaySVG, \"overlay\"), this.signaturesBlinking = !1, this.signaturesQuarters = 0, this.parentElement = document.createElement(\"div\"), this.parentElement.style.overflow = \"auto\", this.div.appendChild(this.parentElement), this.ticking = !1, this.lastKnownScrollLeft = 0, this.parentElement.addEventListener(\"scroll\", this.handleScrollEvent), this.staffSVG = document.createElementNS(o.SVGNS, \"svg\"), this.parentElement.appendChild(this.staffSVG), this.staffG = Object(o.createSVGGroupChild)(this.staffSVG, \"staff\"), this.linesG = Object(o.createSVGGroupChild)(this.staffSVG, \"lines\"), this.setStroke(this.linesG), this.staffG.appendChild(this.linesG), this.musicG = Object(o.createSVGGroupChild)(this.staffSVG, \"music\"), this.setFill(this.musicG), this.setStroke(this.musicG, 0), this.staffG.appendChild(this.musicG), this.signaturesG = Object(o.createSVGGroupChild)(this.staffSVG, \"signatures\"), this.staffG.appendChild(this.signaturesG);\n          let t = 0,\n              e = 0;\n          this.scoreInfo.notes.forEach(n => {\n            t += n.pitch, ++e;\n          });\n          const n = t / e;\n          this.clef = n < 60 ? 50 : 71, this.signaturesList = [{\n            x: 0,\n            q: 0\n          }], this.signatureCurrent = 0, this.signatureNext = 0, this.changeKeySignatureIfNeeded(0), this.changeTimeSignatureIfNeeded(0), this.vStepSize = this.config.noteHeight / 2, this.hStepSize = this.config.pixelsPerTimeStep, this.staffOffset = 0, this.height = 0, this.width = 0, this.musicBlockMap = new Map(), this.playingNotes = [], this.lastBar = 0, this.barAccidentals = {}, this.lastQ = -1;\n        }\n\n        isPaintingActiveNote(t, e) {\n          const n = t.start === e.start,\n                r = t.start <= e.start && t.start + t.length >= e.start + e.length;\n          return n || r;\n        }\n\n        redraw(t, e) {\n          let n = -1;\n          const r = 0 === this.config.pixelsPerTimeStep;\n\n          if (t) {\n            const i = [];\n            this.playingNotes.forEach(e => {\n              this.isPaintingActiveNote(e, t) ? i.push(e) : this.highlightElement(this.getGroup(e), !1);\n            }), this.playingNotes = i;\n            const a = this.getGroup(t);\n\n            if (a) {\n              this.playingNotes.push(t), this.highlightElement(a, !0), n = a.getBoundingClientRect().left - this.staffSVG.getBoundingClientRect().left;\n              const i = t.start,\n                    s = a.getAttribute(\"data-is-bar-beginning\");\n              (this.scrollType !== c.BAR || s) && this.scrollIntoViewIfNeeded(e, n), !r && this.signaturesBlinking && i >= this.signaturesQuarters && (this.signaturesBlinking = !1, Object(o.setFade)(this.overlayG, this.signaturesBlinking));\n            }\n          } else {\n            this.setDetails();\n            const t = -1 === this.lastQ;\n            let e = 0,\n                n = 0;\n            t ? (n = this.drawSignatures(this.overlayG, e, !0, !0, !0), r && (this.width = 0, n += this.config.noteSpacing), n += this.drawRests(this.initialRest, e + n)) : e = this.width, this.musicBlockMap.forEach((t, o) => {\n              r || (e = this.quartersToTime(o) * this.hStepSize), o > this.lastQ ? (n += this.drawMusicBlock(t, e + n), this.lastQ = o) : o === this.lastQ && (n += this.drawRests(t, e + n));\n            });\n            const o = this.staffSVG.getBoundingClientRect(),\n                  i = this.musicG.getBoundingClientRect();\n            if (this.updateVerticalBoundaries(i.top - o.top, i.bottom - o.top), r) this.width += n;else {\n              const t = this.musicBlockMap.get(this.lastQ),\n                    e = this.quartersToTime(this.lastQ + t.notes[0].length);\n              this.width = e * this.config.pixelsPerTimeStep;\n            }\n            this.staffSVG.setAttributeNS(null, \"width\", \"\".concat(this.width)), this.redrawStaff(this.linesG, 0, this.width);\n          }\n\n          return n;\n        }\n\n        drawMusicBlock(t, e) {\n          const n = t.notes[0].start;\n          let a = this.drawBarIfNeeded(n, e);\n          a += this.drawSignaturesIfNeeded(n, e + a);\n          let s = 0;\n\n          for (let e = 4; e >= r.MIN_RESOLUTION && !s; e /= 2) e <= t.notes[0].length && (s = e);\n\n          if (0 === s) {\n            const e = 0 === t.notes[0].length ? \"[infinite]\" : \"\".concat(4 / t.notes[0].length);\n            console.warn(\" StaffRender \", \"background:orange; color:white\", \"StaffRender does not handle notes shorther than \" + \"1/\".concat(4 / r.MIN_RESOLUTION, \"th, and this score tries to draw a \") + \"1/\".concat(e, \"th. Shortest possible note will be drawn instead.\")), s = r.MIN_RESOLUTION;\n          }\n\n          const u = i.NOTE_PATHS[s];\n          let c;\n\n          if (u.stemAnchor && (c = Object(o.createSVGGroupChild)(this.musicG, \"stem\")), t.notes.forEach(n => {\n            const r = n.vSteps * this.vStepSize,\n                  c = 2 * (n.vSteps > 0 ? Math.floor(n.vSteps / 2) : Math.ceil(n.vSteps / 2)),\n                  l = n.vSteps > 0 ? -2 : 2;\n\n            for (let t = c; Math.abs(t) > 4; t += l) Object(o.drawSVGPath)(this.linesG, i.extraLinePath, e + a, t * this.vStepSize, this.scale, 1);\n\n            if (n.g = n.tiedFrom ? n.tiedFrom.g : Object(o.createSVGGroupChild)(this.musicG, \"\".concat(n.start, \"-\").concat(n.pitch)), t.isBarBeginning && n.g.setAttribute(\"data-is-bar-beginning\", \"true\"), n.tiedFrom) {\n              const t = e + a - n.tiedFrom.xHeadRight;\n              Object(o.drawSVGPath)(n.g, i.tiePath, n.tiedFrom.xHeadRight, r, t / i.PATH_SCALE, this.scale * (n.vSteps < 0 ? -1 : 1), n.opacity);\n            }\n\n            Object(o.drawSVGPath)(n.g, u.path, e + a, r, this.scale, this.scale, n.opacity), n.xHeadRight = e + a + u.width * this.scale, 1.5 * s <= n.length && Object(o.drawSVGPath)(n.g, i.dotPath, e + a + u.width * this.scale + this.vStepSize / 2, r - this.vStepSize / 2, this.scale, this.scale, n.opacity), 0 !== n.accidental && Object(o.drawSVGPath)(n.g, i.ACCIDENTAL_PATHS[n.accidental], e + a, r, this.scale, this.scale, n.opacity);\n          }), u.stemAnchor) {\n            let n,\n                s,\n                l = e + a;\n            const h = u.stemAnchor * this.scale,\n                  p = t.minVStep + t.maxVStep < 0,\n                  f = u.flags > 2 ? 2 * (u.flags - 2) : 0;\n            if (p ? (n = t.maxVStep * this.vStepSize - h, s = (t.minVStep + 7 + f) * this.vStepSize) : (l += (u.width - r.STEM_WIDTH) * this.scale, n = t.minVStep * this.vStepSize + h, s = (t.maxVStep - 7 - f) * this.vStepSize), Object(o.drawSVGPath)(c, i.stemPath, l, n, this.scale, (s - n) / i.PATH_SCALE), 1 === u.flags) Object(o.drawSVGPath)(c, i.singleFlagPath, l, s, this.scale, this.scale * (p ? -1 : 1), 1);else if (u.flags > 1) for (let t = 0; t < u.flags; ++t) Object(o.drawSVGPath)(c, i.multiFlagPath, l, s, this.scale, this.scale * (p ? -1 : 1), 1), s += (p ? -2 : 2) * this.vStepSize;\n          }\n\n          return 0 === this.config.pixelsPerTimeStep && (a += u.width * this.scale, c && (a += c.getBoundingClientRect().width), a += this.config.noteSpacing), a += this.drawRests(t, e + a);\n        }\n\n        drawBarIfNeeded(t, e) {\n          let n = 0;\n          const r = this.lastBar + this.getBarLength();\n          return 0 !== t && t >= r && (this.config.pixelsPerTimeStep > 0 ? e -= this.config.noteSpacing : n = this.config.noteSpacing, Object(o.drawSVGPath)(this.linesG, i.barPath, e, 0, 1, this.scale), this.lastBar = r), n;\n        }\n\n        drawRests(t, e) {\n          let n = 0,\n              a = t.restToNextLength;\n\n          if (a) {\n            this.config.pixelsPerTimeStep > 0 && (e += this.quartersToTime(t.notes[0].length) * this.hStepSize);\n            let s = t.notes[0].start + t.notes[0].length,\n                u = 0;\n            const c = this.lastBar + this.getBarLength() - s;\n            let l;\n\n            for (a > c && (u = a - c, a = c), l = 4; l > this.getBarLength() && l >= r.MIN_RESOLUTION; l /= 2);\n\n            let h = l;\n\n            for (; (a || u) && h >= r.MIN_RESOLUTION;) {\n              if (h <= a) {\n                n += this.drawBarIfNeeded(s, e + n), n += this.drawSignaturesIfNeeded(s, e + n);\n                const t = Object(o.drawSVGPath)(this.musicG, i.REST_PATHS[h], e + n, 0, this.scale, this.scale);\n                this.config.pixelsPerTimeStep > 0 ? e += this.quartersToTime(h) * this.hStepSize : (n += t.getBoundingClientRect().width, n += this.config.noteSpacing), s += h, a -= h;\n              }\n\n              if (u && a <= 0) {\n                const t = this.getBarLength();\n\n                for (u > t ? (a = t, u -= t) : (a = u, u = 0), l = 4; l > this.getBarLength() && l >= r.MIN_RESOLUTION; l /= 2);\n\n                h = l;\n              }\n\n              a < h && (h /= 2);\n            }\n          }\n\n          return n;\n        }\n\n        redrawStaff(t, e, n) {\n          let r = t.querySelector('g[data-id=\"staff-five-lines\"]');\n          if (r) r.setAttributeNS(null, \"transform\", \"scale(\".concat(n / i.PATH_SCALE, \", 1)\"));else {\n            r = Object(o.createSVGGroupChild)(t, \"staff-five-lines\");\n            const a = 0;\n\n            for (let t = -4; t <= 4; t += 2) Object(o.drawSVGPath)(r, i.staffLinePath, e, a + t * this.vStepSize, n / i.PATH_SCALE, 1);\n          }\n          return r;\n        }\n\n        clearSignatureOverlay() {\n          for (; this.overlayG.lastChild;) this.overlayG.removeChild(this.overlayG.lastChild);\n        }\n\n        drawSignaturesIfNeeded(t, e) {\n          let n = 0;\n          const i = this.changeKeySignatureIfNeeded(t),\n                a = this.changeTimeSignatureIfNeeded(t);\n\n          if (i || a) {\n            const s = r.COMPACT_SPACING * this.scale * (this.config.pixelsPerTimeStep > 0 ? 3 : 2);\n            this.signaturesList.push({\n              x: e - s,\n              q: t\n            }), null === this.signatureNext && (this.signatureNext = e);\n            const u = t > 0 ? Object(o.createSVGGroupChild)(this.signaturesG, \"signatures\") : this.overlayG;\n            n += this.drawSignatures(u, e + n, !1, i, a);\n          }\n\n          return 0 === this.config.pixelsPerTimeStep ? n : 0;\n        }\n\n        drawSignatures(t, e, n, a, u) {\n          const c = r.COMPACT_SPACING * this.scale;\n          let l,\n              h = c;\n          const p = t === this.overlayG || this.config.pixelsPerTimeStep > 0;\n\n          if (p) {\n            (l = document.createElementNS(o.SVGNS, \"rect\")).setAttributeNS(null, \"x\", \"\".concat(e)), l.setAttributeNS(null, \"y\", \"0\"), l.setAttributeNS(null, \"width\", \"1\"), l.setAttributeNS(null, \"height\", \"1\"), l.setAttribute(\"data-id\", \"background\"), t.appendChild(l);\n            const n = document.defaultView.getComputedStyle(this.div.parentElement);\n            l.setAttributeNS(null, \"fill\", n.getPropertyValue(\"background-color\"));\n          }\n\n          if (n) {\n            const n = Object(o.drawSVGPath)(t, i.CLEF_PATHS[this.clef].path, e + h, 0, this.scale, this.scale);\n            this.setFill(n), h += 3 * c;\n          }\n\n          if (a) {\n            const n = s[this.key].accidental,\n                  r = 71 === this.clef ? 0 : 14;\n            s[this.key].pitches.forEach(a => {\n              const s = this.getPitchDetails(a).vSteps,\n                    u = Object(o.drawSVGPath)(t, i.ACCIDENTAL_PATHS[n], e + h, (r + s) * this.vStepSize, this.scale, this.scale);\n              this.setFill(u), h += u.getBoundingClientRect().width;\n            });\n          }\n\n          if (u) {\n            const n = Object(o.createSVGGroupChild)(t, \"time-key\"),\n                  r = \"\".concat(2.85 * this.config.noteHeight, \"px\");\n            Object(o.drawSVGText)(n, \"\".concat(this.timeSignatureNumerator), e + h, -.5, r, !0), Object(o.drawSVGText)(n, \"\".concat(this.timeSignatureDenominator), e + h, 4 * this.vStepSize - .5, r, !0), this.setFill(n), h += n.getBoundingClientRect().width + c;\n          }\n\n          const f = this.redrawStaff(t, e, h);\n          this.setStroke(f);\n          const d = this.div.getBoundingClientRect(),\n                m = t.getBoundingClientRect();\n\n          if (this.updateVerticalBoundaries(m.top - d.top, m.bottom - d.top), p && (l.setAttributeNS(null, \"y\", \"\".concat(-this.staffOffset)), l.setAttributeNS(null, \"height\", \"\".concat(this.height)), l.setAttributeNS(null, \"width\", \"\".concat(h))), t === this.overlayG) {\n            this.overlaySVG.setAttributeNS(null, \"width\", \"\".concat(h + 5));\n\n            for (let e = 0; e < 5; ++e) {\n              const n = Object(o.drawSVGPath)(t, i.stemPath, h + e, e * e - this.staffOffset, 1 / r.STEM_WIDTH, (this.height - 2 * e * e) / i.PATH_SCALE, (e - 5) * (e - 5) * 2 / i.PATH_SCALE);\n              this.setFill(n);\n            }\n          }\n\n          if (this.config.pixelsPerTimeStep > 0) {\n            const n = 0 === this.signaturesQuarters;\n            return n && (this.signaturesQuarters = this.timeToQuarters(h / this.hStepSize)), (n || e > 0) && (this.signaturesBlinking = !0, Object(o.setFade)(t, this.signaturesBlinking)), 0;\n          }\n\n          return h;\n        }\n\n        changeKeySignatureIfNeeded(t) {\n          if (this.scoreInfo.keySignatures) {\n            let e = this.key;\n\n            for (let n = 0; n < this.scoreInfo.keySignatures.length && this.scoreInfo.keySignatures[n].start <= t; ++n) e = this.scoreInfo.keySignatures[n].key;\n\n            if (e !== this.key) return this.key = e, !0;\n          }\n\n          return !1;\n        }\n\n        changeTimeSignatureIfNeeded(t) {\n          if (this.scoreInfo.timeSignatures) {\n            let e = this.timeSignatureNumerator,\n                n = this.timeSignatureDenominator;\n\n            for (let r = 0; r < this.scoreInfo.timeSignatures.length && this.scoreInfo.timeSignatures[r].start <= t; ++r) e = this.scoreInfo.timeSignatures[r].numerator, n = this.scoreInfo.timeSignatures[r].denominator;\n\n            if (e !== this.timeSignatureNumerator || n !== this.timeSignatureDenominator) return this.timeSignatureNumerator = e, this.timeSignatureDenominator = n, !0;\n          }\n\n          return !1;\n        }\n\n        changeAndDrawSignaturesIfNeeded(t) {\n          let e;\n\n          if (t < this.signatureCurrent || null !== this.signatureNext && this.signatureNext <= t) {\n            e = this.signaturesList[0].q, this.signatureNext = null;\n\n            for (let n = 0; n < this.signaturesList.length; ++n) {\n              if (t < this.signaturesList[n].x) {\n                this.signatureNext = this.signaturesList[n].x;\n                break;\n              }\n\n              this.signatureCurrent = this.signaturesList[n].x, e = this.signaturesList[n].q;\n            }\n          }\n\n          if (void 0 !== e) {\n            const t = this.key,\n                  n = this.timeSignatureNumerator,\n                  r = this.timeSignatureDenominator;\n            this.changeKeySignatureIfNeeded(e), this.changeTimeSignatureIfNeeded(e), this.clearSignatureOverlay(), this.drawSignatures(this.overlayG, 0, !0, !0, !0), this.key = t, this.timeSignatureNumerator = n, this.timeSignatureDenominator = r;\n          }\n\n          this.config.pixelsPerTimeStep > 0 && 0 === t && (this.signatureNext = 0, this.signaturesBlinking = !0, Object(o.setFade)(this.overlayG, this.signaturesBlinking));\n        }\n\n        getBarLength() {\n          return 4 * this.timeSignatureNumerator / this.timeSignatureDenominator;\n        }\n\n        scrollIntoViewIfNeeded(t, e) {\n          if (t) if (this.scrollType === c.PAGE) {\n            const t = this.parentElement.getBoundingClientRect().width;\n            e > this.parentElement.scrollLeft + t && (this.parentElement.scrollLeft = e - 20);\n          } else {\n            const t = this.parentElement.getBoundingClientRect().width;\n            this.parentElement.scrollLeft = e - .5 * t;\n          }\n        }\n\n        updateVerticalBoundaries(t, e) {\n          let n = 0;\n\n          if (t < 0) {\n            this.staffOffset -= t;\n            const e = \"translate(0, \".concat(this.staffOffset, \")\");\n            this.overlayG.setAttributeNS(null, \"transform\", e), this.staffG.setAttributeNS(null, \"transform\", e), n = this.height - t;\n          }\n\n          if ((n = Math.max(n, e - t)) > this.height) {\n            this.height = n, this.overlaySVG.setAttributeNS(null, \"height\", \"\".concat(this.height)), this.staffSVG.setAttributeNS(null, \"height\", \"\".concat(this.height));\n            const t = this.div.querySelectorAll('rect[data-id=\"background\"]');\n\n            for (let e = 0; e < t.length; ++e) {\n              const n = t[e];\n              n.setAttributeNS(null, \"y\", \"\".concat(-this.staffOffset)), n.setAttributeNS(null, \"height\", \"\".concat(this.height));\n            }\n          }\n        }\n\n        setFill(t, e = !1) {\n          t.setAttributeNS(null, \"fill\", this.getColor(e));\n        }\n\n        setStroke(t, e = r.LINE_STROKE, n = !1) {\n          t.setAttributeNS(null, \"stroke\", this.getColor(n)), t.setAttributeNS(null, \"stroke-width\", \"\".concat(e));\n        }\n\n        getColor(t) {\n          return \"rgb(\".concat(t ? this.config.activeNoteRGB : this.config.noteRGB, \")\");\n        }\n\n        getOpacity(t) {\n          return t ? t / 127 * .8 + .2 : 1;\n        }\n\n        getGroup(t) {\n          const e = t.start,\n                n = t.pitch;\n          return this.staffSVG.querySelector(\"g[data-id=\\\"\".concat(e, \"-\").concat(n, \"\\\"]\"));\n        }\n\n        highlightElement(t, e) {\n          t.setAttribute(\"fill\", this.getColor(e)), t.setAttribute(\"stroke\", this.getColor(e));\n        }\n\n        getBarBeginnings() {\n          const t = new Set();\n          let e = 0;\n          this.scoreInfo.notes.forEach(t => {\n            t.start + t.length > e && (e = t.start + t.length);\n          });\n          const n = this.scoreInfo.timeSignatures ? this.scoreInfo.timeSignatures.slice(0) : [{\n            start: 0,\n            numerator: 4,\n            denominator: 4\n          }];\n          n.sort((t, e) => t.start - e.start);\n          let r = 0;\n\n          for (let o = 0; o < n.length; ++o) {\n            const i = o === n.length - 1 ? e : n[o].start,\n                  a = 4 * n[o].numerator / n[o].denominator;\n\n            for (; r < i; r += a) t.add(r);\n          }\n\n          return t;\n        }\n\n        quartersToTime(t) {\n          return t / this.scoreInfo.tempos[0].qpm * 60;\n        }\n\n        timeToQuarters(t) {\n          return t * this.scoreInfo.tempos[0].qpm / 60;\n        }\n\n        setDetails() {\n          let t = new Map();\n          const e = this.getBarBeginnings(),\n                n = new Set(e);\n          this.scoreInfo.notes.slice().sort((t, e) => t.start - e.start).forEach(e => {\n            const r = this.getQNote(e);\n            n.add(r.start), n.add(r.start + r.length), t.has(r.start) ? t.get(r.start).push(r) : t.set(r.start, [r]);\n          }), Array.from(n).sort((t, e) => t - e).forEach(e => {\n            const n = [];\n            t.forEach(t => {\n              t.forEach(t => {\n                const r = this.splitQNote(t, e);\n                r && n.push(r);\n              });\n            }), n.forEach(e => {\n              t.has(e.start) ? t.get(e.start).push(e) : t.set(e.start, [e]);\n            });\n          }), t = new Map(Array.from(t).sort((t, e) => t[0] - e[0]));\n          const r = this.key;\n          let o = null,\n              i = 0;\n          const a = e[Symbol.iterator]();\n          let s = a.next();\n          t.forEach((t, e) => {\n            const n = {\n              maxVStep: Number.MAX_SAFE_INTEGER,\n              minVStep: Number.MIN_SAFE_INTEGER,\n              restToNextLength: 0,\n              isBarBeginning: !1,\n              notes: []\n            };\n            this.changeKeySignatureIfNeeded(e);\n            const r = s.value + this.getBarLength();\n            !s.done && e >= r && (s = a.next(), this.barAccidentals = {}, n.isBarBeginning = !0), t.forEach(t => {\n              this.analyzePitch(t, e), n.minVStep = Math.max(t.vSteps, n.minVStep), n.maxVStep = Math.min(t.vSteps, n.maxVStep), n.notes.push(t);\n            }), o && (o.restToNextLength = e - i), this.musicBlockMap.set(e, n), o = n, i = e + n.notes[0].length;\n          }), this.initialRest = {\n            maxVStep: 0,\n            minVStep: 0,\n            restToNextLength: this.musicBlockMap.values().next().value.notes[0].start,\n            isBarBeginning: !0,\n            notes: [{\n              start: 0,\n              length: 0,\n              vSteps: 0,\n              accidental: 0,\n              opacity: 0,\n              pitch: 0,\n              xHeadRight: 0\n            }]\n          }, this.key = r;\n        }\n\n        getQNote(t) {\n          return {\n            start: t.start,\n            length: t.length,\n            vSteps: 0,\n            accidental: 0,\n            opacity: this.getOpacity(t.intensity),\n            pitch: t.pitch,\n            xHeadRight: 0\n          };\n        }\n\n        splitQNote(t, e) {\n          const n = t.start + t.length - e;\n          return e > t.start && n > 0 ? (t.length -= n, {\n            start: e,\n            length: n,\n            vSteps: t.vSteps,\n            accidental: t.accidental,\n            opacity: t.opacity,\n            pitch: t.pitch,\n            xHeadRight: 0,\n            tiedFrom: t\n          }) : null;\n        }\n\n        analyzePitch(t, e) {\n          const n = this.getPitchDetails(t.pitch);\n          n.vSteps in this.barAccidentals ? n.accidental === this.barAccidentals[n.vSteps] ? n.accidental = 0 : (3 === this.barAccidentals[n.vSteps] ? n.accidental = n.keyAccidental : 0 === n.accidental && (n.accidental = 3), this.barAccidentals[n.vSteps] = n.accidental) : (t.tiedFrom && (n.accidental = 0), this.barAccidentals[n.vSteps] = n.accidental), t.vSteps = n.vSteps, t.accidental = n.accidental;\n        }\n\n        getPitchDetails(t) {\n          const e = t - 60,\n                n = Math.floor(e / 12),\n                r = e - 12 * n,\n                o = a[this.key].steps[r],\n                i = 71 === this.clef ? 6 : -6,\n                u = 1 === s[this.key].accidental ? 69 + (r + 3) % 12 : 64 + (r + 8) % 12;\n          return {\n            vSteps: i - 7 * n + o,\n            accidental: a[this.key].accidental[r],\n            keyAccidental: s[this.key].pitches.indexOf(u) > -1 ? s[this.key].accidental : 0\n          };\n        }\n\n      }\n    }, function (t, e, n) {\n      \"use strict\";\n\n      n.r(e);\n      var r = n(3);\n      n.d(e, \"MAX_QUARTER_DIVISION\", function () {\n        return r.MAX_QUARTER_DIVISION;\n      }), n.d(e, \"ScrollType\", function () {\n        return r.ScrollType;\n      }), n.d(e, \"StaffSVGRender\", function () {\n        return r.StaffSVGRender;\n      });\n    }]);\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = function (t) {\n      for (var e = new Array(t), n = 0; n < t; ++n) e[n] = n;\n\n      return e;\n    };\n  }, function (t, e) {\n    function n(t) {\n      return !!t.constructor && \"function\" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t);\n    }\n    /*!\n     * Determine if an object is a Buffer\n     *\n     * @author   Feross Aboukhadijeh <https://feross.org>\n     * @license  MIT\n     */\n\n\n    t.exports = function (t) {\n      return null != t && (n(t) || function (t) {\n        return \"function\" == typeof t.readFloatLE && \"function\" == typeof t.slice && n(t.slice(0, 0));\n      }(t) || !!t._isBuffer);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(34),\n        o = n(15),\n        i = n(41),\n        a = n(56);\n\n    t.exports = function (t, e, n) {\n      var s,\n          u,\n          c = e.shape,\n          l = c.length,\n          h = 1,\n          p = new Array(l),\n          f = 0;\n\n      for (s = l - 1; s >= 0; --s) if (p[s] = h, h *= c[s], f = Math.max(f, a.scratchMemory(c[s])), e.shape[s] !== n.shape[s]) throw new Error(\"Shape mismatch, real and imaginary arrays must have same size\");\n\n      var d,\n          m = 4 * h + f;\n      d = \"array\" === e.dtype || \"float64\" === e.dtype || \"custom\" === e.dtype ? i.mallocDouble(m) : i.mallocFloat(m);\n      var g,\n          v,\n          y,\n          b,\n          w = o(d, c.slice(0), p, 0),\n          x = o(d, c.slice(0), p.slice(0), h),\n          S = o(d, c.slice(0), p.slice(0), 2 * h),\n          E = o(d, c.slice(0), p.slice(0), 3 * h),\n          C = 4 * h;\n\n      for (r.assign(w, e), r.assign(x, n), s = l - 1; s >= 0 && (a(t, h / c[s], c[s], d, w.offset, x.offset, C), 0 !== s); --s) {\n        for (v = 1, y = S.stride, b = E.stride, u = s - 1; u < l; ++u) b[u] = y[u] = v, v *= c[u];\n\n        for (u = s - 2; u >= 0; --u) b[u] = y[u] = v, v *= c[u];\n\n        r.assign(S, w), r.assign(E, x), g = w, w = S, S = g, g = x, x = E, E = g;\n      }\n\n      r.assign(e, w), r.assign(n, x), i.free(d);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(54);\n\n    t.exports = function (t) {\n      var e = [\"'use strict'\", \"var CACHED={}\"],\n          n = [],\n          o = t.funcName + \"_cwise_thunk\";\n      e.push([\"return function \", o, \"(\", t.shimArgs.join(\",\"), \"){\"].join(\"\"));\n\n      for (var i = [], a = [], s = [[\"array\", t.arrayArgs[0], \".shape.slice(\", Math.max(0, t.arrayBlockIndices[0]), t.arrayBlockIndices[0] < 0 ? \",\" + t.arrayBlockIndices[0] + \")\" : \")\"].join(\"\")], u = [], c = [], l = 0; l < t.arrayArgs.length; ++l) {\n        var h = t.arrayArgs[l];\n        n.push([\"t\", h, \"=array\", h, \".dtype,\", \"r\", h, \"=array\", h, \".order\"].join(\"\")), i.push(\"t\" + h), i.push(\"r\" + h), a.push(\"t\" + h), a.push(\"r\" + h + \".join()\"), s.push(\"array\" + h + \".data\"), s.push(\"array\" + h + \".stride\"), s.push(\"array\" + h + \".offset|0\"), l > 0 && (u.push(\"array\" + t.arrayArgs[0] + \".shape.length===array\" + h + \".shape.length+\" + (Math.abs(t.arrayBlockIndices[0]) - Math.abs(t.arrayBlockIndices[l]))), c.push(\"array\" + t.arrayArgs[0] + \".shape[shapeIndex+\" + Math.max(0, t.arrayBlockIndices[0]) + \"]===array\" + h + \".shape[shapeIndex+\" + Math.max(0, t.arrayBlockIndices[l]) + \"]\"));\n      }\n\n      for (t.arrayArgs.length > 1 && (e.push(\"if (!(\" + u.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same dimensionality!')\"), e.push(\"for(var shapeIndex=array\" + t.arrayArgs[0] + \".shape.length-\" + Math.abs(t.arrayBlockIndices[0]) + \"; shapeIndex--\\x3e0;) {\"), e.push(\"if (!(\" + c.join(\" && \") + \")) throw new Error('cwise: Arrays do not all have the same shape!')\"), e.push(\"}\")), l = 0; l < t.scalarArgs.length; ++l) s.push(\"scalar\" + t.scalarArgs[l]);\n\n      return n.push([\"type=[\", a.join(\",\"), \"].join()\"].join(\"\")), n.push(\"proc=CACHED[type]\"), e.push(\"var \" + n.join(\",\")), e.push([\"if(!proc){\", \"CACHED[type]=proc=compile([\", i.join(\",\"), \"])}\", \"return proc(\", s.join(\",\"), \")}\"].join(\"\")), t.debug && console.log(\"-----Generated thunk:\\n\" + e.join(\"\\n\") + \"\\n----------\"), new Function(\"compile\", e.join(\"\\n\"))(r.bind(void 0, t));\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(40);\n\n    function o(t, e, n) {\n      var r,\n          o,\n          i = t.length,\n          a = e.arrayArgs.length,\n          s = e.indexArgs.length > 0,\n          u = [],\n          c = [],\n          l = 0,\n          h = 0;\n\n      for (r = 0; r < i; ++r) c.push([\"i\", r, \"=0\"].join(\"\"));\n\n      for (o = 0; o < a; ++o) for (r = 0; r < i; ++r) h = l, l = t[r], 0 === r ? c.push([\"d\", o, \"s\", r, \"=t\", o, \"p\", l].join(\"\")) : c.push([\"d\", o, \"s\", r, \"=(t\", o, \"p\", l, \"-s\", h, \"*t\", o, \"p\", h, \")\"].join(\"\"));\n\n      for (c.length > 0 && u.push(\"var \" + c.join(\",\")), r = i - 1; r >= 0; --r) l = t[r], u.push([\"for(i\", r, \"=0;i\", r, \"<s\", l, \";++i\", r, \"){\"].join(\"\"));\n\n      for (u.push(n), r = 0; r < i; ++r) {\n        for (h = l, l = t[r], o = 0; o < a; ++o) u.push([\"p\", o, \"+=d\", o, \"s\", r].join(\"\"));\n\n        s && (r > 0 && u.push([\"index[\", h, \"]-=s\", h].join(\"\")), u.push([\"++index[\", l, \"]\"].join(\"\"))), u.push(\"}\");\n      }\n\n      return u.join(\"\\n\");\n    }\n\n    function i(t, e, n) {\n      for (var r = t.body, o = [], i = [], a = 0; a < t.args.length; ++a) {\n        var s = t.args[a];\n\n        if (!(s.count <= 0)) {\n          var u = new RegExp(s.name, \"g\"),\n              c = \"\",\n              l = e.arrayArgs.indexOf(a);\n\n          switch (e.argTypes[a]) {\n            case \"offset\":\n              var h = e.offsetArgIndex.indexOf(a);\n              l = e.offsetArgs[h].array, c = \"+q\" + h;\n\n            case \"array\":\n              c = \"p\" + l + c;\n              var p = \"l\" + a,\n                  f = \"a\" + l;\n              if (0 === e.arrayBlockIndices[l]) 1 === s.count ? \"generic\" === n[l] ? s.lvalue ? (o.push([\"var \", p, \"=\", f, \".get(\", c, \")\"].join(\"\")), r = r.replace(u, p), i.push([f, \".set(\", c, \",\", p, \")\"].join(\"\"))) : r = r.replace(u, [f, \".get(\", c, \")\"].join(\"\")) : r = r.replace(u, [f, \"[\", c, \"]\"].join(\"\")) : \"generic\" === n[l] ? (o.push([\"var \", p, \"=\", f, \".get(\", c, \")\"].join(\"\")), r = r.replace(u, p), s.lvalue && i.push([f, \".set(\", c, \",\", p, \")\"].join(\"\"))) : (o.push([\"var \", p, \"=\", f, \"[\", c, \"]\"].join(\"\")), r = r.replace(u, p), s.lvalue && i.push([f, \"[\", c, \"]=\", p].join(\"\")));else {\n                for (var d = [s.name], m = [c], g = 0; g < Math.abs(e.arrayBlockIndices[l]); g++) d.push(\"\\\\s*\\\\[([^\\\\]]+)\\\\]\"), m.push(\"$\" + (g + 1) + \"*t\" + l + \"b\" + g);\n\n                if (u = new RegExp(d.join(\"\"), \"g\"), c = m.join(\"+\"), \"generic\" === n[l]) throw new Error(\"cwise: Generic arrays not supported in combination with blocks!\");\n                r = r.replace(u, [f, \"[\", c, \"]\"].join(\"\"));\n              }\n              break;\n\n            case \"scalar\":\n              r = r.replace(u, \"Y\" + e.scalarArgs.indexOf(a));\n              break;\n\n            case \"index\":\n              r = r.replace(u, \"index\");\n              break;\n\n            case \"shape\":\n              r = r.replace(u, \"shape\");\n          }\n        }\n      }\n\n      return [o.join(\"\\n\"), r, i.join(\"\\n\")].join(\"\\n\").trim();\n    }\n\n    function a(t) {\n      for (var e = new Array(t.length), n = !0, r = 0; r < t.length; ++r) {\n        var o = t[r],\n            i = o.match(/\\d+/);\n        i = i ? i[0] : \"\", 0 === o.charAt(0) ? e[r] = \"u\" + o.charAt(1) + i : e[r] = o.charAt(0) + i, r > 0 && (n = n && e[r] === e[r - 1]);\n      }\n\n      return n ? e[0] : e.join(\"\");\n    }\n\n    t.exports = function (t, e) {\n      for (var n = e[1].length - Math.abs(t.arrayBlockIndices[0]) | 0, s = new Array(t.arrayArgs.length), u = new Array(t.arrayArgs.length), c = 0; c < t.arrayArgs.length; ++c) u[c] = e[2 * c], s[c] = e[2 * c + 1];\n\n      var l = [],\n          h = [],\n          p = [],\n          f = [],\n          d = [];\n\n      for (c = 0; c < t.arrayArgs.length; ++c) {\n        t.arrayBlockIndices[c] < 0 ? (p.push(0), f.push(n), l.push(n), h.push(n + t.arrayBlockIndices[c])) : (p.push(t.arrayBlockIndices[c]), f.push(t.arrayBlockIndices[c] + n), l.push(0), h.push(t.arrayBlockIndices[c]));\n\n        for (var m = [], g = 0; g < s[c].length; g++) p[c] <= s[c][g] && s[c][g] < f[c] && m.push(s[c][g] - p[c]);\n\n        d.push(m);\n      }\n\n      var v = [\"SS\"],\n          y = [\"'use strict'\"],\n          b = [];\n\n      for (g = 0; g < n; ++g) b.push([\"s\", g, \"=SS[\", g, \"]\"].join(\"\"));\n\n      for (c = 0; c < t.arrayArgs.length; ++c) {\n        v.push(\"a\" + c), v.push(\"t\" + c), v.push(\"p\" + c);\n\n        for (g = 0; g < n; ++g) b.push([\"t\", c, \"p\", g, \"=t\", c, \"[\", p[c] + g, \"]\"].join(\"\"));\n\n        for (g = 0; g < Math.abs(t.arrayBlockIndices[c]); ++g) b.push([\"t\", c, \"b\", g, \"=t\", c, \"[\", l[c] + g, \"]\"].join(\"\"));\n      }\n\n      for (c = 0; c < t.scalarArgs.length; ++c) v.push(\"Y\" + c);\n\n      if (t.shapeArgs.length > 0 && b.push(\"shape=SS.slice(0)\"), t.indexArgs.length > 0) {\n        var w = new Array(n);\n\n        for (c = 0; c < n; ++c) w[c] = \"0\";\n\n        b.push([\"index=[\", w.join(\",\"), \"]\"].join(\"\"));\n      }\n\n      for (c = 0; c < t.offsetArgs.length; ++c) {\n        var x = t.offsetArgs[c],\n            S = [];\n\n        for (g = 0; g < x.offset.length; ++g) 0 !== x.offset[g] && (1 === x.offset[g] ? S.push([\"t\", x.array, \"p\", g].join(\"\")) : S.push([x.offset[g], \"*t\", x.array, \"p\", g].join(\"\")));\n\n        0 === S.length ? b.push(\"q\" + c + \"=0\") : b.push([\"q\", c, \"=\", S.join(\"+\")].join(\"\"));\n      }\n\n      var E = r([].concat(t.pre.thisVars).concat(t.body.thisVars).concat(t.post.thisVars));\n\n      for ((b = b.concat(E)).length > 0 && y.push(\"var \" + b.join(\",\")), c = 0; c < t.arrayArgs.length; ++c) y.push(\"p\" + c + \"|=0\");\n\n      t.pre.body.length > 3 && y.push(i(t.pre, t, u));\n\n      var C = i(t.body, t, u),\n          I = function (t) {\n        for (var e = 0, n = t[0].length; e < n;) {\n          for (var r = 1; r < t.length; ++r) if (t[r][e] !== t[0][e]) return e;\n\n          ++e;\n        }\n\n        return e;\n      }(d);\n\n      I < n ? y.push(function (t, e, n, r) {\n        for (var i = e.length, a = n.arrayArgs.length, s = n.blockSize, u = n.indexArgs.length > 0, c = [], l = 0; l < a; ++l) c.push([\"var offset\", l, \"=p\", l].join(\"\"));\n\n        for (l = t; l < i; ++l) c.push([\"for(var j\" + l + \"=SS[\", e[l], \"]|0;j\", l, \">0;){\"].join(\"\")), c.push([\"if(j\", l, \"<\", s, \"){\"].join(\"\")), c.push([\"s\", e[l], \"=j\", l].join(\"\")), c.push([\"j\", l, \"=0\"].join(\"\")), c.push([\"}else{s\", e[l], \"=\", s].join(\"\")), c.push([\"j\", l, \"-=\", s, \"}\"].join(\"\")), u && c.push([\"index[\", e[l], \"]=j\", l].join(\"\"));\n\n        for (l = 0; l < a; ++l) {\n          for (var h = [\"offset\" + l], p = t; p < i; ++p) h.push([\"j\", p, \"*t\", l, \"p\", e[p]].join(\"\"));\n\n          c.push([\"p\", l, \"=(\", h.join(\"+\"), \")\"].join(\"\"));\n        }\n\n        for (c.push(o(e, n, r)), l = t; l < i; ++l) c.push(\"}\");\n\n        return c.join(\"\\n\");\n      }(I, d[0], t, C)) : y.push(o(d[0], t, C)), t.post.body.length > 3 && y.push(i(t.post, t, u)), t.debug && console.log(\"-----Generated cwise routine for \", e, \":\\n\" + y.join(\"\\n\") + \"\\n----------\");\n      var A = [t.funcName || \"unnamed\", \"_cwise_loop_\", s[0].join(\"s\"), \"m\", I, a(u)].join(\"\");\n      return new Function([\"function \", A, \"(\", v.join(\",\"), \"){\", y.join(\"\\n\"), \"} return \", A].join(\"\"))();\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    t.exports = function (t, e) {\n      switch (void 0 === e && (e = 0), typeof t) {\n        case \"number\":\n          if (t > 0) return function (t, e) {\n            var n, r;\n\n            for (n = new Array(t), r = 0; r < t; ++r) n[r] = e;\n\n            return n;\n          }(0 | t, e);\n          break;\n\n        case \"object\":\n          if (\"number\" == typeof t.length) return function t(e, n, r) {\n            var o = 0 | e[r];\n            if (o <= 0) return [];\n            var i,\n                a = new Array(o);\n            if (r === e.length - 1) for (i = 0; i < o; ++i) a[i] = n;else for (i = 0; i < o; ++i) a[i] = t(e, n, r + 1);\n            return a;\n          }(t, e, 0);\n      }\n\n      return [];\n    };\n  }, function (t, e, n) {\n    var r = n(42);\n\n    function o(t, e, n, o, i, a) {\n      var s, u, c, l, h, p, f, d, m, g, v, y, b, w, x, S, E, C, I, A, k, T, N, P;\n\n      for (t |= 0, e |= 0, i |= 0, a |= 0, s = n |= 0, u = r.log2(s), C = 0; C < e; ++C) {\n        for (f = s >> 1, h = 0, c = 0; c < s - 1; c++) {\n          for (c < h && (b = o[i + c], o[i + c] = o[i + h], o[i + h] = b, b = o[a + c], o[a + c] = o[a + h], o[a + h] = b), p = f; p <= h;) h -= p, p >>= 1;\n\n          h += p;\n        }\n\n        for (v = -1, y = 0, g = 1, d = 0; d < u; d++) {\n          for (m = g, g <<= 1, S = 1, E = 0, h = 0; h < m; h++) {\n            for (c = h; c < s; c += g) I = o[i + (l = c + m)], A = o[a + l], k = o[i + c], T = o[a + c], w = (N = S * (I + A)) - A * (S + E), x = N + (P = I * (E - S)), o[i + l] = k - w, o[a + l] = T - x, o[i + c] += w, o[a + c] += x;\n\n            P = S * (y - v), S = (N = v * (S + E)) - E * (v + y), E = N + P;\n          }\n\n          y = Math.sqrt((1 - v) / 2), t < 0 && (y = -y), v = Math.sqrt((1 + v) / 2);\n        }\n\n        if (t < 0) {\n          var R = 1 / s;\n\n          for (c = 0; c < s; c++) o[i + c] *= R, o[a + c] *= R;\n        }\n\n        i += n, a += n;\n      }\n    }\n\n    t.exports = function (t, e, n, i, a, s, u) {\n      t |= 0, e |= 0, n |= 0, a |= 0, s |= 0, r.isPow2(n) ? o(t, e, n, i, a, s) : function (t, e, n, i, a, s, u) {\n        t |= 0, e |= 0, n |= 0, a |= 0, s |= 0, u |= 0;\n        var c,\n            l,\n            h,\n            p,\n            f,\n            d,\n            m,\n            g,\n            v,\n            y = r.nextPow2(2 * n + 1),\n            b = u,\n            w = b + n,\n            x = w + n,\n            S = x + y,\n            E = S + y,\n            C = E + y,\n            I = -t * Math.PI / n;\n\n        for (v = 0; v < n; ++v) l = I * (v * v % (2 * n)), p = Math.cos(l), f = Math.sin(l), i[E + (y - v)] = i[E + v] = i[b + v] = p, i[C + (y - v)] = i[C + v] = i[w + v] = f;\n\n        for (v = n; v <= y - n; ++v) i[E + v] = 0;\n\n        for (v = n; v <= y - n; ++v) i[C + v] = 0;\n\n        o(1, 1, y, i, E, C), I = t < 0 ? 1 / n : 1;\n\n        for (c = 0; c < e; ++c) {\n          for (v = 0; v < n; ++v) l = i[a + v], h = i[s + v], p = i[b + v], f = -i[w + v], d = p * (l + h), m = l * (f - p), g = h * (p + f), i[x + v] = d - g, i[S + v] = d + m;\n\n          for (v = n; v < y; ++v) i[x + v] = 0;\n\n          for (v = n; v < y; ++v) i[S + v] = 0;\n\n          for (o(1, 1, y, i, x, S), v = 0; v < y; ++v) l = i[x + v], h = i[S + v], p = i[E + v], f = i[C + v], d = p * (l + h), m = l * (f - p), g = h * (p + f), i[x + v] = d - g, i[S + v] = d + m;\n\n          for (o(-1, 1, y, i, x, S), v = 0; v < n; ++v) l = i[x + v], h = i[S + v], p = i[b + v], f = -i[w + v], d = p * (l + h), m = l * (f - p), g = h * (p + f), i[a + v] = I * (d - g), i[s + v] = I * (d + m);\n\n          a += n, s += n;\n        }\n      }(t, e, n, i, a, s, u);\n    }, t.exports.scratchMemory = function (t) {\n      return r.isPow2(t) ? 0 : 2 * t + 4 * r.nextPow2(2 * t + 1);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(15),\n        o = n(34),\n        i = n(41);\n    e.clone = function (t) {\n      var e = t.dtype;\n      \"generic\" !== e && \"array\" !== e || (e = \"double\");\n      var n = i.malloc(t.size, e),\n          a = r(n, t.shape);\n      return o.assign(a, t), a;\n    }, e.malloc = function (t, e) {\n      e || (e = \"double\");\n\n      for (var n = 1, o = new Array(t.length), a = t.length - 1; a >= 0; --a) o[a] = n, n *= t[a];\n\n      return r(i.malloc(n, e), t, o, 0);\n    }, e.free = function (t) {\n      \"generic\" !== t.dtype && \"array\" !== t.dtype && i.free(t.data);\n    }, e.zeros = function (t, e) {\n      e || (e = \"double\");\n\n      for (var n = 1, o = new Array(t.length), a = t.length - 1; a >= 0; --a) o[a] = n, n *= t[a];\n\n      var s = i.malloc(n, e);\n\n      for (a = 0; a < n; ++a) s[a] = 0;\n\n      return r(s, t, o, 0);\n    }, e.ones = function (t, e) {\n      e || (e = \"double\");\n\n      for (var n = 1, o = new Array(t.length), a = t.length - 1; a >= 0; --a) o[a] = n, n *= t[a];\n\n      var s = i.malloc(n, e);\n\n      for (a = 0; a < n; ++a) s[a] = 1;\n\n      return r(s, t, o, 0);\n    }, e.eye = function (t, e) {\n      var n, o;\n      e || (e = \"double\");\n      var a = 1,\n          s = new Array(t.length);\n\n      for (n = t.length - 1; n >= 0; --n) s[n] = a, a *= t[n];\n\n      var u = i.malloc(a, e);\n\n      for (n = 0; n < a; ++n) u[n] = 0;\n\n      var c = 1 / 0,\n          l = 0;\n\n      for (n = t.length - 1; n >= 0; n--) l += s[n], c = Math.min(c, t[n]);\n\n      for (n = 0, o = 0; n < c; n++, o += l) u[o] = 1;\n\n      return r(u, t, s, 0);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var r = n(59),\n        o = n(39),\n        i = [\"args\", \"body\"],\n        a = [\"pre\", \"post\", \"printCode\", \"funcName\", \"blockSize\"];\n\n    t.exports = function (t) {\n      for (var e in t) i.indexOf(e) < 0 && a.indexOf(e) < 0 && console.warn(\"cwise: Unknown argument '\" + e + \"' passed to expression compiler\");\n\n      for (var n = 0; n < i.length; ++n) if (!t[i[n]]) throw new Error(\"cwise: Missing argument: \" + i[n]);\n\n      return o({\n        args: t.args,\n        pre: r(t.pre || function () {}),\n        body: r(t.body),\n        post: r(t.post || function () {}),\n        debug: !!t.printCode,\n        funcName: t.funcName || t.body.name || \"cwise\",\n        blockSize: t.blockSize || 64\n      });\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    (function (e) {\n      var r = n(60),\n          o = n(40),\n          i = 0;\n\n      function a(t, e, n) {\n        this.name = t, this.lvalue = e, this.rvalue = n, this.count = 0;\n      }\n\n      function s(t, e, n, r) {\n        this.body = t, this.args = e, this.thisVars = n, this.localVars = r;\n      }\n\n      t.exports = function (t) {\n        for (var n = [\"(\", t, \")()\"].join(\"\"), u = r.parse(n, {\n          range: !0\n        }), c = \"_inline_\" + i++ + \"_\", l = function (t) {\n          for (var e = t.body[0].expression.callee.params, n = new Array(e.length), r = 0; r < e.length; ++r) n[r] = e[r].name;\n\n          return n;\n        }(u), h = new Array(l.length), p = 0; p < l.length; ++p) h[p] = new a([c, \"arg\", p, \"_\"].join(\"\"), !1, !1);\n\n        for (var f = new Array(n.length), d = (p = 0, n.length); p < d; ++p) f[p] = n.charAt(p);\n\n        var m = [],\n            g = [];\n\n        function v(t, e) {\n          for (var n = t.range[0], r = t.range[1], o = n + 1; o < r; ++o) f[o] = \"\";\n\n          f[n] = e;\n        }\n\n        var y,\n            b = 1,\n            w = 2;\n        return function t(n, r) {\n          if (n.parent = r, \"MemberExpression\" === n.type) n.computed ? (t(n.object, n), t(n.property, n)) : \"ThisExpression\" === n.object.type ? v(n, (x = n.property.name, S = \"this_\" + x.replace(/\\_/g, \"__\"), g.push(S), S)) : t(n.object, n);else {\n            if (\"ThisExpression\" === n.type) throw new Error(\"cwise-parser: Computed this is not allowed\");\n\n            if (\"Identifier\" === n.type) {\n              var o = n.name,\n                  i = l.indexOf(o);\n\n              if (i >= 0) {\n                var a = h[i],\n                    s = function (t) {\n                  return \"AssignmentExpression\" === t.parent.type && t.parent.left === t ? \"=\" === t.parent.operator ? b : b | w : \"UpdateExpression\" === t.parent.type ? b | w : w;\n                }(n);\n\n                s & b && (a.lvalue = !0), s & w && (a.rvalue = !0), ++a.count, v(n, a.name);\n              } else (function (t) {\n                if (\"eval\" === t) throw new Error(\"cwise-parser: eval() not allowed\");\n                return \"undefined\" != typeof window ? t in window : void 0 !== e ? t in e : \"undefined\" != typeof self && t in self;\n              })(o) || v(n, function (t) {\n                var e = c + t.replace(/\\_/g, \"__\");\n                return m.push(e), e;\n              }(o));\n            } else if (\"Literal\" === n.type) \"string\" == typeof n.value && v(n, \"'\" + n.value.replace(/\\_/g, \"\\\\_\").replace(/\\'/g, \"'\") + \"'\");else {\n              if (\"WithStatement\" === n.type) throw new Error(\"cwise-parser: with() statements not allowed\");\n\n              for (var u = Object.keys(n), p = 0, f = u.length; p < f; ++p) if (\"parent\" !== u[p]) {\n                var d = n[u[p]];\n                if (d) if (d instanceof Array) for (var y = 0; y < d.length; ++y) d[y] && \"string\" == typeof d[y].type && t(d[y], n);else \"string\" == typeof d.type && t(d, n);\n              }\n            }\n          }\n          var x, S;\n        }(u.body[0].expression.callee.body, void 0), o(m), o(g), new s((y = u.body[0].expression.callee.body, f.slice(y.range[0], y.range[1]).join(\"\")), h, g, m);\n      };\n    }).call(this, n(8));\n  }, function (t, e, n) {\n    var r, o, i;\n    !function (n, a) {\n      \"use strict\";\n\n      o = [e], void 0 === (i = \"function\" == typeof (r = function (t) {\n        var e, n, r, o, i, a, s, u, c, l, h, p, f, d, m, g, v, y;\n\n        function b(t, e) {\n          if (!t) throw new Error(\"ASSERT: \" + e);\n        }\n\n        function w(t) {\n          return t >= 48 && t <= 57;\n        }\n\n        function x(t) {\n          return \"0123456789abcdefABCDEF\".indexOf(t) >= 0;\n        }\n\n        function S(t) {\n          return \"01234567\".indexOf(t) >= 0;\n        }\n\n        function E(t) {\n          return 32 === t || 9 === t || 11 === t || 12 === t || 160 === t || t >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(t) >= 0;\n        }\n\n        function C(t) {\n          return 10 === t || 13 === t || 8232 === t || 8233 === t;\n        }\n\n        function I(t) {\n          return 36 === t || 95 === t || t >= 65 && t <= 90 || t >= 97 && t <= 122 || 92 === t || t >= 128 && s.NonAsciiIdentifierStart.test(String.fromCharCode(t));\n        }\n\n        function A(t) {\n          return 36 === t || 95 === t || t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 48 && t <= 57 || 92 === t || t >= 128 && s.NonAsciiIdentifierPart.test(String.fromCharCode(t));\n        }\n\n        function k(t) {\n          switch (t) {\n            case \"implements\":\n            case \"interface\":\n            case \"package\":\n            case \"private\":\n            case \"protected\":\n            case \"public\":\n            case \"static\":\n            case \"yield\":\n            case \"let\":\n              return !0;\n\n            default:\n              return !1;\n          }\n        }\n\n        function T(t) {\n          return \"eval\" === t || \"arguments\" === t;\n        }\n\n        function N(t, e, n, r, o) {\n          var i;\n          b(\"number\" == typeof n, \"Comment must have valid position\"), v.lastCommentStart >= n || (v.lastCommentStart = n, i = {\n            type: t,\n            value: e\n          }, y.range && (i.range = [n, r]), y.loc && (i.loc = o), y.comments.push(i), y.attachComment && (y.leadingComments.push(i), y.trailingComments.push(i)));\n        }\n\n        function P(t) {\n          var e, n, r, o;\n\n          for (e = h - t, n = {\n            start: {\n              line: p,\n              column: h - f - t\n            }\n          }; h < d;) if (r = c.charCodeAt(h), ++h, C(r)) return y.comments && (o = c.slice(e + t, h - 1), n.end = {\n            line: p,\n            column: h - f - 1\n          }, N(\"Line\", o, e, h - 1, n)), 13 === r && 10 === c.charCodeAt(h) && ++h, ++p, void (f = h);\n\n          y.comments && (o = c.slice(e + t, h), n.end = {\n            line: p,\n            column: h - f\n          }, N(\"Line\", o, e, h, n));\n        }\n\n        function R() {\n          var t, e, n, r;\n\n          for (y.comments && (t = h - 2, e = {\n            start: {\n              line: p,\n              column: h - f - 2\n            }\n          }); h < d;) if (C(n = c.charCodeAt(h))) 13 === n && 10 === c.charCodeAt(h + 1) && ++h, ++p, f = ++h, h >= d && $({}, a.UnexpectedToken, \"ILLEGAL\");else if (42 === n) {\n            if (47 === c.charCodeAt(h + 1)) return ++h, ++h, void (y.comments && (r = c.slice(t + 2, h - 2), e.end = {\n              line: p,\n              column: h - f\n            }, N(\"Block\", r, t, h, e)));\n            ++h;\n          } else ++h;\n\n          $({}, a.UnexpectedToken, \"ILLEGAL\");\n        }\n\n        function _() {\n          var t, e;\n\n          for (e = 0 === h; h < d;) if (E(t = c.charCodeAt(h))) ++h;else if (C(t)) ++h, 13 === t && 10 === c.charCodeAt(h) && ++h, ++p, f = h, e = !0;else if (47 === t) {\n            if (47 === (t = c.charCodeAt(h + 1))) ++h, ++h, P(2), e = !0;else {\n              if (42 !== t) break;\n              ++h, ++h, R();\n            }\n          } else if (e && 45 === t) {\n            if (45 !== c.charCodeAt(h + 1) || 62 !== c.charCodeAt(h + 2)) break;\n            h += 3, P(3);\n          } else {\n            if (60 !== t) break;\n            if (\"!--\" !== c.slice(h + 1, h + 4)) break;\n            ++h, ++h, ++h, ++h, P(4);\n          }\n        }\n\n        function M(t) {\n          var e,\n              n,\n              r,\n              o = 0;\n\n          for (n = \"u\" === t ? 4 : 2, e = 0; e < n; ++e) {\n            if (!(h < d && x(c[h]))) return \"\";\n            r = c[h++], o = 16 * o + \"0123456789abcdef\".indexOf(r.toLowerCase());\n          }\n\n          return String.fromCharCode(o);\n        }\n\n        function O() {\n          var t, e;\n\n          for (t = c.charCodeAt(h++), e = String.fromCharCode(t), 92 === t && (117 !== c.charCodeAt(h) && $({}, a.UnexpectedToken, \"ILLEGAL\"), ++h, (t = M(\"u\")) && \"\\\\\" !== t && I(t.charCodeAt(0)) || $({}, a.UnexpectedToken, \"ILLEGAL\"), e = t); h < d && A(t = c.charCodeAt(h));) ++h, e += String.fromCharCode(t), 92 === t && (e = e.substr(0, e.length - 1), 117 !== c.charCodeAt(h) && $({}, a.UnexpectedToken, \"ILLEGAL\"), ++h, (t = M(\"u\")) && \"\\\\\" !== t && A(t.charCodeAt(0)) || $({}, a.UnexpectedToken, \"ILLEGAL\"), e += t);\n\n          return e;\n        }\n\n        function D() {\n          var t, n;\n          return t = h, {\n            type: 1 === (n = 92 === c.charCodeAt(h) ? O() : function () {\n              var t, e;\n\n              for (t = h++; h < d;) {\n                if (92 === (e = c.charCodeAt(h))) return h = t, O();\n                if (!A(e)) break;\n                ++h;\n              }\n\n              return c.slice(t, h);\n            }()).length ? e.Identifier : function (t) {\n              if (l && k(t)) return !0;\n\n              switch (t.length) {\n                case 2:\n                  return \"if\" === t || \"in\" === t || \"do\" === t;\n\n                case 3:\n                  return \"var\" === t || \"for\" === t || \"new\" === t || \"try\" === t || \"let\" === t;\n\n                case 4:\n                  return \"this\" === t || \"else\" === t || \"case\" === t || \"void\" === t || \"with\" === t || \"enum\" === t;\n\n                case 5:\n                  return \"while\" === t || \"break\" === t || \"catch\" === t || \"throw\" === t || \"const\" === t || \"yield\" === t || \"class\" === t || \"super\" === t;\n\n                case 6:\n                  return \"return\" === t || \"typeof\" === t || \"delete\" === t || \"switch\" === t || \"export\" === t || \"import\" === t;\n\n                case 7:\n                  return \"default\" === t || \"finally\" === t || \"extends\" === t;\n\n                case 8:\n                  return \"function\" === t || \"continue\" === t || \"debugger\" === t;\n\n                case 10:\n                  return \"instanceof\" === t;\n\n                default:\n                  return !1;\n              }\n            }(n) ? e.Keyword : \"null\" === n ? e.NullLiteral : \"true\" === n || \"false\" === n ? e.BooleanLiteral : e.Identifier,\n            value: n,\n            lineNumber: p,\n            lineStart: f,\n            start: t,\n            end: h\n          };\n        }\n\n        function F() {\n          var t,\n              n,\n              r,\n              o,\n              i = h,\n              s = c.charCodeAt(h),\n              u = c[h];\n\n          switch (s) {\n            case 46:\n            case 40:\n            case 41:\n            case 59:\n            case 44:\n            case 123:\n            case 125:\n            case 91:\n            case 93:\n            case 58:\n            case 63:\n            case 126:\n              return ++h, y.tokenize && (40 === s ? y.openParenToken = y.tokens.length : 123 === s && (y.openCurlyToken = y.tokens.length)), {\n                type: e.Punctuator,\n                value: String.fromCharCode(s),\n                lineNumber: p,\n                lineStart: f,\n                start: i,\n                end: h\n              };\n\n            default:\n              if (61 === (t = c.charCodeAt(h + 1))) switch (s) {\n                case 43:\n                case 45:\n                case 47:\n                case 60:\n                case 62:\n                case 94:\n                case 124:\n                case 37:\n                case 38:\n                case 42:\n                  return h += 2, {\n                    type: e.Punctuator,\n                    value: String.fromCharCode(s) + String.fromCharCode(t),\n                    lineNumber: p,\n                    lineStart: f,\n                    start: i,\n                    end: h\n                  };\n\n                case 33:\n                case 61:\n                  return h += 2, 61 === c.charCodeAt(h) && ++h, {\n                    type: e.Punctuator,\n                    value: c.slice(i, h),\n                    lineNumber: p,\n                    lineStart: f,\n                    start: i,\n                    end: h\n                  };\n              }\n          }\n\n          return \">>>=\" === (o = c.substr(h, 4)) ? (h += 4, {\n            type: e.Punctuator,\n            value: o,\n            lineNumber: p,\n            lineStart: f,\n            start: i,\n            end: h\n          }) : \">>>\" === (r = o.substr(0, 3)) || \"<<=\" === r || \">>=\" === r ? (h += 3, {\n            type: e.Punctuator,\n            value: r,\n            lineNumber: p,\n            lineStart: f,\n            start: i,\n            end: h\n          }) : u === (n = r.substr(0, 2))[1] && \"+-<>&|\".indexOf(u) >= 0 || \"=>\" === n ? (h += 2, {\n            type: e.Punctuator,\n            value: n,\n            lineNumber: p,\n            lineStart: f,\n            start: i,\n            end: h\n          }) : \"<>=!+-*%&|^/\".indexOf(u) >= 0 ? (++h, {\n            type: e.Punctuator,\n            value: u,\n            lineNumber: p,\n            lineStart: f,\n            start: i,\n            end: h\n          }) : void $({}, a.UnexpectedToken, \"ILLEGAL\");\n        }\n\n        function L() {\n          var t, n, r;\n\n          if (b(w((r = c[h]).charCodeAt(0)) || \".\" === r, \"Numeric literal must start with a decimal digit or a decimal point\"), n = h, t = \"\", \".\" !== r) {\n            if (t = c[h++], r = c[h], \"0\" === t) {\n              if (\"x\" === r || \"X\" === r) return ++h, function (t) {\n                for (var n = \"\"; h < d && x(c[h]);) n += c[h++];\n\n                return 0 === n.length && $({}, a.UnexpectedToken, \"ILLEGAL\"), I(c.charCodeAt(h)) && $({}, a.UnexpectedToken, \"ILLEGAL\"), {\n                  type: e.NumericLiteral,\n                  value: parseInt(\"0x\" + n, 16),\n                  lineNumber: p,\n                  lineStart: f,\n                  start: t,\n                  end: h\n                };\n              }(n);\n              if (S(r) && function () {\n                var t, e;\n\n                for (t = h + 1; t < d; ++t) {\n                  if (\"8\" === (e = c[t]) || \"9\" === e) return !1;\n                  if (!S(e)) return !0;\n                }\n\n                return !0;\n              }()) return function (t) {\n                for (var n = \"0\" + c[h++]; h < d && S(c[h]);) n += c[h++];\n\n                return (I(c.charCodeAt(h)) || w(c.charCodeAt(h))) && $({}, a.UnexpectedToken, \"ILLEGAL\"), {\n                  type: e.NumericLiteral,\n                  value: parseInt(n, 8),\n                  octal: !0,\n                  lineNumber: p,\n                  lineStart: f,\n                  start: t,\n                  end: h\n                };\n              }(n);\n            }\n\n            for (; w(c.charCodeAt(h));) t += c[h++];\n\n            r = c[h];\n          }\n\n          if (\".\" === r) {\n            for (t += c[h++]; w(c.charCodeAt(h));) t += c[h++];\n\n            r = c[h];\n          }\n\n          if (\"e\" === r || \"E\" === r) if (t += c[h++], \"+\" !== (r = c[h]) && \"-\" !== r || (t += c[h++]), w(c.charCodeAt(h))) for (; w(c.charCodeAt(h));) t += c[h++];else $({}, a.UnexpectedToken, \"ILLEGAL\");\n          return I(c.charCodeAt(h)) && $({}, a.UnexpectedToken, \"ILLEGAL\"), {\n            type: e.NumericLiteral,\n            value: parseFloat(t),\n            lineNumber: p,\n            lineStart: f,\n            start: n,\n            end: h\n          };\n        }\n\n        function B() {\n          var t, n, r, o;\n          return g = null, _(), t = h, n = function () {\n            var t, e, n, r;\n\n            for (b(\"/\" === (t = c[h]), \"Regular expression literal must start with a slash\"), e = c[h++], n = !1, r = !1; h < d;) if (e += t = c[h++], \"\\\\\" === t) C((t = c[h++]).charCodeAt(0)) && $({}, a.UnterminatedRegExp), e += t;else if (C(t.charCodeAt(0))) $({}, a.UnterminatedRegExp);else if (n) \"]\" === t && (n = !1);else {\n              if (\"/\" === t) {\n                r = !0;\n                break;\n              }\n\n              \"[\" === t && (n = !0);\n            }\n\n            return r || $({}, a.UnterminatedRegExp), {\n              value: e.substr(1, e.length - 2),\n              literal: e\n            };\n          }(), r = function () {\n            var t, e, n, r;\n\n            for (e = \"\", n = \"\"; h < d && A((t = c[h]).charCodeAt(0));) if (++h, \"\\\\\" === t && h < d) {\n              if (\"u\" === (t = c[h])) {\n                if (r = ++h, t = M(\"u\")) for (n += t, e += \"\\\\u\"; r < h; ++r) e += c[r];else h = r, n += \"u\", e += \"\\\\u\";\n                K({}, a.UnexpectedToken, \"ILLEGAL\");\n              } else e += \"\\\\\", K({}, a.UnexpectedToken, \"ILLEGAL\");\n            } else n += t, e += t;\n\n            return {\n              value: n,\n              literal: e\n            };\n          }(), o = function (t, e) {\n            var n;\n\n            try {\n              n = new RegExp(t, e);\n            } catch (t) {\n              $({}, a.InvalidRegExp);\n            }\n\n            return n;\n          }(n.value, r.value), y.tokenize ? {\n            type: e.RegularExpression,\n            value: o,\n            lineNumber: p,\n            lineStart: f,\n            start: t,\n            end: h\n          } : {\n            literal: n.literal + r.literal,\n            value: o,\n            start: t,\n            end: h\n          };\n        }\n\n        function z() {\n          var t, e, n, r;\n          return _(), t = h, e = {\n            start: {\n              line: p,\n              column: h - f\n            }\n          }, n = B(), e.end = {\n            line: p,\n            column: h - f\n          }, y.tokenize || (y.tokens.length > 0 && (r = y.tokens[y.tokens.length - 1]).range[0] === t && \"Punctuator\" === r.type && (\"/\" !== r.value && \"/=\" !== r.value || y.tokens.pop()), y.tokens.push({\n            type: \"RegularExpression\",\n            value: n.literal,\n            range: [t, h],\n            loc: e\n          })), n;\n        }\n\n        function q() {\n          var t;\n          return _(), h >= d ? {\n            type: e.EOF,\n            lineNumber: p,\n            lineStart: f,\n            start: h,\n            end: h\n          } : I(t = c.charCodeAt(h)) ? D() : 40 === t || 41 === t || 59 === t ? F() : 39 === t || 34 === t ? function () {\n            var t,\n                n,\n                r,\n                o,\n                i,\n                s,\n                u,\n                l,\n                m = \"\",\n                g = !1;\n\n            for (u = p, l = f, b(\"'\" === (t = c[h]) || '\"' === t, \"String literal must starts with a quote\"), n = h, ++h; h < d;) {\n              if ((r = c[h++]) === t) {\n                t = \"\";\n                break;\n              }\n\n              if (\"\\\\\" === r) {\n                if ((r = c[h++]) && C(r.charCodeAt(0))) ++p, \"\\r\" === r && \"\\n\" === c[h] && ++h, f = h;else switch (r) {\n                  case \"u\":\n                  case \"x\":\n                    s = h, (i = M(r)) ? m += i : (h = s, m += r);\n                    break;\n\n                  case \"n\":\n                    m += \"\\n\";\n                    break;\n\n                  case \"r\":\n                    m += \"\\r\";\n                    break;\n\n                  case \"t\":\n                    m += \"\\t\";\n                    break;\n\n                  case \"b\":\n                    m += \"\\b\";\n                    break;\n\n                  case \"f\":\n                    m += \"\\f\";\n                    break;\n\n                  case \"v\":\n                    m += \"\\v\";\n                    break;\n\n                  default:\n                    S(r) ? (0 !== (o = \"01234567\".indexOf(r)) && (g = !0), h < d && S(c[h]) && (g = !0, o = 8 * o + \"01234567\".indexOf(c[h++]), \"0123\".indexOf(r) >= 0 && h < d && S(c[h]) && (o = 8 * o + \"01234567\".indexOf(c[h++]))), m += String.fromCharCode(o)) : m += r;\n                }\n              } else {\n                if (C(r.charCodeAt(0))) break;\n                m += r;\n              }\n            }\n\n            return \"\" !== t && $({}, a.UnexpectedToken, \"ILLEGAL\"), {\n              type: e.StringLiteral,\n              value: m,\n              octal: g,\n              startLineNumber: u,\n              startLineStart: l,\n              lineNumber: p,\n              lineStart: f,\n              start: n,\n              end: h\n            };\n          }() : 46 === t ? w(c.charCodeAt(h + 1)) ? L() : F() : w(t) ? L() : y.tokenize && 47 === t ? function () {\n            var t, e;\n            if (!(t = y.tokens[y.tokens.length - 1])) return z();\n\n            if (\"Punctuator\" === t.type) {\n              if (\"]\" === t.value) return F();\n              if (\")\" === t.value) return !(e = y.tokens[y.openParenToken - 1]) || \"Keyword\" !== e.type || \"if\" !== e.value && \"while\" !== e.value && \"for\" !== e.value && \"with\" !== e.value ? F() : z();\n\n              if (\"}\" === t.value) {\n                if (y.tokens[y.openCurlyToken - 3] && \"Keyword\" === y.tokens[y.openCurlyToken - 3].type) {\n                  if (!(e = y.tokens[y.openCurlyToken - 4])) return F();\n                } else {\n                  if (!y.tokens[y.openCurlyToken - 4] || \"Keyword\" !== y.tokens[y.openCurlyToken - 4].type) return F();\n                  if (!(e = y.tokens[y.openCurlyToken - 5])) return z();\n                }\n\n                return r.indexOf(e.value) >= 0 ? F() : z();\n              }\n\n              return z();\n            }\n\n            return \"Keyword\" === t.type && \"this\" !== t.value ? z() : F();\n          }() : F();\n        }\n\n        function V() {\n          var t, r, o;\n          return _(), t = {\n            start: {\n              line: p,\n              column: h - f\n            }\n          }, r = q(), t.end = {\n            line: p,\n            column: h - f\n          }, r.type !== e.EOF && (o = c.slice(r.start, r.end), y.tokens.push({\n            type: n[r.type],\n            value: o,\n            range: [r.start, r.end],\n            loc: t\n          })), r;\n        }\n\n        function U() {\n          var t;\n          return h = (t = g).end, p = t.lineNumber, f = t.lineStart, g = void 0 !== y.tokens ? V() : q(), h = t.end, p = t.lineNumber, f = t.lineStart, t;\n        }\n\n        function j() {\n          var t, e, n;\n          t = h, e = p, n = f, g = void 0 !== y.tokens ? V() : q(), h = t, p = e, f = n;\n        }\n\n        function W(t, e) {\n          this.line = t, this.column = e;\n        }\n\n        function G(t, e, n, r) {\n          this.start = new W(t, e), this.end = new W(n, r);\n        }\n\n        function H() {\n          var t, e, n, r;\n          return t = h, e = p, n = f, _(), r = p !== e, h = t, p = e, f = n, r;\n        }\n\n        function $(t, e) {\n          var n,\n              r = Array.prototype.slice.call(arguments, 2),\n              o = e.replace(/%(\\d)/g, function (t, e) {\n            return b(e < r.length, \"Message reference must be in range\"), r[e];\n          });\n          throw \"number\" == typeof t.lineNumber ? ((n = new Error(\"Line \" + t.lineNumber + \": \" + o)).index = t.start, n.lineNumber = t.lineNumber, n.column = t.start - f + 1) : ((n = new Error(\"Line \" + p + \": \" + o)).index = h, n.lineNumber = p, n.column = h - f + 1), n.description = o, n;\n        }\n\n        function K() {\n          try {\n            $.apply(null, arguments);\n          } catch (t) {\n            if (!y.errors) throw t;\n            y.errors.push(t);\n          }\n        }\n\n        function Q(t) {\n          if (t.type === e.EOF && $(t, a.UnexpectedEOS), t.type === e.NumericLiteral && $(t, a.UnexpectedNumber), t.type === e.StringLiteral && $(t, a.UnexpectedString), t.type === e.Identifier && $(t, a.UnexpectedIdentifier), t.type === e.Keyword) {\n            if (function (t) {\n              switch (t) {\n                case \"class\":\n                case \"enum\":\n                case \"export\":\n                case \"extends\":\n                case \"import\":\n                case \"super\":\n                  return !0;\n\n                default:\n                  return !1;\n              }\n            }(t.value)) $(t, a.UnexpectedReserved);else if (l && k(t.value)) return void K(t, a.StrictReservedWord);\n            $(t, a.UnexpectedToken, t.value);\n          }\n\n          $(t, a.UnexpectedToken, t.value);\n        }\n\n        function X(t) {\n          var n = U();\n          n.type === e.Punctuator && n.value === t || Q(n);\n        }\n\n        function Y(t) {\n          var n = U();\n          n.type === e.Keyword && n.value === t || Q(n);\n        }\n\n        function J(t) {\n          return g.type === e.Punctuator && g.value === t;\n        }\n\n        function Z(t) {\n          return g.type === e.Keyword && g.value === t;\n        }\n\n        function tt() {\n          var t,\n              n = h,\n              r = p,\n              o = f,\n              i = g;\n          if (59 === c.charCodeAt(h) || J(\";\")) U();else {\n            if (t = p, _(), p !== t) return h = n, p = r, f = o, void (g = i);\n            g.type === e.EOF || J(\"}\") || Q(g);\n          }\n        }\n\n        function et(t) {\n          return t.type === o.Identifier || t.type === o.MemberExpression;\n        }\n\n        function nt(t, e) {\n          var n, r, o;\n          return n = l, o = g, r = It(), e && l && T(t[0].name) && K(e, a.StrictParamName), l = n, m.markEnd(m.createFunctionExpression(null, t, [], r), o);\n        }\n\n        function rt() {\n          var t, n;\n          return n = g, (t = U()).type === e.StringLiteral || t.type === e.NumericLiteral ? (l && t.octal && K(t, a.StrictOctalLiteral), m.markEnd(m.createLiteral(t), n)) : m.markEnd(m.createIdentifier(t.value), n);\n        }\n\n        function ot() {\n          var t, n, r, o, i, s;\n          return s = g, (t = g).type === e.Identifier ? (r = rt(), \"get\" !== t.value || J(\":\") ? \"set\" !== t.value || J(\":\") ? (X(\":\"), o = mt(), m.markEnd(m.createProperty(\"init\", r, o), s)) : (n = rt(), X(\"(\"), (t = g).type !== e.Identifier ? (X(\")\"), K(t, a.UnexpectedToken, t.value), o = nt([])) : (i = [yt()], X(\")\"), o = nt(i, t)), m.markEnd(m.createProperty(\"set\", n, o), s)) : (n = rt(), X(\"(\"), X(\")\"), o = nt([]), m.markEnd(m.createProperty(\"get\", n, o), s))) : t.type !== e.EOF && t.type !== e.Punctuator ? (n = rt(), X(\":\"), o = mt(), m.markEnd(m.createProperty(\"init\", n, o), s)) : void Q(t);\n        }\n\n        function it() {\n          var t, n, r, s;\n          if (J(\"(\")) return function () {\n            var t;\n            return X(\"(\"), t = gt(), X(\")\"), t;\n          }();\n          if (J(\"[\")) return function () {\n            var t,\n                e = [];\n\n            for (t = g, X(\"[\"); !J(\"]\");) J(\",\") ? (U(), e.push(null)) : (e.push(mt()), J(\"]\") || X(\",\"));\n\n            return U(), m.markEnd(m.createArrayExpression(e), t);\n          }();\n          if (J(\"{\")) return function () {\n            var t,\n                e,\n                n,\n                r,\n                s,\n                u = [],\n                c = {},\n                h = String;\n\n            for (s = g, X(\"{\"); !J(\"}\");) e = (t = ot()).key.type === o.Identifier ? t.key.name : h(t.key.value), r = \"init\" === t.kind ? i.Data : \"get\" === t.kind ? i.Get : i.Set, n = \"$\" + e, Object.prototype.hasOwnProperty.call(c, n) ? (c[n] === i.Data ? l && r === i.Data ? K({}, a.StrictDuplicateProperty) : r !== i.Data && K({}, a.AccessorDataProperty) : r === i.Data ? K({}, a.AccessorDataProperty) : c[n] & r && K({}, a.AccessorGetSet), c[n] |= r) : c[n] = r, u.push(t), J(\"}\") || X(\",\");\n\n            return X(\"}\"), m.markEnd(m.createObjectExpression(u), s);\n          }();\n          if (t = g.type, s = g, t === e.Identifier) r = m.createIdentifier(U().value);else if (t === e.StringLiteral || t === e.NumericLiteral) l && g.octal && K(g, a.StrictOctalLiteral), r = m.createLiteral(U());else if (t === e.Keyword) {\n            if (Z(\"function\")) return function () {\n              var t,\n                  e,\n                  n,\n                  r,\n                  o,\n                  i,\n                  s,\n                  u,\n                  c,\n                  h = null;\n              c = g, Y(\"function\"), J(\"(\") || (t = g, h = yt(), l ? T(t.value) && K(t, a.StrictFunctionName) : T(t.value) ? (n = t, r = a.StrictFunctionName) : k(t.value) && (n = t, r = a.StrictReservedWord));\n              o = At(n), i = o.params, e = o.stricted, n = o.firstRestricted, o.message && (r = o.message);\n              u = l, s = It(), l && n && $(n, r);\n              l && e && K(e, r);\n              return l = u, m.markEnd(m.createFunctionExpression(h, i, [], s), c);\n            }();\n            Z(\"this\") ? (U(), r = m.createThisExpression()) : Q(U());\n          } else t === e.BooleanLiteral ? ((n = U()).value = \"true\" === n.value, r = m.createLiteral(n)) : t === e.NullLiteral ? ((n = U()).value = null, r = m.createLiteral(n)) : J(\"/\") || J(\"/=\") ? (r = void 0 !== y.tokens ? m.createLiteral(z()) : m.createLiteral(B()), j()) : Q(U());\n          return m.markEnd(r, s);\n        }\n\n        function at() {\n          var t = [];\n          if (X(\"(\"), !J(\")\")) for (; h < d && (t.push(mt()), !J(\")\"));) X(\",\");\n          return X(\")\"), t;\n        }\n\n        function st() {\n          var t, n;\n          return n = g, function (t) {\n            return t.type === e.Identifier || t.type === e.Keyword || t.type === e.BooleanLiteral || t.type === e.NullLiteral;\n          }(t = U()) || Q(t), m.markEnd(m.createIdentifier(t.value), n);\n        }\n\n        function ut() {\n          return X(\".\"), st();\n        }\n\n        function ct() {\n          var t;\n          return X(\"[\"), t = gt(), X(\"]\"), t;\n        }\n\n        function lt() {\n          var t, e, n;\n          return n = g, Y(\"new\"), t = function () {\n            var t, e, n;\n            b(v.allowIn, \"callee of new expression always allow in keyword.\"), n = g, t = Z(\"new\") ? lt() : it();\n\n            for (; J(\".\") || J(\"[\");) J(\"[\") ? (e = ct(), t = m.createMemberExpression(\"[\", t, e)) : (e = ut(), t = m.createMemberExpression(\".\", t, e)), m.markEnd(t, n);\n\n            return t;\n          }(), e = J(\"(\") ? at() : [], m.markEnd(m.createNewExpression(t, e), n);\n        }\n\n        function ht() {\n          var t,\n              n,\n              r = g;\n          return t = function () {\n            var t,\n                e,\n                n,\n                r,\n                o = v.allowIn;\n\n            for (r = g, v.allowIn = !0, t = Z(\"new\") ? lt() : it();;) {\n              if (J(\".\")) n = ut(), t = m.createMemberExpression(\".\", t, n);else if (J(\"(\")) e = at(), t = m.createCallExpression(t, e);else {\n                if (!J(\"[\")) break;\n                n = ct(), t = m.createMemberExpression(\"[\", t, n);\n              }\n              m.markEnd(t, r);\n            }\n\n            return v.allowIn = o, t;\n          }(), g.type === e.Punctuator && (!J(\"++\") && !J(\"--\") || H() || (l && t.type === o.Identifier && T(t.name) && K({}, a.StrictLHSPostfix), et(t) || K({}, a.InvalidLHSInAssignment), n = U(), t = m.markEnd(m.createPostfixExpression(n.value, t), r))), t;\n        }\n\n        function pt() {\n          var t, n, r;\n          return g.type !== e.Punctuator && g.type !== e.Keyword ? n = ht() : J(\"++\") || J(\"--\") ? (r = g, t = U(), n = pt(), l && n.type === o.Identifier && T(n.name) && K({}, a.StrictLHSPrefix), et(n) || K({}, a.InvalidLHSInAssignment), n = m.createUnaryExpression(t.value, n), n = m.markEnd(n, r)) : J(\"+\") || J(\"-\") || J(\"~\") || J(\"!\") ? (r = g, t = U(), n = pt(), n = m.createUnaryExpression(t.value, n), n = m.markEnd(n, r)) : Z(\"delete\") || Z(\"void\") || Z(\"typeof\") ? (r = g, t = U(), n = pt(), n = m.createUnaryExpression(t.value, n), n = m.markEnd(n, r), l && \"delete\" === n.operator && n.argument.type === o.Identifier && K({}, a.StrictDelete)) : n = ht(), n;\n        }\n\n        function ft(t, n) {\n          var r = 0;\n          if (t.type !== e.Punctuator && t.type !== e.Keyword) return 0;\n\n          switch (t.value) {\n            case \"||\":\n              r = 1;\n              break;\n\n            case \"&&\":\n              r = 2;\n              break;\n\n            case \"|\":\n              r = 3;\n              break;\n\n            case \"^\":\n              r = 4;\n              break;\n\n            case \"&\":\n              r = 5;\n              break;\n\n            case \"==\":\n            case \"!=\":\n            case \"===\":\n            case \"!==\":\n              r = 6;\n              break;\n\n            case \"<\":\n            case \">\":\n            case \"<=\":\n            case \">=\":\n            case \"instanceof\":\n              r = 7;\n              break;\n\n            case \"in\":\n              r = n ? 7 : 0;\n              break;\n\n            case \"<<\":\n            case \">>\":\n            case \">>>\":\n              r = 8;\n              break;\n\n            case \"+\":\n            case \"-\":\n              r = 9;\n              break;\n\n            case \"*\":\n            case \"/\":\n            case \"%\":\n              r = 11;\n          }\n\n          return r;\n        }\n\n        function dt() {\n          var t, e, n, r, o;\n          return o = g, t = function () {\n            var t, e, n, r, o, i, a, s, u, c;\n            if (t = g, u = pt(), 0 === (o = ft(r = g, v.allowIn))) return u;\n\n            for (r.prec = o, U(), e = [t, g], i = [u, r, a = pt()]; (o = ft(g, v.allowIn)) > 0;) {\n              for (; i.length > 2 && o <= i[i.length - 2].prec;) a = i.pop(), s = i.pop().value, u = i.pop(), n = m.createBinaryExpression(s, u, a), e.pop(), t = e[e.length - 1], m.markEnd(n, t), i.push(n);\n\n              (r = U()).prec = o, i.push(r), e.push(g), n = pt(), i.push(n);\n            }\n\n            for (n = i[c = i.length - 1], e.pop(); c > 1;) n = m.createBinaryExpression(i[c - 1].value, i[c - 2], n), c -= 2, t = e.pop(), m.markEnd(n, t);\n\n            return n;\n          }(), J(\"?\") && (U(), e = v.allowIn, v.allowIn = !0, n = mt(), v.allowIn = e, X(\":\"), r = mt(), t = m.createConditionalExpression(t, n, r), m.markEnd(t, o)), t;\n        }\n\n        function mt() {\n          var t, n, r, i, s, u;\n          return t = g, s = g, i = n = dt(), g.type !== e.Punctuator || \"=\" !== (u = g.value) && \"*=\" !== u && \"/=\" !== u && \"%=\" !== u && \"+=\" !== u && \"-=\" !== u && \"<<=\" !== u && \">>=\" !== u && \">>>=\" !== u && \"&=\" !== u && \"^=\" !== u && \"|=\" !== u || (et(n) || K({}, a.InvalidLHSInAssignment), l && n.type === o.Identifier && T(n.name) && K(t, a.StrictLHSAssignment), t = U(), r = mt(), i = m.markEnd(m.createAssignmentExpression(t.value, n, r), s)), i;\n        }\n\n        function gt() {\n          var t,\n              e = g;\n\n          if (t = mt(), J(\",\")) {\n            for (t = m.createSequenceExpression([t]); h < d && J(\",\");) U(), t.expressions.push(mt());\n\n            m.markEnd(t, e);\n          }\n\n          return t;\n        }\n\n        function vt() {\n          var t, e;\n          return e = g, X(\"{\"), t = function () {\n            for (var t, e = []; h < d && !J(\"}\") && void 0 !== (t = Tt());) e.push(t);\n\n            return e;\n          }(), X(\"}\"), m.markEnd(m.createBlockStatement(t), e);\n        }\n\n        function yt() {\n          var t, n;\n          return n = g, (t = U()).type !== e.Identifier && Q(t), m.markEnd(m.createIdentifier(t.value), n);\n        }\n\n        function bt(t) {\n          var e,\n              n,\n              r = null;\n          return n = g, e = yt(), l && T(e.name) && K({}, a.StrictVarName), \"const\" === t ? (X(\"=\"), r = mt()) : J(\"=\") && (U(), r = mt()), m.markEnd(m.createVariableDeclarator(e, r), n);\n        }\n\n        function wt(t) {\n          var e = [];\n\n          do {\n            if (e.push(bt(t)), !J(\",\")) break;\n            U();\n          } while (h < d);\n\n          return e;\n        }\n\n        function xt() {\n          var t,\n              e,\n              n,\n              r,\n              o,\n              i,\n              s,\n              u,\n              c,\n              l,\n              h = v.allowIn;\n          return t = e = n = null, Y(\"for\"), X(\"(\"), J(\";\") ? U() : (Z(\"var\") || Z(\"let\") ? (v.allowIn = !1, l = g, u = U(), c = wt(), t = m.markEnd(m.createVariableDeclaration(c, u.value), l), v.allowIn = h, 1 === t.declarations.length && Z(\"in\") && (U(), r = t, o = gt(), t = null)) : (v.allowIn = !1, t = gt(), v.allowIn = h, Z(\"in\") && (et(t) || K({}, a.InvalidLHSInForIn), U(), r = t, o = gt(), t = null)), void 0 === r && X(\";\")), void 0 === r && (J(\";\") || (e = gt()), X(\";\"), J(\")\") || (n = gt())), X(\")\"), s = v.inIteration, v.inIteration = !0, i = Ct(), v.inIteration = s, void 0 === r ? m.createForStatement(t, e, n, i) : m.createForInStatement(r, o, i);\n        }\n\n        function St() {\n          var t,\n              e,\n              n,\n              r = [];\n\n          for (n = g, Z(\"default\") ? (U(), t = null) : (Y(\"case\"), t = gt()), X(\":\"); h < d && !(J(\"}\") || Z(\"default\") || Z(\"case\"));) e = Ct(), r.push(e);\n\n          return m.markEnd(m.createSwitchCase(t, r), n);\n        }\n\n        function Et() {\n          var t,\n              e,\n              n,\n              r,\n              o = [],\n              i = null;\n          return Y(\"try\"), t = vt(), Z(\"catch\") && o.push((r = g, Y(\"catch\"), X(\"(\"), J(\")\") && Q(g), e = yt(), l && T(e.name) && K({}, a.StrictCatchVariable), X(\")\"), n = vt(), m.markEnd(m.createCatchClause(e, n), r))), Z(\"finally\") && (U(), i = vt()), 0 !== o.length || i || $({}, a.NoCatchOrFinally), m.createTryStatement(t, [], o, i);\n        }\n\n        function Ct() {\n          var t,\n              n,\n              r,\n              i,\n              s,\n              u,\n              p,\n              f,\n              y,\n              b = g.type;\n          if (b === e.EOF && Q(g), b === e.Punctuator && \"{\" === g.value) return vt();\n          if (i = g, b === e.Punctuator) switch (g.value) {\n            case \";\":\n              return m.markEnd((X(\";\"), m.createEmptyStatement()), i);\n\n            case \"(\":\n              return m.markEnd(function () {\n                var t = gt();\n                return tt(), m.createExpressionStatement(t);\n              }(), i);\n          }\n          if (b === e.Keyword) switch (g.value) {\n            case \"break\":\n              return m.markEnd(function () {\n                var t,\n                    n = null;\n                return Y(\"break\"), 59 === c.charCodeAt(h) ? (U(), v.inIteration || v.inSwitch || $({}, a.IllegalBreak), m.createBreakStatement(null)) : H() ? (v.inIteration || v.inSwitch || $({}, a.IllegalBreak), m.createBreakStatement(null)) : (g.type === e.Identifier && (t = \"$\" + (n = yt()).name, Object.prototype.hasOwnProperty.call(v.labelSet, t) || $({}, a.UnknownLabel, n.name)), tt(), null !== n || v.inIteration || v.inSwitch || $({}, a.IllegalBreak), m.createBreakStatement(n));\n              }(), i);\n\n            case \"continue\":\n              return m.markEnd(function () {\n                var t,\n                    n = null;\n                return Y(\"continue\"), 59 === c.charCodeAt(h) ? (U(), v.inIteration || $({}, a.IllegalContinue), m.createContinueStatement(null)) : H() ? (v.inIteration || $({}, a.IllegalContinue), m.createContinueStatement(null)) : (g.type === e.Identifier && (t = \"$\" + (n = yt()).name, Object.prototype.hasOwnProperty.call(v.labelSet, t) || $({}, a.UnknownLabel, n.name)), tt(), null !== n || v.inIteration || $({}, a.IllegalContinue), m.createContinueStatement(n));\n              }(), i);\n\n            case \"debugger\":\n              return m.markEnd((Y(\"debugger\"), tt(), m.createDebuggerStatement()), i);\n\n            case \"do\":\n              return m.markEnd((Y(\"do\"), y = v.inIteration, v.inIteration = !0, p = Ct(), v.inIteration = y, Y(\"while\"), X(\"(\"), f = gt(), X(\")\"), J(\";\") && U(), m.createDoWhileStatement(p, f)), i);\n\n            case \"for\":\n              return m.markEnd(xt(), i);\n\n            case \"function\":\n              return m.markEnd(kt(), i);\n\n            case \"if\":\n              return m.markEnd(function () {\n                var t, e, n;\n                return Y(\"if\"), X(\"(\"), t = gt(), X(\")\"), e = Ct(), Z(\"else\") ? (U(), n = Ct()) : n = null, m.createIfStatement(t, e, n);\n              }(), i);\n\n            case \"return\":\n              return m.markEnd((u = null, Y(\"return\"), v.inFunctionBody || K({}, a.IllegalReturn), 32 === c.charCodeAt(h) && I(c.charCodeAt(h + 1)) ? (u = gt(), tt(), m.createReturnStatement(u)) : H() ? m.createReturnStatement(null) : (J(\";\") || J(\"}\") || g.type === e.EOF || (u = gt()), tt(), m.createReturnStatement(u))), i);\n\n            case \"switch\":\n              return m.markEnd(function () {\n                var t, e, n, r, o;\n                if (Y(\"switch\"), X(\"(\"), t = gt(), X(\")\"), X(\"{\"), e = [], J(\"}\")) return U(), m.createSwitchStatement(t, e);\n\n                for (r = v.inSwitch, v.inSwitch = !0, o = !1; h < d && !J(\"}\");) null === (n = St()).test && (o && $({}, a.MultipleDefaultsInSwitch), o = !0), e.push(n);\n\n                return v.inSwitch = r, X(\"}\"), m.createSwitchStatement(t, e);\n              }(), i);\n\n            case \"throw\":\n              return m.markEnd(function () {\n                var t;\n                return Y(\"throw\"), H() && $({}, a.NewlineAfterThrow), t = gt(), tt(), m.createThrowStatement(t);\n              }(), i);\n\n            case \"try\":\n              return m.markEnd(Et(), i);\n\n            case \"var\":\n              return m.markEnd((Y(\"var\"), s = wt(), tt(), m.createVariableDeclaration(s, \"var\")), i);\n\n            case \"while\":\n              return m.markEnd(function () {\n                var t, e, n;\n                return Y(\"while\"), X(\"(\"), t = gt(), X(\")\"), n = v.inIteration, v.inIteration = !0, e = Ct(), v.inIteration = n, m.createWhileStatement(t, e);\n              }(), i);\n\n            case \"with\":\n              return m.markEnd(function () {\n                var t, e;\n                return l && (_(), K({}, a.StrictModeWith)), Y(\"with\"), X(\"(\"), t = gt(), X(\")\"), e = Ct(), m.createWithStatement(t, e);\n              }(), i);\n          }\n          return (t = gt()).type === o.Identifier && J(\":\") ? (U(), r = \"$\" + t.name, Object.prototype.hasOwnProperty.call(v.labelSet, r) && $({}, a.Redeclaration, \"Label\", t.name), v.labelSet[r] = !0, n = Ct(), delete v.labelSet[r], m.markEnd(m.createLabeledStatement(t, n), i)) : (tt(), m.markEnd(m.createExpressionStatement(t), i));\n        }\n\n        function It() {\n          var t,\n              n,\n              r,\n              i,\n              s,\n              u,\n              p,\n              f,\n              y = [];\n\n          for (f = g, X(\"{\"); h < d && g.type === e.StringLiteral && (n = g, t = Tt(), y.push(t), t.expression.type === o.Literal);) \"use strict\" === c.slice(n.start + 1, n.end - 1) ? (l = !0, r && K(r, a.StrictOctalLiteral)) : !r && n.octal && (r = n);\n\n          for (i = v.labelSet, s = v.inIteration, u = v.inSwitch, p = v.inFunctionBody, v.labelSet = {}, v.inIteration = !1, v.inSwitch = !1, v.inFunctionBody = !0; h < d && !J(\"}\") && void 0 !== (t = Tt());) y.push(t);\n\n          return X(\"}\"), v.labelSet = i, v.inIteration = s, v.inSwitch = u, v.inFunctionBody = p, m.markEnd(m.createBlockStatement(y), f);\n        }\n\n        function At(t) {\n          var e,\n              n,\n              r,\n              o,\n              i,\n              s,\n              u = [];\n          if (X(\"(\"), !J(\")\")) for (o = {}; h < d && (n = g, e = yt(), i = \"$\" + n.value, l ? (T(n.value) && (r = n, s = a.StrictParamName), Object.prototype.hasOwnProperty.call(o, i) && (r = n, s = a.StrictParamDupe)) : t || (T(n.value) ? (t = n, s = a.StrictParamName) : k(n.value) ? (t = n, s = a.StrictReservedWord) : Object.prototype.hasOwnProperty.call(o, i) && (t = n, s = a.StrictParamDupe)), u.push(e), o[i] = !0, !J(\")\"));) X(\",\");\n          return X(\")\"), {\n            params: u,\n            stricted: r,\n            firstRestricted: t,\n            message: s\n          };\n        }\n\n        function kt() {\n          var t, e, n, r, o, i, s, u, c, h;\n          return h = g, Y(\"function\"), r = g, t = yt(), l ? T(r.value) && K(r, a.StrictFunctionName) : T(r.value) ? (s = r, u = a.StrictFunctionName) : k(r.value) && (s = r, u = a.StrictReservedWord), e = (i = At(s)).params, o = i.stricted, s = i.firstRestricted, i.message && (u = i.message), c = l, n = It(), l && s && $(s, u), l && o && K(o, u), l = c, m.markEnd(m.createFunctionDeclaration(t, e, [], n), h);\n        }\n\n        function Tt() {\n          if (g.type === e.Keyword) switch (g.value) {\n            case \"const\":\n            case \"let\":\n              return t = g.value, r = g, Y(t), n = wt(t), tt(), m.markEnd(m.createVariableDeclaration(n, t), r);\n\n            case \"function\":\n              return kt();\n\n            default:\n              return Ct();\n          }\n          var t, n, r;\n          if (g.type !== e.EOF) return Ct();\n        }\n\n        function Nt() {\n          var t, n;\n          return _(), j(), n = g, l = !1, t = function () {\n            for (var t, n, r, i = []; h < d && (n = g).type === e.StringLiteral && (t = Tt(), i.push(t), t.expression.type === o.Literal);) \"use strict\" === c.slice(n.start + 1, n.end - 1) ? (l = !0, r && K(r, a.StrictOctalLiteral)) : !r && n.octal && (r = n);\n\n            for (; h < d && void 0 !== (t = Tt());) i.push(t);\n\n            return i;\n          }(), m.markEnd(m.createProgram(t), n);\n        }\n\n        function Pt() {\n          var t,\n              e,\n              n,\n              r = [];\n\n          for (t = 0; t < y.tokens.length; ++t) n = {\n            type: (e = y.tokens[t]).type,\n            value: e.value\n          }, y.range && (n.range = e.range), y.loc && (n.loc = e.loc), r.push(n);\n\n          y.tokens = r;\n        }\n\n        (n = {})[(e = {\n          BooleanLiteral: 1,\n          EOF: 2,\n          Identifier: 3,\n          Keyword: 4,\n          NullLiteral: 5,\n          NumericLiteral: 6,\n          Punctuator: 7,\n          StringLiteral: 8,\n          RegularExpression: 9\n        }).BooleanLiteral] = \"Boolean\", n[e.EOF] = \"<end>\", n[e.Identifier] = \"Identifier\", n[e.Keyword] = \"Keyword\", n[e.NullLiteral] = \"Null\", n[e.NumericLiteral] = \"Numeric\", n[e.Punctuator] = \"Punctuator\", n[e.StringLiteral] = \"String\", n[e.RegularExpression] = \"RegularExpression\", r = [\"(\", \"{\", \"[\", \"in\", \"typeof\", \"instanceof\", \"new\", \"return\", \"case\", \"delete\", \"throw\", \"void\", \"=\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"&=\", \"|=\", \"^=\", \",\", \"+\", \"-\", \"*\", \"/\", \"%\", \"++\", \"--\", \"<<\", \">>\", \">>>\", \"&\", \"|\", \"^\", \"!\", \"~\", \"&&\", \"||\", \"?\", \":\", \"===\", \"==\", \">=\", \"<=\", \"<\", \">\", \"!=\", \"!==\"], o = {\n          AssignmentExpression: \"AssignmentExpression\",\n          ArrayExpression: \"ArrayExpression\",\n          BlockStatement: \"BlockStatement\",\n          BinaryExpression: \"BinaryExpression\",\n          BreakStatement: \"BreakStatement\",\n          CallExpression: \"CallExpression\",\n          CatchClause: \"CatchClause\",\n          ConditionalExpression: \"ConditionalExpression\",\n          ContinueStatement: \"ContinueStatement\",\n          DoWhileStatement: \"DoWhileStatement\",\n          DebuggerStatement: \"DebuggerStatement\",\n          EmptyStatement: \"EmptyStatement\",\n          ExpressionStatement: \"ExpressionStatement\",\n          ForStatement: \"ForStatement\",\n          ForInStatement: \"ForInStatement\",\n          FunctionDeclaration: \"FunctionDeclaration\",\n          FunctionExpression: \"FunctionExpression\",\n          Identifier: \"Identifier\",\n          IfStatement: \"IfStatement\",\n          Literal: \"Literal\",\n          LabeledStatement: \"LabeledStatement\",\n          LogicalExpression: \"LogicalExpression\",\n          MemberExpression: \"MemberExpression\",\n          NewExpression: \"NewExpression\",\n          ObjectExpression: \"ObjectExpression\",\n          Program: \"Program\",\n          Property: \"Property\",\n          ReturnStatement: \"ReturnStatement\",\n          SequenceExpression: \"SequenceExpression\",\n          SwitchStatement: \"SwitchStatement\",\n          SwitchCase: \"SwitchCase\",\n          ThisExpression: \"ThisExpression\",\n          ThrowStatement: \"ThrowStatement\",\n          TryStatement: \"TryStatement\",\n          UnaryExpression: \"UnaryExpression\",\n          UpdateExpression: \"UpdateExpression\",\n          VariableDeclaration: \"VariableDeclaration\",\n          VariableDeclarator: \"VariableDeclarator\",\n          WhileStatement: \"WhileStatement\",\n          WithStatement: \"WithStatement\"\n        }, i = {\n          Data: 1,\n          Get: 2,\n          Set: 4\n        }, a = {\n          UnexpectedToken: \"Unexpected token %0\",\n          UnexpectedNumber: \"Unexpected number\",\n          UnexpectedString: \"Unexpected string\",\n          UnexpectedIdentifier: \"Unexpected identifier\",\n          UnexpectedReserved: \"Unexpected reserved word\",\n          UnexpectedEOS: \"Unexpected end of input\",\n          NewlineAfterThrow: \"Illegal newline after throw\",\n          InvalidRegExp: \"Invalid regular expression\",\n          UnterminatedRegExp: \"Invalid regular expression: missing /\",\n          InvalidLHSInAssignment: \"Invalid left-hand side in assignment\",\n          InvalidLHSInForIn: \"Invalid left-hand side in for-in\",\n          MultipleDefaultsInSwitch: \"More than one default clause in switch statement\",\n          NoCatchOrFinally: \"Missing catch or finally after try\",\n          UnknownLabel: \"Undefined label '%0'\",\n          Redeclaration: \"%0 '%1' has already been declared\",\n          IllegalContinue: \"Illegal continue statement\",\n          IllegalBreak: \"Illegal break statement\",\n          IllegalReturn: \"Illegal return statement\",\n          StrictModeWith: \"Strict mode code may not include a with statement\",\n          StrictCatchVariable: \"Catch variable may not be eval or arguments in strict mode\",\n          StrictVarName: \"Variable name may not be eval or arguments in strict mode\",\n          StrictParamName: \"Parameter name eval or arguments is not allowed in strict mode\",\n          StrictParamDupe: \"Strict mode function may not have duplicate parameter names\",\n          StrictFunctionName: \"Function name may not be eval or arguments in strict mode\",\n          StrictOctalLiteral: \"Octal literals are not allowed in strict mode.\",\n          StrictDelete: \"Delete of an unqualified identifier in strict mode.\",\n          StrictDuplicateProperty: \"Duplicate data property in object literal not allowed in strict mode\",\n          AccessorDataProperty: \"Object literal may not have data and accessor property with the same name\",\n          AccessorGetSet: \"Object literal may not have multiple get/set accessors with the same name\",\n          StrictLHSAssignment: \"Assignment to eval or arguments is not allowed in strict mode\",\n          StrictLHSPostfix: \"Postfix increment/decrement may not have eval or arguments operand in strict mode\",\n          StrictLHSPrefix: \"Prefix increment/decrement may not have eval or arguments operand in strict mode\",\n          StrictReservedWord: \"Use of future reserved word in strict mode\"\n        }, s = {\n          NonAsciiIdentifierStart: new RegExp(\"[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]\"),\n          NonAsciiIdentifierPart: new RegExp(\"[------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------]\")\n        }, u = {\n          name: \"SyntaxTree\",\n          processComment: function (t) {\n            var e, n;\n\n            if (!(t.type === o.Program && t.body.length > 0)) {\n              for (y.trailingComments.length > 0 ? y.trailingComments[0].range[0] >= t.range[1] ? (n = y.trailingComments, y.trailingComments = []) : y.trailingComments.length = 0 : y.bottomRightStack.length > 0 && y.bottomRightStack[y.bottomRightStack.length - 1].trailingComments && y.bottomRightStack[y.bottomRightStack.length - 1].trailingComments[0].range[0] >= t.range[1] && (n = y.bottomRightStack[y.bottomRightStack.length - 1].trailingComments, delete y.bottomRightStack[y.bottomRightStack.length - 1].trailingComments); y.bottomRightStack.length > 0 && y.bottomRightStack[y.bottomRightStack.length - 1].range[0] >= t.range[0];) e = y.bottomRightStack.pop();\n\n              e ? e.leadingComments && e.leadingComments[e.leadingComments.length - 1].range[1] <= t.range[0] && (t.leadingComments = e.leadingComments, delete e.leadingComments) : y.leadingComments.length > 0 && y.leadingComments[y.leadingComments.length - 1].range[1] <= t.range[0] && (t.leadingComments = y.leadingComments, y.leadingComments = []), n && (t.trailingComments = n), y.bottomRightStack.push(t);\n            }\n          },\n          markEnd: function (t, e) {\n            return y.range && (t.range = [e.start, h]), y.loc && (t.loc = new G(void 0 === e.startLineNumber ? e.lineNumber : e.startLineNumber, e.start - (void 0 === e.startLineStart ? e.lineStart : e.startLineStart), p, h - f), this.postProcess(t)), y.attachComment && this.processComment(t), t;\n          },\n          postProcess: function (t) {\n            return y.source && (t.loc.source = y.source), t;\n          },\n          createArrayExpression: function (t) {\n            return {\n              type: o.ArrayExpression,\n              elements: t\n            };\n          },\n          createAssignmentExpression: function (t, e, n) {\n            return {\n              type: o.AssignmentExpression,\n              operator: t,\n              left: e,\n              right: n\n            };\n          },\n          createBinaryExpression: function (t, e, n) {\n            return {\n              type: \"||\" === t || \"&&\" === t ? o.LogicalExpression : o.BinaryExpression,\n              operator: t,\n              left: e,\n              right: n\n            };\n          },\n          createBlockStatement: function (t) {\n            return {\n              type: o.BlockStatement,\n              body: t\n            };\n          },\n          createBreakStatement: function (t) {\n            return {\n              type: o.BreakStatement,\n              label: t\n            };\n          },\n          createCallExpression: function (t, e) {\n            return {\n              type: o.CallExpression,\n              callee: t,\n              arguments: e\n            };\n          },\n          createCatchClause: function (t, e) {\n            return {\n              type: o.CatchClause,\n              param: t,\n              body: e\n            };\n          },\n          createConditionalExpression: function (t, e, n) {\n            return {\n              type: o.ConditionalExpression,\n              test: t,\n              consequent: e,\n              alternate: n\n            };\n          },\n          createContinueStatement: function (t) {\n            return {\n              type: o.ContinueStatement,\n              label: t\n            };\n          },\n          createDebuggerStatement: function () {\n            return {\n              type: o.DebuggerStatement\n            };\n          },\n          createDoWhileStatement: function (t, e) {\n            return {\n              type: o.DoWhileStatement,\n              body: t,\n              test: e\n            };\n          },\n          createEmptyStatement: function () {\n            return {\n              type: o.EmptyStatement\n            };\n          },\n          createExpressionStatement: function (t) {\n            return {\n              type: o.ExpressionStatement,\n              expression: t\n            };\n          },\n          createForStatement: function (t, e, n, r) {\n            return {\n              type: o.ForStatement,\n              init: t,\n              test: e,\n              update: n,\n              body: r\n            };\n          },\n          createForInStatement: function (t, e, n) {\n            return {\n              type: o.ForInStatement,\n              left: t,\n              right: e,\n              body: n,\n              each: !1\n            };\n          },\n          createFunctionDeclaration: function (t, e, n, r) {\n            return {\n              type: o.FunctionDeclaration,\n              id: t,\n              params: e,\n              defaults: n,\n              body: r,\n              rest: null,\n              generator: !1,\n              expression: !1\n            };\n          },\n          createFunctionExpression: function (t, e, n, r) {\n            return {\n              type: o.FunctionExpression,\n              id: t,\n              params: e,\n              defaults: n,\n              body: r,\n              rest: null,\n              generator: !1,\n              expression: !1\n            };\n          },\n          createIdentifier: function (t) {\n            return {\n              type: o.Identifier,\n              name: t\n            };\n          },\n          createIfStatement: function (t, e, n) {\n            return {\n              type: o.IfStatement,\n              test: t,\n              consequent: e,\n              alternate: n\n            };\n          },\n          createLabeledStatement: function (t, e) {\n            return {\n              type: o.LabeledStatement,\n              label: t,\n              body: e\n            };\n          },\n          createLiteral: function (t) {\n            return {\n              type: o.Literal,\n              value: t.value,\n              raw: c.slice(t.start, t.end)\n            };\n          },\n          createMemberExpression: function (t, e, n) {\n            return {\n              type: o.MemberExpression,\n              computed: \"[\" === t,\n              object: e,\n              property: n\n            };\n          },\n          createNewExpression: function (t, e) {\n            return {\n              type: o.NewExpression,\n              callee: t,\n              arguments: e\n            };\n          },\n          createObjectExpression: function (t) {\n            return {\n              type: o.ObjectExpression,\n              properties: t\n            };\n          },\n          createPostfixExpression: function (t, e) {\n            return {\n              type: o.UpdateExpression,\n              operator: t,\n              argument: e,\n              prefix: !1\n            };\n          },\n          createProgram: function (t) {\n            return {\n              type: o.Program,\n              body: t\n            };\n          },\n          createProperty: function (t, e, n) {\n            return {\n              type: o.Property,\n              key: e,\n              value: n,\n              kind: t\n            };\n          },\n          createReturnStatement: function (t) {\n            return {\n              type: o.ReturnStatement,\n              argument: t\n            };\n          },\n          createSequenceExpression: function (t) {\n            return {\n              type: o.SequenceExpression,\n              expressions: t\n            };\n          },\n          createSwitchCase: function (t, e) {\n            return {\n              type: o.SwitchCase,\n              test: t,\n              consequent: e\n            };\n          },\n          createSwitchStatement: function (t, e) {\n            return {\n              type: o.SwitchStatement,\n              discriminant: t,\n              cases: e\n            };\n          },\n          createThisExpression: function () {\n            return {\n              type: o.ThisExpression\n            };\n          },\n          createThrowStatement: function (t) {\n            return {\n              type: o.ThrowStatement,\n              argument: t\n            };\n          },\n          createTryStatement: function (t, e, n, r) {\n            return {\n              type: o.TryStatement,\n              block: t,\n              guardedHandlers: e,\n              handlers: n,\n              finalizer: r\n            };\n          },\n          createUnaryExpression: function (t, e) {\n            return \"++\" === t || \"--\" === t ? {\n              type: o.UpdateExpression,\n              operator: t,\n              argument: e,\n              prefix: !0\n            } : {\n              type: o.UnaryExpression,\n              operator: t,\n              argument: e,\n              prefix: !0\n            };\n          },\n          createVariableDeclaration: function (t, e) {\n            return {\n              type: o.VariableDeclaration,\n              declarations: t,\n              kind: e\n            };\n          },\n          createVariableDeclarator: function (t, e) {\n            return {\n              type: o.VariableDeclarator,\n              id: t,\n              init: e\n            };\n          },\n          createWhileStatement: function (t, e) {\n            return {\n              type: o.WhileStatement,\n              test: t,\n              body: e\n            };\n          },\n          createWithStatement: function (t, e) {\n            return {\n              type: o.WithStatement,\n              object: t,\n              body: e\n            };\n          }\n        }, t.version = \"1.2.5\", t.tokenize = function (t, n) {\n          var r, o;\n          r = String, \"string\" == typeof t || t instanceof String || (t = r(t)), m = u, h = 0, p = (c = t).length > 0 ? 1 : 0, f = 0, d = c.length, g = null, v = {\n            allowIn: !0,\n            labelSet: {},\n            inFunctionBody: !1,\n            inIteration: !1,\n            inSwitch: !1,\n            lastCommentStart: -1\n          }, y = {}, (n = n || {}).tokens = !0, y.tokens = [], y.tokenize = !0, y.openParenToken = -1, y.openCurlyToken = -1, y.range = \"boolean\" == typeof n.range && n.range, y.loc = \"boolean\" == typeof n.loc && n.loc, \"boolean\" == typeof n.comment && n.comment && (y.comments = []), \"boolean\" == typeof n.tolerant && n.tolerant && (y.errors = []);\n\n          try {\n            if (j(), g.type === e.EOF) return y.tokens;\n\n            for (U(); g.type !== e.EOF;) try {\n              U();\n            } catch (t) {\n              if (g, y.errors) {\n                y.errors.push(t);\n                break;\n              }\n\n              throw t;\n            }\n\n            Pt(), o = y.tokens, void 0 !== y.comments && (o.comments = y.comments), void 0 !== y.errors && (o.errors = y.errors);\n          } catch (t) {\n            throw t;\n          } finally {\n            y = {};\n          }\n\n          return o;\n        }, t.parse = function (t, e) {\n          var n, r;\n          r = String, \"string\" == typeof t || t instanceof String || (t = r(t)), m = u, h = 0, p = (c = t).length > 0 ? 1 : 0, f = 0, d = c.length, g = null, v = {\n            allowIn: !0,\n            labelSet: {},\n            inFunctionBody: !1,\n            inIteration: !1,\n            inSwitch: !1,\n            lastCommentStart: -1\n          }, y = {}, void 0 !== e && (y.range = \"boolean\" == typeof e.range && e.range, y.loc = \"boolean\" == typeof e.loc && e.loc, y.attachComment = \"boolean\" == typeof e.attachComment && e.attachComment, y.loc && null !== e.source && void 0 !== e.source && (y.source = r(e.source)), \"boolean\" == typeof e.tokens && e.tokens && (y.tokens = []), \"boolean\" == typeof e.comment && e.comment && (y.comments = []), \"boolean\" == typeof e.tolerant && e.tolerant && (y.errors = []), y.attachComment && (y.range = !0, y.comments = [], y.bottomRightStack = [], y.trailingComments = [], y.leadingComments = []));\n\n          try {\n            n = Nt(), void 0 !== y.comments && (n.comments = y.comments), void 0 !== y.tokens && (Pt(), n.tokens = y.tokens), void 0 !== y.errors && (n.errors = y.errors);\n          } catch (t) {\n            throw t;\n          } finally {\n            y = {};\n          }\n\n          return n;\n        }, t.Syntax = function () {\n          var t,\n              e = {};\n\n          for (t in \"function\" == typeof Object.create && (e = Object.create(null)), o) o.hasOwnProperty(t) && (e[t] = o[t]);\n\n          return \"function\" == typeof Object.freeze && Object.freeze(e), e;\n        }();\n      }) ? r.apply(e, o) : r) || (t.exports = i);\n    }();\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(2);\n    n.d(e, \"NoteSequence\", function () {\n      return r.a;\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(35),\n        o = n(16),\n        i = n(1),\n        a = n(10),\n        s = n(5),\n        u = n(11),\n        c = n(6),\n        l = n(3);\n    const h = 4;\n\n    class p {}\n\n    class f {\n      constructor(t, e = 1) {\n        this.clicksPerQuarter = 1, this.muted = !1, this.loClick = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.hiClick = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.loClickNote = \"c5\", this.hiClickNote = \"g5\", this.ticking = !1, this.startedAt = null, this.step = -1, this.reset(), this.callbackObject = t, this.clicksPerQuarter = e;\n      }\n\n      isTicking() {\n        return this.ticking;\n      }\n\n      getStartedAt() {\n        return this.startedAt;\n      }\n\n      getOffsetTime() {\n        return l.immediate() - this.startedAt;\n      }\n\n      start(t = 120) {\n        this.reset(), this.ticking = !0, this.callbackObject.click || (this.callbackObject.click = () => {}), this.callbackObject.quarter || (this.callbackObject.quarter = () => {}), this.callbackObject.bar || (this.callbackObject.bar = () => {});\n        let e = 0;\n        const n = h * this.clicksPerQuarter;\n        l.Transport.scheduleRepeat(t => {\n          this.startedAt || (this.startedAt = t);\n          const r = t - this.startedAt;\n          this.step++;\n          const o = this.step % n,\n                i = Math.floor(o / this.clicksPerQuarter),\n                a = o % this.clicksPerQuarter;\n          this.callbackObject.click(r, o), 0 === a && this.callbackObject.quarter(r, i), this.muted || (0 === o ? this.hiClick.triggerAttack(this.hiClickNote, t, .1) : this.loClick.triggerAttack(this.loClickNote, t, .1)), 0 === o && (this.callbackObject.bar(r, e), e++);\n        }, \"\".concat(n, \"n\")), l.Transport.bpm.value = t, l.Transport.start();\n      }\n\n      stop() {\n        this.ticking = !1, l.Transport.cancel(), l.Transport.stop();\n      }\n\n      reset() {\n        this.muted = !1, this.ticking = !1, this.step = -1, this.startedAt = null;\n      }\n\n    }\n\n    var d = n(48),\n        m = n(17);\n\n    function g(t) {\n      return \"number\" == typeof t;\n    }\n\n    const v = function () {\n      const t = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;\n      return e => function (t) {\n        return \"string\" == typeof t;\n      }(e) && t.test(e);\n    }();\n\n    const y = function () {\n      const t = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n            e = {\n        cbb: -2,\n        cb: -1,\n        c: 0,\n        \"c#\": 1,\n        cx: 2,\n        dbb: 0,\n        db: 1,\n        d: 2,\n        \"d#\": 3,\n        dx: 4,\n        ebb: 2,\n        eb: 3,\n        e: 4,\n        \"e#\": 5,\n        ex: 6,\n        fbb: 3,\n        fb: 4,\n        f: 5,\n        \"f#\": 6,\n        fx: 7,\n        gbb: 5,\n        gb: 6,\n        g: 7,\n        \"g#\": 8,\n        gx: 9,\n        abb: 7,\n        ab: 8,\n        a: 9,\n        \"a#\": 10,\n        ax: 11,\n        bbb: 9,\n        bb: 10,\n        b: 11,\n        \"b#\": 12,\n        bx: 13\n      };\n      return n => {\n        const r = t.exec(n),\n              o = r[1],\n              i = r[2];\n        return e[o.toLowerCase()] + 12 * (parseInt(i) + 1);\n      };\n    }();\n\n    function b(t, e) {\n      if (t.length) {\n        const n = function (t, e) {\n          let n = 0;\n          const r = t.length;\n          let o = r;\n          if (r > 0 && t[r - 1].time <= e) return r - 1;\n\n          for (; n < o;) {\n            let r = Math.floor(n + (o - n) / 2);\n            const i = t[r],\n                  a = t[r + 1];\n\n            if (i.time === e) {\n              for (let n = r; n < t.length; n++) {\n                t[n].time === e && (r = n);\n              }\n\n              return r;\n            }\n\n            if (i.time < e && a.time > e) return r;\n            i.time > e ? o = r : i.time < e && (n = r + 1);\n          }\n\n          return -1;\n        }(t, e.time);\n\n        t.splice(n + 1, 0, e);\n      } else t.push(e);\n    }\n\n    const w = {\n      1: \"modulationWheel\",\n      2: \"breath\",\n      4: \"footController\",\n      5: \"portamentoTime\",\n      7: \"volume\",\n      8: \"balance\",\n      10: \"pan\",\n      64: \"sustain\",\n      65: \"portamentoTime\",\n      66: \"sostenuto\",\n      67: \"softPedal\",\n      68: \"legatoFootswitch\",\n      84: \"portamentoContro\"\n    };\n\n    class x {\n      constructor(t, e, n) {\n        this.number = t, this.time = e, this.value = n;\n      }\n\n      get name() {\n        if (w.hasOwnProperty(this.number)) return w[this.number];\n      }\n\n    }\n\n    function S(t, e) {\n      for (let n = 0; n < t.length; n++) {\n        let r = t[n],\n            o = e[n];\n        if (r.length > o) return !0;\n      }\n\n      return !1;\n    }\n\n    function E(t, e, n) {\n      let r = 0,\n          o = 1 / 0;\n\n      for (let n = 0; n < t.length; n++) {\n        let i = t[n],\n            a = e[n];\n        i[a] && i[a].time < o && (r = n, o = i[a].time);\n      }\n\n      n[r](t[r][e[r]]), e[r] += 1;\n    }\n\n    class C {\n      static fromJSON(t) {\n        return new C(t.midi, t.time, t.duration, t.velocity);\n      }\n\n      constructor(t, e, n = 0, r = 1) {\n        if (g(t)) this.midi = t;else {\n          if (!v(t)) throw new Error(\"the midi value must either be in Pitch Notation (e.g. C#4) or a midi value\");\n          this.name = t;\n        }\n        this.time = e, this.duration = n, this.velocity = r;\n      }\n\n      match(t) {\n        return g(t) ? this.midi === t : v(t) ? this.name.toLowerCase() === t.toLowerCase() : void 0;\n      }\n\n      get name() {\n        return function (t) {\n          const e = Math.floor(t / 12) - 1;\n          return [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"][t % 12] + e;\n        }(this.midi);\n      }\n\n      set name(t) {\n        this.midi = y(t);\n      }\n\n      get noteOn() {\n        return this.time;\n      }\n\n      set noteOn(t) {\n        this.time = t;\n      }\n\n      get noteOff() {\n        return this.time + this.duration;\n      }\n\n      set noteOff(t) {\n        this.duration = t - this.time;\n      }\n\n      toJSON() {\n        return {\n          name: this.name,\n          midi: this.midi,\n          time: this.time,\n          velocity: this.velocity,\n          duration: this.duration\n        };\n      }\n\n    }\n\n    const I = [\"acoustic grand piano\", \"bright acoustic piano\", \"electric grand piano\", \"honky-tonk piano\", \"electric piano 1\", \"electric piano 2\", \"harpsichord\", \"clavi\", \"celesta\", \"glockenspiel\", \"music box\", \"vibraphone\", \"marimba\", \"xylophone\", \"tubular bells\", \"dulcimer\", \"drawbar organ\", \"percussive organ\", \"rock organ\", \"church organ\", \"reed organ\", \"accordion\", \"harmonica\", \"tango accordion\", \"acoustic guitar (nylon)\", \"acoustic guitar (steel)\", \"electric guitar (jazz)\", \"electric guitar (clean)\", \"electric guitar (muted)\", \"overdriven guitar\", \"distortion guitar\", \"guitar harmonics\", \"acoustic bass\", \"electric bass (finger)\", \"electric bass (pick)\", \"fretless bass\", \"slap bass 1\", \"slap bass 2\", \"synth bass 1\", \"synth bass 2\", \"violin\", \"viola\", \"cello\", \"contrabass\", \"tremolo strings\", \"pizzicato strings\", \"orchestral harp\", \"timpani\", \"string ensemble 1\", \"string ensemble 2\", \"synthstrings 1\", \"synthstrings 2\", \"choir aahs\", \"voice oohs\", \"synth voice\", \"orchestra hit\", \"trumpet\", \"trombone\", \"tuba\", \"muted trumpet\", \"french horn\", \"brass section\", \"synthbrass 1\", \"synthbrass 2\", \"soprano sax\", \"alto sax\", \"tenor sax\", \"baritone sax\", \"oboe\", \"english horn\", \"bassoon\", \"clarinet\", \"piccolo\", \"flute\", \"recorder\", \"pan flute\", \"blown bottle\", \"shakuhachi\", \"whistle\", \"ocarina\", \"lead 1 (square)\", \"lead 2 (sawtooth)\", \"lead 3 (calliope)\", \"lead 4 (chiff)\", \"lead 5 (charang)\", \"lead 6 (voice)\", \"lead 7 (fifths)\", \"lead 8 (bass + lead)\", \"pad 1 (new age)\", \"pad 2 (warm)\", \"pad 3 (polysynth)\", \"pad 4 (choir)\", \"pad 5 (bowed)\", \"pad 6 (metallic)\", \"pad 7 (halo)\", \"pad 8 (sweep)\", \"fx 1 (rain)\", \"fx 2 (soundtrack)\", \"fx 3 (crystal)\", \"fx 4 (atmosphere)\", \"fx 5 (brightness)\", \"fx 6 (goblins)\", \"fx 7 (echoes)\", \"fx 8 (sci-fi)\", \"sitar\", \"banjo\", \"shamisen\", \"koto\", \"kalimba\", \"bag pipe\", \"fiddle\", \"shanai\", \"tinkle bell\", \"agogo\", \"steel drums\", \"woodblock\", \"taiko drum\", \"melodic tom\", \"synth drum\", \"reverse cymbal\", \"guitar fret noise\", \"breath noise\", \"seashore\", \"bird tweet\", \"telephone ring\", \"helicopter\", \"applause\", \"gunshot\"],\n          A = [\"piano\", \"chromatic percussion\", \"organ\", \"guitar\", \"bass\", \"strings\", \"ensemble\", \"brass\", \"reed\", \"pipe\", \"synth lead\", \"synth pad\", \"synth effects\", \"ethnic\", \"percussive\", \"sound effects\"],\n          k = {\n      0: \"standard kit\",\n      8: \"room kit\",\n      16: \"power kit\",\n      24: \"electronic kit\",\n      25: \"tr-808 kit\",\n      32: \"jazz kit\",\n      40: \"brush kit\",\n      48: \"orchestra kit\",\n      56: \"sound fx kit\"\n    };\n\n    class T {\n      static fromJSON(t) {\n        var e = new T(t.name, t.instrumentNumber, t.channelNumber);\n        return e.id = t.id, t.notes && t.notes.forEach(t => {\n          var n = C.fromJSON(t);\n          e.notes.push(n);\n        }), t.controlChanges && (e.controlChanges = t.controlChanges), e;\n      }\n\n      constructor(t, e = -1, n = -1) {\n        this.name = t, this.channelNumber = n, this.notes = [], this.controlChanges = {}, this.instrumentNumber = e;\n      }\n\n      note(t, e, n = 0, r = 1) {\n        const o = new C(t, e, n, r);\n        return b(this.notes, o), this;\n      }\n\n      noteOn(t, e, n = 1) {\n        const r = new C(t, e, 0, n);\n        return b(this.notes, r), this;\n      }\n\n      noteOff(t, e) {\n        for (let n = 0; n < this.notes.length; n++) {\n          let r = this.notes[n];\n\n          if (r.match(t) && 0 === r.duration) {\n            r.noteOff = e;\n            break;\n          }\n        }\n\n        return this;\n      }\n\n      cc(t, e, n) {\n        this.controlChanges.hasOwnProperty(t) || (this.controlChanges[t] = []);\n        const r = new x(t, e, n);\n        return b(this.controlChanges[t], r), this;\n      }\n\n      patch(t) {\n        return this.instrumentNumber = t, this;\n      }\n\n      channel(t) {\n        return this.channelNumber = t, this;\n      }\n\n      get noteOns() {\n        const t = [];\n        return this.notes.forEach(e => {\n          t.push({\n            time: e.noteOn,\n            midi: e.midi,\n            name: e.name,\n            velocity: e.velocity\n          });\n        }), t;\n      }\n\n      get noteOffs() {\n        const t = [];\n        return this.notes.forEach(e => {\n          t.push({\n            time: e.noteOff,\n            midi: e.midi,\n            name: e.name\n          });\n        }), t;\n      }\n\n      get length() {\n        return this.notes.length;\n      }\n\n      get startTime() {\n        if (this.notes.length) {\n          return this.notes[0].noteOn;\n        }\n\n        return 0;\n      }\n\n      get duration() {\n        if (this.notes.length) {\n          return this.notes[this.notes.length - 1].noteOff;\n        }\n\n        return 0;\n      }\n\n      get instrument() {\n        return this.isPercussion ? k[this.instrumentNumber] : I[this.instrumentNumber];\n      }\n\n      set instrument(t) {\n        const e = I.indexOf(t);\n        -1 !== e && (this.instrumentNumber = e);\n      }\n\n      get isPercussion() {\n        return [9, 10].includes(this.channelNumber);\n      }\n\n      get instrumentFamily() {\n        return this.isPercussion ? \"drums\" : A[Math.floor(this.instrumentNumber / 8)];\n      }\n\n      scale(t) {\n        return this.notes.forEach(e => {\n          e.time *= t, e.duration *= t;\n        }), this;\n      }\n\n      slice(t = 0, e = this.duration) {\n        const n = Math.max(this.notes.findIndex(e => e.time >= t), 0),\n              r = this.notes.findIndex(t => t.noteOff >= e) + 1,\n              o = new T(this.name);\n        return o.notes = this.notes.slice(n, r), o.notes.forEach(e => e.time = e.time - t), o;\n      }\n\n      encode(t, e) {\n        const n = e.PPQ / (60 / e.bpm);\n        let r = 0;\n        const o = Math.max(0, this.channelNumber);\n\n        function i(t) {\n          const e = Math.floor(n * t),\n                o = Math.max(e - r, 0);\n          return r = e, o;\n        }\n\n        -1 !== this.instrumentNumber && t.instrument(o, this.instrumentNumber), function (...t) {\n          const e = t.filter((t, e) => e % 2 == 0),\n                n = new Uint32Array(e.length),\n                r = t.filter((t, e) => e % 2 == 1);\n\n          for (; S(e, n);) E(e, n, r);\n        }(this.noteOns.sort((t, e) => t.time - e.time), e => {\n          t.addNoteOn(o, e.name, i(e.time), Math.floor(127 * e.velocity));\n        }, this.noteOffs.sort((t, e) => t.time - e.time), e => {\n          t.addNoteOff(o, e.name, i(e.time));\n        });\n      }\n\n      toJSON() {\n        const t = {\n          startTime: this.startTime,\n          duration: this.duration,\n          length: this.length,\n          notes: [],\n          controlChanges: {}\n        };\n        return void 0 !== this.id && (t.id = this.id), t.name = this.name, -1 !== this.instrumentNumber && (t.instrumentNumber = this.instrumentNumber, t.instrument = this.instrument, t.instrumentFamily = this.instrumentFamily), -1 !== this.channelNumber && (t.channelNumber = this.channelNumber, t.isPercussion = this.isPercussion), this.notes.length && (t.notes = this.notes.map(t => t.toJSON())), Object.keys(this.controlChanges).length && (t.controlChanges = this.controlChanges), t;\n      }\n\n    }\n\n    class N {\n      static fromJSON(t) {\n        var e = new N();\n        return e.header = t.header, t.tracks.forEach(t => {\n          var n = T.fromJSON(t);\n          e.tracks.push(n);\n        }), e;\n      }\n\n      constructor() {\n        this.header = {\n          bpm: 120,\n          timeSignature: [4, 4],\n          PPQ: 480\n        }, this.tracks = [];\n      }\n\n      load(t, e = null, n = \"GET\") {\n        return new Promise((r, o) => {\n          var i = new XMLHttpRequest();\n          i.open(n, t), i.responseType = \"arraybuffer\", i.addEventListener(\"load\", () => {\n            4 === i.readyState && 200 === i.status ? r(this.decode(i.response)) : o(i.status);\n          }), i.addEventListener(\"error\", o), i.send(e);\n        }).catch(function (t) {\n          console.log(t);\n        });\n      }\n\n      decode(t) {\n        if (t instanceof ArrayBuffer) {\n          var e = new Uint8Array(t);\n          t = String.fromCharCode.apply(null, e);\n        }\n\n        const n = d(t);\n        return this.header = function (t) {\n          for (var e = {\n            PPQ: t.header.ticksPerBeat\n          }, n = 0; n < t.tracks.length; n++) for (var r = t.tracks[n], o = 0; o < r.length; o++) {\n            var i = r[o];\n            \"meta\" === i.type && (\"timeSignature\" === i.subtype ? e.timeSignature = [i.numerator, i.denominator] : \"setTempo\" === i.subtype && (e.bpm || (e.bpm = 6e7 / i.microsecondsPerBeat)));\n          }\n\n          return e.bpm = e.bpm || 120, e;\n        }(n), this.tracks = [], n.tracks.forEach((t, e) => {\n          const n = new T();\n          n.id = e, this.tracks.push(n);\n          let r = 0;\n          t.forEach(t => {\n            r += function (t, e) {\n              return 60 / e.bpm * (t / e.PPQ);\n            }(t.deltaTime, this.header), \"meta\" === t.type && \"trackName\" === t.subtype ? n.name = function (t) {\n              return t.replace(/\\u0000/g, \"\");\n            }(t.text) : \"noteOn\" === t.subtype ? (n.noteOn(t.noteNumber, r, t.velocity / 127), -1 === n.channelNumber && (n.channelNumber = t.channel)) : \"noteOff\" === t.subtype ? n.noteOff(t.noteNumber, r) : \"controller\" === t.subtype && t.controllerType ? n.cc(t.controllerType, r, t.value / 127) : \"meta\" === t.type && \"instrumentName\" === t.subtype ? n.instrument = t.text : \"channel\" === t.type && \"programChange\" === t.subtype && (n.patch(t.programNumber), n.channelNumber = t.channel);\n          }), this.header.name || n.length || !n.name || (this.header.name = n.name);\n        }), this;\n      }\n\n      encode() {\n        const t = new m.File({\n          ticks: this.header.PPQ\n        }),\n              e = this.tracks.filter(t => !t.length)[0];\n\n        if (this.header.name && (!e || e.name !== this.header.name)) {\n          t.addTrack().addEvent(new m.MetaEvent({\n            time: 0,\n            type: m.MetaEvent.TRACK_NAME,\n            data: this.header.name\n          }));\n        }\n\n        return this.tracks.forEach(e => {\n          const n = t.addTrack();\n          n.setTempo(this.bpm), e.name && n.addEvent(new m.MetaEvent({\n            time: 0,\n            type: m.MetaEvent.TRACK_NAME,\n            data: e.name\n          })), e.encode(n, this.header);\n        }), t.toBytes();\n      }\n\n      toArray() {\n        const t = this.encode(),\n              e = new Array(t.length);\n\n        for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);\n\n        return e;\n      }\n\n      toJSON() {\n        const t = {\n          header: this.header,\n          startTime: this.startTime,\n          duration: this.duration,\n          tracks: (this.tracks || []).map(t => t.toJSON())\n        };\n        return t.header.name || (t.header.name = \"\"), t;\n      }\n\n      track(t) {\n        const e = new T(t);\n        return this.tracks.push(e), e;\n      }\n\n      get(t) {\n        return g(t) ? this.tracks[t] : this.tracks.find(e => e.name === t);\n      }\n\n      slice(t = 0, e = this.duration) {\n        const n = new N();\n        return n.header = this.header, n.tracks = this.tracks.map(n => n.slice(t, e)), n;\n      }\n\n      get startTime() {\n        const t = this.tracks.map(t => t.startTime);\n        return t.length && Math.min.apply(Math, t) || 0;\n      }\n\n      get bpm() {\n        return this.header.bpm;\n      }\n\n      set bpm(t) {\n        const e = this.header.bpm;\n        this.header.bpm = t;\n        const n = e / t;\n        this.tracks.forEach(t => t.scale(n));\n      }\n\n      get timeSignature() {\n        return this.header.timeSignature;\n      }\n\n      set timeSignature(t) {\n        this.header.timeSignature = t;\n      }\n\n      get duration() {\n        const t = this.tracks.map(t => t.duration);\n        return t.length && Math.max.apply(Math, t) || 0;\n      }\n\n    }\n\n    var P = n(2);\n\n    class R extends Error {\n      constructor(t) {\n        super(t), Object.setPrototypeOf(this, new.target.prototype);\n      }\n\n    }\n\n    function _(t) {\n      const e = (n = t, new N().decode(n));\n      var n;\n      const r = P.a.create();\n      r.ticksPerQuarter = e.header.PPQ, r.sourceInfo = P.a.SourceInfo.create({\n        parser: P.a.SourceInfo.Parser.TONEJS_MIDI_CONVERT,\n        encodingType: P.a.SourceInfo.EncodingType.MIDI\n      }), e.header.timeSignature ? r.timeSignatures.push(P.a.TimeSignature.create({\n        time: 0,\n        numerator: e.header.timeSignature[0],\n        denominator: e.header.timeSignature[1]\n      })) : r.timeSignatures.push(P.a.TimeSignature.create({\n        time: 0,\n        numerator: 4,\n        denominator: 4\n      })), r.tempos.push(P.a.Tempo.create({\n        time: 0,\n        qpm: e.header.bpm\n      }));\n      let o = -1;\n\n      for (const t of e.tracks) {\n        t.notes.length > 0 && (o += 1);\n\n        for (const e of t.notes) {\n          const n = e.time,\n                a = n + e.duration;\n          r.notes.push(P.a.Note.create({\n            instrument: o,\n            program: t.instrumentNumber,\n            startTime: n,\n            endTime: a,\n            pitch: e.midi,\n            velocity: Math.floor(e.velocity * i.MIDI_VELOCITIES),\n            isDrum: t.isPercussion\n          })), a > r.totalTime && (r.totalTime = a);\n        }\n      }\n\n      return r;\n    }\n\n    function M(t) {\n      c.isQuantizedSequence(t) && (t = c.unquantizeSequence(t));\n\n      const e = t => 0 === t || void 0 === t;\n\n      if (t.tempos && 0 !== t.tempos.length || (t.tempos = [{\n        time: 0,\n        qpm: i.DEFAULT_QUARTERS_PER_MINUTE\n      }]), t.timeSignatures && 0 !== t.timeSignatures.length || (t.timeSignatures = [{\n        time: 0,\n        numerator: 4,\n        denominator: 4\n      }]), 1 !== t.tempos.length || !e(t.tempos[0].time)) throw new R(\"NoteSequence must have exactly 1 tempo at time 0\");\n      if (1 !== t.timeSignatures.length || !e(t.timeSignatures[0].time)) throw new R(\"NoteSequence must have exactly 1 time signature at time 0\");\n      const n = {\n        header: {\n          bpm: t.tempos[0].qpm,\n          PPQ: t.ticksPerQuarter ? t.ticksPerQuarter : i.DEFAULT_TICKS_PER_QUARTER,\n          timeSignature: [t.timeSignatures[0].numerator, t.timeSignatures[0].denominator]\n        },\n        tracks: []\n      },\n            r = new Map();\n\n      for (const e of t.notes) {\n        const t = e.instrument ? e.instrument : 0;\n        r.has(t) || r.set(t, []), r.get(t).push(e);\n      }\n\n      const o = Array.from(r.keys()).sort((t, e) => t - e);\n\n      for (let t = 0; t < o.length; t++) {\n        if (t !== o[t]) throw new R(\"Instrument list must be continuous and start at 0\");\n        const e = r.get(t),\n              a = {\n          id: t,\n          notes: [],\n          isPercussion: void 0 !== e[0].isDrum && e[0].isDrum,\n          channelNumber: e[0].isDrum ? i.DRUM_CHANNEL : i.DEFAULT_CHANNEL,\n          instrumentNumber: void 0 === e[0].program ? i.DEFAULT_PROGRAM : e[0].program\n        };\n        a.notes = e.map(t => {\n          const e = void 0 === t.velocity ? i.DEFAULT_VELOCITY : t.velocity;\n          return {\n            midi: t.pitch,\n            time: t.startTime,\n            duration: t.endTime - t.startTime,\n            velocity: (e + 1) / i.MIDI_VELOCITIES\n          };\n        }), n.tracks.push(a);\n      }\n\n      return new Uint8Array(function (t) {\n        return N.fromJSON(t);\n      }(n).toArray());\n    }\n\n    function O(t) {\n      return new Promise((e, n) => {\n        fetch(t).then(t => t.blob()).then(t => {\n          e(t);\n        }).catch(t => n(t));\n      });\n    }\n\n    function D(t) {\n      return new Promise((e, n) => {\n        const r = new FileReader();\n        r.onload = t => {\n          try {\n            const t = _(r.result);\n\n            e(t);\n          } catch (t) {\n            n(t);\n          }\n        }, r.onerror = t => n(t), r.readAsBinaryString(t);\n      });\n    }\n\n    function F(t) {\n      return O(t).then(D);\n    }\n\n    class L {\n      constructor(t) {\n        this.FADE_SECONDS = .1, this.baseURL = t, this.buffers = new l.Buffers([]), this.sourceMap = new Map(), this.initialized = !1;\n      }\n\n      async initialize() {\n        await fetch(\"\".concat(this.baseURL, \"/instrument.json\")).then(t => t.json()).then(t => {\n          this.name = t.name, this.minPitch = t.minPitch, this.maxPitch = t.maxPitch, this.durationSeconds = t.durationSeconds, this.releaseSeconds = t.releaseSeconds, this.percussive = t.percussive, this.velocities = t.velocities, this.initialized = !0;\n        });\n      }\n\n      sampleInfoToName(t) {\n        return this.velocities ? \"p\".concat(t.pitch, \"_v\").concat(t.velocity) : \"p\".concat(t.pitch);\n      }\n\n      sampleNameToURL(t) {\n        return \"\".concat(this.baseURL, \"/\").concat(t, \".mp3\");\n      }\n\n      nearestVelocity(t) {\n        if (!this.velocities) return t;\n        t || (t = i.DEFAULT_VELOCITY);\n        let e = void 0,\n            n = i.MIDI_VELOCITIES;\n        return this.velocities.forEach(r => {\n          const o = Math.abs(r - t);\n          o < n && (e = r, n = o);\n        }), e;\n      }\n\n      async loadSamples(t) {\n        this.initialized || (await this.initialize());\n        const e = t.filter(t => !(t.pitch < this.minPitch || t.pitch > this.maxPitch) || (s.log(\"Pitch \".concat(t.pitch, \" is outside the valid range for \").concat(this.name, \", ignoring.\"), \"SoundFont\"), !1)).map(t => this.sampleInfoToName({\n          pitch: t.pitch,\n          velocity: this.nearestVelocity(t.velocity)\n        })),\n              n = Array.from(new Set(e)).filter(t => !this.buffers.has(t)).map(t => ({\n          name: t,\n          url: this.sampleNameToURL(t)\n        }));\n        n.length > 0 && (n.forEach(t => this.buffers.add(t.name, t.url)), await new Promise(t => l.Buffer.on(\"load\", t)), s.log(\"Loaded samples for \".concat(this.name, \".\"), \"SoundFont\"));\n      }\n\n      playNote(t, e, n, r, o) {\n        const i = this.getBuffer(t, e);\n        r > this.durationSeconds && s.log(\"Requested note duration longer than sample duration: \".concat(r, \" > \").concat(this.durationSeconds), \"SoundFont\");\n        const a = new l.BufferSource({\n          buffer: i,\n          fadeOut: this.FADE_SECONDS\n        }).connect(o);\n\n        if (a.start(n, 0, void 0, 1, 0), !this.percussive && r < this.durationSeconds) {\n          const t = new l.BufferSource(i).connect(o);\n          a.stop(n + r + this.FADE_SECONDS), t.start(n + r, this.durationSeconds, void 0, 1, this.FADE_SECONDS);\n        }\n      }\n\n      playNoteDown(t, e, n) {\n        const r = this.getBuffer(t, e),\n              o = new l.BufferSource(r).connect(n);\n        o.start(0, 0, void 0, 1, 0), this.sourceMap.has(t) && this.sourceMap.get(t).stop(l.now() + this.FADE_SECONDS, this.FADE_SECONDS), this.sourceMap.set(t, o);\n      }\n\n      playNoteUp(t, e, n) {\n        if (!this.sourceMap.has(t)) return;\n        const r = this.getBuffer(t, e);\n        new l.BufferSource(r).connect(n).start(0, this.durationSeconds, void 0, 1, this.FADE_SECONDS), this.sourceMap.get(t).stop(l.now() + this.FADE_SECONDS, this.FADE_SECONDS), this.sourceMap.delete(t);\n      }\n\n      getBuffer(t, e) {\n        if (!this.initialized) throw new Error(\"Instrument is not initialized.\");\n        if (t < this.minPitch || t > this.maxPitch) return void s.log(\"Pitch \".concat(t, \" is outside the valid range for \").concat(this.name, \" (\").concat(this.minPitch, \"-\").concat(this.maxPitch, \")\"), \"SoundFont\");\n        const n = this.sampleInfoToName({\n          pitch: t,\n          velocity: this.nearestVelocity(e)\n        });\n        if (!this.buffers.has(n)) throw new Error(\"Buffer not found for \".concat(this.name, \": \").concat(n));\n        const r = this.buffers.get(n);\n        if (!r.loaded) throw new Error(\"Buffer not loaded for \".concat(this.name, \": \").concat(n));\n        return r;\n      }\n\n    }\n\n    class B {\n      constructor(t) {\n        this.baseURL = t, this.instruments = new Map(), this.initialized = !1;\n      }\n\n      async initialize() {\n        await fetch(\"\".concat(this.baseURL, \"/soundfont.json\")).then(t => t.json()).then(t => {\n          this.name = t.name;\n\n          for (const e in t.instruments) {\n            const n = \"\".concat(this.baseURL, \"/\").concat(t.instruments[e]);\n            this.instruments.set(\"drums\" === e ? \"drums\" : +e, new L(n));\n          }\n\n          this.initialized = !0;\n        });\n      }\n\n      async loadSamples(t) {\n        this.initialized || (await this.initialize());\n        const e = new Map();\n        t.forEach(t => {\n          t.isDrum = t.isDrum || !1, t.program = t.program || 0;\n          const n = t.isDrum ? \"drums\" : t.program,\n                r = {\n            pitch: t.pitch,\n            velocity: t.velocity\n          };\n          e.has(n) ? e.get(n).push(r) : this.instruments.has(n) ? e.set(n, [r]) : s.log(\"No instrument in \".concat(this.name, \" for: program=\").concat(t.program, \", isDrum=\").concat(t.isDrum), \"SoundFont\");\n        }), await Promise.all(Array.from(e.keys()).map(t => this.instruments.get(t).loadSamples(e.get(t))));\n      }\n\n      playNote(t, e, n, r, o = 0, i = !1, a) {\n        const u = i ? \"drums\" : o;\n        if (!this.initialized) throw new Error(\"SoundFont is not initialized.\");\n        this.instruments.has(u) ? this.instruments.get(u).playNote(t, e, n, r, a) : s.log(\"No instrument in \".concat(this.name, \" for: program=\").concat(o, \", isDrum=\").concat(i), \"SoundFont\");\n      }\n\n      playNoteDown(t, e, n = 0, r = !1, o) {\n        const i = r ? \"drums\" : n;\n        if (!this.initialized) throw new Error(\"SoundFont is not initialized.\");\n        this.instruments.has(i) ? this.instruments.get(i).playNoteDown(t, e, o) : s.log(\"No instrument in \".concat(this.name, \" for: program=\").concat(n, \", isDrum=\").concat(r), \"SoundFont\");\n      }\n\n      playNoteUp(t, e, n = 0, r = !1, o) {\n        const i = r ? \"drums\" : n;\n        if (!this.initialized) throw new Error(\"SoundFont is not initialized.\");\n        this.instruments.has(i) ? this.instruments.get(i).playNoteUp(t, e, o) : s.log(\"No instrument in \".concat(this.name, \" for: program=\").concat(n, \", isDrum=\").concat(r), \"SoundFont\");\n      }\n\n    }\n\n    function z(t, e) {\n      return t.quantizedStartStep < e.quantizedStartStep ? -1 : t.quantizedStartStep > e.quantizedStartStep ? 1 : t.pitch < e.pitch ? -1 : 1;\n    }\n\n    class q {}\n\n    class V {\n      constructor(t = !1, e) {\n        this.playClick = t, this.callbackObject = e, this.desiredQPM = void 0;\n      }\n\n      setTempo(t) {\n        this.desiredQPM = t, \"started\" === l.Transport.state && (l.Transport.bpm.value = t);\n      }\n\n      makeClickSequence(t) {\n        const e = c.clone(t),\n              n = e.notes.map(t => t.quantizedEndStep),\n              r = Math.max(...n);\n\n        for (let t = 0; t < r; t += 4) {\n          const n = {\n            pitch: t % 16 == 0 ? i.LO_CLICK_PITCH : i.HI_CLICK_PITCH,\n            quantizedStartStep: t,\n            isDrum: !0,\n            quantizedEndStep: t + 1\n          };\n          e.notes.push(n);\n        }\n\n        return e.notes.sort(z), e;\n      }\n\n      resumeContext() {\n        l.context.resume();\n      }\n\n      start(t, e) {\n        this.resumeContext();\n        const n = c.isQuantizedSequence(t);\n        if (this.playClick && n && (t = this.makeClickSequence(t)), e ? l.Transport.bpm.value = e : t.tempos && t.tempos.length > 0 && t.tempos[0].qpm > 0 ? l.Transport.bpm.value = t.tempos[0].qpm : l.Transport.bpm.value = i.DEFAULT_QUARTERS_PER_MINUTE, n) t = c.unquantizeSequence(t, e);else if (e) throw new Error(\"Cannot specify a `qpm` for a non-quantized sequence.\");\n        return this.currentPart = new l.Part((t, e) => {\n          (this.playClick || e.pitch !== i.LO_CLICK_PITCH && e.pitch !== i.HI_CLICK_PITCH) && this.playNote(t, e), this.callbackObject && l.Draw.schedule(() => {\n            this.callbackObject.run(e, t);\n          }, t);\n        }, t.notes.map(t => [t.startTime, t])), this.desiredQPM && (l.Transport.bpm.value = this.desiredQPM), this.currentPart.start(), \"started\" !== l.Transport.state && l.Transport.start(), new Promise(e => {\n          this.scheduledStop = l.Transport.schedule(() => {\n            this.stop(), e(), this.callbackObject && this.callbackObject.stop();\n          }, \"+\".concat(t.totalTime));\n        });\n      }\n\n      stop() {\n        this.currentPart && (this.currentPart.stop(), l.Transport.stop(), this.currentPart = null), l.Transport.clear(this.scheduledStop), this.scheduledStop = void 0, this.desiredQPM = void 0;\n      }\n\n      pause() {\n        l.Transport.pause();\n      }\n\n      resume() {\n        l.Transport.start();\n      }\n\n      isPlaying() {\n        return !!this.currentPart;\n      }\n\n      getPlayState() {\n        return l.Transport.state;\n      }\n\n    }\n\n    class U {\n      constructor() {\n        this.DRUM_PITCH_TO_CLASS = new Map(), this.kick = new l.MembraneSynth().toMaster(), this.tomLow = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .01,\n            decay: .5,\n            sustain: 0\n          }\n        }).toMaster(), this.tomMid = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .01,\n            decay: .5,\n            sustain: 0\n          }\n        }).toMaster(), this.tomHigh = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .01,\n            decay: .5,\n            sustain: 0\n          }\n        }).toMaster(), this.closedHihat = new l.MetalSynth({\n          frequency: 400,\n          envelope: {\n            attack: .001,\n            decay: .1,\n            release: .8\n          },\n          harmonicity: 5.1,\n          modulationIndex: 32,\n          resonance: 4e3,\n          octaves: 1\n        }).toMaster(), this.openHihat = new l.MetalSynth({\n          frequency: 400,\n          envelope: {\n            attack: .001,\n            decay: .5,\n            release: .8,\n            sustain: 1\n          },\n          harmonicity: 5.1,\n          modulationIndex: 32,\n          resonance: 4e3,\n          octaves: 1\n        }).toMaster(), this.ride = new l.MetalSynth().toMaster(), this.crash = new l.MetalSynth({\n          frequency: 300,\n          envelope: {\n            attack: .001,\n            decay: 1,\n            release: 3\n          },\n          harmonicity: 5.1,\n          modulationIndex: 64,\n          resonance: 4e3,\n          octaves: 1.5\n        }).toMaster(), this.snare = new l.NoiseSynth({\n          noise: {\n            type: \"white\"\n          },\n          envelope: {\n            attack: .005,\n            decay: .05,\n            sustain: .1,\n            release: .4\n          }\n        }).toMaster(), this.loClick = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.hiClick = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.pitchPlayers = [(t, e = 1) => this.kick.triggerAttackRelease(\"C2\", \"8n\", t, e), (t, e = 1) => this.snare.triggerAttackRelease(\"16n\", t, e), (t, e = 1) => this.closedHihat.triggerAttack(t, .3, e), (t, e = 1) => this.openHihat.triggerAttack(t, .3, e), (t, e = .5) => this.tomLow.triggerAttack(\"G3\", t, e), (t, e = .5) => this.tomMid.triggerAttack(\"C4\", t, e), (t, e = .5) => this.tomHigh.triggerAttack(\"F4\", t, e), (t, e = 1) => this.crash.triggerAttack(t, 1, e), (t, e = 1) => this.ride.triggerAttack(t, .5, e), (t, e = .5) => this.loClick.triggerAttack(\"G5\", t, e), (t, e = .5) => this.hiClick.triggerAttack(\"C6\", t, e)];\n\n        for (let t = 0; t < a.DEFAULT_DRUM_PITCH_CLASSES.length; ++t) a.DEFAULT_DRUM_PITCH_CLASSES[t].forEach(e => {\n          this.DRUM_PITCH_TO_CLASS.set(e, t);\n        });\n\n        this.DRUM_PITCH_TO_CLASS.set(i.LO_CLICK_PITCH, i.LO_CLICK_CLASS), this.DRUM_PITCH_TO_CLASS.set(i.HI_CLICK_PITCH, i.HI_CLICK_CLASS);\n      }\n\n      static getInstance() {\n        return U.instance || (U.instance = new U()), U.instance;\n      }\n\n      playNote(t, e, n) {\n        this.pitchPlayers[this.DRUM_PITCH_TO_CLASS.get(t)](e, n);\n      }\n\n    }\n\n    class j extends V {\n      constructor() {\n        super(...arguments), this.drumKit = U.getInstance(), this.bassSynth = new l.Synth({\n          volume: 5,\n          oscillator: {\n            type: \"triangle\"\n          }\n        }).toMaster(), this.polySynth = new l.PolySynth(10).toMaster();\n      }\n\n      playNote(t, e) {\n        const n = e.hasOwnProperty(\"velocity\") ? e.velocity / i.MAX_MIDI_VELOCITY : void 0;\n        if (e.isDrum) this.drumKit.playNote(e.pitch, t, n);else {\n          const r = new l.Frequency(e.pitch, \"midi\"),\n                o = e.endTime - e.startTime;\n          this.getSynth(e.instrument, e.program).triggerAttackRelease(r, o, t, n);\n        }\n      }\n\n      getSynth(t, e) {\n        return void 0 !== e && e >= 32 && e <= 39 ? this.bassSynth : this.polySynth;\n      }\n\n    }\n\n    j.tone = l;\n\n    class W extends V {\n      constructor(t, e = l.Master, n, r, o) {\n        super(!1, o), this.soundFont = new B(t), this.output = e, this.programOutputs = n, this.drumOutputs = r;\n      }\n\n      async loadSamples(t) {\n        await this.soundFont.loadSamples(t.notes.map(t => ({\n          pitch: t.pitch,\n          velocity: t.velocity,\n          program: t.program || 0,\n          isDrum: t.isDrum || !1\n        })));\n      }\n\n      async loadAllSamples(t = 0, e = !1) {\n        const n = P.a.create(),\n              r = e ? i.MIN_DRUM_PITCH : i.MIN_PIANO_PITCH,\n              o = e ? i.MAX_DRUM_PITCH : i.MAX_PIANO_PITCH;\n\n        for (let a = r; a <= o; a++) for (let r = i.MIN_MIDI_VELOCITY; r < i.MAX_MIDI_VELOCITY; r++) n.notes.push({\n          pitch: a,\n          velocity: r,\n          program: t,\n          isDrum: e\n        });\n\n        return this.loadSamples(n);\n      }\n\n      resumeContext() {\n        l.context.resume();\n      }\n\n      start(t, e) {\n        return this.resumeContext(), this.loadSamples(t).then(() => super.start(t, e));\n      }\n\n      playNote(t, e) {\n        this.soundFont.playNote(e.pitch, e.velocity, t, e.endTime - e.startTime, e.program, e.isDrum, this.getAudioNodeOutput(e));\n      }\n\n      playNoteDown(t) {\n        this.soundFont.playNoteDown(t.pitch, t.velocity, t.program, t.isDrum, this.getAudioNodeOutput(t));\n      }\n\n      playNoteUp(t) {\n        this.soundFont.playNoteUp(t.pitch, t.velocity, t.program, t.isDrum, this.getAudioNodeOutput(t));\n      }\n\n      getAudioNodeOutput(t) {\n        let e = this.output;\n        return this.programOutputs && !t.isDrum ? this.programOutputs.has(t.program) && (e = this.programOutputs.get(t.program)) : this.drumOutputs && t.isDrum && this.drumOutputs.has(t.pitch) && (e = this.drumOutputs.get(t.pitch)), e;\n      }\n\n    }\n\n    class G extends j {\n      constructor(t) {\n        super(!0, t);\n      }\n\n    }\n\n    class H extends V {\n      constructor(t) {\n        super(!1, t), this.outputs = [], this.outputChannel = 0, this.availableOutputs = [], this.NOTE_ON = 144, this.NOTE_OFF = 128;\n      }\n\n      async requestMIDIAccess() {\n        return navigator.requestMIDIAccess ? new Promise((t, e) => {\n          navigator.requestMIDIAccess().then(e => {\n            e.addEventListener(\"statechange\", t => this.initOutputs(e)), t(this.initOutputs(e));\n          }, t => console.log(\"Something went wrong\", e(t)));\n        }) : null;\n      }\n\n      initOutputs(t) {\n        const e = t.outputs.values();\n\n        for (let t = e.next(); t && !t.done; t = e.next()) this.availableOutputs.push(t.value);\n\n        return this.availableOutputs;\n      }\n\n      playNote(t, e) {\n        const n = e.velocity || 100,\n              r = 1e3 * (e.endTime - e.startTime),\n              o = [this.NOTE_ON + this.outputChannel, e.pitch, n],\n              i = [this.NOTE_OFF + this.outputChannel, e.pitch, n],\n              a = this.outputs ? this.outputs : this.availableOutputs;\n\n        for (let t = 0; t < a.length; t++) this.sendMessageToOutput(a[t], o), this.sendMessageToOutput(a[t], i, window.performance.now() + r);\n      }\n\n      sendMessageToOutput(t, e, n) {\n        t && t.send(e, n);\n      }\n\n      playNoteDown(t) {\n        const e = [this.NOTE_ON, t.pitch, t.velocity],\n              n = this.outputs ? this.outputs : this.availableOutputs;\n\n        for (let t = 0; t < n.length; t++) this.sendMessageToOutput(n[t], e);\n      }\n\n      playNoteUp(t) {\n        const e = [this.NOTE_OFF, t.pitch, t.velocity],\n              n = this.outputs ? this.outputs : this.availableOutputs;\n\n        for (let r = 0; r < n.length; r++) this.sendMessageToOutput(n[r], e, t.endTime - t.startTime);\n      }\n\n    }\n\n    class $ {}\n\n    class K {\n      constructor(t = {}, e) {\n        this.notes = [], this.midiInputs = [], this.loClick = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.hiClick = new l.MembraneSynth({\n          pitchDecay: .008,\n          envelope: {\n            attack: .001,\n            decay: .3,\n            sustain: 0\n          }\n        }).toMaster(), this.config = {\n          playClick: t.playClick,\n          qpm: t.qpm || i.DEFAULT_QUARTERS_PER_MINUTE,\n          playCountIn: t.playCountIn,\n          startRecordingAtFirstNote: t.startRecordingAtFirstNote || !1\n        }, this.callbackObject = e, this.recording = !1, this.onNotes = new Map();\n      }\n\n      async initialize() {\n        await navigator.requestMIDIAccess().then(t => this.midiReady(t), t => console.log(\"Something went wrong\", t));\n      }\n\n      midiReady(t) {\n        s.log(\"Initialized Recorder\", \"Recorder\");\n        const e = t.inputs.values();\n\n        for (let t = e.next(); t && !t.done; t = e.next()) this.midiInputs.push(t.value);\n      }\n\n      isRecording() {\n        return this.recording;\n      }\n\n      setTempo(t) {\n        this.config.qpm = t, \"started\" === l.Transport.state && (l.Transport.bpm.value = t);\n      }\n\n      enablePlayClick(t) {\n        this.config.playClick = t;\n      }\n\n      enablePlayCountIn(t) {\n        this.config.playCountIn = t;\n      }\n\n      initClickLoop() {\n        let t = 0;\n        this.clickLoop = new l.Loop(e => {\n          t % 4 == 0 ? this.loClick.triggerAttack(\"G5\", e) : this.hiClick.triggerAttack(\"C6\", e), t++, this.config.playCountIn && 4 === t && (l.Transport.stop(), this.clickLoop.stop());\n        }, \"4n\");\n      }\n\n      getMIDIInputs() {\n        return this.midiInputs;\n      }\n\n      start(t) {\n        const e = t || this.midiInputs;\n\n        for (const t of e) t.onmidimessage = t => {\n          this.midiMessageReceived(t);\n        };\n\n        if (this.config.playClick || this.config.playCountIn ? (this.initClickLoop(), l.Transport.bpm.value = this.config.qpm, l.Transport.start(), this.clickLoop.start()) : this.clickLoop = null, this.recording = !0, this.firstNoteTimestamp = void 0, this.notes = [], this.onNotes = new Map(), !this.startRecordingAtFirstNote) {\n          const t = Date.now();\n          this.firstNoteTimestamp = t;\n        }\n      }\n\n      stop() {\n        this.recording = !1;\n        const t = Date.now();\n        this.onNotes.forEach((e, n) => {\n          this.noteOff(n, t);\n        });\n\n        for (const t of this.midiInputs) t.onmidimessage = null;\n\n        return this.clickLoop && (l.Transport.stop(), this.clickLoop.stop()), 0 === this.notes.length ? null : this.getNoteSequence();\n      }\n\n      getNoteSequence() {\n        return 0 === this.notes.length ? null : P.a.create({\n          notes: this.notes,\n          totalTime: this.notes[this.notes.length - 1].endTime\n        });\n      }\n\n      reset() {\n        const t = this.stop();\n        return this.firstNoteTimestamp = void 0, this.notes = [], this.onNotes = new Map(), t;\n      }\n\n      midiMessageReceived(t) {\n        if (!this.recording) return;\n        let e;\n        const n = (e = void 0 !== t.timeStamp && 0 !== t.timeStamp ? t.timeStamp : performance.now()) + performance.timing.navigationStart;\n        void 0 === this.firstNoteTimestamp && (this.firstNoteTimestamp = n);\n        const r = t.data[0] >> 4,\n              o = t.data[1],\n              i = t.data.length > 2 ? t.data[2] : 1,\n              a = t.srcElement;\n        8 === r || 9 === r && 0 === i ? (this.callbackObject && this.callbackObject.noteOff && this.callbackObject.noteOff(o, i, a), this.noteOff(o, n), this.callbackObject && this.callbackObject.run && this.callbackObject.run(this.getNoteSequence())) : 9 === r && (this.callbackObject && this.callbackObject.noteOn && this.callbackObject.noteOn(o, i, a), this.noteOn(o, i, n));\n      }\n\n      noteOn(t, e, n) {\n        const r = new P.a.Note();\n        r.pitch = t, r.startTime = (n - this.firstNoteTimestamp) / 1e3, r.velocity = e, this.onNotes.set(t, r);\n      }\n\n      noteOff(t, e) {\n        const n = this.onNotes.get(t);\n        n && (n.endTime = (e - this.firstNoteTimestamp) / 1e3, this.notes.push(n)), this.onNotes.delete(t);\n      }\n\n    }\n\n    var Q,\n        X = n(49);\n\n    class Y {\n      constructor(t, e = {}) {\n        this.noteSequence = t, this.sequenceIsQuantized = c.isQuantizedSequence(this.noteSequence);\n\n        if (this.config = {\n          noteHeight: e.noteHeight || 6,\n          noteSpacing: e.noteSpacing || 1,\n          pixelsPerTimeStep: e.pixelsPerTimeStep || 30,\n          noteRGB: e.noteRGB || \"8, 41, 64\",\n          activeNoteRGB: e.activeNoteRGB || \"240, 84, 119\",\n          minPitch: e.minPitch,\n          maxPitch: e.maxPitch\n        }, this.sequenceIsQuantized) {\n          const e = t.quantizationInfo.stepsPerQuarter;\n          this.config.pixelsPerTimeStep = e ? this.config.pixelsPerTimeStep / e : 7;\n        }\n\n        const n = this.getSize();\n        this.width = n.width, this.height = n.height;\n      }\n\n      getSize() {\n        if (void 0 === this.config.minPitch || void 0 === this.config.maxPitch) {\n          this.config.minPitch = i.MAX_MIDI_PITCH, this.config.maxPitch = i.MIN_MIDI_PITCH;\n\n          for (const t of this.noteSequence.notes) this.config.minPitch = Math.min(t.pitch, this.config.minPitch), this.config.maxPitch = Math.max(t.pitch, this.config.maxPitch);\n\n          this.config.minPitch -= 2, this.config.maxPitch += 2;\n        }\n\n        const t = (this.config.maxPitch - this.config.minPitch) * this.config.noteHeight,\n              e = this.sequenceIsQuantized ? this.noteSequence.totalQuantizedSteps : this.noteSequence.totalTime;\n        if (!e) throw new Error(\"The sequence you are using with the mm.PianoRollSVGVisualizer does not have a \" + (this.sequenceIsQuantized ? \"totalQuantizedSteps\" : \"totalTime\") + \" field set, so the visualizer can't be horizontally sized correctly.\");\n        return {\n          width: e * this.config.pixelsPerTimeStep,\n          height: t\n        };\n      }\n\n      getNotePosition(t, e) {\n        const n = this.getNoteStartTime(t) * this.config.pixelsPerTimeStep,\n              r = this.config.pixelsPerTimeStep * (this.getNoteEndTime(t) - this.getNoteStartTime(t)) - this.config.noteSpacing;\n        return {\n          x: n,\n          y: this.height - (t.pitch - this.config.minPitch) * this.config.noteHeight,\n          w: r,\n          h: this.config.noteHeight\n        };\n      }\n\n      scrollIntoViewIfNeeded(t, e) {\n        if (t && this.parentElement) {\n          const t = this.parentElement.getBoundingClientRect().width;\n          e > this.parentElement.scrollLeft + t && (this.parentElement.scrollLeft = e - 20);\n        }\n      }\n\n      getNoteStartTime(t) {\n        return this.sequenceIsQuantized ? t.quantizedStartStep : Math.round(1e8 * t.startTime) / 1e8;\n      }\n\n      getNoteEndTime(t) {\n        return this.sequenceIsQuantized ? t.quantizedEndStep : Math.round(1e8 * t.endTime) / 1e8;\n      }\n\n      isPaintingActiveNote(t, e) {\n        const n = this.getNoteStartTime(t) === this.getNoteStartTime(e),\n              r = this.getNoteStartTime(t) <= this.getNoteStartTime(e) && this.getNoteEndTime(t) >= this.getNoteEndTime(e);\n        return n || r;\n      }\n\n    }\n\n    class J extends Y {\n      constructor(t, e, n = {}) {\n        super(t, n), this.ctx = e.getContext(\"2d\"), this.parentElement = e.parentElement;\n        const r = window.devicePixelRatio || 1;\n        this.ctx && (this.ctx.canvas.width = r * this.width, this.ctx.canvas.height = r * this.height, e.style.width = \"\".concat(this.width, \"px\"), e.style.height = \"\".concat(this.height, \"px\"), this.ctx.scale(r, r)), this.redraw();\n      }\n\n      redraw(t, e) {\n        let n;\n        this.clear();\n\n        for (let e = 0; e < this.noteSequence.notes.length; e++) {\n          const r = this.noteSequence.notes[e],\n                o = this.getNotePosition(r, e),\n                i = .2,\n                a = r.velocity ? r.velocity / 100 + i : 1,\n                s = t && this.isPaintingActiveNote(r, t),\n                u = \"rgba(\".concat(s ? this.config.activeNoteRGB : this.config.noteRGB, \",\\n  \").concat(a, \")\");\n          this.redrawNote(o.x, o.y, o.w, o.h, u), s && r === t && (n = o.x);\n        }\n\n        return this.scrollIntoViewIfNeeded(e, n), n;\n      }\n\n      clear() {\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n      }\n\n      redrawNote(t, e, n, r, o) {\n        this.ctx.fillStyle = o, this.ctx.fillRect(Math.round(t), Math.round(e), Math.round(n), Math.round(r));\n      }\n\n    }\n\n    class Z extends J {\n      constructor(t, e, n = {}) {\n        super(t, e, n), s.log(\"mm.Visualizer is deprecated, and will be removed in a future          version. Please use mm.PianoRollCanvasVisualizer instead\", \"mm.Visualizer\", 5);\n      }\n\n    }\n\n    class tt extends Y {\n      constructor(t, e, n = {}) {\n        if (super(t, n), !(e instanceof SVGSVGElement)) throw new Error(\"mm.PianoRollSVGVisualizer requires an <svg> element to display the visualization\");\n        this.svg = e, this.parentElement = e.parentElement, this.drawn = !1, this.svg.style.width = \"\".concat(this.width, \"px\"), this.svg.style.height = \"\".concat(this.height, \"px\"), this.clear(), this.draw();\n      }\n\n      redraw(t, e) {\n        if (this.drawn || this.draw(), !t) return null;\n        const n = this.svg.querySelectorAll(\"rect.active\");\n\n        for (let t = 0; t < n.length; ++t) {\n          const e = n[t],\n                r = this.getNoteFillColor(this.noteSequence.notes[parseInt(e.getAttribute(\"data-index\"), 10)], !1);\n          e.setAttribute(\"fill\", r), e.removeAttribute(\"class\");\n        }\n\n        let r;\n\n        for (let e = 0; e < this.noteSequence.notes.length; e++) {\n          const n = this.noteSequence.notes[e];\n          if (!(t && this.isPaintingActiveNote(n, t))) continue;\n          const o = this.svg.querySelector(\"rect[data-index=\\\"\".concat(e, \"\\\"]\")),\n                i = this.getNoteFillColor(n, !0);\n          o.setAttribute(\"fill\", i), o.setAttribute(\"class\", \"active\"), n === t && (r = parseFloat(o.getAttribute(\"x\")));\n        }\n\n        return this.scrollIntoViewIfNeeded(e, r), r;\n      }\n\n      draw() {\n        for (let t = 0; t < this.noteSequence.notes.length; t++) {\n          const e = this.noteSequence.notes[t],\n                n = this.getNotePosition(e, t),\n                r = this.getNoteFillColor(e, !1);\n          this.drawNote(n.x, n.y, n.w, n.h, r, t);\n        }\n\n        this.drawn = !0;\n      }\n\n      getNoteFillColor(t, e) {\n        const n = t.velocity ? t.velocity / 100 + .2 : 1;\n        return \"rgba(\".concat(e ? this.config.activeNoteRGB : this.config.noteRGB, \",\\n  \").concat(n, \")\");\n      }\n\n      drawNote(t, e, n, r, o, i) {\n        if (!this.svg) return;\n        const a = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n        a.setAttribute(\"fill\", o), a.setAttribute(\"x\", \"\".concat(Math.round(t))), a.setAttribute(\"y\", \"\".concat(Math.round(e))), a.setAttribute(\"width\", \"\".concat(Math.round(n))), a.setAttribute(\"height\", \"\".concat(Math.round(r))), a.setAttribute(\"data-index\", \"\".concat(i)), this.svg.appendChild(a);\n      }\n\n      clear() {\n        this.svg.innerHTML = \"\", this.drawn = !1;\n      }\n\n    }\n\n    !function (t) {\n      t[t.PAGE = 0] = \"PAGE\", t[t.NOTE = 1] = \"NOTE\", t[t.BAR = 2] = \"BAR\";\n    }(Q || (Q = {}));\n\n    class et extends Y {\n      constructor(t, e, n = {}) {\n        super(t, n), (void 0 === n.pixelsPerTimeStep || n.pixelsPerTimeStep <= 0) && (this.config.pixelsPerTimeStep = 0), this.instruments = n.instruments || [], this.render = new X.StaffSVGRender(this.getScoreInfo(t), {\n          noteHeight: this.config.noteHeight,\n          noteSpacing: this.config.noteSpacing,\n          pixelsPerTimeStep: this.config.pixelsPerTimeStep,\n          noteRGB: this.config.noteRGB,\n          activeNoteRGB: this.config.activeNoteRGB,\n          defaultKey: n.defaultKey || 0,\n          scrollType: n.scrollType || Q.PAGE\n        }, e), this.drawnNotes = t.notes.length, this.clear(), this.redraw();\n      }\n\n      clear() {\n        this.render.clear();\n      }\n\n      redraw(t, e) {\n        this.drawnNotes !== this.noteSequence.notes.length && (this.render.scoreInfo = this.getScoreInfo(this.noteSequence));\n        const n = t ? this.getNoteInfo(t) : void 0;\n        return this.render.redraw(n, e);\n      }\n\n      isNoteInInstruments(t) {\n        return void 0 === t.instrument || 0 === this.instruments.length || this.instruments.indexOf(t.instrument) >= 0;\n      }\n\n      timeToQuarters(t) {\n        const e = t * this.noteSequence.tempos[0].qpm / 60;\n        return Math.round(16 * e) / 16;\n      }\n\n      quantizedStepsToQuarters(t) {\n        const e = t / this.noteSequence.quantizationInfo.stepsPerQuarter;\n        return Math.round(16 * e) / 16;\n      }\n\n      getNoteInfo(t) {\n        const e = this.sequenceIsQuantized ? this.quantizedStepsToQuarters(t.quantizedStartStep) : this.timeToQuarters(t.startTime);\n        return {\n          start: e,\n          length: (this.sequenceIsQuantized ? this.quantizedStepsToQuarters(t.quantizedEndStep) : this.timeToQuarters(t.endTime)) - e,\n          pitch: t.pitch,\n          intensity: t.velocity\n        };\n      }\n\n      getScoreInfo(t) {\n        const e = [];\n        return t.notes.forEach(t => {\n          this.isNoteInInstruments(t) && e.push(this.getNoteInfo(t));\n        }), {\n          notes: e,\n          tempos: t.tempos ? t.tempos.map(t => ({\n            start: this.timeToQuarters(t.time),\n            qpm: t.qpm\n          })) : [],\n          keySignatures: t.keySignatures ? t.keySignatures.map(t => ({\n            start: this.timeToQuarters(t.time),\n            key: t.key\n          })) : [],\n          timeSignatures: t.timeSignatures ? t.timeSignatures.map(t => ({\n            start: this.timeToQuarters(t.time),\n            numerator: t.numerator,\n            denominator: t.denominator\n          })) : []\n        };\n      }\n\n    }\n\n    n.d(e, \"aux_inputs\", function () {\n      return r;\n    }), n.d(e, \"chords\", function () {\n      return o;\n    }), n.d(e, \"constants\", function () {\n      return i;\n    }), n.d(e, \"data\", function () {\n      return a;\n    }), n.d(e, \"logging\", function () {\n      return s;\n    }), n.d(e, \"performance\", function () {\n      return u;\n    }), n.d(e, \"sequences\", function () {\n      return c;\n    }), n.d(e, \"MetronomeCallbackObject\", function () {\n      return p;\n    }), n.d(e, \"Metronome\", function () {\n      return f;\n    }), n.d(e, \"MidiConversionError\", function () {\n      return R;\n    }), n.d(e, \"midiToSequenceProto\", function () {\n      return _;\n    }), n.d(e, \"sequenceProtoToMidi\", function () {\n      return M;\n    }), n.d(e, \"urlToBlob\", function () {\n      return O;\n    }), n.d(e, \"blobToNoteSequence\", function () {\n      return D;\n    }), n.d(e, \"urlToNoteSequence\", function () {\n      return F;\n    }), n.d(e, \"BasePlayerCallback\", function () {\n      return q;\n    }), n.d(e, \"BasePlayer\", function () {\n      return V;\n    }), n.d(e, \"Player\", function () {\n      return j;\n    }), n.d(e, \"SoundFontPlayer\", function () {\n      return W;\n    }), n.d(e, \"PlayerWithClick\", function () {\n      return G;\n    }), n.d(e, \"MIDIPlayer\", function () {\n      return H;\n    }), n.d(e, \"BaseRecorderCallback\", function () {\n      return $;\n    }), n.d(e, \"Recorder\", function () {\n      return K;\n    }), n.d(e, \"BaseVisualizer\", function () {\n      return Y;\n    }), n.d(e, \"PianoRollCanvasVisualizer\", function () {\n      return J;\n    }), n.d(e, \"Visualizer\", function () {\n      return Z;\n    }), n.d(e, \"PianoRollSVGVisualizer\", function () {\n      return tt;\n    }), n.d(e, \"ScrollType\", function () {\n      return Q;\n    }), n.d(e, \"StaffSVGVisualizer\", function () {\n      return et;\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(0),\n        o = n(5),\n        i = n(18),\n        a = n(9);\n    const s = .0661371661726,\n          u = .113718730221,\n          c = .8,\n          l = 0,\n          h = 16e3,\n          p = 64e3,\n          f = 512,\n          d = 2048,\n          m = [[1, 1, 1.0087615084725814], [2, 1, .029087889211125567], [2, 2, .958243896036208], [3, 2, .5326346877272624], [3, 3, .45988057223186607], [4, 3, 1.0072850129664943], [5, 4, 1.0050894259864507], [6, 4, .016233689242197466], [6, 5, .9763230964529687], [7, 5, .5149287456976357], [7, 6, .48299891928441196], [8, 6, 1.0020339883784544], [9, 7, 1.0013940582804204], [10, 7, .004285414445239434], [10, 8, .9936677765505681], [11, 8, .4979349533263788], [11, 9, .5020647178266697], [12, 9, .9896782321684733], [12, 10, .006967080931645349], [13, 10, 1.0022486641537054], [14, 11, 1.0033233953996759], [15, 11, .4782757843614299], [15, 12, .5183887055972138], [16, 12, .9736767011426267], [16, 13, .01804416217807709], [17, 13, 1.0056329663266226], [18, 14, 1.00808642668908], [19, 14, .4576416347984229], [19, 15, .5340800956534676], [20, 15, .9582897445862256], [20, 16, .028988367857957848], [21, 16, 1.008754652772106], [22, 17, 1.0122552436937966], [23, 17, .4380796830853842], [23, 18, .5491738237632201], [24, 18, .9434838949694413], [24, 19, .039794474296176746], [25, 19, 1.0116287566447584], [26, 20, 1.0158945544322868], [27, 20, .41952402212367873], [27, 21, .5637020154076856], [28, 21, .9292283399303117], [28, 22, .05045785324282485], [29, 22, 1.0142694870195312], [30, 23, 1.0190617246342517], [31, 23, .40191289323704393], [31, 24, .5776942788784806], [32, 24, .915494649120402], [32, 25, .060974426459003916], [33, 25, 1.016690283888679], [34, 26, 1.0218076651124588], [35, 26, .3851885348435194], [35, 27, .5911779611807773], [36, 27, .9022565352474414], [36, 28, .07134062388959171], [37, 28, 1.0189038677945517], [38, 29, 1.0241776077147466], [39, 29, .369297000124277], [39, 30, .6041783722578726], [40, 30, .8894896443111251], [40, 31, .08155334505527755], [41, 31, 1.0209222848386956], [42, 32, 1.0262117836546005], [43, 32, .35418795675261777], [43, 33, .6167189821271176], [44, 33, .87717137085618], [44, 34, .09160992335204851], [45, 34, 1.0227569476841007], [46, 35, 1.0279460165329002], [47, 35, .3398144781420294], [47, 36, .628821594757742], [48, 36, .8652806947525041], [48, 37, .10150809298528844], [49, 37, 1.0244186730654867], [50, 38, 1.029412240942602], [51, 38, .32613283297317347], [51, 39, .6405065019041107], [52, 39, .8537980365619783], [52, 40, .11124595830527892], [53, 40, 1.0259177162406141], [54, 41, 1.030638956235277], [55, 41, .3131022777355948], [55, 42, .6517926196031543], [56, 42, .8427051290118196], [56, 43, .12082196533877268], [57, 43, 1.0272638027474759], [58, 44, 1.031651623831845], [59, 44, .3006848555240512], [59, 45, .6626976096262132], [60, 45, .8319849024715039], [60, 46, .13023487533380312], [61, 46, 1.0284661577762764], [62, 47, 1.0324730153919173], [63, 47, .28884520321029805], [63, 48, .6732379878311283], [64, 48, .821621382643116], [64, 49, .1394837401591093], [65, 49, 1.0295335334192939], [66, 50, 1.0331235182054521], [67, 50, .27755036829985363], [67, 51, .68342922107227], [68, 51, .8115995989355603], [68, 52, .148567879414825], [69, 52, 1.0304742340231496], [70, 53, 1.0336214033370148], [71, 53, .2667696361817086], [71, 54, .6932858140884962], [72, 54, .8019055022130549], [72, 55, .1574868591255191], [73, 55, 1.031296139836255], [74, 56, 1.0339830613212895], [75, 56, .2564743680536822], [75, 57, .7028213875855097], [76, 57, .7925258907912134], [76, 58, .16624047189958738], [77, 58, 1.032006729117501], [78, 59, 1.0342232095724524], [79, 59, .24663784949713183], [79, 60, .7120487485622758], [80, 60, .7834483437084975], [80, 61, .17482871845079165], [81, 61, 1.032613098850059], [82, 62, 1.0343550751159198], [83, 62, .2372351494674972], [83, 63, .7209799537859948], [84, 63, .7746611604312031], [84, 64, .18325179038711914], [85, 64, 1.0331219841851924], [86, 65, 1.0343905557724016], [87, 65, .22824298931879333], [87, 66, .7296263672031092], [88, 66, .7661533062642226], [88, 67, .19151005417692718], [89, 67, 1.0335397767254908], [90, 68, 1.0343403625078313], [91, 68, .21963962139622123], [91, 69, .7379987119645334], [92, 69, .7579143628308538], [92, 70, .19960403621540457], [93, 70, 1.0338725417430177], [94, 71, 1.0342141453043734], [95, 71, .21140471667072153], [95, 72, .746107117663542], [96, 72, .7499344830670268], [96, 73, .20753440891552338], [97, 73, 1.0341260344172454], [98, 74, 1.034020604597683], [99, 74, .20351926086574523], [99, 75, .7539611633021215], [100, 75, .7422043502477234], [100, 76, .2153019777561019], [101, 76, 1.0343057151671131], [102, 77, 1.0337675900563705], [103, 77, .19596545852169872], [103, 78, .7615699164421695], [104, 78, .734715140616724], [104, 79, .22290766922455862], [105, 79, 1.034416764143981], [106, 80, 1.03346218824938], [107, 80, .1887266444456389], [107, 81, .7689419689404797], [108, 81, .7274584892496355], [108, 82, .23035251959385997], [109, 82, 1.0344640949448594], [110, 83, 1.0331108005456808], [111, 83, .18178720201436843], [111, 84, .7760854696185804], [112, 84, .7204264588178948], [112, 85, .23763766448199494], [113, 85, 1.0344523675990727], [114, 86, 1.032719212418228], [115, 86, .1751324878193402], [115, 87, .7830081541774375], [116, 87, .7136115109646374], [116, 88, .2447643291417676], [117, 88, 1.0343860008764458], [118, 89, 1.0322926551739824], [119, 89, .16874876216974247], [119, 90, .789717372631832], [120, 90, .7070064800338803], [120, 91, .2517338194331562], [121, 91, 1.0342691839607763], [122, 92, 1.0318358610025598], [123, 92, .16262312499771858], [123, 93, .7962201145052664], [124, 93, .7006045489251309], [124, 94, .25854751343650967], [125, 94, 1.0341058875275075], [126, 95, 1.0313531121234998], [127, 95, .15674345673841866], [127, 96, .8025230320033012], [128, 96, .6943992268713032], [128, 97, .2652068536620191], [129, 97, 1.033899874262366], [130, 98, 1.030848284714744], [131, 98, .1510983637896712], [131, 99, .8086324613545763], [132, 99, .6883843289574696], [132, 100, .2717133398209474], [133, 100, 1.033654708853177], [134, 101, 1.0303248882205327], [135, 101, .14567712818173575], [135, 102, .8145544424922615], [136, 102, .6825539572209546], [136, 103, .2780685221191216], [137, 103, 1.033373767485838], [138, 104, 1.0297861005632643], [139, 104, .14046966111762169], [139, 105, .8202947372282664], [140, 105, .6769024831869065], [140, 106, .28427399504058354], [141, 106, 1.0330602468722847], [142, 107, 1.029234799720434], [143, 107, .13546646006984392], [143, 108, .8258588460540109], [144, 108, .671424531713726], [144, 109, .290331391589362], [145, 109, 1.0327171728357682], [146, 110, 1.0286735920712562], [147, 110, .13065856914309196], [147, 111, .8312520236957351], [148, 111, .6661149660273628], [148, 112, .2962423779602388], [149, 112, 1.03234740847843], [150, 113, 1.0281048378703825], [151, 113, .12603754244145], [151, 114, .8364792935255917], [152, 114, .6609688738465388], [152, 115, .30200864860954885], [153, 115, 1.0319536619522978], [154, 116, 1.0275306741623285], [155, 116, .12159541018943322], [155, 117, .8415454609370665], [156, 117, .655981554500098], [156, 118, .3076319217011811], [157, 118, 1.031538493855763], [158, 119, 1.0269530354146845], [159, 119, .11732464738966399], [159, 120, .846455125764718], [160, 120, .6511485069565366], [160, 121, .3131139349019227], [161, 121, 1.0311043242739946], [162, 122, 1.0263736721146446], [163, 122, .11321814480714538], [163, 123, .851212693834753], [164, 123, .6464654186857061], [164, 124, .3184564415055735], [165, 124, 1.0306534394819706], [166, 125, 1.0257941675461106], [167, 125, .10926918209624069], [167, 126, .8558223877141483], [168, 126, .6419281552876014], [168, 127, .32366120686047056], [169, 127, 1.0301879983273805], [170, 128, 1.0252159529388847], [171, 128, .10547140289367021], [171, 129, .8602882567276612], [172, 129, .6375327508240597], [172, 130, .32873000508360367], [173, 130, 1.0297100383091813], [174, 131, 1.0246403211604227], [175, 131, .10181879172477112], [175, 132, .8646141862987496], [176, 132, .6332753987956673], [176, 133, .33366461604209907], [177, 133, 1.0292214813668379], [178, 134, 1.0240684391009978], [179, 134, .09830565257411007], [179, 135, .8688039066707689], [180, 135, .6291524437169539], [180, 136, .3384668225808326], [181, 136, 1.0287241393952773], [182, 137, 1.0235013588866442], [183, 137, .0949265889928822], [183, 138, .8728610010546515], [184, 138, .6251603732380943], [184, 139, .3431384079843332], [185, 139, 1.0282197194980238], [186, 140, 1.0229400280388043], [187, 140, .09167648561647405], [187, 141, .8767889132518744], [188, 141, .6212958107744541], [188, 142, .3476811536535296], [189, 142, 1.0277098289923983], [190, 143, 1.0223852986877378], [191, 143, .08855049098843445], [191, 144, .8805909547856343], [192, 144, .6175555086043407], [192, 145, .35209683698566024], [193, 145, 1.0271959801772084], [194, 146, 1.021837935933431], [195, 146, .08554400158179727], [195, 147, .8842703115872171], [196, 147, .6139363413989273], [196, 148, .35638722943949186], [197, 148, 1.026679594876984], [198, 149, 1.0212986254395027], [199, 149, .082652646931321], [199, 150, .8878300502607867], [200, 150, .6104353001536761], [200, 151, .3605540947783916], [201, 151, 1.0261620087703698], [202, 152, 1.020767980334856], [203, 152, .07987227578640096], [203, 153, .8912731239662092], [204, 153, .6070494864912312], [204, 154, .364599187472458], [205, 154, 1.025644475516362], [206, 155, 1.0202465474911722], [207, 155, .07719894321045902], [207, 156, .8946023779404728], [208, 156, .6037761073076129], [208, 157, .36852425125748506], [209, 157, 1.0251281706842847], [210, 158, 1.0197348132361097], [211, 158, .07462889855138014], [211, 159, .8978205546916732], [212, 159, .6006124697383151], [212, 160, .3723310178292769], [213, 160, 1.0246141955013988], [214, 161, 1.0192332085569418], [215, 161, .07215857422040488], [215, 162, .9009302988805], [216, 162, .5975559764226185], [216, 163, .37602120567284064], [217, 163, 1.024103580422386], [218, 164, 1.018742113842709], [219, 164, .06978457521665815], [219, 165, .9039341619174114], [220, 165, .5946041210439893], [220, 166, .3795965190111676], [221, 166, 1.0235972885322195], [222, 167, 1.0182618632088625], [223, 167, .0675036693443592], [223, 168, .9068346062921914], [224, 168, .5917544841265701], [224, 169, .3830586468674795], [225, 169, 1.0230962187892327], [226, 170, 1.0177927484431766], [227, 170, .06531277806896706], [227, 171, .9096340096561174], [228, 171, .5890047290713193], [228, 172, .38640926223293437], [229, 172, 1.0226012091159231], [230, 173, 1.017335022608167], [231, 173, .0632089679653424], [231, 174, .9123346686734497], [232, 174, .586352598418078], [232, 175, .3896500213288084], [233, 175, 1.0221130393455482], [234, 176, 1.0168889033326205], [235, 176, .06118944272087777], [235, 177, .914938802652698], [236, 177, .5837959103122896], [236, 178, .39278256296329067], [237, 178, 1.0216324340290364], [238, 179, 1.0164545758191], [239, 179, .05925153564332089], [239, 180, .9174485569826359], [240, 180, .5813325551691159], [240, 181, .3958085079669357], [241, 181, 1.0211600651125134], [242, 182, 1.01603219559476], [243, 182, .05739270264601734], [243, 183, .919866006375456], [244, 183, .578960492519135], [244, 184, .39872945870775167], [245, 184, 1.020696554488055], [246, 185, 1.0156218910279706], [247, 185, .055610515672866775], [247, 186, .9221931579354511], [248, 186, .5766777480237313], [248, 187, .4015469986761612], [249, 187, 1.0202424764259312], [250, 188, 1.0152237656316911], [251, 188, .05390265653168126], [251, 189, .9244319540637365], [252, 189, .5744824106486663], [252, 190, .4042626921377848], [253, 190, 1.0197983598926021], [254, 191, 1.0148379001729047], [255, 191, .052266911108559244], [255, 192, .9265842752073952], [256, 192, .5723726299899468], [256, 193, .40687808384383367], [257, 193, 1.0193646907609162], [258, 194, 1.0144643546050645], [259, 194, .05070116393653833], [259, 195, .9286519424651887], [260, 195, .5703466137364466], [260, 196, .4093946987997115], [261, 196, 1.0189419139168765], [262, 197, 1.014103169839173], [263, 197, .04920339309393266], [263, 198, .9306367200572258], [264, 198, .5684026252644323], [264, 199, .41181404208517797], [265, 199, 1.0185304352678317], [266, 200, 1.0137543693675302], [267, 200, .04777166540942449], [267, 201, .9325403176671191], [268, 201, .5665389813575877], [268, 202, .4141375987198434], [269, 202, 1.0181306236573189], [270, 203, 1.0134179607527265], [271, 203, .04640413195303674], [271, 204, .934364392667829], [272, 204, .5647540500383554], [272, 205, .4163668335733731], [273, 205, 1.017742812691386], [274, 206, 1.0130939369942324], [275, 206, .04509902379599986], [275, 207, .9361105522297561], [276, 207, .5630462485124229], [276, 208, .4185031913161667], [277, 208, 1.0173673024779883], [278, 209, 1.0127822777820206], [279, 209, .043854648017688035], [279, 210, .9377803553285139], [280, 210, .5614140412123577], [280, 211, .42054809640522234], [281, 211, 1.0170043612872055], [282, 212, 1.0124829506474082], [283, 212, .042669383945431606], [283, 213, .9393753146522579], [284, 213, .5598559379382144], [284, 214, .42250295310432634], [285, 214, 1.016654227133528], [286, 215, 1.0121959120202477], [287, 215, .04154167961383383], [287, 216, .9408968984130733], [288, 216, .5583704920894111], [288, 217, .42436914553372207], [289, 217, 1.0163171092845467], [290, 218, 1.0119211081990869], [291, 218, .04047004842376173], [291, 219, .9423465320743504], [292, 219, .5569562989809166], [292, 220, .4261480377490578], [293, 220, 1.0159931896995795], [294, 221, 1.0116584762427925], [295, 221, .03945306599345366], [295, 222, .9437255999933521], [296, 222, .5556119942410062], [296, 223, .4278409738424421], [297, 223, 1.0156826244024533], [298, 224, 1.0114079447897668], [299, 224, .038489367187566605], [299, 225, .9450354469842541], [300, 225, .5543362522836106], [300, 226, .42944927807097044], [301, 226, 1.015385544788648], [302, 227, 1.0111694348102989], [303, 227, .03757764331096192], [303, 228, .9462773798108762], [304, 228, .5531277848528364], [304, 229, .4309742550012965], [305, 229, 1.0151020588742643], [306, 230, 1.010942860298229], [307, 230, .036716639459590646], [307, 231, .9474526686068676], [308, 231, .5519853396352962], [308, 232, .4324171896758833], [309, 232, 1.0148322524854105], [310, 233, 1.0107281289063446], [311, 233, .03590515201636021], [311, 234, .9485625482321702], [312, 234, .5509076989367998], [312, 235, .43377934779319954], [313, 235, 1.0145761903940136], [314, 236, 1.0105251425307091], [315, 236, .03514202628559325], [315, 237, .9496082195647421], [316, 237, .5498936784177629], [316, 238, .4350619759070698], [317, 238, 1.014333917399279], [318, 239, 1.0103337978471305], [319, 239, .03442615425358563], [319, 240, .9505908507379167], [320, 240, .5489421258861396], [320, 241, .43626630163460317], [321, 241, 1.0141054593619083], [322, 242, 1.01015398680447], [323, 242, .03375647247069698], [323, 243, .9515115783174108], [324, 243, .5480519201477565], [324, 244, .43739353387882146], [325, 244, 1.0138908241879996], [326, 245, 1.0099855970782285], [327, 245, .033131960048180864], [327, 246, .9523715084281075], [328, 246, .5472219699015581], [328, 247, .438444863061944], [329, 247, 1.013690002769195], [330, 248, 1.009828512486449], [331, 248, .0325516367573507], [331, 249, .9531717178331495], [332, 249, .5464512126887197], [332, 250, .43942146136466664], [333, 250, 1.0135029698801676], [334, 251, 1.0096826133725936], [335, 251, .03201456123217285], [335, 252, .9539132549610332], [336, 252, .5457386138858732], [336, 253, .4403244829779182], [337, 253, 1.0133296850325435], [338, 254, 1.009547776957031], [339, 254, .03151982926510845], [339, 255, .9545971408911784], [340, 255, .5450831657405287], [340, 256, .44115506435778573], [341, 256, 1.0131700932920482], [342, 257, 1.0094238776594737], [343, 257, .031066572189892106], [343, 258, .9552243702967873], [344, 258, .5444838864501296], [344, 259, .44191432448690826], [345, 259, 1.013024126057376], [346, 260, 1.0093107873949636], [347, 260, .030653955347715485], [347, 261, .9557959123477745], [348, 261, .5439398192781751], [348, 262, .44260336514265247], [349, 262, 1.01289170180302], [350, 263, 1.0092083758457435], [351, 263, .03028117663272106], [351, 264, .956312711573757], [352, 264, .5434500317097861], [352, 265, .44322327116676213], [353, 265, 1.012772726788603], [354, 266, 1.0091165107105933], [355, 266, .029947465111254432], [355, 267, .9567756886915669], [356, 267, .5430136146404813], [356, 268, .443775110739594], [357, 268, 1.0126670957357586], [358, 269, 1.0090350579329337], [359, 269, .02965207970869547], [359, 270, .9571857414000476], [360, 270, .5426296815994802], [360, 271, .44425993565630856], [361, 271, 1.012574692474406], [362, 272, 1.0089638819102829], [363, 272, .029394307963707546], [363, 273, .9575437451393404], [364, 273, .5422973680058967], [364, 274, .4446787816043237], [365, 274, 1.0124953905592755], [366, 275, 1.0089028456858484], [367, 275, .029173464843693937], [367, 276, .9578505538209541], [368, 276, .5420158304528419], [368, 277, .44503266844280676], [369, 277, 1.0124290538587923], [370, 278, 1.0088518111235036], [371, 278, .028988891617224174], [371, 279, .9581070005279474], [372, 279, .5417842460227992], [372, 280, .4453226004830567], [373, 280, 1.012375537116488], [374, 281, 1.0088106390682976], [375, 281, .028839954783933083], [375, 282, .9583138981860433], [376, 282, .5416018116287169], [376, 283, .4455495667668758], [377, 283, 1.0123346864882432], [378, 284, 1.008779189492711], [379, 284, .02872604505481853], [379, 285, .9584720402070429], [380, 285, .5414677433849261], [380, 286, .44571454134485444], [381, 286, 1.0123063400541175], [382, 287, 1.008757321629678], [383, 287, .028646576380597488], [383, 288, .9585822011116006], [384, 288, .5413812759956369], [384, 289, .4458184835568685], [385, 289, 1.0122903283078832], [386, 290, 1.0087448940943453], [387, 290, .028600985028178233], [387, 291, .9586451371206854], [388, 291, .541341662177547], [388, 292, .44586233830592226], [389, 292, 1.0122864746237836], [390, 293, 1.0087417649949195], [391, 293, .028588728701898054], [391, 294, .9586615867284015], [392, 294, .5413481720936798], [392, 295, .44584703633543826], [393, 295, 1.0122945957030358], [394, 296, 1.0087477920325896], [395, 296, .028609285702619672], [395, 297, .958632271251788], [396, 297, .5414000928186515], [396, 298, .44577349450072723], [397, 298, 1.0123145019997328], [398, 299, 1.0087628325926643], [399, 299, .028662154128659946], [399, 300, .9585578953591529], [400, 300, .5414967278190544], [400, 301, .4456426160405528], [401, 301, 1.0123459981276965], [402, 302, 1.0087867438270437], [403, 302, .028746851113718195], [403, 303, .9584391475775814], [404, 303, .5416373964555454], [404, 304, .4454552908447334], [405, 304, 1.0123888832492127], [406, 305, 1.0088193827286074], [407, 305, .02886291209986826], [407, 306, .9582767007831089], [408, 306, .541821433501071], [408, 307, .44521239571891796], [409, 307, 1.0124429514472502], [410, 308, 1.0088606061980132], [411, 308, .029009890142771087], [411, 309, .9580712126699451], [412, 309, .5420481886827784], [412, 310, .4449147946460895], [413, 310, 1.01250799207953], [414, 311, 1.0089102711038211], [415, 311, .029187355249536997], [415, 312, .9578233262044412], [416, 312, .5423170262339921], [416, 313, .44456333904778883], [417, 313, 1.0125837901172945], [418, 314, 1.0089682343360202], [419, 314, .02939489374516595], [419, 315, .9575336700623188], [420, 315, .5426273244683578], [420, 316, .4441588680360723], [421, 316, 1.0126701264704934], [422, 317, 1.0090343528545804], [423, 317, .029632107670909735], [423, 318, .9572028590461733], [424, 318, .5429784753662162], [424, 319, .44370220866623333], [425, 319, 1.0127667782967882], [426, 320, 1.0091084837312583], [427, 320, .02989861420426184], [427, 321, .9568314944924141], [428, 321, .5433698841780775], [428, 322, .44319417618582607], [429, 322, 1.0128735192969558], [430, 323, 1.0091904841873789], [431, 323, .03019404510848359], [431, 324, .9564201646615609], [432, 324, .5438009690392793], [432, 325, .442635574278337], [433, 325, 1.0129901199984148], [434, 326, 1.0092802116265451], [435, 326, .030518046204357472], [435, 327, .9559694451142186], [436, 327, .5442711606026257], [436, 328, .4420271953022404], [437, 328, 1.013116348025554], [438, 329, 1.0093775236632159], [439, 329, .030870276865616747], [439, 330, .9554798990737882], [440, 330, .5447799016825403], [440, 331, .4413698205263152], [441, 331, 1.0132519683584005], [442, 332, 1.009482278147551], [443, 332, .03125040953717358], [443, 333, .9549520777754482], [444, 333, .5453266469100869], [444, 334, .4406642203630321], [445, 334, 1.0133967435791398], [446, 335, 1.009594333186143], [447, 335, .031658129272365214], [447, 336, .9543865208053518], [448, 336, .5459108623998897], [448, 337, .43991115459682073], [449, 337, 1.0135504341086077], [450, 338, 1.0097135471594447], [451, 338, .03209313328990995], [451, 339, .9537837564264052], [452, 339, .5465320254328632], [452, 340, .4391113726049666], [453, 340, 1.013712798432744], [454, 341, 1.009839778736762], [455, 341, .03255513055252836], [455, 342, .9531443018899375], [456, 342, .5471896241467579], [456, 343, .43826561357805704], [457, 343, 1.0138835933177033], [458, 344, 1.0099728868869051], [459, 344, .033043841357819334], [459, 345, .9524686637453139], [460, 345, .5478831572348231], [460, 346, .437374606734874], [461, 346, 1.0140625740178375], [462, 347, 1.0101127308880269], [463, 347, .03355899695286791], [463, 348, .9517573381261256], [464, 348, .5486121336621822], [464, 349, .436439071532636], [465, 349, 1.0142494944714182], [466, 350, 1.0102591703335964], [467, 350, .03410033916008615], [467, 351, .9510108110386514], [468, 351, .5493760723833191], [468, 352, .4354597178717026], [469, 352, 1.0144441074918717], [470, 353, 1.0104120651366326], [471, 353, .03466762001996195], [471, 354, .9502295586328896], [472, 354, .5501745020753853], [472, 355, .43443724629963687], [473, 355, 1.0146461649465606], [474, 356, 1.0105712755316636], [475, 356, .035260601448092795], [475, 357, .9494140474694148], [476, 357, .5510069608761691], [476, 358, .43337234820709825], [477, 358, 1.0148554179311553], [478, 359, 1.0107366620751033], [479, 359, .035879054907258415], [479, 360, .9485647347731454], [480, 360, .5518729961339426], [480, 361, .4322657060211073], [481, 361, 1.0150716169344107], [482, 362, 1.0109080856433987], [483, 362, .036522761091017805], [483, 363, .9476820686815849], [484, 363, .5527721641646695], [484, 364, .4311179933933358], [485, 364, 1.0152945119966836], [486, 365, 1.011085407429963], [487, 365, .037191509621709105], [487, 366, .9467664884832998], [488, 366, .5537040300164661], [488, 367, .42992987538427074], [489, 367, 1.0155238528614574], [490, 368, 1.0112684889404733], [491, 368, .03788509876006132], [491, 369, .945818424848663], [492, 369, .5546681672409077], [492, 370, .42870200864543534], [493, 370, 1.015759389119438], [494, 371, 1.0114571919861517], [495, 371, .038603335123549486], [495, 372, .9448383000574974], [496, 372, .5556641576735553], [496, 373, .42743504159139284], [497, 373, 1.016000870349307], [498, 374, 1.0116513786769457], [499, 374, .03934603342038135], [499, 375, .9438265282100843], [500, 375, .556691591222498], [500, 376, .42612961457530607], [501, 376, 1.0162480462474877], [502, 377, 1.011850911412824], [503, 377, .0401130161915153], [503, 378, .9427835154401112], [504, 378, .5577500656591832], [504, 379, .42478636005357434], [505, 379, 1.0165006667574357], [506, 380, 1.012055652873517], [507, 380, .04090411356002747], [507, 381, .9417096601187289], [508, 381, .5588391864205529], [508, 382, .4234059027505881], [509, 382, 1.016758482190165], [510, 383, 1.0122654660085202], [511, 383, .04171916299559172], [511, 384, .940605353048487], [512, 384, .5599585664146272], [512, 385, .4219888598177451], [513, 385, 1.0170212433404524], [514, 386, 1.0124802140252198], [515, 386, .04255800908365318], [515, 387, .9394709776545362], [516, 387, .5611078258344457], [516, 388, .42053584098827806], [517, 388, 1.0172887015980372], [518, 389, 1.0126997603766286], [519, 389, .04342050330548295], [519, 390, .9383069101697904], [520, 390, .5622865919744513], [520, 391, .4190474487280153], [521, 391, 1.0175606090547666], [522, 392, 1.0129239687479124], [523, 392, .044306503823998804], [523, 393, .9371135198133816], [524, 393, .5634944990567509], [524, 394, .41752427838399275], [525, 394, 1.017836718605313], [526, 395, 1.0131527030429122], [527, 395, .04521587528078427], [527, 396, .9358911689630978], [528, 396, .5647311880602439], [528, 397, .4159669183258934], [529, 397, 1.0181167840454461], [530, 398, 1.013385827369556], [531, 398, .04614848859869256], [531, 399, .9346402133241121], [532, 399, .5659963065530312], [532, 400, .41437595008823225], [533, 400, 1.0184005601646522], [534, 401, 1.0136232060250132], [535, 401, .04710422079259773], [535, 402, .9333610020906034], [536, 402, .5672895085344858], [536, 403, .41275194850334485], [537, 403, 1.0186878028359048], [538, 404, 1.0138647034793364], [539, 404, .048082954782625906], [539, 405, .9320538781067357], [540, 405, .5686104542795039], [540, 406, .4110954818363832], [541, 406, 1.0189782691001303], [542, 407, 1.0141101843606544], [543, 407, .04908457922335384], [543, 408, .9307191780153855], [544, 408, .5699588101870642], [544, 409, .40940711191046436], [545, 409, 1.0192717172488233], [546, 410, 1.0143595134378742], [547, 410, .05010898832967291], [547, 411, .9293572324099554], [548, 411, .571334248633412], [548, 412, .4076873942350095], [549, 412, 1.0195679069010588], [550, 413, 1.014612555604275], [551, 413, .05115608171422347], [551, 414, .9279683659767549], [552, 414, .5727364478324755], [552, 415, .4059368781231612], [553, 415, 1.0198665990790994], [554, 416, 1.0148691758602966], [555, 416, .05222576422885553], [555, 417, .9265528976348417], [556, 417, .5741650916958022], [556, 418, .40415610681371494], [557, 418, 1.0201675562784311], [558, 419, 1.0151292392959954], [559, 419, .05331794581129548], [559, 420, .9251111406735011], [560, 420, .575619869698764], [560, 421, .40234561758289383], [561, 421, 1.020470542537326], [562, 422, 1.0153926110734461], [563, 422, .05443254133751677], [563, 423, .9236434028815992], [564, 423, .577100476753225], [564, 424, .40050594185671334], [565, 424, 1.0207753235006762], [566, 425, 1.0156591564087798], [567, 425, .05556947047932675], [567, 426, .9221499866777003], [568, 426, .5786066130792553], [568, 427, .3986376053171075], [569, 427, 1.021081666483685], [570, 428, 1.0159287405542117], [571, 428, .056728657567230105], [571, 429, .9206311892316345], [572, 429, .5801379840824749], [572, 430, .3967411280111777], [573, 430, 1.0213893405291132], [574, 431, 1.016201228779567], [575, 431, .057910031456259455], [575, 432, .9190873025878152], [576, 432, .5816943002369833], [576, 433, .39481702444623007], [577, 433, 1.021698116466727], [578, 434, 1.0164764863538518], [579, 434, .05911352539724152], [579, 435, .9175186137811212], [580, 435, .5832752769689779], [580, 436, .3928658036922941], [581, 436, 1.0220077669657777], [582, 437, 1.0167543785266802], [583, 437, .06033907691219022], [583, 438, .9159254049505173], [584, 438, .5848806345442068], [584, 439, .3908879694785636], [585, 439, 1.022318066586335], [586, 440, 1.017034770509633], [587, 440, .061586627674206584], [587, 441, .914307953451257], [588, 441, .58651009795775], [588, 442, .3888840202832941], [589, 442, 1.0226287918300547], [590, 443, 1.017317527457434], [591, 443, .06285612338957339], [591, 444, .9126665319603182], [592, 444, .5881633968320044], [592, 445, .3868544494242516], [593, 445, 1.0229397211858324], [594, 446, 1.0176025144493452], [595, 446, .06414751368695158], [595, 447, .9110014085827639], [596, 447, .5898402653081352], [596, 448, .3847997451452973], [597, 448, 1.0232506351759092], [598, 449, 1.0178895964699735], [599, 449, .06546075200505637], [599, 450, .9093128469516464], [600, 450, .5915404419502857], [600, 451, .38272039070347513], [601, 451, 1.0235613163962847], [602, 452, 1.018178638390636], [603, 452, .06679579548876291], [603, 453, .9076011063291527], [604, 453, .5932636696450677], [604, 454, .3806168644453139], [605, 454, 1.0238715495601471], [606, 455, 1.0184695049504477], [607, 455, .06815260488510425], [607, 456, .9058664416991429], [608, 456, .5950096955107654], [608, 457, .37848963988927037], [609, 457, 1.024181121533852], [610, 458, 1.0187620607370533], [611, 458, .06953114444294146], [611, 459, .9041091038666588], [612, 459, .5967782707982764], [612, 460, .3763391858013562], [613, 460, 1.0244898213757605], [614, 461, 1.0190561701684775], [615, 461, .07093138181829654], [615, 462, .9023293395404434], [616, 462, .5985691508103589], [616, 463, .37416596626748977], [617, 463, 1.0247974403689852], [618, 464, 1.0193516974735164], [619, 464, .07235328797779521], [619, 465, .9005273914292568], [620, 465, .6003820948062436], [620, 466, .37197044076689306], [621, 466, 1.0251037720559506], [622, 467, 1.0196485066733956], [623, 467, .07379683710904351], [623, 468, .8987034983230944], [624, 468, .6022168659211814], [624, 469, .3697530642404009], [625, 469, 1.025408612268551], [626, 470, 1.01994646156273], [627, 470, .07526200653052777], [627, 471, .8968578951803935], [628, 471, .6040732310832857], [628, 472, .36751428715382667], [629, 472, 1.0257117591594511], [630, 473, 1.0202454256910738], [631, 473, .07674877660715493], [631, 474, .8949908132065928], [632, 474, .6059509609308075], [632, 475, .3652545555682938], [633, 475, 1.0260130132278693], [634, 476, 1.0205452623441595], [635, 476, .07825713066499564], [635, 477, .8931024799348216], [636, 477, .6078498297369068], [636, 478, .36297431119783957], [637, 478, 1.026312177347325], [638, 479, 1.0208458345252258], [639, 479, .07978705490923481], [639, 480, .8911931193041005], [640, 480, .6097696153313106], [640, 481, .360673991471839], [641, 481, 1.0266090567901067], [642, 482, 1.021147004936792], [643, 482, .08133853834681559], [643, 483, .8892629517341233], [644, 483, .6117100990244927], [644, 484, .3583540295921792], [645, 484, 1.0269034592511874], [646, 485, 1.0214486359623245], [647, 485, .08291157270803175], [647, 486, .8873121941972261], [648, 486, .6136710655396947], [648, 487, .35601485458732646], [649, 487, 1.0271951948700204], [650, 488, 1.0217505896477503], [651, 488, .08450615237016054], [651, 489, .885341060291742], [652, 489, .6156523029400911], [652, 490, .3536568913681695], [653, 490, 1.0274840762511013], [654, 491, 1.022052727683594], [655, 491, .08612227428601159], [655, 492, .8833497603088218], [656, 492, .6176536025590085], [656, 493, .3512805607832744], [657, 493, 1.02776991848203], [658, 494, 1.0223549113867765], [659, 494, .08775993791161714], [659, 495, .8813385013049766], [660, 495, .6196747589336273], [660, 496, .34888627966024516], [661, 496, 1.028052539155018], [662, 497, 1.0226570016825074], [663, 497, .08941914513388247], [663, 498, .8793074871648813], [664, 498, .621715569739104], [664, 499, .346474460866357], [665, 499, 1.0283317583791294], [666, 500, 1.0229588590871557], [667, 500, .09109990020637701], [667, 501, .8772569186645972], [668, 501, .6237758357289777], [668, 502, .34404551334349676], [669, 502, 1.0286073987990987], [670, 503, 1.023260343690056], [671, 503, .09280220968027517], [671, 504, .8751869935378795], [672, 504, .6258553606671395], [672, 505, .3415998421603758], [673, 505, 1.0288792856085094], [674, 506, 1.0235613151361742], [675, 506, .09452608233896752], [675, 507, .8730979065358732], [676, 507, .6279539512706841], [676, 508, .33913784855416224], [677, 508, 1.0291472465628844], [678, 509, 1.0238616326091752], [679, 509, .09627152913686766], [679, 510, .8709898494841083], [680, 510, .6300714171530707], [680, 511, .3366599299694516], [681, 511, 1.0294111119920568], [682, 512, 1.0241611548135297], [683, 512, .09803856313307117], [683, 513, .8688630113461538], [684, 513, .6322075707612916], [684, 514, .3341664801038121], [685, 514, 1.0296707148107829], [686, 515, 1.0244597399582411], [687, 515, .09982719943517422], [687, 516, .8667175782751595], [688, 516, .6343622273238361], [688, 517, .33165788894132453], [689, 517, 1.029925890529174], [690, 518, 1.024757245739534], [691, 518, .10163745513498708], [691, 519, .864553733672022], [692, 519, .6365352047963319], [692, 520, .32913454279236454], [693, 520, 1.0301764772610114], [694, 521, 1.0250535293244536], [695, 521, .10346934925456013], [695, 522, .8623716582378126], [696, 522, .6387263238040831], [696, 523, .32659682433041565], [697, 523, 1.0304223157317631], [698, 524, 1.0253484473338592], [699, 524, .10532290268142636], [699, 525, .8601715300305955], [700, 525, .6409354075949926], [700, 526, .32404511262442137], [701, 526, 1.0306632492858765], [702, 527, 1.0256418558269649], [703, 527, .10719813812199533], [703, 528, .8579535245094766], [704, 528, .6431622819855923], [704, 529, .3214797831731655], [705, 529, 1.0308991238920382], [706, 530, 1.0259336102845216], [707, 530, .10909508003982304], [707, 531, .855717814591042], [708, 531, .6454067753119441], [708, 532, .3189012079363341], [709, 532, 1.03112978814904], [710, 533, 1.0262235655929648], [711, 533, .11101375459950885], [711, 534, .8534645706974212], [712, 534, .6476687183847731], [712, 535, .31630975536452444], [713, 535, 1.0313550932895121], [714, 536, 1.0265115760290215], [715, 536, .11295418962138112], [715, 537, .8511939607995829], [716, 537, .6499479444348513], [716, 538, .3137057904341974], [717, 538, 1.0315748931821125], [718, 539, 1.0267974952437684], [719, 539, .11491641452111552], [719, 540, .8489061504692988], [720, 540, .6522442890739327], [720, 541, .3110896746693046], [721, 541, 1.0317890443354898], [722, 542, 1.027081176247435], [723, 542, .11690046026072583], [723, 543, .8466013029223681], [724, 543, .6545575902471419], [724, 544, .3084617661720711], [725, 544, 1.0319974058989068], [726, 545, 1.0273624713942857], [727, 545, .11890635929917114], [727, 546, .8442795790631381], [728, 546, .6568876881880987], [728, 547, .3058224196480645], [729, 547, 1.0321998396634169], [730, 548, 1.0276412323675237], [731, 548, .12093414553884717], [731, 549, .8419411375296247], [732, 549, .6592344253774453], [732, 550, .3031719864317822], [733, 550, 1.0323962100616533], [734, 551, 1.027917310164898], [735, 551, .12298385427920393], [735, 552, .8395861347312832], [736, 552, .661597646501151], [736, 553, .30051081451364153], [737, 553, 1.0325863841657408], [738, 554, 1.028190555083932], [739, 554, .12505552216817234], [739, 555, .8372147248951822], [740, 555, .6639771984076539], [740, 556, .2978392485576317], [741, 556, 1.0327702316879357], [742, 557, 1.0284608167076257], [743, 557, .12714918714905468], [743, 558, .8348270601054527], [744, 558, .6663729300704698], [744, 559, .2951576299293991], [745, 559, 1.0329476249762861], [746, 560, 1.0287279438905246], [747, 560, .12926488841857217], [747, 561, .8324232903405301], [748, 561, .6687846925454237], [748, 562, .2924662967182933], [749, 562, 1.0331184390116956], [750, 563, 1.0289917847447467], [751, 563, .13140266637549056], [751, 564, .8300035635173267], [752, 564, .6712123389365675], [752, 565, .28976558374944045], [753, 565, 1.033282551406384], [754, 566, 1.0292521866268258], [755, 566, .13356256257828694], [755, 567, .8275680255195722], [756, 567, .6736557243576808], [756, 568, .28705582261488644], [757, 568, 1.0334398423957492], [758, 569, 1.0295089961237516], [759, 569, .1357446196959754], [759, 570, .8251168202441111], [760, 570, .6761147058925864], [760, 571, .2843373416864493], [761, 571, 1.0335901948361186], [762, 572, 1.0297620590403478], [763, 572, .13794888146102224], [763, 573, .822650089632257], [764, 573, .6785891425651428], [764, 574, .2816104661359854], [765, 574, 1.0337334941973482], [766, 575, 1.0300112203862977], [767, 575, .1401753926301894], [767, 576, .8201679737037143], [768, 576, .6810788952992894], [768, 577, .278875517953921], [769, 577, 1.0338696285566522], [770, 578, 1.0302563243634062], [771, 578, .14242419893016717], [771, 579, .8176706105975015], [772, 579, .6835838268889712], [772, 580, .2761328159639002], [773, 580, 1.0339984885922306], [774, 581, 1.0304972143534852], [775, 581, .14469534702456693], [775, 582, .8151581365963325], [776, 582, .6861038019600981], [776, 583, .2733826758448351], [777, 583, 1.0341199675739228], [778, 584, 1.0307337329063364], [779, 584, .14698888445850505], [779, 585, .8126306861670012], [780, 585, .6886386869453004], [780, 586, .2706254101402667], [781, 586, 1.0342339613562985], [782, 587, 1.0309657217274584], [783, 587, .14930485962229872], [783, 588, .810088391991206], [784, 588, .6911883500416512], [784, 589, .267861328280309], [785, 589, 1.0343403683692496], [786, 590, 1.0311930216672842], [787, 590, .1516433217043255], [787, 591, .80753138499415], [788, 591, .6937526611907388], [788, 592, .2650907365900638], [789, 592, 1.0344390896084676], [790, 593, 1.0314154727094134], [791, 593, .1540043206504027], [791, 594, .8049597943767033], [792, 594, .6963314920402311], [792, 595, .2623139383094437], [793, 595, 1.034530028625162], [794, 596, 1.0316329139598897], [795, 596, .1563879071152346], [795, 597, .8023737476471726], [796, 597, .6989247159176777], [796, 598, .25953123360660696], [797, 598, 1.0346130915153564], [798, 599, 1.0318451836365417], [799, 599, .15879413242528773], [799, 600, .799773370648628], [800, 600, .7015322078013413], [800, 601, .256742919587031], [801, 601, 1.0346881869094755], [802, 602, 1.0320521190584917], [803, 602, .16122304853347555], [803, 603, .7971587875884961], [804, 603, .7041538442893039], [804, 604, .2539492903120581], [805, 604, 1.0347552259598483], [806, 605, 1.032253556636297], [807, 605, .16367470797552194], [807, 606, .7945301210672343], [808, 606, .7067895035746306], [808, 607, .2511506368077842], [809, 607, 1.0348141223290412], [810, 608, 1.0324493318619021], [811, 608, .16614916382632547], [811, 609, .7918874921076472], [812, 609, .709439065413448], [812, 610, .24834724708249672], [813, 610, 1.0348647921767888], [814, 611, 1.032639279299876], [815, 611, .1686464696616927], [815, 612, .7892310201754584], [816, 612, .7121024111062217], [816, 613, .24553940613187852], [817, 613, 1.0349071541468273], [818, 614, 1.0328232325774014], [819, 614, .17116667951302045], [819, 615, .7865608232133336], [820, 615, .7147794234616441], [820, 616, .24272739595679857], [821, 616, 1.0349411293537], [822, 617, 1.0330010243763053], [823, 617, .17370984782335191], [823, 618, .7838770176637189], [824, 618, .7174699867799718], [824, 619, .23991149556876706], [825, 619, 1.0349666413686411], [826, 620, 1.033172486424039], [827, 620, .17627602940857415], [827, 621, .7811797184924586], [828, 621, .720173986819918], [828, 622, .23709198101021747], [829, 622, 1.0349836162040225], [830, 623, 1.0333374494861536], [831, 623, .1788652794118951], [831, 624, .7784690392157592], [832, 624, .7228913107823544], [832, 625, .234269125354749], [833, 625, 1.0349919822996723], [834, 626, 1.0334957433581187], [835, 626, .18147765326305537], [835, 627, .7757450919251534], [836, 627, .7256218472813651], [836, 628, .23144319872166874], [837, 628, 1.0349916705072433], [838, 629, 1.033647196858036], [839, 629, .1841132066386375], [839, 630, .773007987305413], [840, 630, .7283654863202004], [840, 631, .22861446829229304], [841, 631, 1.0349826140730403], [842, 632, 1.033791637819688], [843, 632, .1867719954109858], [843, 633, .7702578346682248], [844, 633, .7311221192693971], [844, 634, .2257831983137577], [845, 634, 1.0349647486235953], [846, 635, 1.0339288930859631], [847, 635, .18945407561392777], [847, 636, .7674947419659374], [848, 636, .7338916388459672], [848, 637, .22294965011006523], [849, 637, 1.0349380121480094], [850, 638, 1.0342420464149167], [851, 638, .1924281237940313], [851, 639, .5378425839134362], [852, 639, .5202524171708031], [852, 640, .4568109772775498], [852, 641, .05199677850209752], [853, 640, .24351254102567055], [853, 641, .5225687624093359], [853, 642, .2921493228893563], [854, 642, .25538328243481595], [854, 643, .5241438210153896], [854, 644, .23257172527298814], [855, 643, .011987787701546808], [855, 644, .3172219958151092], [855, 645, .4868674616302827], [855, 646, .176468024136203], [856, 645, .07357769424953754], [856, 646, .38294232266815553], [856, 647, .4259205416014665], [856, 648, .11753224171517974], [857, 647, .13246196705929972], [857, 648, .4398303708699065], [857, 649, .36708371923835004], [857, 650, .06067586883292038], [858, 649, .18926719214302565], [858, 650, .4946697651421086], [858, 651, .3040061179704405], [858, 652, .005602736230038195], [859, 651, .23906249586178907], [859, 652, .5231149368578739], [859, 653, .2495840468006932], [860, 653, .2897970473112013], [860, 654, .5026442283960142], [860, 655, .20274559579570214], [861, 654, .04664315619110009], [861, 655, .3473240465998149], [861, 656, .4526192727121032], [861, 657, .1523595035438806], [862, 656, .09766699822939251], [862, 657, .3969699779916487], [862, 658, .40188113292822186], [862, 659, .1034820659161816], [863, 658, .14649823031506354], [863, 659, .44395391725661004], [863, 660, .3530826952522148], [863, 661, .056517279244449437], [864, 660, .193417537810633], [864, 661, .48905272813711814], [864, 662, .30196784607077015], [864, 663, .011088189502860925], [865, 662, .235165441654809], [865, 663, .5161755064939912], [865, 664, .25593745749264785], [866, 664, .27598857145168865], [866, 665, .5055165820237347], [866, 666, .21733399798014585], [867, 665, .03142691535889764], [867, 666, .321995701601107], [867, 667, .4677769922252197], [867, 668, .17692400337387545], [868, 667, .07312870986769164], [868, 668, .3630952451007391], [868, 669, .4264378437134144], [868, 670, .13731285791147696], [869, 669, .11270032695167025], [869, 670, .4009509624326517], [869, 671, .38688927555227676], [869, 672, .09946833663506985], [870, 671, .15050630725355646], [870, 672, .43706477714430675], [870, 673, .34910378546507886], [870, 674, .06336347754327785], [871, 673, .1865736616624162], [871, 674, .4714631653468664], [871, 675, .3125696686315781], [871, 676, .028869775846049314], [872, 675, .22058655357283705], [872, 676, .502393455771382], [872, 677, .27458473006488804], [873, 677, .24983886475629993], [873, 678, .5137748593109537], [873, 679, .24315322539257223], [874, 678, .0036240101488931717], [874, 679, .2812413419420975], [874, 680, .49584386088869215], [874, 681, .2153614227018543], [875, 680, .034735500335029305], [875, 681, .3144060917430617], [875, 682, .46485314373790926], [875, 683, .18595981453922283], [876, 682, .0641063484572785], [876, 683, .34219859962945964], [876, 684, .43549740951782173], [876, 685, .15817234633893226], [877, 684, .091864261548934], [877, 685, .3683988258245694], [877, 686, .407752916631107], [877, 687, .13197572785525458], [878, 686, .11803256264694018], [878, 687, .3930296465168421], [878, 688, .3815964769154389], [878, 689, .10734720976073055], [879, 688, .1426340315995158], [879, 689, .4161134070872291], [879, 690, .35700543857338174], [879, 691, .08426456699687354], [880, 690, .16569092182506315], [880, 691, .43767193845249674], [880, 692, .33395766972405766], [880, 693, .06270608273067858], [881, 692, .1872249764612122], [881, 693, .457726572814142], [881, 694, .3124315425508366], [881, 695, .04265053289025597], [882, 694, .20725744392861123], [882, 695, .47629815883858434], [882, 696, .29240591801936916], [882, 697, .024077171256560802], [883, 696, .22580909293436022], [883, 697, .49340707629100294], [883, 698, .272739666255128], [883, 699, .006906252371233933], [884, 698, .24190643067177103], [884, 699, .5047275543873398], [884, 700, .2549459812508028], [885, 700, .2567100539467806], [885, 701, .5031577036963546], [885, 702, .24065881914660317], [886, 701, .008634717813202674], [886, 702, .27224949572145724], [886, 703, .49094674236787206], [886, 704, .22719544196570912], [887, 703, .02292373131969297], [887, 704, .28597629401801355], [887, 705, .47672398599653515], [887, 706, .2143533208320832], [888, 705, .035751602096786475], [888, 706, .29743237559552355], [888, 707, .46390276826706217], [888, 708, .20289630196958544], [889, 707, .04719579903029385], [889, 708, .3075210742305127], [889, 709, .45246460115847775], [889, 710, .19280622955805915], [890, 709, .057274491299496445], [890, 710, .3162602301176305], [890, 711, .4423913913890736], [890, 712, .18406533389761395], [891, 711, .0660054606502899], [891, 712, .3236673045470217], [891, 713, .43366542899845073], [891, 714, .17665622026124392], [892, 713, .07340611260620647], [892, 714, .3297593908476435], [892, 715, .4262693763198494], [892, 716, .17056185812791913], [893, 715, .07949348729590157], [893, 716, .33455322495703466], [893, 717, .42018625732795906], [893, 718, .16576557078065143], [894, 717, .0842842699121286], [894, 718, .3380651956328206], [894, 719, .41539944734620887], [894, 720, .16225102525634236], [895, 719, .0877948008176482], [895, 720, .3403113543186734], [895, 721, .41189266310148215], [895, 722, .1600022226324315], [896, 721, .09004108530992379], [896, 722, .3413074246800344], [896, 723, .4096499531105413], [896, 724, .15900348863810745], [897, 723, .0910388030604564], [897, 724, .341068811820455], [897, 725, .4086556883871424], [897, 726, .15923946457791555], [898, 725, .09080331723824445], [898, 726, .33961061119156805], [898, 727, .40889455345709996], [898, 728, .16069509855546693], [899, 727, .08934968333179105], [899, 728, .33694761720865024], [899, 729, .41035153766953336], [899, 730, .1633556369851302], [900, 729, .08669265767999552], [900, 730, .33309433158306806], [900, 731, .41301192679237225], [900, 732, .16720661638248935], [901, 731, .08284670572359325], [901, 732, .32806497138102175], [901, 733, .41686129488304347], [901, 734, .17223385542154263], [902, 733, .0778260099865808], [902, 734, .3218734768206457], [902, 735, .421885496422382], [902, 736, .17842344724960524], [903, 735, .07164447779930824], [903, 736, .31453351881588426], [903, 737, .42807065870301164], [903, 738, .185761752049803], [904, 737, .06431574877136567], [904, 738, .3060585062772846], [904, 739, .435403174462235], [904, 740, .19423538984244326], [905, 739, .05585320202451507], [905, 740, .29646159317816856], [905, 741, .4438696947508069], [905, 742, .20383123351642937], [906, 741, .04626996319383157], [906, 742, .2857556853951481], [906, 743, .4534571220289279], [906, 744, .21453640208174513], [907, 743, .03557891120608933], [907, 744, .27395344733160587], [907, 745, .4640838862781736], [907, 746, .2259711147745072], [908, 745, .02378916236694485], [908, 746, .26064383557298154], [908, 747, .4744097020055178], [908, 748, .23741469023048611], [908, 749, .0029874664482454345], [909, 747, .010888485342882084], [909, 748, .24524012825579347], [909, 749, .47705262348683797], [909, 750, .25146343127990345], [909, 751, .018030374036361534], [910, 750, .23051594568994063], [910, 751, .4659638155007443], [910, 752, .26789265476733026], [910, 753, .034103962104678205], [911, 752, .2157780537828917], [911, 753, .4490488012027463], [911, 754, .28394240197843773], [911, 755, .051207169174446954], [912, 754, .19869680451466967], [912, 755, .4309201309554197], [912, 756, .3010279740476113], [912, 757, .06933596927309439], [913, 756, .18059146729117878], [913, 757, .4117775174928008], [913, 758, .3191380672559441], [913, 759, .08847923890660256], [914, 758, .16147315955443303], [914, 759, .3916318997027402], [914, 760, .33826157637971177], [914, 761, .10862604895508292], [915, 760, .14135280401108383], [915, 761, .37049402581791996], [915, 762, .35838758963377015], [915, 763, .12976565972904766], [916, 762, .12024113359574008], [916, 763, .34837445826725], [916, 764, .3795053837685538], [916, 765, .15188751617588445], [917, 764, .0981486962833266], [917, 765, .32528357838026745], [917, 766, .40160441931520835], [917, 767, .17498124323033803], [918, 766, .07508585975635881], [918, 767, .30123159095005636], [918, 768, .42467433597326765], [918, 769, .19903664130457108], [919, 768, .05106281593203439], [919, 769, .2762285286588279], [919, 770, .4480441892579001], [919, 771, .22091817857346802], [920, 770, .02605116606412028], [920, 771, .24679268601046497], [920, 772, .4613333588465915], [920, 773, .24636316696152993], [920, 774, .026661594315488448], [921, 772, .00017143112777602207], [921, 773, .22016507993495968], [921, 774, .4450006731455823], [921, 775, .27654268563105877], [921, 776, .05450703342817279], [922, 775, .19537707282293476], [922, 776, .4169980825615683], [922, 777, .3043455873211709], [922, 778, .08322496813649063], [923, 777, .16671893224886847], [923, 778, .3873911007134449], [923, 779, .333032487802997], [923, 780, .11284587069811512], [924, 779, .1371380798307044], [924, 780, .3568813039463011], [924, 781, .36262258254682433], [924, 782, .14336176762117853], [925, 781, .10666365535341012], [925, 782, .32548606626333626], [925, 783, .39310680323983005], [925, 784, .17476372572452537], [926, 783, .07530458232966944], [926, 784, .2932141772790525], [926, 785, .4235343782302751], [926, 786, .20429957725699868], [927, 785, .04297407877416276], [927, 786, .2566282342451322], [927, 787, .44609730979381396], [927, 788, .23600300007995265], [927, 789, .023774697332874434], [928, 787, .00973561058609779], [928, 788, .22213324067090034], [928, 789, .4366882593279592], [928, 790, .27231575108916795], [928, 791, .058813271383982776], [929, 790, .1899112794795718], [929, 791, .4051174305988943], [929, 792, .3087329260703045], [929, 793, .09459113946159277], [930, 792, .15536737862587172], [930, 793, .36909687837539557], [930, 794, .3443998634306182], [930, 795, .13113054742980831], [931, 794, .11887833690004168], [931, 795, .3317399346424034], [931, 796, .3809015150071346], [931, 797, .1684974582828263], [932, 796, .08156315084174257], [932, 797, .29356399783457987], [932, 798, .4168389957384664], [932, 799, .2027189344423823], [933, 798, .043285265762028874], [933, 799, .2496929999720567], [933, 800, .44089395742648096], [933, 801, .24052352812737388], [933, 802, .03507425254057242], [934, 800, .0043335535351657515], [934, 801, .21027601904641954], [934, 802, .42143856683278325], [934, 803, .2844016743443022], [934, 804, .07585590645285804], [935, 803, .17353832434253885], [935, 804, .38262846297038483], [935, 805, .3257498632562316], [935, 806, .11730189433403454], [936, 805, .13268775789077444], [936, 806, .3407519309130924], [936, 807, .3670972990020704], [936, 808, .15947396875496164], [937, 807, .09057464650490143], [937, 808, .2978183751219168], [937, 809, .40749895190525254], [937, 810, .19795010289674397], [938, 809, .0474866463063797], [938, 810, .24850494279526708], [938, 811, .4346436181876547], [938, 812, .2403211224239381], [938, 813, .04014881320170647], [939, 811, .003878639500178961], [939, 812, .2047038150773143], [939, 813, .41157455841171137], [939, 814, .28957529821809164], [939, 815, .08560320920592149], [940, 814, .16385621221760913], [940, 815, .36828320787286745], [940, 816, .33550406688664397], [940, 817, .13164677712134118], [941, 816, .11836297424309958], [941, 817, .32185871977911545], [941, 818, .3799973298161782], [941, 819, .17581896778117206], [942, 818, .07143918326167292], [942, 819, .2705029465809176], [942, 820, .4180894904987747], [942, 821, .22040151023922497], [942, 822, .023261093492508676], [943, 820, .023754358875460287], [943, 821, .22082957274806367], [943, 822, .41735892037093947], [943, 823, .26975946681527463], [943, 824, .07244459405934162], [944, 823, .17462856886910824], [944, 824, .376380003235797], [944, 825, .32258384746152186], [944, 826, .12234695850241085], [945, 825, .12764964491952732], [945, 826, .32754202842781277], [945, 827, .3705351976091778], [945, 828, .17002290467196218], [946, 827, .07705703864783364], [946, 828, .27228373423426855], [946, 829, .4119493110954956], [946, 830, .21796235075295245], [946, 831, .024608216085607083], [947, 829, .025780053026113373], [947, 830, .2190518649272109], [947, 831, .41169318411556594], [947, 832, .27077590916361477], [947, 833, .07732052594065236], [948, 832, .1695115580680664], [948, 833, .36773423672329814], [948, 834, .3275311475162098], [948, 835, .13077893984001213], [949, 834, .11922966876699366], [949, 835, .31565346594837984], [949, 836, .37813100062036553], [949, 837, .17991281790206778], [950, 836, .06510103041600655], [950, 837, .25463712967072577], [950, 838, .4162975451493948], [950, 839, .23222690463246418], [950, 840, .043347365043106205], [951, 838, .010682336294089382], [951, 839, .20025854636251755], [951, 840, .3947874901107556], [951, 841, .2917173663646273], [951, 842, .09950708368621437], [952, 841, .14911244770443477], [952, 842, .3431424199239878], [952, 843, .3480530442639449], [952, 844, .15411315971947762], [953, 843, .0934299055238343], [953, 844, .2830893937829872], [953, 845, .3971235804951196], [953, 846, .20716078374370134], [953, 847, .020137203526012115], [954, 845, .036025540013401365], [954, 846, .22261124110739972], [954, 847, .40630997808531094], [954, 848, .2648205963423913], [954, 849, .07872881878459281], [955, 848, .16692727676480973], [955, 849, .35954874836594064], [955, 850, .328443108696204], [955, 851, .13751082396144756], [956, 850, .11152248261980105], [956, 851, .3006327942159715], [956, 852, .3829521945790107], [956, 853, .1916328343080391], [956, 854, .0076262937092498664], [957, 852, .0514953905500914], [957, 853, .2343500090068106], [957, 854, .41021535649217705], [957, 855, .25030428726128284], [957, 856, .06835964516566889], [958, 855, .17563114080501685], [958, 856, .3667504924135684], [958, 857, .31835263030310357], [958, 858, .1299663000321827], [959, 857, .11940718803292909], [959, 858, .3065438045294419], [959, 859, .37569491987401304], [959, 860, .18605528589059708], [959, 861, .004834820768368334], [960, 859, .05684866493974193], [960, 860, .2366688077210537], [960, 861, .4085057240274029], [960, 862, .24678375999468344], [960, 863, .06783571840441664], [961, 862, .17558642045742334], [961, 863, .36451985113857055], [961, 864, .3173137388508224], [961, 865, .13129392160626782], [962, 864, .11725721455632943], [962, 865, .3008194332920608], [962, 866, .37580301677160466], [962, 867, .19024874552861262], [962, 868, .011245575393110812], [963, 866, .05231298976932004], [963, 867, .23017401181136463], [963, 868, .40175554736854613], [963, 869, .2536595659979476], [963, 870, .07679940668774121], [964, 869, .16706057585212106], [964, 870, .35303258747063304], [964, 871, .3251768586309606], [964, 872, .14116418004635392], [965, 871, .10550294433561781], [965, 872, .28424844668945237], [965, 873, .38249269088982873], [965, 874, .2036626805762719], [965, 875, .02684871916582402], [966, 873, .03836058116912999], [966, 874, .21480488879977247], [966, 875, .389260042863657], [966, 876, .27095452974310497], [966, 877, .09504101254228686], [967, 876, .1502807743955375], [967, 877, .3328577086192332], [967, 878, .3421239629983485], [967, 879, .15918522100542254], [968, 878, .08474515454977341], [968, 879, .25820758590913884], [968, 880, .3938397310124852], [968, 881, .22523159171338067], [968, 882, .05190695217080459], [969, 880, .015820211753405387], [969, 881, .19007905592596833], [969, 882, .36921246833932636], [969, 883, .2980889913883655], [969, 884, .12132017371569158], [970, 883, .1247775639085626], [970, 884, .3015570552958629], [970, 885, .36552163552482225], [970, 886, .18684713857492927], [970, 887, .014284415706242481], [971, 885, .055013622481818666], [971, 886, .2263705108609403], [971, 887, .39186593267986564], [971, 888, .2561333080985603], [971, 889, .08592049273991473], [972, 888, .1575841200944441], [972, 889, .3370827060887002], [972, 890, .33284859953655166], [972, 891, .15390042438231766], [973, 890, .08972988049108406], [973, 891, .2590326783958039], [973, 892, .38812639016604245], [973, 893, .22348813860080616], [973, 894, .054161074977768404], [974, 892, .017081968749935856], [974, 893, .18740927170107446], [974, 894, .3625874079443392], [974, 895, .2990263270079478], [974, 896, .12613079428882987], [975, 895, .11819045745461297], [975, 896, .28905735771716573], [975, 897, .36789499357104777], [975, 898, .19628130377264577], [975, 899, .02735424128922767], [976, 897, .04494375361325131], [976, 898, .21330043570426716], [976, 899, .37902147922066165], [976, 900, .2697531768133337], [976, 901, .10241904377888808], [977, 900, .14130067843136315], [977, 901, .3150246804904708], [977, 902, .3480110183643501], [977, 903, .1725701388645175], [977, 904, .005966983373903607], [978, 902, .06884101502859519], [978, 903, .23351128359258333], [978, 904, .3898863909020141], [978, 905, .24593198700119934], [978, 906, .08224765045066], [979, 905, .1597942440306211], [979, 906, .3346851109670727], [979, 907, .3285973743088808], [979, 908, .15444027476874822], [980, 907, .08792661347585409], [980, 908, .2508895640647832], [980, 909, .38533070676895603], [980, 910, .22893712756876922], [980, 911, .06583953763953361], [981, 909, .01060737785460527], [981, 910, .17530908392596897], [981, 911, .34707093920704996], [981, 912, .3101853041457825], [981, 913, .1404924603408273], [982, 912, .1016482122325276], [982, 913, .2640331008343238], [982, 914, .3757885914855772], [982, 915, .21658719088481612], [982, 916, .05379076081392352], [983, 914, .023321537452804155], [983, 915, .1869789080592518], [983, 916, .35433193126746176], [983, 917, .2960976478285003], [983, 918, .13047091456929613], [984, 917, .11086010315035294], [984, 918, .272590889791831], [984, 919, .3683410258652817], [984, 920, .20801518542415245], [984, 921, .04616290894518408], [985, 919, .03202626907959427], [985, 920, .1942489952348069], [985, 921, .35801621736570555], [985, 922, .2871844809716754], [985, 923, .12448425960359358], [986, 922, .11614980664040801], [986, 923, .2769245860037902], [986, 924, .3634503371272694], [986, 925, .20337777894188264], [986, 926, .04278533591281287], [987, 924, .036633170664026604], [987, 925, .19735437260885233], [987, 926, .3585975660673821], [987, 927, .28298312203941667], [987, 928, .12237172260813765], [988, 927, .11761764880185657], [988, 928, .2769347836061358], [988, 929, .3613222869658947], [988, 930, .20269252495682932], [988, 931, .04352084243134597], [989, 929, .03715658569409518], [989, 930, .19646584076452728], [989, 931, .3563193376763676], [989, 932, .28325914825402143], [989, 933, .12401877287718965], [990, 932, .11535841088563661], [990, 933, .2726772185957825], [990, 934, .36193002492598775], [990, 935, .2058724789923987], [990, 936, .04828585408934835], [991, 934, .03368059076582972], [991, 935, .19166681871807822], [991, 936, .35120102320155516], [991, 937, .2879669101334489], [991, 938, .12934311950798513], [992, 937, .10947528483272252], [992, 938, .2643619456949593], [992, 939, .36503164238003943], [992, 940, .21273290367631378], [992, 941, .05704255868679827], [993, 939, .026351338857843194], [993, 940, .18296002570453515], [993, 941, .3430562989307297], [993, 942, .29724916938947604], [993, 943, .13830626997954892], [994, 942, .10006782116457263], [994, 943, .2523219642979947], [994, 944, .3701807952606593], [994, 945, .22297333198451888], [994, 946, .06976592160365215], [995, 944, .015392306252147629], [995, 945, .17030051412165803], [995, 946, .33152253946088156], [995, 947, .31147369956054877], [995, 948, .1509473916728322], [996, 947, .087196881644584], [996, 948, .2369586950063475], [996, 949, .376718339613223], [996, 950, .2345765114615184], [996, 951, .08521591343298078], [997, 949, .0011357385555340561], [997, 950, .15263475001807864], [997, 951, .311827742306229], [997, 952, .32860504822914505], [997, 953, .16942021655341175], [997, 954, .016626147439510436], [998, 952, .07024774813594223], [998, 953, .2212622403680772], [998, 954, .36621398307130515], [998, 955, .2523140266095425], [998, 956, .10329850546808812], [999, 955, .13345393361930616], [999, 956, .2868146645965228], [999, 957, .3438149621043634], [999, 958, .19052159754051476], [999, 959, .038598535306774456], [1e3, 957, .04874340776161587], [1e3, 958, .20027433884645776], [1e3, 959, .35045072214288214], [1e3, 960, .2752172040116266], [1e3, 961, .1246081801436533], [1001, 960, .11153410463061227], [1001, 961, .25968030157128735], [1001, 962, .3589611456155988], [1001, 963, .21376355164890676], [1001, 964, .06462574300561937], [1002, 962, .024112239164856285], [1002, 963, .1744379670887302], [1002, 964, .32884307142135794], [1002, 965, .3038963549633426], [1002, 966, .14989396525089382], [1002, 967, .002787631885767016], [1003, 965, .08652179776851913], [1003, 966, .23158274748299973], [1003, 967, .37014802862444746], [1003, 968, .23660182809114255], [1003, 969, .09233857620429504], [1004, 968, .14320871996140178], [1004, 969, .2949268298641504], [1004, 970, .33370967770704096], [1004, 971, .1821563205430922], [1004, 972, .03341416685633306], [1005, 970, .05691996613850173], [1005, 971, .2048164607341282], [1005, 972, .34996958396767003], [1005, 973, .26846185022737096], [1005, 974, .12203613352843197], [1006, 973, .11270360292617912], [1006, 974, .2573174820670815], [1006, 975, .35551075517876596], [1006, 976, .21342439841857963], [1006, 977, .06808655521031844], [1007, 975, .02300584415020569], [1007, 976, .1693741701851818], [1007, 977, .31909197071849676], [1007, 978, .3064750144925845], [1007, 979, .1569666027177789], [1007, 980, .01237576860780718], [1008, 978, .07918600624195261], [1008, 979, .22224585329482], [1008, 980, .36060022658704466], [1008, 981, .24542280629144228], [1008, 982, .10372340547250797], [1009, 981, .13025049048804305], [1009, 982, .2755544084078468], [1009, 983, .34173289952302016], [1009, 984, .19757209548510224], [1009, 985, .052414383405106256], [1010, 983, .04055057399599624], [1010, 984, .18602861646793578], [1010, 985, .3325126760154172], [1010, 986, .28836807114447566], [1010, 987, .1417402962688462], [1010, 988, .0007268068329768394], [1011, 986, .0921230324039655], [1011, 987, .23132424535108578], [1011, 988, .3651955312519228], [1011, 989, .23251096307120944], [1011, 990, .09383068210249161], [1012, 989, .1395300348660987], [1012, 990, .2846106560560243], [1012, 991, .33325384799782276], [1012, 992, .18901293891606955], [1012, 993, .045352651706964286], [1013, 991, .0492531143811913], [1013, 992, .19272260635298227], [1013, 993, .33561458168523745], [1013, 994, .27986377343343843], [1013, 995, .13637852619084528], [1014, 994, .09650852938196901], [1014, 995, .2338020594070448], [1014, 996, .36193613166585775], [1014, 997, .22898317334607854], [1014, 998, .09193468643195023], [1015, 996, .002457496874436509], [1015, 997, .14093777570167637], [1015, 998, .28368384860268375], [1015, 999, .33027760738271117], [1015, 1e3, .1884400273628213], [1015, 1001, .046968846655108074], [1016, 999, .04899295849310335], [1016, 1e3, .19034003312195327], [1016, 1001, .3313219755276299], [1016, 1002, .28105052006571385], [1016, 1003, .13948843868730657], [1016, 1004, .0023949943264103815], [1017, 1002, .09296476581718328], [1017, 1003, .22852898102309294], [1017, 1004, .35981389159869226], [1017, 1005, .23289594529521537], [1017, 1006, .09793041579114306], [1018, 1005, .13381394889325862], [1018, 1006, .27358691892030107], [1018, 1007, .33460745416509985], [1018, 1008, .1955825556102765], [1018, 1009, .05665143264068217], [1019, 1007, .040361378819567154], [1019, 1008, .17925977203170015], [1019, 1009, .31806447498945245], [1019, 1010, .2909077306146313], [1019, 1011, .1516962543781077], [1019, 1012, .01525050343287846], [1020, 1010, .08150854362929537], [1020, 1011, .21698349128246774], [1020, 1012, .3497669475500838], [1020, 1013, .24583808157633427], [1020, 1014, .11136370502634059], [1021, 1013, .1194990282921764], [1021, 1014, .25479878825131264], [1021, 1015, .34346022054644576], [1021, 1016, .20933239464254857], [1021, 1017, .07400664151417581], [1022, 1015, .023670383811016393], [1022, 1016, .1594303860158249], [1022, 1017, .29640289279632487], [1022, 1018, .3088876485347881], [1022, 1019, .17249814489158258], [1022, 1020, .03643709112995095], [1023, 1018, .062217701784737935], [1023, 1019, .19815982330648652], [1023, 1020, .3337745723213922], [1023, 1021, .3700921432339217], [1023, 1022, .3700921432339217]];\n\n    function g() {\n      const t = r.buffer([1024, 1024]);\n\n      for (let e = 0; e < m.length; e++) {\n        const n = m[e];\n        t.set(n[2], n[0], n[1]);\n      }\n\n      return t.toTensor();\n    }\n\n    function v(t, e, n) {\n      return r.div(r.sub(t, n), e);\n    }\n\n    async function y(t) {\n      return function (t, e) {\n        const n = t.length,\n              r = t[0].length / 2,\n              o = e.winLength || r,\n              i = e.hopLength || Math.floor(o / 4),\n              s = e.center || !1;\n        let u = Object(a.b)(o);\n\n        for (let t = 0; t < u.length; t++) u[t] = u[t] / 1.5;\n\n        u = Object(a.f)(u, r);\n        const c = r + i * (n - 1),\n              l = new Float32Array(c);\n\n        for (let e = 0; e < n; e++) {\n          const n = e * i;\n          let o = w(t[e]);\n          o = x(o = Object(a.a)(o, u), l.slice(n, n + r)), l.set(o, n);\n        }\n\n        let h = 0,\n            f = c;\n        s ? (h = r / 2, f = l.length - r / 2) : (h = c - p, f = l.length - h);\n        return l.slice(h, f);\n      }(t, {\n        nFFt: d,\n        winLength: d,\n        hopLength: f,\n        sampleRate: h,\n        center: !1\n      });\n    }\n\n    async function b(t) {\n      const e = r.tidy(() => {\n        const e = function (t) {\n          return r.tidy(() => {\n            const e = g().expandDims(0),\n                  n = v(t, s, u),\n                  o = r.exp(n),\n                  i = r.matMul(o, e);\n            return r.sqrt(i);\n          });\n        }(r.slice(t, [0, 0, 0, 0], [1, -1, -1, 1]).reshape([1, 128, 1024])),\n              n = function (t) {\n          return r.tidy(() => {\n            const e = g().expandDims(0),\n                  n = v(t, c, l),\n                  o = r.cumsum(r.mul(n, Math.PI), 1);\n            return r.matMul(o, e);\n          });\n        }(r.slice(t, [0, 0, 0, 1], [1, -1, -1, 1]).reshape([1, 128, 1024]));\n\n        let o = e.mul(r.cos(n));\n        const i = r.reverse(o.slice([0, 0, 0], [1, 128, 1023]), 2);\n        o = r.concat([o, i], 2);\n        let a = e.mul(r.sin(n));\n        const h = r.reverse(a.slice([0, 0, 0], [1, 128, 1023]), 2);\n        return [o, a = r.concat([a, r.mul(h, -1)], 2)];\n      }),\n            n = await function (t, e) {\n        const n = r.tidy(() => {\n          let n = r.concat([t, e], 0).expandDims(3);\n          n = r.pad(n, [[0, 0], [0, 0], [1, 0], [0, 0]]);\n          return r.batchToSpaceND(n, [1, 2], [[0, 0], [0, 0]]).reshape([128, 4096]);\n        }),\n              o = n.dataSync(),\n              i = [];\n\n        for (let t = 0; t < 128; t++) i[t] = o.slice(4096 * t, 4096 * (t + 1));\n\n        return n.dispose(), i;\n      }(e[0], e[1]),\n            o = await y(n);\n      return e.forEach(t => t.dispose()), o;\n    }\n\n    function w(t) {\n      const e = t.length / 2,\n            n = new i(e),\n            r = n.createComplexArray();\n      return n.inverseTransform(r, t), n.fromComplexArray(r);\n    }\n\n    function x(t, e) {\n      if (t.length !== e.length) return console.error(\"Array lengths must be equal to add: \".concat(t.length, \", \").concat(t.length)), null;\n      const n = new Float32Array(t.length);\n\n      for (let r = 0; r < t.length; r++) n[r] = t[r] + e[r];\n\n      return n;\n    }\n\n    class S extends r.layers.Layer {\n      constructor(t = 1e-8, e = {}) {\n        super(e), this.epsilon = t, this.layerConfig = e, this.supportsMasking = !0;\n      }\n\n      computeOutputShape(t) {\n        return [t[0], t[1], t[2], t[3]];\n      }\n\n      call(t) {\n        return r.tidy(() => {\n          let e = t;\n          Array.isArray(e) && (e = e[0]);\n          const n = r.mean(r.square(e), [3], !0);\n          return r.mul(e, r.rsqrt(r.add(n, this.epsilon)));\n        });\n      }\n\n      getClassName() {\n        return \"PixelNorm\";\n      }\n\n    }\n\n    function E(t = 1e-8, e = {}) {\n      return new S(t, e);\n    }\n\n    class C extends r.layers.Layer {\n      constructor(t = 2, e = 16, n = {}) {\n        super(n), this.kernelH = t, this.kernelW = e, this.layerConfig = n, this.supportsMasking = !0;\n      }\n\n      computeOutputShape(t) {\n        return [t[0], 2 * (this.kernelH - 1) + t[1], 2 * (this.kernelW - 1) + t[2], t[3]];\n      }\n\n      call(t) {\n        let e = t;\n        Array.isArray(e) && (e = e[0]);\n        const n = this.kernelH - 1,\n              o = this.kernelW - 1;\n        return r.pad(e, [[0, 0], [n, n], [o, o], [0, 0]]);\n      }\n\n      getClassName() {\n        return \"InitialPad\";\n      }\n\n    }\n\n    class I extends r.layers.Layer {\n      constructor(t = 2) {\n        super({}), this.scale = t, this.supportsMasking = !0;\n      }\n\n      computeOutputShape(t) {\n        return [t[0], this.scale * t[1], this.scale * t[2], t[3]];\n      }\n\n      call(t) {\n        return r.tidy(() => {\n          let e = t;\n          Array.isArray(e) && (e = e[0]);\n          const n = r.tile(e, [this.scale ** 2, 1, 1, 1]);\n          return r.batchToSpaceND(n, [this.scale, this.scale], [[0, 0], [0, 0]]);\n        });\n      }\n\n      getClassName() {\n        return \"BoxUpscale\";\n      }\n\n    }\n\n    function A(t = 2) {\n      return new I(t);\n    }\n\n    class k {\n      constructor(t) {\n        this.nn = r.sequential(), this.nLatents = 256, this.nPitches = 61, this.minMidiPitch = 24, this.maxMidiPitch = 84, this.midiPitches = this.maxMidiPitch - this.minMidiPitch + 1, this.checkpointURL = t;\n      }\n\n      async initialize() {\n        const t = performance.now(),\n              e = await fetch(\"\".concat(this.checkpointURL, \"/weights_manifest.json\")).then(t => t.json()).then(t => r.io.loadWeights(t, this.checkpointURL));\n        r.tidy(() => {\n          for (const t in e) if (t.includes(\"kernel\")) {\n            const n = e[t].shape[0] * e[t].shape[1] * e[t].shape[2],\n                  o = e[t];\n            e[t] = r.mul(o, r.sqrt(2 / n)), o.dispose();\n          }\n\n          this.build(e), this.initialized = !0, o.logWithDuration(\"Initialized model\", t, \"GANSynth\");\n        }), Object.keys(e).map(t => e[t].dispose());\n      }\n\n      dispose() {\n        this.initialized && (this.nn.dispose(), this.initialized = !1);\n      }\n\n      isInitialized() {\n        return this.initialized;\n      }\n\n      build(t) {\n        r.tidy(() => {\n          const e = {\n            filters: 256,\n            kernelSize: [2, 16],\n            strides: [1, 1],\n            activation: \"linear\",\n            useBias: !0,\n            padding: \"valid\",\n            dilationRate: [1, 1],\n            trainable: !1\n          },\n                n = {\n            inputShape: [1, 1, this.nLatents + this.nPitches]\n          };\n          this.nn.add(E(1e-8, n)), this.nn.add(function (t = 2, e = 16, n = {}) {\n            return new C(t, e, n);\n          }(2, 16)), this.nn.add(r.layers.conv2d(e)), this.nn.add(r.layers.leakyReLU({\n            alpha: .2\n          })), this.nn.add(E()), e.padding = \"same\", e.kernelSize = [3, 3], this.nn.add(r.layers.conv2d(e)), this.nn.add(r.layers.leakyReLU({\n            alpha: .2\n          })), this.nn.add(E());\n          const o = [256, 256, 256, 128, 64, 32];\n\n          for (let t = 0; t < o.length; t++) this.nn.add(A(2)), e.filters = o[t], this.nn.add(r.layers.conv2d(e)), this.nn.add(r.layers.leakyReLU({\n            alpha: .2\n          })), this.nn.add(E()), this.nn.add(r.layers.conv2d(e)), this.nn.add(r.layers.leakyReLU({\n            alpha: .2\n          })), this.nn.add(E());\n\n          e.filters = 2, e.kernelSize = [1, 1], e.activation = \"tanh\", this.nn.add(r.layers.conv2d(e)), this.setWeights(t);\n        });\n      }\n\n      setWeights(t) {\n        function e(e) {\n          const n = t[e];\n          if (void 0 === n) throw Error(\"Variable not found: \".concat(e));\n          return n;\n        }\n\n        const n = \"Generator/progressive_gan_generator/progressive_gan_block_\",\n              r = [e(\"\".concat(n, \"1/conv0/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"1/conv0/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"1/conv1/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"1/conv1/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"2/conv0/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"2/conv0/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"2/conv1/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"2/conv1/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"3/conv0/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"3/conv0/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"3/conv1/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"3/conv1/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"4/conv0/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"4/conv0/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"4/conv1/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"4/conv1/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"5/conv0/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"5/conv0/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"5/conv1/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"5/conv1/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"6/conv0/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"6/conv0/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"6/conv1/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"6/conv1/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"7/conv0/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"7/conv0/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"7/conv1/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"7/conv1/bias/ExponentialMovingAverage\")), e(\"\".concat(n, \"7/to_rgb/conv2d/kernel/ExponentialMovingAverage\")), e(\"\".concat(n, \"7/to_rgb/bias/ExponentialMovingAverage\"))];\n        this.nn.setWeights(r);\n      }\n\n      predict(t, e) {\n        return this.nn.predict(t, {\n          batchSize: e\n        });\n      }\n\n      randomSample(t) {\n        return r.tidy(() => {\n          const e = r.randomNormal([1, this.nLatents], 0, 1, \"float32\"),\n                n = r.tensor1d([t - this.minMidiPitch], \"int32\"),\n                o = r.oneHot(n, this.midiPitches),\n                i = r.concat([e, o], 1).expandDims(1).expandDims(1);\n          return this.predict(i, 1);\n        });\n      }\n\n      specgramsToAudio(t) {\n        return b(t);\n      }\n\n    }\n\n    n.d(e, \"GANSynth\", function () {\n      return k;\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(0),\n        o = n(9),\n        i = n(5);\n    const a = 16e3,\n          s = 512,\n          u = s / a,\n          c = 229,\n          l = 21,\n          h = 108 - l + 1;\n    var p = n(2);\n    const f = 3;\n\n    function d(t, e, n) {\n      return 1 === t.shape[0] ? t : r.tidy(() => {\n        const o = t.slice([0, 0], [1, e]);\n        let i = n % e;\n        i <= f && (i += e);\n        const a = t.slice([t.shape[0] - 1, t.shape[1] - i], [-1, -1]);\n        let s = [o, a];\n\n        if (t.shape[0] > 2) {\n          const n = t.shape[0] - 2;\n          s = [o, t.slice([1, f], [n, e]).as3D(1, n * e, -1), a];\n        }\n\n        return r.concat(s, 1);\n      });\n    }\n\n    class m {\n      constructor(t, e = 250) {\n        this.checkpointURL = t, this.chunkLength = e;\n      }\n\n      async initialize() {\n        this.dispose();\n        const t = performance.now(),\n              e = await fetch(\"\".concat(this.checkpointURL, \"/weights_manifest.json\")).then(t => t.json()).then(t => r.io.loadWeights(t, this.checkpointURL));\n        this.build(e), Object.keys(e).map(t => e[t].dispose()), this.initialized = !0, i.logWithDuration(\"Initialized model\", t, \"O&F\");\n      }\n\n      dispose() {\n        this.initialized && (this.onsetsCnn.dispose(), this.onsetsRnn.dispose(), this.activationCnn.dispose(), this.frameRnn.dispose(), this.velocityCnn.dispose(), this.initialized = !1);\n      }\n\n      isInitialized() {\n        return this.initialized;\n      }\n\n      async transcribeFromMelSpec(t, e = 4) {\n        this.isInitialized() || this.initialize();\n        const n = performance.now();\n        i.log(\"Computing onsets, frames, and velocities...\", \"O&F\", 20);\n\n        const _r$tidy = r.tidy(() => {\n          const n = function (t, e) {\n            let n = Math.ceil(t.length / e),\n                o = t.length % e,\n                i = 0;\n            if (n > 1 && o > 0 && o <= f && (n -= 1, i = o, o = 0), 1 === n) return r.tensor2d(t).expandDims(0);\n            const a = e + 2 * f,\n                  s = r.tensor2d(t.slice(0, a)).expandDims(0),\n                  u = r.tensor2d(t.slice(t.length - a)).expandDims(0);\n            if (2 === n) return r.concat([s, u], 0);\n            let c;\n            c = o ? r.tensor2d(t).pad([[0, e - o], [0, 0]]).as3D(n, e, -1) : r.tensor2d(t.slice(0, t.length - i)).as3D(n, e, -1);\n            const l = r.slice(c, [0, e - f], [n - 2, -1]),\n                  h = r.slice(c, [2, 0], [-1, f]),\n                  p = r.concat([l, c.slice(1, n - 2), h], 1);\n            return r.concat([s, p, u], 0);\n          }(t, this.chunkLength);\n\n          return this.processBatches(n, this.chunkLength, t.length, e);\n        }),\n              _r$tidy2 = _slicedToArray(_r$tidy, 3),\n              o = _r$tidy2[0],\n              a = _r$tidy2[1],\n              s = _r$tidy2[2];\n\n        i.log(\"Converting to NoteSequence...\", \"O&F\", 20);\n\n        const c = async function (t, e, n, o = .5, i = .5) {\n          const a = p.a.create(),\n                s = new Uint32Array(h),\n                c = new Uint8Array(h);\n          let f = new Uint8Array(h);\n\n          function d(t, e) {\n            a.notes.push(p.a.Note.create({\n              pitch: t + l,\n              startTime: (s[t] - 1) * u,\n              endTime: e * u,\n              velocity: c[t]\n            })), s[t] = 0;\n          }\n\n          function m(t, e, n) {\n            s[t] ? f[t] || (d(t, e), s[t] = e + 1, c[t] = n) : (s[t] = e + 1, c[t] = n);\n          }\n\n          const g = r.tidy(() => {\n            let a = r.greater(e, o),\n                s = r.greater(t, i);\n            return a = a.pad([[0, 1], [0, 0]]), s = s.pad([[0, 1], [0, 0]]), n = n.pad([[0, 1], [0, 0]]), [s = r.logicalOr(s, a), a, n];\n          }),\n                _ref8 = await Promise.all(g.map(t => t.data())),\n                _ref9 = _slicedToArray(_ref8, 3),\n                v = _ref9[0],\n                y = _ref9[1],\n                b = _ref9[2];\n\n          g.forEach(t => t.dispose());\n          const w = t.shape[0];\n\n          for (let t = 0; t < w + 1; ++t) {\n            for (let e = 0; e < h; ++e) {\n              const n = t * h + e;\n              y[n] ? m(e, t, b[n]) : !v[n] && s[e] && d(e, t);\n            }\n\n            f = y.slice(t * h, (t + 1) * h);\n          }\n\n          return a.totalTime = w * u, a;\n        }(o, a, s);\n\n        return c.then(() => {\n          o.dispose(), a.dispose(), s.dispose(), i.logWithDuration(\"Transcribed from mel spec\", n, \"O&F\");\n        }), c;\n      }\n\n      async transcribeFromAudioBuffer(t, e = 4) {\n        const n = performance.now(),\n              r = async function (t) {\n          const e = await Object(o.h)(t);\n          return Object(o.g)(Object(o.e)(e, {\n            sampleRate: a,\n            hopLength: s,\n            nMels: c,\n            nFft: 2048,\n            fMin: 30\n          }));\n        }(t);\n\n        return r.then(() => i.logWithDuration(\"Converted audio to mel spec\", n, \"O&F\", 20)), r.then(t => this.transcribeFromMelSpec(t.map(t => Array.from(t), e)));\n      }\n\n      async transcribeFromAudioFile(t) {\n        const e = await Object(o.c)(t);\n        return this.transcribeFromAudioBuffer(e);\n      }\n\n      async transcribeFromAudioURL(t) {\n        const e = await Object(o.d)(t);\n        return this.transcribeFromAudioBuffer(e);\n      }\n\n      processBatches(t, e, n, o) {\n        const i = t => [this.onsetsCnn.predict(t, o), this.activationCnn.predict(t, o), this.velocityCnn.predict(t, o)];\n\n        let a, s, u;\n\n        if (1 === t.shape[0]) {\n          var _i2 = i(t.expandDims(-1));\n\n          var _i3 = _slicedToArray(_i2, 3);\n\n          a = _i3[0];\n          s = _i3[1];\n          u = _i3[2];\n        } else {\n          const r = i(t.expandDims(-1)),\n                o = [];\n\n          for (let t = 0; t < 3; ++t) o.push(d(r[t], e, n));\n\n          a = o[0];\n          s = o[1];\n          u = o[2];\n        }\n\n        const c = this.onsetsRnn.predict(a, this.chunkLength);\n        a.dispose();\n        const l = r.concat3d([c, s], -1);\n        s.dispose();\n        const h = this.frameRnn.predict(l, this.chunkLength),\n              p = r.clipByValue(u, 0, 1).mul(r.scalar(80)).add(r.scalar(10)).toInt();\n        return u.dispose(), [h.squeeze(), c.squeeze(), p.squeeze()];\n      }\n\n      build(t) {\n        r.tidy(() => {\n          this.onsetsCnn = new g(), this.onsetsCnn.setWeights(t, \"onsets\"), this.onsetsRnn = new v([null, this.onsetsCnn.outputShape[2]]), this.onsetsRnn.setWeights(t, \"onsets\", \"onset_probs\"), this.activationCnn = new g(\"sigmoid\"), this.activationCnn.setWeights(t, \"frame\", \"activation_probs\"), this.frameRnn = new v([null, 2 * h]), this.frameRnn.setWeights(t, \"frame\", \"frame_probs\"), this.velocityCnn = new g(\"linear\"), this.velocityCnn.setWeights(t, \"velocity\", \"onset_velocities\");\n        });\n      }\n\n    }\n\n    class g {\n      constructor(t) {\n        this.nn = r.sequential();\n        const e = {\n          filters: 48,\n          kernelSize: [3, 3],\n          activation: \"linear\",\n          useBias: !1,\n          padding: \"same\",\n          dilationRate: [1, 1],\n          inputShape: [null, c, 1],\n          trainable: !1\n        },\n              n = {\n          scale: !1,\n          trainable: !1\n        };\n        this.nn.add(r.layers.conv2d(e)), this.nn.add(r.layers.batchNormalization(n)), this.nn.add(r.layers.activation({\n          activation: \"relu\"\n        })), e.inputShape = null, this.nn.add(r.layers.conv2d(e)), this.nn.add(r.layers.batchNormalization(n)), this.nn.add(r.layers.activation({\n          activation: \"relu\"\n        })), this.nn.add(r.layers.maxPooling2d({\n          poolSize: [1, 2],\n          strides: [1, 2]\n        })), e.filters = 96, this.nn.add(r.layers.conv2d(e)), this.nn.add(r.layers.batchNormalization(n)), this.nn.add(r.layers.activation({\n          activation: \"relu\"\n        })), this.nn.add(r.layers.maxPooling2d({\n          poolSize: [1, 2],\n          strides: [1, 2]\n        }));\n        const o = this.nn.outputShape;\n        this.nn.add(r.layers.reshape({\n          targetShape: [o[1], o[2] * o[3]]\n        })), this.nn.add(r.layers.dense({\n          units: 768,\n          activation: \"relu\",\n          trainable: !1\n        })), t && this.nn.add(r.layers.dense({\n          units: h,\n          activation: t,\n          trainable: !1\n        })), this.outputShape = this.nn.outputShape;\n      }\n\n      dispose() {\n        this.nn.dispose();\n      }\n\n      predict(t, e) {\n        return this.nn.predict(t, {\n          batchSize: e\n        });\n      }\n\n      setWeights(t, e, n) {\n        function r(e) {\n          const n = t[e];\n          if (void 0 === n) throw Error(\"Variable not found: \".concat(e));\n          return n;\n        }\n\n        let o = [r(\"\".concat(e, \"/conv0/weights\")), r(\"\".concat(e, \"/conv0/BatchNorm/beta\")), r(\"\".concat(e, \"/conv0/BatchNorm/moving_mean\")), r(\"\".concat(e, \"/conv0/BatchNorm/moving_variance\")), r(\"\".concat(e, \"/conv1/weights\")), r(\"\".concat(e, \"/conv1/BatchNorm/beta\")), r(\"\".concat(e, \"/conv1/BatchNorm/moving_mean\")), r(\"\".concat(e, \"/conv1/BatchNorm/moving_variance\")), r(\"\".concat(e, \"/conv2/weights\")), r(\"\".concat(e, \"/conv2/BatchNorm/beta\")), r(\"\".concat(e, \"/conv2/BatchNorm/moving_mean\")), r(\"\".concat(e, \"/conv2/BatchNorm/moving_variance\")), r(\"\".concat(e, \"/fc_end/weights\")), r(\"\".concat(e, \"/fc_end/biases\"))];\n        n && (o = o.concat([r(\"\".concat(e, \"/\").concat(n, \"/weights\")), r(\"\".concat(e, \"/\").concat(n, \"/biases\"))])), this.nn.setWeights(o);\n      }\n\n    }\n\n    class v {\n      constructor(t, e = 384) {\n        this.dense = r.sequential(), this.units = e, this.lstm = function () {\n          const n = r.layers.lstm({\n            inputShape: t,\n            units: e,\n            returnSequences: !0,\n            recurrentActivation: \"sigmoid\",\n            returnState: !0,\n            kernelInitializer: \"zeros\",\n            recurrentInitializer: \"zeros\",\n            biasInitializer: \"zeros\",\n            trainable: !1\n          }),\n                o = [r.input({\n            shape: t\n          }), r.input({\n            shape: [e]\n          }), r.input({\n            shape: [e]\n          })],\n                i = n.apply(o);\n          return r.model({\n            inputs: o,\n            outputs: i\n          });\n        }(), this.dense.add(r.layers.dense({\n          inputShape: [null, e],\n          units: h,\n          activation: \"sigmoid\",\n          trainable: !1\n        }));\n      }\n\n      dispose() {\n        this.lstm.dispose(), this.dense.dispose();\n      }\n\n      setWeights(t, e, n) {\n        function o(e) {\n          const n = t[e];\n          if (void 0 === n) throw Error(\"Variable not found: \".concat(e));\n          return n;\n        }\n\n        const i = (t, e = 0) => {\n          const _r$split = r.split(t, 4, -1),\n                _r$split2 = _slicedToArray(_r$split, 4),\n                n = _r$split2[0],\n                o = _r$split2[1],\n                i = _r$split2[2],\n                a = _r$split2[3];\n\n          return r.concat([n, i.add(r.scalar(e)), o, a], -1);\n        },\n              a = t => r.split(i(t), [t.shape[0] - this.units, this.units]),\n              s = \"cudnn_lstm/rnn/multi_rnn_cell/cell_0/cudnn_compatible_lstm_cell\";\n\n        (t => t.setWeights(a(o(\"\".concat(e, \"/\").concat(s, \"/kernel\"))).concat(i(o(\"\".concat(e, \"/\").concat(s, \"/bias\")), 1))))(this.lstm), this.dense.setWeights([o(\"\".concat(e, \"/\").concat(n, \"/weights\")), o(\"\".concat(e, \"/\").concat(n, \"/biases\"))]);\n      }\n\n      predict(t, e) {\n        return r.tidy(() => this.predictImpl(t, e));\n      }\n\n      predictImpl(t, e) {\n        const n = t.shape[1],\n              o = Math.ceil(n / e);\n        let i = [r.zeros([1, this.units]), r.zeros([1, this.units])];\n        const a = [];\n\n        for (let n = 0; n < o; ++n) {\n          const r = t.slice([0, n * e], [-1, n < o - 1 ? e : -1]),\n                s = this.lstm.predict([r, i[0], i[1]]);\n          a.push(this.dense.predict(s[0])), i = s.slice(1);\n        }\n\n        return 1 === a.length ? a[0] : r.concat3d(a, 1);\n      }\n\n    }\n\n    n.d(e, \"OnsetsAndFrames\", function () {\n      return m;\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(4),\n        o = n(5),\n        i = n(6),\n        a = n(2);\n    const s = /iPad|iPhone|iPod/.test(navigator.userAgent),\n          u = 46,\n          c = 36,\n          l = 4;\n    const h = {\n      useSoftmaxLoss: !0,\n      batchNormVarianceEpsilon: 1e-7,\n      numInstruments: 4,\n      numFilters: 128,\n      numLayers: 33,\n      numRegularConvLayers: 0,\n      dilation: [[1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32], [1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32], [1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32], [1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32], [1, 1], [2, 2], [4, 4], [8, 8], [16, 16], [16, 32]],\n      layers: null,\n      interleaveSplitEveryNLayers: 16,\n      numPointwiseSplits: 4\n    };\n\n    class p {\n      constructor(t, e) {\n        this.residualPeriod = 2, this.outputForResidual = null, this.residualCounter = -1, this.rawVars = null, this.spec = t, this.rawVars = e;\n      }\n\n      dispose() {\n        null !== this.rawVars && r.i(this.rawVars), this.outputForResidual && this.outputForResidual.dispose();\n      }\n\n      predictFromPianoroll(t, e) {\n        return r.v(() => {\n          let n = this.getConvnetInput(t, e);\n          const r = this.spec.layers.length;\n\n          for (let t = 0; t < r; t++) {\n            this.residualCounter += 1, this.residualSave(n);\n            let e = null;\n            this.spec.interleaveSplitEveryNLayers && t > 0 && t < r - 2 && t % (this.spec.interleaveSplitEveryNLayers + 1) == 0 && (e = this.spec.numPointwiseSplits), n = this.applyConvolution(n, this.spec.layers[t], t, t >= this.spec.numRegularConvLayers, e), n = this.applyResidual(n, 0 === t, t === r - 1, t), n = this.applyActivation(n, this.spec.layers[t], t), n = this.applyPooling(n, this.spec.layers[t], t);\n          }\n\n          return this.computePredictions(n);\n        });\n      }\n\n      computePredictions(t) {\n        return this.spec.useSoftmaxLoss ? t.transpose([0, 1, 3, 2]).softmax().transpose([0, 1, 3, 2]) : t.sigmoid();\n      }\n\n      residualReset() {\n        this.outputForResidual = null, this.residualCounter = 0;\n      }\n\n      residualSave(t) {\n        this.residualCounter % this.residualPeriod == 1 && (this.outputForResidual = t);\n      }\n\n      applyResidual(t, e, n, r) {\n        return null == this.outputForResidual ? t : this.outputForResidual.shape[this.outputForResidual.shape.length - 1] !== t.shape[t.shape.length - 1] ? (this.residualReset(), t) : (this.residualCounter % this.residualPeriod == 0 && (e || n || (t = t.add(this.outputForResidual))), t);\n      }\n\n      getVar(t, e) {\n        const n = \"model/conv\".concat(e, \"/\").concat(t);\n        return this.rawVars[n];\n      }\n\n      getSepConvVar(t, e) {\n        const n = \"model/conv\".concat(e, \"/SeparableConv2d/\").concat(t);\n        return this.rawVars[n];\n      }\n\n      getPointwiseSplitVar(t, e, n) {\n        const r = \"model/conv\".concat(e, \"/split_\").concat(e, \"_\").concat(n, \"/\").concat(t);\n        return this.rawVars[r];\n      }\n\n      applyConvolution(t, e, n, o, i) {\n        if (null == e.filters) return t;\n        const a = e.filters,\n              s = e.convStride || 1,\n              u = e.convPad ? e.convPad.toLowerCase() : \"same\";\n        let c = null;\n\n        if (o) {\n          const o = this.getSepConvVar(\"depthwise_weights\", n);\n\n          if (i) {\n            c = r.h(t, o, [s, s], u, \"NHWC\", e.dilation);\n            const l = r.s(c, i, c.rank - 1),\n                  h = [];\n\n            for (let t = 0; t < i; t++) {\n              const e = a[3] / i,\n                    o = this.getPointwiseSplitVar(\"kernel\", n, t),\n                    s = this.getPointwiseSplitVar(\"bias\", n, t),\n                    u = r.k(l[t].reshape([-1, e]), o, !1, !1),\n                    c = r.a(u, s);\n              h.push(c.reshape([l[t].shape[0], l[t].shape[1], l[t].shape[2], e]));\n            }\n\n            c = r.e(h, c.rank - 1);\n          } else {\n            const i = this.getSepConvVar(\"pointwise_weights\", n),\n                  a = this.getSepConvVar(\"biases\", n);\n            c = r.r(t, o, i, [s, s], u, e.dilation, \"NHWC\").add(a);\n          }\n        } else {\n          const o = this.getVar(\"weights\", n),\n                i = e.convStride || 1,\n                a = e.convPad ? e.convPad.toLowerCase() : \"same\";\n          c = r.f(t, o, [i, i], a, \"NHWC\", [1, 1]);\n        }\n\n        return this.applyBatchnorm(c, n);\n      }\n\n      applyBatchnorm(t, e) {\n        const n = this.getVar(\"gamma\", e),\n              o = this.getVar(\"beta\", e),\n              i = this.getVar(\"popmean\", e),\n              a = this.getVar(\"popvariance\", e);\n\n        if (s) {\n          const e = a.arraySync()[0][0][0],\n                s = r.u(e.map(t => Math.sqrt(t + this.spec.batchNormVarianceEpsilon)));\n          return t.sub(i).mul(n.div(s)).add(o);\n        }\n\n        return r.b(t, r.t(i), r.t(a), r.t(o), r.t(n), this.spec.batchNormVarianceEpsilon);\n      }\n\n      applyActivation(t, e, n) {\n        return \"identity\" === e.activation ? t : t.relu();\n      }\n\n      applyPooling(t, e, n) {\n        if (null == e.pooling) return t;\n        const o = e.pooling,\n              i = e.poolPad ? e.poolPad.toLowerCase() : \"same\";\n        return r.l(t, [o[0], o[1]], [o[0], o[1]], i);\n      }\n\n      getConvnetInput(t, e) {\n        return t = r.q(1, \"float32\").sub(e).mul(t), e = r.q(1, \"float32\").sub(e), t.concat(e, 3);\n      }\n\n    }\n\n    class f {\n      constructor(t) {\n        this.spec = null, this.initialized = !1, this.checkpointURL = t, this.spec = h;\n      }\n\n      async initialize() {\n        this.dispose();\n        const t = performance.now();\n        this.instantiateFromSpec();\n        const e = await fetch(\"\".concat(this.checkpointURL, \"/weights_manifest.json\")).then(t => t.json()).then(t => r.j.loadWeights(t, this.checkpointURL));\n        this.convnet = new p(this.spec, e), this.initialized = !0, o.logWithDuration(\"Initialized model\", t, \"Coconet\");\n      }\n\n      dispose() {\n        this.convnet && this.convnet.dispose(), this.initialized = !1;\n      }\n\n      isInitialized() {\n        return this.initialized;\n      }\n\n      instantiateFromSpec() {\n        this.spec.layers = [], this.spec.layers.push({\n          filters: [3, 3, 2 * this.spec.numInstruments, this.spec.numFilters]\n        });\n\n        for (let t = 0; t < this.spec.numLayers - 3; t++) this.spec.layers.push({\n          filters: [3, 3, this.spec.numFilters, this.spec.numFilters],\n          dilation: this.spec.dilation ? this.spec.dilation[t] : null\n        });\n\n        this.spec.layers.push({\n          filters: [2, 2, this.spec.numFilters, this.spec.numFilters]\n        }), this.spec.layers.push({\n          filters: [2, 2, this.spec.numFilters, this.spec.numInstruments],\n          activation: \"identity\"\n        });\n      }\n\n      async infill(t, e) {\n        if (i.assertIsRelativeQuantizedSequence(t), 0 === t.notes.length) throw new Error(\"NoteSequence \".concat(t.id, \" does not have any notes to infill.\"));\n\n        const n = t.totalQuantizedSteps || t.notes[t.notes.length - 1].quantizedEndStep,\n              s = function (t, e) {\n          const n = r.v(() => r.y([e, u, l]).arraySync());\n          return t.notes.forEach(r => {\n            const i = r.pitch - c,\n                  a = r.quantizedStartStep,\n                  s = r.quantizedEndStep - r.quantizedStartStep,\n                  u = r.instrument;\n            if (u < 0 || u >= l) o.log(\"Found invalid voice \".concat(u, \". Skipping.\"), \"Coconet\", 5);else {\n              if (a + s > e) throw new Error(\"NoteSequence \".concat(t.id, \" has notes that are longer than the sequence's\\n          totalQuantizedSteps.\"));\n\n              for (let t = a; t < a + s; t++) n[t][i][u] = 1;\n            }\n          }), r.u([n]);\n        }(t, n);\n\n        let h,\n            p = .99,\n            f = 96;\n        e ? (f = e.numIterations || f, p = e.temperature || p, h = this.getCompletionMaskFromInput(e.infillMask, s)) : h = this.getCompletionMask(s);\n\n        const d = await this.run(s, f, p, h),\n              m = function (t, e) {\n          const n = r.v(() => t.reshape([e, u, l]).arraySync()),\n                o = a.a.create(),\n                i = [];\n\n          for (let t = 0; t < e; t++) for (let e = 0; e < u; e++) for (let r = 0; r < l; r++) {\n            if (1 === n[t][e][r]) {\n              const n = a.a.Note.create({\n                pitch: e + c,\n                instrument: r,\n                quantizedStartStep: t,\n                quantizedEndStep: t + 1\n              });\n              i.push(n);\n            }\n          }\n\n          return o.notes = i, o.totalQuantizedSteps = i[i.length - 1].quantizedEndStep, o.quantizationInfo = {\n            stepsPerQuarter: 4\n          }, o;\n        }(d, n);\n\n        return s.dispose(), d.dispose(), h.dispose(), m;\n      }\n\n      async run(t, e, n, r) {\n        return this.gibbs(t, e, n, r);\n      }\n\n      getCompletionMaskFromInput(t, e) {\n        if (t) {\n          const n = r.c([e.shape[1], 4]);\n\n          for (let e = 0; e < t.length; e++) n.set(1, t[e].step, t[e].voice);\n\n          return r.v(() => n.toTensor().expandDims(1).tile([1, u, 1]).expandDims(0));\n        }\n\n        return this.getCompletionMask(e);\n      }\n\n      getCompletionMask(t) {\n        return r.v(() => {\n          const e = t.sum(2, !0).equal(r.q(0, \"float32\"));\n          return r.d(e, \"float32\").add(r.z(t));\n        });\n      }\n\n      async gibbs(t, e, n, o) {\n        const i = r.q(e, \"float32\");\n        let a = t.clone();\n\n        for (let t = 0; t < e; t++) {\n          const e = this.yaoSchedule(t, i),\n                s = this.bernoulliMask(a.shape, e, o);\n          await r.m();\n          const u = r.v(() => this.convnet.predictFromPianoroll(a, s));\n          await r.m(), a = r.v(() => {\n            const t = this.samplePredictions(u, n),\n                  o = r.x(r.d(s, \"bool\"), t, a);\n            return a.dispose(), u.dispose(), s.dispose(), e.dispose(), o;\n          }), await r.m();\n        }\n\n        return i.dispose(), a;\n      }\n\n      yaoSchedule(t, e) {\n        return r.v(() => {\n          const n = r.q(.1, \"float32\"),\n                o = r.q(.9, \"float32\"),\n                i = r.q(.7, \"float32\"),\n                a = o.sub(n).mul(r.q(t, \"float32\")).div(e),\n                s = o.sub(a).div(i);\n          return n.reshape([1]).concat(s.reshape([1])).max();\n        });\n      }\n\n      bernoulliMask(t, e, n) {\n        return r.v(() => {\n          const _t2 = _slicedToArray(t, 4),\n                o = _t2[0],\n                i = _t2[1],\n                a = _t2[2],\n                s = _t2[3],\n                u = r.w(r.p([o, i, 1, s], 0, 1, \"float32\"), [1, 1, a, 1]).less(e);\n\n          return r.d(u, \"float32\").mul(n);\n        });\n      }\n\n      samplePredictions(t, e) {\n        return r.v(() => {\n          t = r.o(t, r.q(1 / e, \"float32\"));\n          const n = r.g(t, 2, !1, !1),\n                o = n.slice([0, 0, n.shape[2] - 1, 0], [n.shape[0], n.shape[1], 1, n.shape[3]]),\n                i = r.p(o.shape, 0, 1, \"float32\").mul(o).less(n).argMax(2);\n          return r.n(i.flatten(), t.shape[2], 1, 0).reshape([t.shape[0], t.shape[1], t.shape[3], t.shape[2]]).transpose([0, 1, 3, 2]);\n        });\n      }\n\n    }\n\n    n.d(e, \"Coconet\", function () {\n      return f;\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(0),\n        o = n(5);\n\n    class i extends r.layers.Layer {\n      constructor() {\n        super({});\n      }\n\n      computeOutputShape(t) {\n        return t[0];\n      }\n\n      call(t) {\n        return r.tidy(() => {\n          const _t3 = _slicedToArray(t, 2),\n                e = _t3[0],\n                n = _t3[1];\n\n          return r.add(r.mul(r.randomNormal(n.shape), n), e);\n        });\n      }\n\n      getClassName() {\n        return \"SamplingLayer\";\n      }\n\n    }\n\n    class a {\n      constructor(t = {}) {\n        this.trained = !1, this.initialized = !1, this.config = {\n          encoder_layers: t.encoder_layers || [1024, 256, 64],\n          decoder_layers: t.decoder_layers || [64, 256, 1024],\n          input_size: t.input_size || 256,\n          latent_size: t.latent_size || 4,\n          beta: t.beta || 1,\n          epochs: t.epochs || 10\n        };\n      }\n\n      dispose() {\n        this.initialized && (this.encoder.dispose(), this.decoder.dispose(), this.vae.dispose(), this.initialized = !1);\n      }\n\n      initialize() {\n        this.dispose();\n        const t = performance.now(),\n              e = r.input({\n          shape: [this.config.input_size]\n        });\n        this.encoder = this.getEncoder(e);\n\n        const _this$encoder$apply = this.encoder.apply(e),\n              _this$encoder$apply2 = _slicedToArray(_this$encoder$apply, 2),\n              n = _this$encoder$apply2[0];\n\n        this.decoder = this.getDecoder(n.shape.slice(1));\n        const i = this.decoder.apply(n);\n        this.vae = r.model({\n          inputs: e,\n          outputs: i,\n          name: \"vae\"\n        }), this.initialized = !0, o.logWithDuration(\"Initialized model\", t, \"MidiMe\");\n      }\n\n      async train(t, e) {\n        const n = performance.now();\n        this.trained = !1;\n        let i = .001;\n        !1 === r.ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\") && !1 === r.ENV.get(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\") && 1 === r.ENV.get(\"WEBGL_VERSION\") && (i = 5e-5);\n        const a = r.train.adam(i);\n\n        for (let n = 0; n < this.config.epochs; n++) await r.nextFrame(), await a.minimize(() => r.tidy(() => {\n          const _this$encoder$predict = this.encoder.predict(t),\n                _this$encoder$predict2 = _slicedToArray(_this$encoder$predict, 3),\n                r = _this$encoder$predict2[1],\n                o = _this$encoder$predict2[2],\n                i = this.vae.predict(t),\n                a = this.loss(r, o, i, t);\n\n          return e && e(n, {\n            y: i,\n            total: a.totalLoss.arraySync(),\n            losses: [a.reconLoss.arraySync(), a.latentLoss.arraySync()]\n          }), a.totalLoss;\n        })), await r.nextFrame();\n\n        o.logWithDuration(\"Training finished\", n, \"MidiMe\"), this.trained = !0, a.dispose();\n      }\n\n      async sample(t = 1) {\n        return this.initialized || (await this.initialize()), r.tidy(() => {\n          const e = r.randomNormal([t, this.config.latent_size]);\n          return this.decoder.predict(e);\n        });\n      }\n\n      async decode(t) {\n        return this.initialized || (await this.initialize()), this.decoder.predict(t);\n      }\n\n      async encode(t) {\n        this.initialized || (await this.initialize());\n\n        const _this$encoder$predict3 = this.encoder.predict(t),\n              _this$encoder$predict4 = _slicedToArray(_this$encoder$predict3, 2),\n              e = _this$encoder$predict4[0];\n\n        return e;\n      }\n\n      predict(t) {\n        return this.vae.predict(t);\n      }\n\n      getEncoder(t) {\n        let e = t;\n\n        for (let t = 0; t < this.config.encoder_layers.length; t++) e = r.layers.dense({\n          units: this.config.encoder_layers[t],\n          activation: \"relu\"\n        }).apply(e);\n\n        const n = this.getAffineLayers(e, this.config.latent_size, t, !1),\n              o = this.getAffineLayers(e, this.config.latent_size, t, !0),\n              a = new i().apply([n, o]);\n        return r.model({\n          inputs: t,\n          outputs: [a, n, o],\n          name: \"encoder\"\n        });\n      }\n\n      getDecoder(t) {\n        const e = r.input({\n          shape: t\n        });\n        let n = e;\n\n        for (let t = 0; t < this.config.decoder_layers.length; t++) n = r.layers.dense({\n          units: this.config.decoder_layers[t],\n          activation: \"relu\"\n        }).apply(n);\n\n        const o = this.getAffineLayers(n, this.config.input_size, e, !1);\n        return r.model({\n          inputs: e,\n          outputs: o,\n          name: \"decoder\"\n        });\n      }\n\n      loss(t, e, n, o) {\n        return r.tidy(() => {\n          const i = this.klLoss(t, e),\n                a = this.reconstructionLoss(o, n);\n          return {\n            latentLoss: i,\n            reconLoss: a,\n            totalLoss: r.add(a, r.mul(i, this.config.beta))\n          };\n        });\n      }\n\n      reconstructionLoss(t, e) {\n        return r.tidy(() => {\n          const n = r.pow(r.sub(t, e), 2),\n                o = r.div(n, r.mul(2, r.pow(r.ones([1]), 2)));\n          return r.mean(r.sum(o, -1));\n        });\n      }\n\n      klLoss(t, e) {\n        return r.tidy(() => {\n          const n = r.pow(t, 2),\n                o = r.pow(e, 2),\n                i = r.add(1, r.log(o)),\n                a = r.add(n, o),\n                s = r.sub(i, a),\n                u = r.div(r.mean(r.sum(s, -1)), 2);\n          return r.mul(-1, u);\n        });\n      }\n\n      getAffineLayers(t, e, n, o) {\n        const i = r.layers.dense({\n          units: e\n        }).apply(t);\n        return o ? r.layers.activation({\n          activation: \"softplus\"\n        }).apply(i) : i;\n      }\n\n    }\n\n    var s = n(16),\n        u = n(1),\n        c = n(10);\n\n    class l {\n      constructor(t, e) {\n        if (void 0 === t) throw Error(\"`kernel` is undefined.\");\n        if (void 0 === e) throw Error(\"`bias` is undefined.\");\n        this.kernel = t, this.bias = e;\n      }\n\n    }\n\n    function h(t, e) {\n      return e.matMul(t.kernel).add(t.bias);\n    }\n\n    class p {}\n\n    class f extends p {\n      constructor(t, e, n) {\n        super(), this.lstmFwVars = t, this.lstmBwVars = e, this.muVars = n, this.zDims = n ? this.muVars.bias.shape[0] : null;\n      }\n\n      encode(t, e) {\n        if (e) throw new Error(\"Variable-length segments not supported in flat encoder\");\n        return r.tidy(() => {\n          const e = this.singleDirection(t, !0),\n                n = this.singleDirection(t, !1),\n                o = r.concat([e[1], n[1]], 1);\n          return this.muVars ? h(this.muVars, o) : o;\n        });\n      }\n\n      singleDirection(t, e) {\n        const n = t.shape[0],\n              o = t.shape[1],\n              i = e ? this.lstmFwVars : this.lstmBwVars;\n        let a = [r.zeros([n, i.bias.shape[0] / 4]), r.zeros([n, i.bias.shape[0] / 4])];\n\n        const s = r.scalar(1),\n              u = (t, e) => r.basicLSTMCell(s, i.kernel, i.bias, t, e[0], e[1]),\n              c = r.split(t.toFloat(), o, 1);\n\n        for (const t of e ? c : c.reverse()) a = u(t.squeeze([1]), a);\n\n        return a;\n      }\n\n    }\n\n    class d extends p {\n      constructor(t, e, n) {\n        super(), this.baseEncoders = t, this.numSteps = e, this.muVars = n, this.zDims = this.muVars.bias.shape[0];\n      }\n\n      encode(t, e) {\n        if (e) {\n          if (1 !== t.shape[0]) throw new Error(\"When using variable-length segments, batch size must be 1.\");\n          if (e.length !== this.numSteps[0]) throw new Error(\"Must provide length for all variable-length segments.\");\n        }\n\n        return r.tidy(() => {\n          let n = t;\n\n          for (let t = 0; t < this.baseEncoders.length; ++t) {\n            const o = this.numSteps[t],\n                  i = r.split(n, o, 1),\n                  a = [];\n\n            for (let n = 0; n < o; ++n) a.push(this.baseEncoders[t].encode(0 === t && e ? r.slice3d(i[n], [0, 0, 0], [1, e[n], -1]) : i[n]));\n\n            n = r.stack(a, 1);\n          }\n\n          return h(this.muVars, n.squeeze([1]));\n        });\n      }\n\n    }\n\n    function m(t, e, n) {\n      const o = [],\n            i = [],\n            a = [],\n            s = r.split(h(n, t).tanh(), 2 * e.length, 1);\n\n      for (let t = 0; t < e.length; ++t) {\n        const n = e[t],\n              u = r.scalar(1);\n        o.push((t, e, o) => r.basicLSTMCell(u, n.kernel, n.bias, t, e, o)), i.push(s[2 * t]), a.push(s[2 * t + 1]);\n      }\n\n      return {\n        cell: o,\n        c: i,\n        h: a\n      };\n    }\n\n    class g {}\n\n    class v extends g {\n      constructor(t, e, n, r) {\n        super(), this.lstmCellVars = t, this.zToInitStateVars = e, this.outputProjectVars = n, this.zDims = this.zToInitStateVars.kernel.shape[0], this.outputDims = r || n.bias.shape[0];\n      }\n\n      decode(t, e, n, o, i) {\n        const a = t.shape[0];\n        return r.tidy(() => {\n          const s = m(t, this.lstmCellVars, this.zToInitStateVars),\n                u = [];\n          let c = n || r.zeros([a, this.outputDims]);\n          const l = i ? r.split(r.tile(i, [a, 1]), i.shape[0]) : void 0;\n\n          for (let n = 0; n < e; ++n) {\n            const e = l ? [c, t, l[n]] : [c, t];\n\n            var _r$multiRNNCell = r.multiRNNCell(s.cell, r.concat(e, 1), s.c, s.h);\n\n            var _r$multiRNNCell2 = _slicedToArray(_r$multiRNNCell, 2);\n\n            s.c = _r$multiRNNCell2[0];\n            s.h = _r$multiRNNCell2[1];\n            const i = h(this.outputProjectVars, s.h[s.h.length - 1]);\n            c = this.sample(i, o), u.push(c);\n          }\n\n          return r.stack(u, 1);\n        });\n      }\n\n    }\n\n    class y extends v {\n      sample(t, e) {\n        const n = t,\n              o = e ? r.multinomial(n.div(r.scalar(e)), 1).as1D() : n.argMax(1).as1D();\n        return r.oneHot(o, this.outputDims).toFloat();\n      }\n\n    }\n\n    class b extends v {\n      constructor(t, e, n, r) {\n        super(t, e, n, r.numDims), this.nade = r;\n      }\n\n      sample(t, e) {\n        const _r$split3 = r.split(t, [this.nade.numHidden, this.nade.numDims], 1),\n              _r$split4 = _slicedToArray(_r$split3, 2),\n              n = _r$split4[0],\n              o = _r$split4[1];\n\n        return this.nade.sample(n, o);\n      }\n\n    }\n\n    class w extends v {\n      sample(t, e) {\n        let _r$split5 = r.split(t, 3, 1),\n            _r$split6 = _slicedToArray(_r$split5, 3),\n            n = _r$split6[0],\n            o = _r$split6[1],\n            i = _r$split6[2];\n\n        if (o = r.sigmoid(o), i = r.tanh(i), e) {\n          n = r.sigmoid(n.div(r.scalar(e)));\n          const t = r.randomUniform(n.shape, 0, 1);\n          n = r.greater(n, t).toFloat();\n        } else n = r.greater(r.sigmoid(n), .5).toFloat();\n\n        return r.concat([n, o, i], 1);\n      }\n\n    }\n\n    class x extends g {\n      constructor(t, e, n, r) {\n        super(), this.coreDecoders = t, this.lstmCellVars = e, this.zToInitStateVars = n, this.numSteps = r, this.zDims = this.zToInitStateVars.kernel.shape[0], this.outputDims = this.coreDecoders.reduce((t, e) => t + e.outputDims, 0);\n      }\n\n      decode(t, e, n, o, i) {\n        const a = t.shape[0];\n        return r.tidy(() => {\n          const n = m(t, this.lstmCellVars, this.zToInitStateVars),\n                s = [];\n          let u = this.coreDecoders.map(t => void 0);\n          const c = r.zeros([a, 1]),\n                l = i ? r.split(i, this.numSteps) : void 0;\n\n          for (let t = 0; t < this.numSteps; ++t) {\n            var _r$multiRNNCell3 = r.multiRNNCell(n.cell, c, n.c, n.h);\n\n            var _r$multiRNNCell4 = _slicedToArray(_r$multiRNNCell3, 2);\n\n            n.c = _r$multiRNNCell4[0];\n            n.h = _r$multiRNNCell4[1];\n            const i = [];\n\n            for (let r = 0; r < this.coreDecoders.length; ++r) i.push(this.coreDecoders[r].decode(n.h[n.h.length - 1], e / this.numSteps, u[r], o, l ? l[t] : void 0));\n\n            s.push(r.concat(i, -1)), u = i.map(t => t.slice([0, t.shape[1] - 1, 0], [a, 1, t.shape[t.rank - 1]]).squeeze([1]).toFloat());\n          }\n\n          return r.concat(s, 1);\n        });\n      }\n\n    }\n\n    class S {\n      constructor(t, e) {\n        this.numDims = t.shape[0], this.numHidden = t.shape[2], this.encWeights = t.as2D(this.numDims, this.numHidden), this.decWeightsT = e.as2D(this.numDims, this.numHidden);\n      }\n\n      sample(t, e) {\n        const n = t.shape[0];\n        return r.tidy(() => {\n          const o = [];\n          let i = t.clone();\n\n          for (let t = 0; t < this.numDims; t++) {\n            const a = r.sigmoid(i),\n                  s = this.encWeights.slice([t, 0], [1, this.numHidden]).as1D(),\n                  u = this.decWeightsT.slice([t, 0], [1, this.numHidden]),\n                  c = e.slice([0, t], [n, 1]).add(r.matMul(a, u, !1, !0)).sigmoid().greaterEqual(r.scalar(.5)).toFloat().as1D();\n            t < this.numDims - 1 && (i = i.add(r.outerProduct(c.toFloat(), s))), o.push(c);\n          }\n\n          return r.stack(o, 1);\n        });\n      }\n\n    }\n\n    class E {\n      constructor(t, e) {\n        this.initialized = !1, this.checkpointURL = t, this.spec = e;\n      }\n\n      instantiateFromSpec() {\n        this.dataConverter = c.converterFromSpec(this.spec.dataConverter), this.chordEncoder = this.spec.chordEncoder ? s.chordEncoderFromType(this.spec.chordEncoder) : void 0;\n      }\n\n      dispose() {\n        void 0 !== this.rawVars && Object.keys(this.rawVars).forEach(t => this.rawVars[t].dispose()), this.encoder = void 0, this.decoder = void 0, this.initialized = !1;\n      }\n\n      getLstmLayers(t, e) {\n        const n = [];\n        let r = 0;\n\n        for (;;) {\n          const o = t.replace(\"%d\", r.toString());\n          if (!(o + \"kernel\" in e)) break;\n          n.push(new l(e[o + \"kernel\"], e[o + \"bias\"])), ++r;\n        }\n\n        return n;\n      }\n\n      async initialize() {\n        this.dispose();\n        const t = performance.now();\n        this.spec || (await fetch(\"\".concat(this.checkpointURL, \"/config.json\")).then(t => t.json()).then(t => {\n          if (\"MusicVAE\" !== t.type) throw new Error(\"Attempted to instantiate MusicVAE model with incorrect type:\\n                  \".concat(t.type));\n          this.spec = t;\n        })), this.instantiateFromSpec();\n        const e = \"cell_%d/bidirectional_rnn/%s/multi_rnn_cell/cell_0/lstm_cell/\",\n              n = \"encoder/\".concat(e),\n              i = \"encoder/hierarchical_level_%d/\".concat(e.replace(\"%d\", \"0\")),\n              a = await fetch(\"\".concat(this.checkpointURL, \"/weights_manifest.json\")).then(t => t.json()).then(t => r.io.loadWeights(t, this.checkpointURL));\n        this.rawVars = a;\n        const s = new l(a[\"encoder/mu/kernel\"], a[\"encoder/mu/bias\"]);\n\n        if (this.dataConverter.numSegments) {\n          const t = this.getLstmLayers(i.replace(\"%s\", \"fw\"), a),\n                e = this.getLstmLayers(i.replace(\"%s\", \"bw\"), a);\n          if (t.length !== e.length || 2 !== t.length) throw Error(\"Only 2 hierarchical encoder levels are supported. \" + \"Got \".concat(t.length, \" forward and \").concat(e.length, \" \") + \"backward.\");\n          const n = [0, 1].map(n => new f(t[n], e[n]));\n          this.encoder = new d(n, [this.dataConverter.numSegments, 1], s);\n        } else {\n          const t = this.getLstmLayers(n.replace(\"%s\", \"fw\"), a),\n                e = this.getLstmLayers(n.replace(\"%s\", \"bw\"), a);\n          if (t.length !== e.length || 1 !== t.length) throw Error(\"Only single-layer bidirectional encoders are supported. \" + \"Got \".concat(t.length, \" forward and \").concat(e.length, \" \") + \"backward.\");\n          this.encoder = new f(t[0], e[0], s);\n        }\n\n        const u = this.dataConverter.numSegments ? \"core_decoder/\" : \"\",\n              c = [];\n        if (this.dataConverter.NUM_SPLITS) for (let t = 0; t < this.dataConverter.NUM_SPLITS; ++t) c.push(\"\".concat(u, \"core_decoder_\").concat(t, \"/decoder/\"));else c.push(\"\".concat(u, \"decoder/\"));\n        const h = c.map(t => {\n          const e = this.getLstmLayers(t + \"multi_rnn_cell/cell_%d/lstm_cell/\", a),\n                n = new l(a[\"\".concat(t, \"z_to_initial_state/kernel\")], a[\"\".concat(t, \"z_to_initial_state/bias\")]),\n                r = new l(a[\"\".concat(t, \"output_projection/kernel\")], a[\"\".concat(t, \"output_projection/bias\")]);\n          return \"\".concat(t, \"nade/w_enc\") in a ? new b(e, n, r, new S(a[\"\".concat(t, \"nade/w_enc\")], a[\"\".concat(t, \"nade/w_dec_t\")])) : \"GrooveConverter\" === this.spec.dataConverter.type ? new w(e, n, r) : new y(e, n, r);\n        });\n\n        if (this.dataConverter.numSegments) {\n          const t = this.getLstmLayers(\"decoder/hierarchical_level_0/cell_%d/lstm_cell/\", a),\n                e = new l(a[\"decoder/hierarchical_level_0/initial_state/kernel\"], a[\"decoder/hierarchical_level_0/initial_state/bias\"]);\n          this.decoder = new x(h, t, e, this.dataConverter.numSegments);\n        } else {\n          if (1 !== h.length) throw Error(\"Unexpected number of base decoders without conductor: \" + \"\".concat(h.length));\n          this.decoder = h[0];\n        }\n\n        this.initialized = !0, o.logWithDuration(\"Initialized model\", t, \"MusicVAE\");\n      }\n\n      isInitialized() {\n        return this.initialized;\n      }\n\n      async interpolate(t, e, n, i) {\n        if (this.chordEncoder && !i) throw new Error(\"Chord progression expected but not provided.\");\n        if (!this.chordEncoder && i) throw new Error(\"Unexpected chord progression provided.\");\n        this.initialized || (await this.initialize());\n        const a = await this.encode(t, i),\n              s = r.tidy(() => this.getInterpolatedZs(a, e));\n        a.dispose();\n        const u = this.decode(s, n, i);\n        return s.dispose(), u.then(() => o.logWithDuration(\"Interpolation completed\", 0, \"MusicVAE\", 20)), u;\n      }\n\n      async getSegmentLengths(t) {\n        if (t.shape[0] > 1) throw new Error(\"Variable-length segments not supported for batch size > 1.\");\n        const e = this.dataConverter.numSteps,\n              n = this.dataConverter.numSegments,\n              o = r.tidy(() => r.min(r.equal(t.squeeze([0]), this.dataConverter.endTensor.expandDims(0)), 1)),\n              i = await o.data();\n        o.dispose();\n        const a = e / n,\n              s = [];\n        let u = 0,\n            c = i.indexOf(1);\n\n        for (; -1 !== c;) s.push(c - u + 1), u += a, c = i.indexOf(1, u);\n\n        if (s.length !== n) throw new Error(\"Incorrect number of segments: \".concat(s.length, \" != \").concat(n));\n        return s;\n      }\n\n      encodeChordProgression(t) {\n        const e = this.dataConverter.numSteps,\n              n = this.dataConverter.numSegments,\n              o = this.dataConverter.SEGMENTED_BY_TRACK ? e / n : e,\n              i = this.dataConverter.SEGMENTED_BY_TRACK ? r.concat2d([this.chordEncoder.encode(u.NO_CHORD).expandDims(0), this.chordEncoder.encodeProgression(t, o - 1)], 0) : this.chordEncoder.encodeProgression(t, o);\n        return this.dataConverter.SEGMENTED_BY_TRACK ? r.tile(i, [n, 1]) : i;\n      }\n\n      async encode(t, e) {\n        if (this.chordEncoder && !e) throw new Error(\"Chord progression expected but not provided.\");\n        if (!this.chordEncoder && e) throw new Error(\"Unexpected chord progression provided.\");\n        if (this.chordEncoder && this.dataConverter.endTensor && e.length > 1) throw new Error(\"Multiple chords not supported when using variable-length segments.\");\n        this.initialized || (await this.initialize());\n        const n = performance.now();\n        let i = r.tidy(() => r.stack(t.map(t => this.dataConverter.toTensor(t))));\n        const a = this.dataConverter.endTensor ? await this.getSegmentLengths(i) : void 0;\n\n        if (this.chordEncoder) {\n          const n = r.tidy(() => {\n            const n = this.encodeChordProgression(e),\n                  o = r.tile(r.expandDims(n, 0), [t.length, 1, 1]);\n            return i.concat(o, 2);\n          });\n          i.dispose(), i = n;\n        }\n\n        const s = this.encoder.encode(i, a);\n        return i.dispose(), o.logWithDuration(\"Encoding completed\", n, \"MusicVAE\", 20), s;\n      }\n\n      async decode(t, e, n, i = u.DEFAULT_STEPS_PER_QUARTER, a = u.DEFAULT_QUARTERS_PER_MINUTE) {\n        if (this.chordEncoder && !n) throw new Error(\"Chord progression expected but not provided.\");\n        if (!this.chordEncoder && n) throw new Error(\"Unexpected chord progression provided.\");\n        if (this.chordEncoder && this.dataConverter.endTensor && n.length > 1) throw new Error(\"Multiple chords not supported when using variable-length segments.\");\n        this.initialized || (await this.initialize());\n        const s = performance.now(),\n              c = this.dataConverter.numSteps,\n              l = r.tidy(() => {\n          const o = this.chordEncoder ? this.encodeChordProgression(n) : void 0,\n                i = this.decoder.decode(t, c, void 0, e, o);\n          return r.split(i, i.shape[0]).map(t => t.squeeze([0]));\n        }),\n              h = [];\n\n        for (const t of l) h.push((await this.dataConverter.toNoteSequence(t, i, a))), t.dispose();\n\n        return o.logWithDuration(\"Decoding completed\", s, \"MusicVAE\", 20), h;\n      }\n\n      getInterpolatedZs(t, e) {\n        if (\"number\" == typeof e && (e = [e]), 2 !== t.shape[0] && 4 !== t.shape[0]) throw new Error(\"Invalid number of input sequences. Requires length 2, or 4\");\n        if (1 !== e.length && 2 !== e.length) throw new Error(\"Invalid number of dimensions. Requires length 1, or 2.\");\n        const n = e[0],\n              o = 2 === e.length ? e[1] : n;\n        return r.tidy(() => {\n          const e = r.linspace(0, 1, n),\n                i = t.slice([0, 0], [1, t.shape[1]]).as1D(),\n                a = t.slice([1, 0], [1, t.shape[1]]).as1D();\n\n          if (2 === t.shape[0]) {\n            const t = a.sub(i);\n            return r.outerProduct(e, t).add(i);\n          }\n\n          if (4 === t.shape[0]) {\n            const s = r.linspace(0, 1, o),\n                  u = t.slice([2, 0], [1, t.shape[1]]).as1D(),\n                  c = t.slice([3, 0], [1, t.shape[1]]).as1D(),\n                  l = r.scalar(1).sub(e),\n                  h = r.scalar(1).sub(s);\n            let p = i.mul(r.outerProduct(h, l).as3D(o, n, 1));\n            return p = r.addStrict(p, a.mul(r.outerProduct(s, l).as3D(o, n, 1))), p = r.addStrict(p, u.mul(r.outerProduct(h, e).as3D(o, n, 1))), (p = r.addStrict(p, c.mul(r.outerProduct(s, e).as3D(o, n, 1)))).as2D(n * o, t.shape[1]);\n          }\n\n          throw new Error(\"Invalid number of note sequences. Requires length 2, or 4\");\n        });\n      }\n\n      async sample(t, e = .5, n, i = u.DEFAULT_STEPS_PER_QUARTER, a = u.DEFAULT_QUARTERS_PER_MINUTE) {\n        if (this.chordEncoder && !n) throw new Error(\"Chord progression expected but not provided.\");\n        if (!this.chordEncoder && n) throw new Error(\"Unexpected chord progression provided.\");\n        this.initialized || (await this.initialize());\n        const s = performance.now(),\n              c = r.tidy(() => r.randomNormal([t, this.decoder.zDims])),\n              l = this.decode(c, e, n, i);\n        return c.dispose(), l.then(() => o.logWithDuration(\"Sampling completed\", s, \"MusicVAE\", 20)), l;\n      }\n\n    }\n\n    n.d(e, \"MidiMe\", function () {\n      return a;\n    }), n.d(e, \"Decoder\", function () {\n      return g;\n    }), n.d(e, \"Encoder\", function () {\n      return p;\n    }), n.d(e, \"MusicVAE\", function () {\n      return E;\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(0),\n        o = n(35),\n        i = n(16),\n        a = n(10),\n        s = n(5),\n        u = n(6);\n    const c = \"attention_cell_wrapper/\";\n\n    class l {\n      constructor(t, e, n) {\n        this.cells = t, this.attnLength = e, this.attnSize = n;\n      }\n\n      static isWrapped(t) {\n        return \"rnn/\".concat(c, \"kernel\") in t;\n      }\n\n      initialize(t) {\n        const e = \"rnn/\".concat(c);\n        this.attnInputMatrix = t[\"\".concat(e, \"kernel\")], this.attnInputBias = t[\"\".concat(e, \"bias\")], this.attnW = t[\"\".concat(e, \"attention/attn_w\")], this.attnV = t[\"\".concat(e, \"attention/attn_v\")], this.attnMatrix = t[\"\".concat(e, \"attention/kernel\")], this.attnBias = t[\"\".concat(e, \"attention/bias\")], this.attnOutputMatrix = t[\"\".concat(e, \"attention_output_projection/kernel\")], this.attnOutputBias = t[\"\".concat(e, \"attention_output_projection/bias\")];\n      }\n\n      initState() {\n        return {\n          attention: r.zeros([this.attnSize]),\n          attentionState: r.zeros([1, this.attnSize * this.attnLength])\n        };\n      }\n\n      call(t, e, n, o) {\n        const i = r.concat([t, o.attention.as2D(1, -1)], 1),\n              a = r.add(r.matMul(i, this.attnInputMatrix), this.attnInputBias.as2D(1, -1));\n\n        var _r$multiRNNCell5 = r.multiRNNCell(this.cells, a, e, n);\n\n        var _r$multiRNNCell6 = _slicedToArray(_r$multiRNNCell5, 2);\n\n        e = _r$multiRNNCell6[0];\n        n = _r$multiRNNCell6[1];\n        const s = r.reshape(o.attentionState, [-1, this.attnLength, 1, this.attnSize]),\n              u = r.conv2d(s, this.attnW, [1, 1], \"same\"),\n              c = [];\n\n        for (let t = 0; t < e.length; t++) c.push(e[t]), c.push(n[t]);\n\n        const l = r.concat(c, 1),\n              h = r.matMul(l, this.attnMatrix).reshape([-1, 1, 1, this.attnSize]),\n              p = r.sum(r.mul(this.attnV, r.tanh(r.add(u, h))), [2, 3]),\n              f = r.softmax(p),\n              d = r.sum(r.mul(r.reshape(f, [-1, this.attnLength, 1, 1]), s), [1, 2]).reshape([-1, this.attnSize]),\n              m = o.attentionState.reshape([-1, this.attnLength, this.attnSize]),\n              g = r.slice(m, [0, 1, 0], [m.shape[0], m.shape[1] - 1, m.shape[2]]),\n              v = r.add(r.matMul(r.concat([n[2], d], 1), this.attnOutputMatrix), this.attnOutputBias),\n              y = d.flatten(),\n              b = r.concat([g, v.as3D(v.shape[0], 1, v.shape[1])], 1).reshape([-1, this.attnLength * this.attnSize]);\n        return {\n          output: v,\n          c: e,\n          h: n,\n          attentionState: {\n            attention: y,\n            attentionState: b\n          }\n        };\n      }\n\n    }\n\n    const h = \"multi_rnn_cell/cell_%d/basic_lstm_cell/\";\n\n    class p {\n      constructor(t, e) {\n        this.checkpointURL = t, this.spec = e, this.initialized = !1, this.rawVars = {}, this.biasShapes = [], this.lstmCells = [];\n      }\n\n      isInitialized() {\n        return this.initialized;\n      }\n\n      instantiateFromSpec() {\n        this.dataConverter = a.converterFromSpec(this.spec.dataConverter), this.attentionLength = this.spec.attentionLength, this.chordEncoder = this.spec.chordEncoder ? i.chordEncoderFromType(this.spec.chordEncoder) : void 0, this.auxInputs = this.spec.auxInputs ? this.spec.auxInputs.map(t => o.auxiliaryInputFromSpec(t)) : void 0;\n      }\n\n      async initialize() {\n        this.dispose();\n        const t = performance.now();\n        this.spec || (await fetch(\"\".concat(this.checkpointURL, \"/config.json\")).then(t => t.json()).then(t => {\n          if (\"MusicRNN\" !== t.type) throw new Error(\"Attempted to instantiate MusicRNN model with incorrect type:\\n                  \".concat(t.type));\n          this.spec = t;\n        })), this.instantiateFromSpec();\n        const e = await fetch(\"\".concat(this.checkpointURL, \"/weights_manifest.json\")).then(t => t.json()).then(t => r.io.loadWeights(t, this.checkpointURL)),\n              n = l.isWrapped(e),\n              o = n ? \"rnn/\".concat(c) : \"rnn/\";\n        this.forgetBias = r.scalar(1), this.lstmCells.length = 0, this.biasShapes.length = 0;\n        let i = 0;\n\n        for (;;) {\n          const t = o + h.replace(\"%d\", i.toString());\n          if (!(\"\".concat(t, \"kernel\") in e)) break;\n          this.lstmCells.push((n, o, i) => r.basicLSTMCell(this.forgetBias, e[\"\".concat(t, \"kernel\")], e[\"\".concat(t, \"bias\")], n, o, i)), this.biasShapes.push(e[\"\".concat(t, \"bias\")].shape[0]), ++i;\n        }\n\n        this.lstmFcW = e[\"fully_connected/weights\"], this.lstmFcB = e[\"fully_connected/biases\"], n && (this.attentionWrapper = new l(this.lstmCells, this.attentionLength, this.biasShapes[0] / 4), this.attentionWrapper.initialize(e)), this.rawVars = e, this.initialized = !0, s.logWithDuration(\"Initialized model\", t, \"MusicRNN\");\n      }\n\n      dispose() {\n        Object.keys(this.rawVars).forEach(t => this.rawVars[t].dispose()), this.rawVars = {}, this.forgetBias && (this.forgetBias.dispose(), this.forgetBias = void 0), this.initialized = !1;\n      }\n\n      async continueSequence(t, e, n, r) {\n        return (await this.continueSequenceImpl(t, e, n, r, !1)).sequence;\n      }\n\n      async continueSequenceAndReturnProbabilities(t, e, n, r) {\n        return this.continueSequenceImpl(t, e, n, r, !0);\n      }\n\n      async continueSequenceImpl(t, e, n, o, i) {\n        if (u.assertIsRelativeQuantizedSequence(t), this.chordEncoder && !o) throw new Error(\"Chord progression expected but not provided.\");\n        if (!this.chordEncoder && o) throw new Error(\"Unexpected chord progression provided.\");\n        this.initialized || (await this.initialize());\n        const a = performance.now(),\n              c = r.tidy(() => {\n          const a = this.dataConverter.toTensor(t),\n                s = a.shape[0],\n                u = a.shape[1],\n                c = this.chordEncoder ? this.chordEncoder.encodeProgression(o, s + e) : void 0,\n                l = this.auxInputs ? r.concat(this.auxInputs.map(t => t.getTensors(s + e)), 1) : void 0,\n                h = this.sampleRnn(a, e, n, c, l, i),\n                p = h.samples;\n          return {\n            samples: r.stack(p).as2D(p.length, u),\n            probs: h.probs\n          };\n        }),\n              l = await c,\n              h = this.dataConverter.toNoteSequence(l.samples, t.quantizationInfo.stepsPerQuarter),\n              p = [];\n        if (i) for (let t = 0; t < l.probs.length; t++) p.push((await l.probs[t].data())), l.probs[t].dispose();\n        return c.samples.dispose(), h.then(() => s.logWithDuration(\"Continuation completed\", a, \"MusicRNN\", 20)), {\n          sequence: h,\n          probs: p\n        };\n      }\n\n      sampleRnn(t, e, n, o, i, a) {\n        const s = t.shape[0],\n              u = t.shape[1];\n        let c = [],\n            l = [];\n\n        for (let t = 0; t < this.biasShapes.length; t++) c.push(r.zeros([1, this.biasShapes[t] / 4])), l.push(r.zeros([1, this.biasShapes[t] / 4]));\n\n        let h,\n            p = this.attentionWrapper ? this.attentionWrapper.initState() : null;\n        t = t.toFloat();\n        const f = [],\n              d = [],\n              m = r.split(t.toFloat(), s),\n              g = o ? r.split(o, o.shape[0]) : void 0,\n              v = i ? r.split(i, i.shape[0]) : void 0;\n\n        for (let t = 0; t < s + e; t++) {\n          var _r$multiRNNCell7, _r$multiRNNCell8;\n\n          let o;\n          if (t < s) o = m[t];else {\n            let t,\n                e = h.matMul(this.lstmFcW).add(this.lstmFcB).as1D();\n            n ? (e = e.div(r.scalar(n)), t = r.multinomial(e, 1).as1D()) : t = e.argMax().as1D(), a && d.push(r.softmax(e)), o = r.oneHot(t, u).toFloat(), f.push(o.as1D());\n          }\n          if (t === s + e - 1) break;\n          const i = [];\n\n          if (g && i.push(g[t + 1]), i.push(o), v && i.push(v[t]), o = r.concat(i, 1), this.attentionWrapper) {\n            const t = this.attentionWrapper.call(o, c, l, p);\n            c = t.c, l = t.h, p = t.attentionState, h = t.output;\n          } else (_r$multiRNNCell7 = r.multiRNNCell(this.lstmCells, o, c, l), _r$multiRNNCell8 = _slicedToArray(_r$multiRNNCell7, 2), c = _r$multiRNNCell8[0], l = _r$multiRNNCell8[1], _r$multiRNNCell7), h = l[l.length - 1];\n        }\n\n        return {\n          samples: f,\n          probs: d\n        };\n      }\n\n    }\n\n    n.d(e, \"MusicRNN\", function () {\n      return p;\n    });\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(0);\n    const o = 31.25,\n          i = 32,\n          a = 2,\n          s = 128,\n          u = 8,\n          c = 88;\n\n    function l(t) {\n      for (let e = 0; e < a; ++e) t.c[e].dispose(), t.h[e].dispose();\n    }\n\n    function h(t, e, n) {\n      if ((e = void 0 !== e ? e : 1) < 0 || e > 1) throw new Error(\"Invalid temperature specified\");\n      let o;\n      if (0 === e) o = r.argMax(t, 0);else {\n        e < 1 && (t = r.div(t, r.scalar(e, \"float32\")));\n        const i = r.reshape(r.softmax(t, 0), [1, -1]),\n              a = r.multinomial(i, 1, n, !0);\n        o = r.reshape(a, []);\n      }\n      return o;\n    }\n\n    class p {\n      constructor(t) {\n        this.checkpointURL = t, this.initialized = !1;\n      }\n\n      isInitialized() {\n        return this.initialized;\n      }\n\n      async initialize(t) {\n        if (this.initialized && this.dispose(), void 0 === this.checkpointURL && void 0 === t) throw new Error(\"Need to specify either URI or static variables\");\n\n        if (void 0 === t) {\n          const t = await fetch(\"\".concat(this.checkpointURL, \"/weights_manifest.json\")).then(t => t.json()).then(t => r.io.loadWeights(t, this.checkpointURL));\n          this.modelVars = t;\n        } else this.modelVars = t;\n\n        this.decLSTMCells = [], this.decForgetBias = r.scalar(1, \"float32\");\n\n        for (let t = 0; t < a; ++t) {\n          const e = \"phero_model/decoder/rnn/rnn/multi_rnn_cell/cell_\".concat(t, \"/lstm_cell/\");\n          this.decLSTMCells.push((t, n, o) => r.basicLSTMCell(this.decForgetBias, this.modelVars[e + \"kernel\"], this.modelVars[e + \"bias\"], t, n, o));\n        }\n\n        this.resetState(), this.initialized = !0, this.next(0), this.resetState();\n      }\n\n      getRnnInputFeats() {\n        return r.tidy(() => {\n          const t = r.tensor1d([this.button], \"float32\");\n          return r.sub(r.mul(2, r.div(t, u - 1)), 1).as1D();\n        });\n      }\n\n      next(t, e, n) {\n        return this.nextWithCustomSamplingFunction(t, t => h(t, e, n));\n      }\n\n      nextFromKeyWhitelist(t, e, n, o) {\n        return this.nextWithCustomSamplingFunction(t, t => {\n          const i = r.tensor1d(e, \"int32\");\n          let a = h(t = r.gather(t, i), n, o);\n          const s = r.gather(i, r.reshape(a, [1]));\n          return a = r.reshape(s, []);\n        });\n      }\n\n      nextWithCustomSamplingFunction(t, e) {\n        const n = this.lastState;\n        this.button = t;\n\n        const r = this.getRnnInputFeats(),\n              _this$evaluateModelAn = this.evaluateModelAndSample(r, n, e),\n              _this$evaluateModelAn2 = _slicedToArray(_this$evaluateModelAn, 2),\n              o = _this$evaluateModelAn2[0],\n              i = _this$evaluateModelAn2[1];\n\n        return r.dispose(), l(this.lastState), this.lastState = o, i;\n      }\n\n      evaluateModelAndSample(t, e, n) {\n        if (!this.initialized) throw new Error(\"Model is not initialized.\");\n\n        const _r$tidy3 = r.tidy(() => {\n          let o = r.matMul(r.expandDims(t, 0), this.modelVars[\"phero_model/decoder/rnn_input/dense/kernel\"]);\n          o = r.add(o, this.modelVars[\"phero_model/decoder/rnn_input/dense/bias\"]);\n\n          const _r$multiRNNCell9 = r.multiRNNCell(this.decLSTMCells, o, e.c, e.h),\n                _r$multiRNNCell10 = _slicedToArray(_r$multiRNNCell9, 2),\n                i = _r$multiRNNCell10[0],\n                s = _r$multiRNNCell10[1],\n                u = {\n            c: i,\n            h: s\n          };\n\n          let l = r.matMul(s[a - 1], this.modelVars[\"phero_model/decoder/pitches/dense/kernel\"]);\n          l = r.add(l, this.modelVars[\"phero_model/decoder/pitches/dense/bias\"]);\n          const h = r.reshape(l, [c]);\n          return [u, n(h).dataSync()[0]];\n        }),\n              _r$tidy4 = _slicedToArray(_r$tidy3, 2),\n              o = _r$tidy4[0],\n              i = _r$tidy4[1];\n\n        return [o, i];\n      }\n\n      resetState() {\n        void 0 !== this.lastState && l(this.lastState), this.lastState = function () {\n          const t = {\n            c: [],\n            h: []\n          };\n\n          for (let e = 0; e < a; ++e) t.c.push(r.zeros([1, s], \"float32\")), t.h.push(r.zeros([1, s], \"float32\"));\n\n          return t;\n        }();\n      }\n\n      dispose() {\n        this.initialized && (Object.keys(this.modelVars).forEach(t => this.modelVars[t].dispose()), this.decForgetBias.dispose(), l(this.lastState), this.initialized = !1);\n      }\n\n    }\n\n    class f extends p {\n      getRnnInputFeats() {\n        return r.tidy(() => {\n          const t = [super.getRnnInputFeats()],\n                e = this.lastOutput,\n                n = this.lastTime,\n                a = this.time;\n          let s;\n          void 0 === this.deltaTimeOverride ? s = (a.getTime() - n.getTime()) / 1e3 : (s = this.deltaTimeOverride, this.deltaTimeOverride = void 0);\n          const u = r.scalar(e, \"int32\"),\n                l = r.addStrict(u, r.scalar(1, \"int32\")),\n                h = r.cast(r.oneHot(l, c + 1), \"float32\");\n          t.push(h);\n          const p = r.scalar(s, \"float32\"),\n                f = r.round(r.mul(p, o)),\n                d = r.minimum(f, i),\n                m = r.cast(r.add(d, 1e-4), \"int32\"),\n                g = r.oneHot(m, i + 1),\n                v = r.cast(g, \"float32\");\n          return t.push(v), this.lastTime = a, r.concat1d(t);\n        });\n      }\n\n      nextWithCustomSamplingFunction(t, e) {\n        this.time = new Date();\n        const n = super.nextWithCustomSamplingFunction(t, e);\n        return this.lastOutput = n, this.lastTime = this.time, n;\n      }\n\n      overrideLastOutput(t) {\n        this.lastOutput = t;\n      }\n\n      overrideDeltaTime(t) {\n        this.deltaTimeOverride = t;\n      }\n\n      resetState() {\n        super.resetState(), this.lastOutput = -1, this.lastTime = new Date(), this.lastTime.setSeconds(this.lastTime.getSeconds() - 1e5), this.time = new Date();\n      }\n\n    }\n\n    var d, m;\n    !function (t) {\n      t[t.None = 0] = \"None\", t[t.C = 1] = \"C\", t[t.Cs = 2] = \"Cs\", t[t.D = 3] = \"D\", t[t.Eb = 4] = \"Eb\", t[t.E = 5] = \"E\", t[t.F = 6] = \"F\", t[t.Fs = 7] = \"Fs\", t[t.G = 8] = \"G\", t[t.Ab = 9] = \"Ab\", t[t.A = 10] = \"A\", t[t.Bb = 11] = \"Bb\", t[t.B = 12] = \"B\";\n    }(d || (d = {})), function (t) {\n      t[t.None = 0] = \"None\", t[t.Maj = 1] = \"Maj\", t[t.Min = 2] = \"Min\", t[t.Aug = 3] = \"Aug\", t[t.Dim = 4] = \"Dim\", t[t.Seven = 5] = \"Seven\", t[t.Maj7 = 6] = \"Maj7\", t[t.Min7 = 7] = \"Min7\", t[t.Min7b5 = 8] = \"Min7b5\";\n    }(m || (m = {}));\n\n    class g extends f {\n      getRnnInputFeats() {\n        return r.tidy(() => {\n          const t = [super.getRnnInputFeats()],\n                e = r.scalar(this.chordRoot, \"int32\"),\n                n = r.subStrict(e, r.scalar(1, \"int32\")),\n                o = r.cast(r.oneHot(n, 12), \"float32\");\n          t.push(o);\n          const i = r.scalar(this.chordFamily, \"int32\"),\n                a = r.subStrict(i, r.scalar(1, \"int32\")),\n                s = r.cast(r.oneHot(a, 8), \"float32\");\n          return t.push(s), r.concat1d(t);\n        });\n      }\n\n      setChordRoot(t) {\n        this.chordRoot = t;\n      }\n\n      setChordFamily(t) {\n        this.chordFamily = t;\n      }\n\n      resetState() {\n        super.resetState(), this.chordRoot = d.None, this.chordFamily = m.None;\n      }\n\n    }\n\n    class v extends f {\n      getRnnInputFeats() {\n        return r.tidy(() => {\n          const t = [super.getRnnInputFeats()],\n                e = r.scalar(this.keySignature, \"int32\"),\n                n = r.subStrict(e, r.scalar(1, \"int32\")),\n                o = r.cast(r.oneHot(n, 12), \"float32\");\n          return t.push(o), r.concat1d(t);\n        });\n      }\n\n      setKeySignature(t) {\n        this.keySignature = t;\n      }\n\n      resetState() {\n        super.resetState(), this.keySignature = d.None;\n      }\n\n    }\n\n    class y extends v {\n      getRnnInputFeats() {\n        return r.tidy(() => {\n          const t = [super.getRnnInputFeats()],\n                e = r.scalar(this.chordRoot, \"int32\"),\n                n = r.subStrict(e, r.scalar(1, \"int32\")),\n                o = r.cast(r.oneHot(n, 12), \"float32\");\n          t.push(o);\n          const i = r.scalar(this.chordFamily, \"int32\"),\n                a = r.subStrict(i, r.scalar(1, \"int32\")),\n                s = r.cast(r.oneHot(a, 8), \"float32\");\n          return t.push(s), r.concat1d(t);\n        });\n      }\n\n      setChordRoot(t) {\n        this.chordRoot = t;\n      }\n\n      setChordFamily(t) {\n        this.chordFamily = t;\n      }\n\n      resetState() {\n        super.resetState(), this.chordRoot = d.None, this.chordFamily = m.None;\n      }\n\n    }\n\n    class b extends v {\n      getRnnInputFeats() {\n        return r.tidy(() => {\n          const t = [super.getRnnInputFeats()],\n                e = r.scalar(this.chordFamily, \"int32\"),\n                n = r.subStrict(e, r.scalar(1, \"int32\")),\n                o = r.cast(r.oneHot(n, 8), \"float32\");\n          return t.push(o), r.concat1d(t);\n        });\n      }\n\n      setChordFamily(t) {\n        this.chordFamily = t;\n      }\n\n      resetState() {\n        super.resetState(), this.chordFamily = m.None;\n      }\n\n    }\n\n    class w extends f {}\n\n    class x extends g {}\n\n    class S extends v {}\n\n    class E extends y {}\n\n    class C extends b {}\n\n    n.d(e, \"PianoGenie\", function () {\n      return w;\n    }), n.d(e, \"PianoGenieKeysig\", function () {\n      return S;\n    }), n.d(e, \"PianoGenieChord\", function () {\n      return x;\n    }), n.d(e, \"PianoGenieKeysigChordFamily\", function () {\n      return C;\n    }), n.d(e, \"PianoGenieKeysigChord\", function () {\n      return E;\n    });\n  }, function (t, e, n) {\n    (function (t) {\n      var r = void 0 !== t && t || \"undefined\" != typeof self && self || window,\n          o = Function.prototype.apply;\n\n      function i(t, e) {\n        this._id = t, this._clearFn = e;\n      }\n\n      e.setTimeout = function () {\n        return new i(o.call(setTimeout, r, arguments), clearTimeout);\n      }, e.setInterval = function () {\n        return new i(o.call(setInterval, r, arguments), clearInterval);\n      }, e.clearTimeout = e.clearInterval = function (t) {\n        t && t.close();\n      }, i.prototype.unref = i.prototype.ref = function () {}, i.prototype.close = function () {\n        this._clearFn.call(r, this._id);\n      }, e.enroll = function (t, e) {\n        clearTimeout(t._idleTimeoutId), t._idleTimeout = e;\n      }, e.unenroll = function (t) {\n        clearTimeout(t._idleTimeoutId), t._idleTimeout = -1;\n      }, e._unrefActive = e.active = function (t) {\n        clearTimeout(t._idleTimeoutId);\n        var e = t._idleTimeout;\n        e >= 0 && (t._idleTimeoutId = setTimeout(function () {\n          t._onTimeout && t._onTimeout();\n        }, e));\n      }, n(70), e.setImmediate = \"undefined\" != typeof self && self.setImmediate || void 0 !== t && t.setImmediate || this && this.setImmediate, e.clearImmediate = \"undefined\" != typeof self && self.clearImmediate || void 0 !== t && t.clearImmediate || this && this.clearImmediate;\n    }).call(this, n(8));\n  }, function (t, e, n) {\n    (function (t, e) {\n      !function (t, n) {\n        \"use strict\";\n\n        if (!t.setImmediate) {\n          var r,\n              o,\n              i,\n              a,\n              s,\n              u = 1,\n              c = {},\n              l = !1,\n              h = t.document,\n              p = Object.getPrototypeOf && Object.getPrototypeOf(t);\n          p = p && p.setTimeout ? p : t, \"[object process]\" === {}.toString.call(t.process) ? r = function (t) {\n            e.nextTick(function () {\n              d(t);\n            });\n          } : !function () {\n            if (t.postMessage && !t.importScripts) {\n              var e = !0,\n                  n = t.onmessage;\n              return t.onmessage = function () {\n                e = !1;\n              }, t.postMessage(\"\", \"*\"), t.onmessage = n, e;\n            }\n          }() ? t.MessageChannel ? ((i = new MessageChannel()).port1.onmessage = function (t) {\n            d(t.data);\n          }, r = function (t) {\n            i.port2.postMessage(t);\n          }) : h && \"onreadystatechange\" in h.createElement(\"script\") ? (o = h.documentElement, r = function (t) {\n            var e = h.createElement(\"script\");\n            e.onreadystatechange = function () {\n              d(t), e.onreadystatechange = null, o.removeChild(e), e = null;\n            }, o.appendChild(e);\n          }) : r = function (t) {\n            setTimeout(d, 0, t);\n          } : (a = \"setImmediate$\" + Math.random() + \"$\", s = function (e) {\n            e.source === t && \"string\" == typeof e.data && 0 === e.data.indexOf(a) && d(+e.data.slice(a.length));\n          }, t.addEventListener ? t.addEventListener(\"message\", s, !1) : t.attachEvent(\"onmessage\", s), r = function (e) {\n            t.postMessage(a + e, \"*\");\n          }), p.setImmediate = function (t) {\n            \"function\" != typeof t && (t = new Function(\"\" + t));\n\n            for (var e = new Array(arguments.length - 1), n = 0; n < e.length; n++) e[n] = arguments[n + 1];\n\n            var o = {\n              callback: t,\n              args: e\n            };\n            return c[u] = o, r(u), u++;\n          }, p.clearImmediate = f;\n        }\n\n        function f(t) {\n          delete c[t];\n        }\n\n        function d(t) {\n          if (l) setTimeout(d, 0, t);else {\n            var e = c[t];\n\n            if (e) {\n              l = !0;\n\n              try {\n                !function (t) {\n                  var e = t.callback,\n                      r = t.args;\n\n                  switch (r.length) {\n                    case 0:\n                      e();\n                      break;\n\n                    case 1:\n                      e(r[0]);\n                      break;\n\n                    case 2:\n                      e(r[0], r[1]);\n                      break;\n\n                    case 3:\n                      e(r[0], r[1], r[2]);\n                      break;\n\n                    default:\n                      e.apply(n, r);\n                  }\n                }(e);\n              } finally {\n                f(t), l = !1;\n              }\n            }\n          }\n        }\n      }(\"undefined\" == typeof self ? void 0 === t ? this : t : self);\n    }).call(this, n(8), n(47));\n  }, function (t, e) {}, function (t, e) {}, function (t, e) {}, function (t, e) {\n    t.exports = function (t) {\n      return t.webpackPolyfill || (t.deprecate = function () {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, \"loaded\", {\n        enumerable: !0,\n        get: function () {\n          return t.l;\n        }\n      }), Object.defineProperty(t, \"id\", {\n        enumerable: !0,\n        get: function () {\n          return t.i;\n        }\n      }), t.webpackPolyfill = 1), t;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    n.r(e);\n    var r = n(0);\n    n.d(e, \"tf\", function () {\n      return r;\n    });\n    var o = n(62);\n    n.d(e, \"aux_inputs\", function () {\n      return o.aux_inputs;\n    }), n.d(e, \"chords\", function () {\n      return o.chords;\n    }), n.d(e, \"constants\", function () {\n      return o.constants;\n    }), n.d(e, \"data\", function () {\n      return o.data;\n    }), n.d(e, \"logging\", function () {\n      return o.logging;\n    }), n.d(e, \"performance\", function () {\n      return o.performance;\n    }), n.d(e, \"sequences\", function () {\n      return o.sequences;\n    }), n.d(e, \"MetronomeCallbackObject\", function () {\n      return o.MetronomeCallbackObject;\n    }), n.d(e, \"Metronome\", function () {\n      return o.Metronome;\n    }), n.d(e, \"MidiConversionError\", function () {\n      return o.MidiConversionError;\n    }), n.d(e, \"midiToSequenceProto\", function () {\n      return o.midiToSequenceProto;\n    }), n.d(e, \"sequenceProtoToMidi\", function () {\n      return o.sequenceProtoToMidi;\n    }), n.d(e, \"urlToBlob\", function () {\n      return o.urlToBlob;\n    }), n.d(e, \"blobToNoteSequence\", function () {\n      return o.blobToNoteSequence;\n    }), n.d(e, \"urlToNoteSequence\", function () {\n      return o.urlToNoteSequence;\n    }), n.d(e, \"BasePlayerCallback\", function () {\n      return o.BasePlayerCallback;\n    }), n.d(e, \"BasePlayer\", function () {\n      return o.BasePlayer;\n    }), n.d(e, \"Player\", function () {\n      return o.Player;\n    }), n.d(e, \"SoundFontPlayer\", function () {\n      return o.SoundFontPlayer;\n    }), n.d(e, \"PlayerWithClick\", function () {\n      return o.PlayerWithClick;\n    }), n.d(e, \"MIDIPlayer\", function () {\n      return o.MIDIPlayer;\n    }), n.d(e, \"BaseRecorderCallback\", function () {\n      return o.BaseRecorderCallback;\n    }), n.d(e, \"Recorder\", function () {\n      return o.Recorder;\n    }), n.d(e, \"BaseVisualizer\", function () {\n      return o.BaseVisualizer;\n    }), n.d(e, \"PianoRollCanvasVisualizer\", function () {\n      return o.PianoRollCanvasVisualizer;\n    }), n.d(e, \"Visualizer\", function () {\n      return o.Visualizer;\n    }), n.d(e, \"PianoRollSVGVisualizer\", function () {\n      return o.PianoRollSVGVisualizer;\n    }), n.d(e, \"ScrollType\", function () {\n      return o.ScrollType;\n    }), n.d(e, \"StaffSVGVisualizer\", function () {\n      return o.StaffSVGVisualizer;\n    });\n    var i = n(65);\n    n.d(e, \"Coconet\", function () {\n      return i.Coconet;\n    });\n    var a = n(67);\n    n.d(e, \"MusicRNN\", function () {\n      return a.MusicRNN;\n    });\n    var s = n(66);\n    n.d(e, \"MidiMe\", function () {\n      return s.MidiMe;\n    }), n.d(e, \"Decoder\", function () {\n      return s.Decoder;\n    }), n.d(e, \"Encoder\", function () {\n      return s.Encoder;\n    }), n.d(e, \"MusicVAE\", function () {\n      return s.MusicVAE;\n    });\n    var u = n(68);\n    n.d(e, \"PianoGenie\", function () {\n      return u.PianoGenie;\n    }), n.d(e, \"PianoGenieKeysig\", function () {\n      return u.PianoGenieKeysig;\n    }), n.d(e, \"PianoGenieChord\", function () {\n      return u.PianoGenieChord;\n    }), n.d(e, \"PianoGenieKeysigChordFamily\", function () {\n      return u.PianoGenieKeysigChordFamily;\n    }), n.d(e, \"PianoGenieKeysigChord\", function () {\n      return u.PianoGenieKeysigChord;\n    });\n    var c = n(61);\n    n.d(e, \"NoteSequence\", function () {\n      return c.NoteSequence;\n    });\n    var l = n(64);\n    n.d(e, \"OnsetsAndFrames\", function () {\n      return l.OnsetsAndFrames;\n    });\n    var h = n(63);\n    n.d(e, \"GANSynth\", function () {\n      return h.GANSynth;\n    });\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}