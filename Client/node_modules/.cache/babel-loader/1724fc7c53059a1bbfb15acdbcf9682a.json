{"ast":null,"code":"import { BinaryInsert } from './BinaryInsert';\nimport { Control } from './Control';\nimport { Merge } from './Merge';\nimport { Note } from './Note';\nimport { instrumentByPatchID, instrumentFamilyByID, drumKitByPatchID } from './instrumentMaps';\n\nclass Track {\n  /**\n  \t * Convert JSON to Track object\n  \t * @param {object} json\n  \t * @static\n  \t * @returns {Track}\n  \t */\n  static fromJSON(json) {\n    var track = new Track(json.name, json.instrumentNumber, json.channelNumber);\n    track.id = json.id;\n\n    if (json.notes) {\n      json.notes.forEach(note => {\n        var newNote = Note.fromJSON(note);\n        track.notes.push(newNote);\n      });\n    }\n\n    if (json.controlChanges) {\n      track.controlChanges = json.controlChanges;\n    }\n\n    return track;\n  }\n\n  constructor(name, instrumentNumber = -1, channel = -1) {\n    /**\n     * The name of the track\n     * @type {String}\n     */\n    this.name = name;\n    /**\n     * The MIDI channel of the track\n     * @type {number}\n     */\n\n    this.channelNumber = channel;\n    /**\n     * The note events\n     * @type {Array}\n     */\n\n    this.notes = [];\n    /**\n     * The control changes\n     * @type {Object}\n     */\n\n    this.controlChanges = {};\n    /**\n     * The MIDI patch ID of the instrument. -1 if none is set.\n     * @type {Number}\n     */\n\n    this.instrumentNumber = instrumentNumber;\n  }\n\n  note(midi, time, duration = 0, velocity = 1) {\n    const note = new Note(midi, time, duration, velocity);\n    BinaryInsert(this.notes, note);\n    return this;\n  }\n  /**\n   * Add a note on event\n   * @param  {Number|String} midi     The midi note as either a midi number or\n   *                                  Pitch Notation like ('C#4')\n   * @param  {Number} time     The time in seconds\n   * @param  {Number} velocity The velocity value 0-1\n   * @return {Track} this\n   */\n\n\n  noteOn(midi, time, velocity = 1) {\n    const note = new Note(midi, time, 0, velocity);\n    BinaryInsert(this.notes, note);\n    return this;\n  }\n  /**\n   * Add a note off event. Go through and find an unresolved\n   * noteOn event with the same pitch.\n   * @param  {String|Number} midi The midi number or note name.\n   * @param  {Number} time The time of the event in seconds\n   * @return {Track} this\n   */\n\n\n  noteOff(midi, time) {\n    for (let i = 0; i < this.notes.length; i++) {\n      let note = this.notes[i];\n\n      if (note.match(midi) && note.duration === 0) {\n        note.noteOff = time;\n        break;\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Add a CC event\n   * @param  {Number} num The CC number\n   * @param  {Number} time The time of the event in seconds\n   * @param  {Number} value The value of the CC\n   * @return {Track} this\n   */\n\n\n  cc(num, time, value) {\n    if (!this.controlChanges.hasOwnProperty(num)) {\n      this.controlChanges[num] = [];\n    }\n\n    const cc = new Control(num, time, value);\n    BinaryInsert(this.controlChanges[num], cc);\n    return this;\n  }\n  /**\n   * Sets instrumentNumber.\n   * For a list of possible values, see the [General MIDI Instrument Patch Map](https://www.midi.org/specifications/item/gm-level-1-sound-set)\n   * @param  {Number} id The Patch ID for this instrument, as specified in the General MIDI Instrument Patch Map\n   */\n\n\n  patch(id) {\n    this.instrumentNumber = id;\n    return this;\n  }\n  /**\n   * Sets channelNumber.\n   * @param  {Number} id The MIDI channel number, between 0 and 0xF.  0x9 and 0xA are percussion\n   */\n\n\n  channel(id) {\n    this.channelNumber = id;\n    return this;\n  }\n  /**\n   * An array of all the note on events\n   * @type {Array<Object>}\n   * @readOnly\n   */\n\n\n  get noteOns() {\n    const noteOns = [];\n    this.notes.forEach(note => {\n      noteOns.push({\n        time: note.noteOn,\n        midi: note.midi,\n        name: note.name,\n        velocity: note.velocity\n      });\n    });\n    return noteOns;\n  }\n  /**\n   * An array of all the noteOff events\n   * @type {Array<Object>}\n   * @readOnly\n   */\n\n\n  get noteOffs() {\n    const noteOffs = [];\n    this.notes.forEach(note => {\n      noteOffs.push({\n        time: note.noteOff,\n        midi: note.midi,\n        name: note.name\n      });\n    });\n    return noteOffs;\n  }\n  /**\n   * The length in seconds of the track\n   * @type {Number}\n   */\n\n\n  get length() {\n    return this.notes.length;\n  }\n  /**\n   * The time of the first event in seconds\n   * @type {Number}\n   */\n\n\n  get startTime() {\n    if (this.notes.length) {\n      let firstNote = this.notes[0];\n      return firstNote.noteOn;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The time of the last event in seconds\n   * @type {Number}\n   */\n\n\n  get duration() {\n    if (this.notes.length) {\n      let lastNote = this.notes[this.notes.length - 1];\n      return lastNote.noteOff;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * The name of the midi instrument\n   * @type {String}\n   */\n\n\n  get instrument() {\n    if (this.isPercussion) {\n      return drumKitByPatchID[this.instrumentNumber];\n    } else {\n      return instrumentByPatchID[this.instrumentNumber];\n    }\n  }\n\n  set instrument(inst) {\n    const index = instrumentByPatchID.indexOf(inst);\n\n    if (index !== -1) {\n      this.instrumentNumber = index;\n    }\n  }\n  /**\n   * Whether or not this is a percussion track\n   * @type {Boolean}\n   */\n\n\n  get isPercussion() {\n    return [0x9, 0xA].includes(this.channelNumber);\n  }\n  /**\n   * The family that the instrument belongs to\n   * @type {String}\n   * @readOnly\n   */\n\n\n  get instrumentFamily() {\n    if (this.isPercussion) {\n      return 'drums';\n    } else {\n      return instrumentFamilyByID[Math.floor(this.instrumentNumber / 8)];\n    }\n  }\n  /**\n   * Scale the timing of all the events in the track\n   * @param {Number} amount The amount to scale all the values\n   */\n\n\n  scale(amount) {\n    this.notes.forEach(note => {\n      note.time *= amount;\n      note.duration *= amount;\n    });\n    return this;\n  }\n  /**\n   * Slice returns a new track with only events that occured between startTime and endTime.\n   * Modifies this track.\n   * @param {Number} startTime\n   * @param {Number} endTime\n   * @returns {Track}\n   */\n\n\n  slice(startTime = 0, endTime = this.duration) {\n    // get the index before the startTime\n    const noteStartIndex = Math.max(this.notes.findIndex(note => note.time >= startTime), 0);\n    const noteEndIndex = this.notes.findIndex(note => note.noteOff >= endTime) + 1;\n    const track = new Track(this.name);\n    track.notes = this.notes.slice(noteStartIndex, noteEndIndex); //shift the start time\n\n    track.notes.forEach(note => note.time = note.time - startTime);\n    return track;\n  }\n  /**\n   * Write the output to the stream\n   */\n\n\n  encode(trackEncoder, header) {\n    const ticksPerSecond = header.PPQ / (60 / header.bpm);\n    let lastEventTime = 0; // unset, `channelNumber` defaults to -1, but that's not a valid MIDI channel\n\n    const channelNumber = Math.max(0, this.channelNumber);\n\n    function getDeltaTime(time) {\n      const ticks = Math.floor(ticksPerSecond * time);\n      const delta = Math.max(ticks - lastEventTime, 0);\n      lastEventTime = ticks;\n      return delta;\n    }\n\n    if (this.instrumentNumber !== -1) {\n      trackEncoder.instrument(channelNumber, this.instrumentNumber);\n    }\n\n    Merge(this.noteOns.sort((a, b) => a.time - b.time), noteOn => {\n      trackEncoder.addNoteOn(channelNumber, noteOn.name, getDeltaTime(noteOn.time), Math.floor(noteOn.velocity * 127));\n    }, this.noteOffs.sort((a, b) => a.time - b.time), noteOff => {\n      trackEncoder.addNoteOff(channelNumber, noteOff.name, getDeltaTime(noteOff.time));\n    });\n  }\n  /**\n   *  Convert all of the fields to JSON\n   *  @return  {Object}\n   */\n\n\n  toJSON() {\n    const ret = {\n      startTime: this.startTime,\n      duration: this.duration,\n      length: this.length,\n      notes: [],\n      controlChanges: {}\n    };\n    if (typeof this.id !== 'undefined') ret.id = this.id;\n    ret.name = this.name;\n\n    if (this.instrumentNumber !== -1) {\n      ret.instrumentNumber = this.instrumentNumber;\n      ret.instrument = this.instrument;\n      ret.instrumentFamily = this.instrumentFamily;\n    }\n\n    if (this.channelNumber !== -1) {\n      ret.channelNumber = this.channelNumber;\n      ret.isPercussion = this.isPercussion;\n    }\n\n    if (this.notes.length) ret.notes = this.notes.map(n => n.toJSON());\n    if (Object.keys(this.controlChanges).length) ret.controlChanges = this.controlChanges;\n    return ret;\n  }\n\n}\n\nexport { Track };","map":null,"metadata":{},"sourceType":"module"}