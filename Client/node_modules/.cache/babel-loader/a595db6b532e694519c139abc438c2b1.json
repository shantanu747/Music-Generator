{"ast":null,"code":"import * as Decoder from 'midi-file-parser';\nimport * as Encoder from 'jsmidgen';\nimport * as Util from './Util';\nimport { Track } from './Track';\nimport { parseHeader } from './Header';\n/**\n * @class The Midi object. Contains tracks and the header info.\n */\n\nclass Midi {\n  /**\n   * Convert JSON to Midi object\n   * @param {object} json\n   * @static\n   * @returns {Midi}\n   */\n  static fromJSON(json) {\n    var midi = new Midi();\n    midi.header = json.header;\n    json.tracks.forEach(track => {\n      var newTrack = Track.fromJSON(track);\n      midi.tracks.push(newTrack);\n    });\n    return midi;\n  }\n\n  constructor() {\n    this.header = {\n      //defaults\n      bpm: 120,\n      timeSignature: [4, 4],\n      PPQ: 480\n    };\n    this.tracks = [];\n  }\n  /**\n   * Load the given url and parse the midi at that url\n   * @param  {String}   url\n   * @param {*} data Anything that should be sent in the XHR\n   * @param {String} method Either GET or POST\n   * @return {Promise}\n   */\n\n\n  load(url, data = null, method = 'GET') {\n    return new Promise((success, fail) => {\n      var request = new XMLHttpRequest();\n      request.open(method, url);\n      request.responseType = 'arraybuffer'; // decode asynchronously\n\n      request.addEventListener('load', () => {\n        if (request.readyState === 4 && request.status === 200) {\n          success(this.decode(request.response));\n        } else {\n          fail(request.status);\n        }\n      });\n      request.addEventListener('error', fail);\n      request.send(data);\n    }).catch(function (error) {\n      console.log(error);\n    });\n  }\n  /**\n   * Decode the bytes\n   * @param  {String|ArrayBuffer} bytes The midi file encoded as a string or ArrayBuffer\n   * @return {Midi}       this\n   */\n\n\n  decode(bytes) {\n    if (bytes instanceof ArrayBuffer) {\n      var byteArray = new Uint8Array(bytes);\n      bytes = String.fromCharCode.apply(null, byteArray);\n    }\n\n    const midiData = Decoder(bytes);\n    this.header = parseHeader(midiData); //replace the previous tracks\n\n    this.tracks = [];\n    midiData.tracks.forEach((trackData, i) => {\n      const track = new Track();\n      track.id = i;\n      this.tracks.push(track);\n      let absoluteTime = 0;\n      trackData.forEach(event => {\n        absoluteTime += Util.ticksToSeconds(event.deltaTime, this.header);\n\n        if (event.type === 'meta' && event.subtype === 'trackName') {\n          track.name = Util.cleanName(event.text);\n        } else if (event.subtype === 'noteOn') {\n          track.noteOn(event.noteNumber, absoluteTime, event.velocity / 127);\n\n          if (track.channelNumber === -1) {\n            track.channelNumber = event.channel;\n          }\n        } else if (event.subtype === 'noteOff') {\n          track.noteOff(event.noteNumber, absoluteTime);\n        } else if (event.subtype === 'controller' && event.controllerType) {\n          track.cc(event.controllerType, absoluteTime, event.value / 127);\n        } else if (event.type === 'meta' && event.subtype === 'instrumentName') {\n          track.instrument = event.text;\n        } else if (event.type === 'channel' && event.subtype === 'programChange') {\n          track.patch(event.programNumber);\n          track.channelNumber = event.channel;\n        }\n      }); //if the track is empty, then it is the file name\n\n      if (!this.header.name && !track.length && track.name) {\n        this.header.name = track.name;\n      }\n    });\n    return this;\n  }\n  /**\n   * Encode the Midi object as a Buffer String\n   * @returns {String}\n   */\n\n\n  encode() {\n    const output = new Encoder.File({\n      ticks: this.header.PPQ\n    });\n    const firstEmptyTrack = this.tracks.filter(track => !track.length)[0];\n\n    if (this.header.name && !(firstEmptyTrack && firstEmptyTrack.name === this.header.name)) {\n      const track = output.addTrack();\n      track.addEvent(new Encoder.MetaEvent({\n        time: 0,\n        type: Encoder.MetaEvent.TRACK_NAME,\n        data: this.header.name\n      }));\n    }\n\n    this.tracks.forEach(track => {\n      const trackEncoder = output.addTrack();\n      trackEncoder.setTempo(this.bpm);\n\n      if (track.name) {\n        trackEncoder.addEvent(new Encoder.MetaEvent({\n          time: 0,\n          type: Encoder.MetaEvent.TRACK_NAME,\n          data: track.name\n        }));\n      }\n\n      track.encode(trackEncoder, this.header);\n    });\n    return output.toBytes();\n  }\n  /**\n   * Convert the output encoding into an Array\n   * @return {Array}\n   */\n\n\n  toArray() {\n    const encodedStr = this.encode();\n    const buffer = new Array(encodedStr.length);\n\n    for (let i = 0; i < encodedStr.length; i++) {\n      buffer[i] = encodedStr.charCodeAt(i);\n    }\n\n    return buffer;\n  }\n  /**\n   *  Convert all of the fields to JSON\n   *  @return  {Object}\n   */\n\n\n  toJSON() {\n    const ret = {\n      header: this.header,\n      startTime: this.startTime,\n      duration: this.duration,\n      tracks: (this.tracks || []).map(track => track.toJSON())\n    };\n    if (!ret.header.name) ret.header.name = '';\n    return ret;\n  }\n  /**\n   * Add a new track.\n   * @param {String=} name Optionally include the name of the track\n   * @returns {Track}\n   */\n\n\n  track(name) {\n    const track = new Track(name);\n    this.tracks.push(track);\n    return track;\n  }\n  /**\n   * Get a track either by it's name or track index\n   * @param  {Number|String} trackName\n   * @return {Track}\n   */\n\n\n  get(trackName) {\n    if (Util.isNumber(trackName)) {\n      return this.tracks[trackName];\n    } else {\n      return this.tracks.find(t => t.name === trackName);\n    }\n  }\n  /**\n   * Slice the midi file between the startTime and endTime. Returns a copy of the\n   * midi\n   * @param {Number} startTime\n   * @param {Number} endTime\n   * @returns {Midi} this\n   */\n\n\n  slice(startTime = 0, endTime = this.duration) {\n    const midi = new Midi();\n    midi.header = this.header;\n    midi.tracks = this.tracks.map(t => t.slice(startTime, endTime));\n    return midi;\n  }\n  /**\n   * the time of the first event\n   * @type {Number}\n   */\n\n\n  get startTime() {\n    const startTimes = this.tracks.map(t => t.startTime);\n    if (!startTimes.length) return 0;\n    return Math.min.apply(Math, startTimes) || 0;\n  }\n  /**\n   * The bpm of the midi file in beats per minute\n   * @type {Number}\n   */\n\n\n  get bpm() {\n    return this.header.bpm;\n  }\n\n  set bpm(bpm) {\n    const prevTempo = this.header.bpm;\n    this.header.bpm = bpm; //adjust the timing of all the notes\n\n    const ratio = prevTempo / bpm;\n    this.tracks.forEach(track => track.scale(ratio));\n  }\n  /**\n   * The timeSignature of the midi file\n   * @type {Array}\n   */\n\n\n  get timeSignature() {\n    return this.header.timeSignature;\n  }\n\n  set timeSignature(timeSig) {\n    this.header.timeSignature = timeSig;\n  }\n  /**\n   * The duration is the end time of the longest track\n   * @type {Number}\n   */\n\n\n  get duration() {\n    const durations = this.tracks.map(t => t.duration);\n    if (!durations.length) return 0;\n    return Math.max.apply(Math, durations) || 0;\n  }\n\n}\n\nexport { Midi };","map":null,"metadata":{},"sourceType":"module"}