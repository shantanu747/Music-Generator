(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/defineProperty'), require('fast-unique-numbers'), require('@babel/runtime/regenerator')) :
    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/defineProperty', 'fast-unique-numbers', '@babel/runtime/regenerator'], factory) :
    (global = global || self, factory(global.brokerFactory = {}, global._slicedToArray, global._defineProperty, global.fastUniqueNumbers, global._regeneratorRuntime));
}(this, (function (exports, _slicedToArray, _defineProperty, fastUniqueNumbers, _regeneratorRuntime) { 'use strict';

    _slicedToArray = _slicedToArray && _slicedToArray.hasOwnProperty('default') ? _slicedToArray['default'] : _slicedToArray;
    _defineProperty = _defineProperty && _defineProperty.hasOwnProperty('default') ? _defineProperty['default'] : _defineProperty;
    _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;

    var isMessagePort = function isMessagePort(sender) {
      return typeof sender.start === 'function';
    };

    var PORT_MAP = new WeakMap();

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
    var extendBrokerImplementation = function extendBrokerImplementation(partialBrokerImplementation) {
      return _objectSpread({}, partialBrokerImplementation, {
        connect: function connect(_ref) {
          var call = _ref.call;
          return function _callee() {
            var _ref2, port1, port2, portId;

            return _regeneratorRuntime.async(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _ref2 = new MessageChannel(), port1 = _ref2.port1, port2 = _ref2.port2;
                    _context.next = 3;
                    return _regeneratorRuntime.awrap(call('connect', {
                      port: port1
                    }, [port1]));

                  case 3:
                    portId = _context.sent;
                    PORT_MAP.set(port2, portId);
                    return _context.abrupt("return", port2);

                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            });
          };
        },
        disconnect: function disconnect(_ref3) {
          var call = _ref3.call;
          return function _callee2(port) {
            var portId;
            return _regeneratorRuntime.async(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    portId = PORT_MAP.get(port);

                    if (!(portId === undefined)) {
                      _context2.next = 3;
                      break;
                    }

                    throw new Error('The given port is not connected.');

                  case 3:
                    _context2.next = 5;
                    return _regeneratorRuntime.awrap(call('disconnect', {
                      portId: portId
                    }));

                  case 5:
                  case "end":
                    return _context2.stop();
                }
              }
            });
          };
        },
        isSupported: function isSupported(_ref4) {
          var call = _ref4.call;
          return function () {
            return call('isSupported');
          };
        }
      });
    };

    function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
    var ONGOING_REQUESTS = new WeakMap();

    var createOrGetOngoingRequests = function createOrGetOngoingRequests(sender) {
      if (ONGOING_REQUESTS.has(sender)) {
        // @todo TypeScript needs to be convinced that has() works as expected.
        return ONGOING_REQUESTS.get(sender);
      }

      var ongoingRequests = new Map();
      ONGOING_REQUESTS.set(sender, ongoingRequests);
      return ongoingRequests;
    };

    var createBroker = function createBroker(brokerImplementation) {
      var fullBrokerImplementation = extendBrokerImplementation(brokerImplementation);
      return function (sender) {
        var ongoingRequests = createOrGetOngoingRequests(sender);
        sender.addEventListener('message', function (_ref) {
          var message = _ref.data;
          var id = message.id;

          if (id !== null && ongoingRequests.has(id)) {
            var _ongoingRequests$get = ongoingRequests.get(id),
                reject = _ongoingRequests$get.reject,
                resolve = _ongoingRequests$get.resolve;

            ongoingRequests["delete"](id);

            if (message.error === undefined) {
              resolve(message.result);
            } else {
              reject(new Error(message.error.message));
            }
          }
        });

        if (isMessagePort(sender)) {
          sender.start();
        }

        var call = function call(method) {
          var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var transferables = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          return new Promise(function (resolve, reject) {
            var id = fastUniqueNumbers.generateUniqueNumber(ongoingRequests);
            ongoingRequests.set(id, {
              reject: reject,
              resolve: resolve
            });

            if (params === null) {
              sender.postMessage({
                id: id,
                method: method
              }, transferables);
            } else {
              sender.postMessage({
                id: id,
                method: method,
                params: params
              }, transferables);
            }
          });
        };

        var notify = function notify(method, params) {
          var transferables = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          sender.postMessage({
            id: null,
            method: method,
            params: params
          }, transferables);
        };

        var functions = {};

        for (var _i = 0, _Object$entries = Object.entries(fullBrokerImplementation); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              key = _Object$entries$_i[0],
              handler = _Object$entries$_i[1];

          functions = _objectSpread$1({}, functions, _defineProperty({}, key, handler({
            call: call,
            notify: notify
          })));
        }

        return _objectSpread$1({}, functions);
      };
    };

    exports.createBroker = createBroker;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
