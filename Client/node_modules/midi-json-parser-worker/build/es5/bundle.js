(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('worker-factory'), require('@babel/runtime/helpers/defineProperty')) :
    typeof define === 'function' && define.amd ? define(['worker-factory', '@babel/runtime/helpers/defineProperty'], factory) :
    (global = global || self, factory(global.workerFactory, global._defineProperty));
}(this, (function (workerFactory, _defineProperty) { 'use strict';

    _defineProperty = _defineProperty && _defineProperty.hasOwnProperty('default') ? _defineProperty['default'] : _defineProperty;

    var isMidiStatusEvent = function isMidiStatusEvent(midiEvent) {
      return midiEvent.channel !== undefined;
    };

    var hexifyNumber = function hexifyNumber(number) {
      return number.toString(16).toUpperCase().padStart(2, '0');
    };

    /**
     * This function turns a part of a given ArrayBuffer into a hexadecimal String.
     */

    var hexify = function hexify(dataView) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : dataView.byteLength - (offset - dataView.byteOffset);
      var byteOffset = offset + dataView.byteOffset;
      var hexArray = [];
      var uint8Array = new Uint8Array(dataView.buffer, byteOffset, length);

      for (var i = 0; i < length; i += 1) {
        hexArray[i] = hexifyNumber(uint8Array[i]);
      }

      return hexArray.join('');
    };

    /**
     * This function turns a part of a given ArrayBuffer into a String.
     */
    var stringify = function stringify(dataView) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : dataView.byteLength - (offset - dataView.byteOffset);
      var byteOffset = offset + dataView.byteOffset;
      var array = new Uint8Array(dataView.buffer, byteOffset, length); // String.fromCharCode() does normally expect numbers but it can also handle a typed array.

      return String.fromCharCode.apply(null, array);
    };

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
    var parseArrayBuffer = function parseArrayBuffer(arrayBuffer) {
      var dataView = new DataView(arrayBuffer);

      var header = _parseHeaderChunk(dataView); // tslint:disable-line:no-use-before-declare


      var offset = 14;
      var tracks = [];

      for (var i = 0, length = header.numberOfTracks; i < length; i += 1) {
        var track = void 0;

        var _parseTrackChunk2 = _parseTrackChunk(dataView, offset);

        offset = _parseTrackChunk2.offset;
        track = _parseTrackChunk2.track;
        // tslint:disable-line:no-use-before-declare
        tracks.push(track);
      }

      return {
        division: header.division,
        format: header.format,
        tracks: tracks
      };
    };

    var _parseEvent = function _parseEvent(dataView, offset, lastStatusByte) {
      var result;

      var _readVariableLengthQu = _readVariableLengthQuantity( // tslint:disable-line:no-use-before-declare
      dataView, offset),
          nextOffset = _readVariableLengthQu.offset,
          delta = _readVariableLengthQu.value;

      var eventTypeByte = dataView.getUint8(nextOffset);

      if (eventTypeByte === 0xF0) {
        // tslint:disable-line:no-bitwise
        result = _parseSysexEvent(dataView, nextOffset + 1); // tslint:disable-line:no-use-before-declare
      } else if (eventTypeByte === 0xFF) {
        // tslint:disable-line:no-bitwise
        result = _parseMetaEvent(dataView, nextOffset + 1); // tslint:disable-line:no-use-before-declare
      } else {
        result = _parseMidiEvent(eventTypeByte, dataView, nextOffset + 1, lastStatusByte); // tslint:disable-line:no-use-before-declare
      }

      return _objectSpread({}, result, {
        event: _objectSpread({}, result.event, {
          delta: delta
        }),
        eventTypeByte: eventTypeByte
      });
    };

    var _parseHeaderChunk = function _parseHeaderChunk(dataView) {
      if (stringify(dataView, 0, 4) !== 'MThd') {
        throw new Error("Unexpected characters \"".concat(stringify(dataView, 0, 4), "\" found instead of \"MThd\""));
      }

      if (dataView.getUint32(4) !== 6) {
        throw new Error("The header has an unexpected length of ".concat(dataView.getUint32(4), " instead of 6"));
      }

      var format = dataView.getUint16(8);
      var numberOfTracks = dataView.getUint16(10);
      var division = dataView.getUint16(12);
      return {
        division: division,
        format: format,
        numberOfTracks: numberOfTracks
      };
    };

    var _parseMetaEvent = function _parseMetaEvent(dataView, offset) {
      var event;
      var metaTypeByte = dataView.getUint8(offset);

      var _readVariableLengthQu2 = _readVariableLengthQuantity( // tslint:disable-line:no-use-before-declare
      dataView, offset + 1),
          nextOffset = _readVariableLengthQu2.offset,
          length = _readVariableLengthQu2.value;

      if (metaTypeByte === 0x01) {
        // tslint:disable-line:no-bitwise
        event = {
          text: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x02) {
        // tslint:disable-line:no-bitwise
        event = {
          copyrightNotice: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x03) {
        // tslint:disable-line:no-bitwise
        event = {
          trackName: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x04) {
        // tslint:disable-line:no-bitwise
        event = {
          instrumentName: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x05) {
        // tslint:disable-line:no-bitwise
        event = {
          lyric: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x06) {
        // tslint:disable-line:no-bitwise
        event = {
          marker: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x08) {
        // tslint:disable-line:no-bitwise
        event = {
          programName: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x09) {
        // tslint:disable-line:no-bitwise
        event = {
          deviceName: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x0A || metaTypeByte === 0x0B || metaTypeByte === 0x0C || metaTypeByte === 0x0D || metaTypeByte === 0x0E || metaTypeByte === 0x0F) {
        // tslint:disable-line:no-bitwise
        event = {
          metaTypeByte: hexifyNumber(metaTypeByte),
          text: stringify(dataView, nextOffset, length)
        };
      } else if (metaTypeByte === 0x20) {
        // tslint:disable-line:no-bitwise
        event = {
          channelPrefix: dataView.getUint8(nextOffset)
        };
      } else if (metaTypeByte === 0x21) {
        // tslint:disable-line:no-bitwise
        event = {
          midiPort: dataView.getUint8(nextOffset)
        };
      } else if (metaTypeByte === 0x2F) {
        // tslint:disable-line:no-bitwise
        // @todo length must be 0
        event = {
          endOfTrack: true
        };
      } else if (metaTypeByte === 0x51) {
        // tslint:disable-line:no-bitwise
        // @todo length must be 5
        event = {
          setTempo: {
            microsecondsPerBeat: (dataView.getUint8(nextOffset) << 16) + ( // tslint:disable-line:no-bitwise
            dataView.getUint8(nextOffset + 1) << 8) + // tslint:disable-line:no-bitwise
            dataView.getUint8(nextOffset + 2)
          }
        };
      } else if (metaTypeByte === 0x54) {
        // tslint:disable-line:no-bitwise
        var frameRate; // @todo length must be 5

        var hourByte = dataView.getUint8(nextOffset);

        if ((hourByte & 0x60) === 0x00) {
          // tslint:disable-line:no-bitwise
          frameRate = 24;
        } else if ((hourByte & 0x60) === 0x20) {
          // tslint:disable-line:no-bitwise
          frameRate = 25;
        } else if ((hourByte & 0x60) === 0x40) {
          // tslint:disable-line:no-bitwise
          frameRate = 29;
        } else if ((hourByte & 0x60) === 0x60) {
          // tslint:disable-line:no-bitwise
          frameRate = 30;
        }

        event = {
          smpteOffset: {
            frame: dataView.getUint8(nextOffset + 3),
            frameRate: frameRate,
            hour: hourByte & 0x1F,
            minutes: dataView.getUint8(nextOffset + 1),
            seconds: dataView.getUint8(nextOffset + 2),
            subFrame: dataView.getUint8(nextOffset + 4)
          }
        };
      } else if (metaTypeByte === 0x58) {
        // tslint:disable-line:no-bitwise
        event = {
          timeSignature: {
            denominator: Math.pow(2, dataView.getUint8(nextOffset + 1)),
            metronome: dataView.getUint8(nextOffset + 2),
            numerator: dataView.getUint8(nextOffset),
            thirtyseconds: dataView.getUint8(nextOffset + 3)
          }
        };
      } else if (metaTypeByte === 0x59) {
        // tslint:disable-line:no-bitwise
        // @todo length must be 2
        event = {
          keySignature: {
            key: dataView.getInt8(nextOffset),
            scale: dataView.getInt8(nextOffset + 1)
          }
        };
      } else if (metaTypeByte === 0x7F) {
        // tslint:disable-line:no-bitwise
        event = {
          sequencerSpecificData: hexify(dataView, nextOffset, length)
        };
      } else {
        throw new Error("Cannot parse a meta event with a type of \"".concat(hexifyNumber(metaTypeByte), "\""));
      }

      return {
        event: event,
        offset: nextOffset + length
      };
    };

    var _parseMidiEvent = function _parseMidiEvent(statusByte, dataView, offset, lastStatusByte) {
      var sanitizedLastStatusByte = (statusByte & 0x80) === 0 ? lastStatusByte : null; // tslint:disable-line:no-bitwise

      var eventType = (sanitizedLastStatusByte === null ? statusByte : sanitizedLastStatusByte) >> 4; // tslint:disable-line:no-bitwise

      var event;
      var sanitizedOffset = sanitizedLastStatusByte === null ? offset : offset - 1; // tslint:disable-line:no-bitwise

      if (eventType === 0x08) {
        // tslint:disable-line:no-bitwise
        event = {
          noteOff: {
            noteNumber: dataView.getUint8(sanitizedOffset),
            velocity: dataView.getUint8(sanitizedOffset + 1)
          }
        };
        sanitizedOffset += 2;
      } else if (eventType === 0x09) {
        // tslint:disable-line:no-bitwise
        var noteNumber = dataView.getUint8(sanitizedOffset);
        var velocity = dataView.getUint8(sanitizedOffset + 1);

        if (velocity === 0) {
          event = {
            noteOff: {
              noteNumber: noteNumber,
              velocity: velocity
            }
          };
        } else {
          event = {
            noteOn: {
              noteNumber: noteNumber,
              velocity: velocity
            }
          };
        }

        sanitizedOffset += 2;
      } else if (eventType === 0x0A) {
        // tslint:disable-line:no-bitwise
        event = {
          keyPressure: {
            pressure: dataView.getUint8(sanitizedOffset)
          }
        };
        sanitizedOffset += 1;
      } else if (eventType === 0x0B) {
        // tslint:disable-line:no-bitwise
        event = {
          controlChange: {
            type: dataView.getUint8(sanitizedOffset),
            value: dataView.getUint8(sanitizedOffset + 1)
          }
        };
        sanitizedOffset += 2;
      } else if (eventType === 0x0C) {
        // tslint:disable-line:no-bitwise
        event = {
          programChange: {
            programNumber: dataView.getUint8(sanitizedOffset)
          }
        };
        sanitizedOffset += 1;
      } else if (eventType === 0x0D) {
        // tslint:disable-line:no-bitwise
        event = {
          channelPressure: {
            noteNumber: dataView.getUint8(sanitizedOffset),
            pressure: dataView.getUint8(sanitizedOffset + 1)
          }
        };
        sanitizedOffset += 2;
      } else if (eventType === 0x0E) {
        // tslint:disable-line:no-bitwise
        event = {
          pitchBend: dataView.getUint8(sanitizedOffset) | dataView.getUint8(sanitizedOffset + 1) << 7 // tslint:disable-line:no-bitwise

        };
        sanitizedOffset += 2;
      } else {
        throw new Error("Cannot parse a midi event with a type of \"".concat(hexifyNumber(eventType), "\""));
      }

      event.channel = (sanitizedLastStatusByte === null ? statusByte : sanitizedLastStatusByte) & 0x0F; // tslint:disable-line:no-bitwise

      return {
        event: event,
        offset: sanitizedOffset
      };
    };

    var _parseSysexEvent = function _parseSysexEvent(dataView, offset) {
      var _readVariableLengthQu3 = _readVariableLengthQuantity( // tslint:disable-line:no-use-before-declare
      dataView, offset),
          nextOffset = _readVariableLengthQu3.offset,
          length = _readVariableLengthQu3.value;

      return {
        event: {
          sysex: hexify(dataView, nextOffset, length)
        },
        offset: nextOffset + length
      };
    };

    var _parseTrackChunk = function _parseTrackChunk(dataView, offset) {
      if (stringify(dataView, offset, 4) !== 'MTrk') {
        throw new Error("Unexpected characters \"".concat(stringify(dataView, offset, 4), "\" found instead of \"MTrk\""));
      }

      var events = [];
      var length = dataView.getUint32(offset + 4) + offset + 8;
      var lastStatusByte = null;
      var nextOffset = offset + 8;

      while (nextOffset < length) {
        var result = _parseEvent(dataView, nextOffset, lastStatusByte);

        var event = result.event,
            eventTypeByte = result.eventTypeByte;
        events.push(event);
        nextOffset = result.offset;

        if (isMidiStatusEvent(event) && (eventTypeByte & 0x80) > 0) {
          // tslint:disable-line:no-bitwise
          lastStatusByte = eventTypeByte;
        }
      }

      return {
        offset: nextOffset,
        track: events
      };
    };

    var _readVariableLengthQuantity = function _readVariableLengthQuantity(dataView, offset) {
      var nextOffset = offset;
      var value = 0;

      while (true) {
        var _byte = dataView.getUint8(nextOffset);

        nextOffset += 1;

        if (_byte > 127) {
          value += _byte & 0x7F; // tslint:disable-line:no-bitwise

          value <<= 7; // tslint:disable-line:no-bitwise
        } else {
          value += _byte;
          return {
            offset: nextOffset,
            value: value
          };
        }
      }
    };

    workerFactory.createWorker(self, {
      parse: function parse(_ref) {
        var arrayBuffer = _ref.arrayBuffer;
        var midiFile = parseArrayBuffer(arrayBuffer);
        return {
          result: midiFile
        };
      }
    });

})));
